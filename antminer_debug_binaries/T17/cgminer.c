/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_11F68();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// FILE *fdopen(int fd, const char *modes);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int sem_wait(sem_t *sem);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int sem_post(sem_t *sem);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strcspn(const char *s, const char *reject);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int inet_pton(int af, const char *cp, void *buf);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int tolower(int c);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int setlogmask(int mask);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int ftell(FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// char *strdup(const char *s);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// uint16_t htons(uint16_t hostshort);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int sysconf(int name);
// int dup2(int fd, int fd2);
// void *realloc(void *ptr, size_t size);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int sigaction_0(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// double floor(double x);
// int __fastcall strtof(_DWORD, _DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo_0(struct sysinfo *info);
// void *malloc(size_t size);
// double log10(double x);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// struct tm *localtime(const time_t *timer);
// char *dirname(char *path);
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// int kill(__pid_t pid, int sig);
// uint32_t ntohl(uint32_t netlong);
// const unsigned __int16 **_ctype_b_loc(void);
// void exit(int status);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// size_t strlen(const char *s);
// int __fastcall round(_DWORD, _DWORD); weak
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int atol(const char *nptr);
// int nice(int inc);
// int fprintf(FILE *stream, const char *format, ...);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int putchar(int c);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// int fileno(FILE *stream);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int access(const char *name, int type);
// int fclose(FILE *stream);
// int pipe(int pipedes[2]);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int shutdown(int fd, int how);
// int sigemptyset(sigset_t *set);
// FILE *popen(const char *command, const char *modes);
// __pid_t fork(void);
// void errx(int status, const char *format, ...);
// uint32_t htonl(uint32_t hostlong);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int execl(const char *path, const char *arg, ...);
// int toupper(int c);
// int listen(int fd, int n);
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int fputc(int c, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
// int sscanf(const char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// void openlog(const char *ident, int option, int facility);
// double exp(double x);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// double atof(const char *nptr);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// int fseek(FILE *stream, int off, int whence);
// char *strncat(char *dest, const char *src, size_t n);
// int sem_destroy(sem_t *sem);
// int isatty(int fd);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int pclose(FILE *stream);
void __noreturn start(void (*)(void), int, int, int, ...); // idb
int call_weak_fn();
void *deregister_tm_clones(); // idb
__int64 register_tm_clones(); // idb
void *_do_global_dtors_aux(); // idb
uint32_t __cdecl swab32(uint32_t v);
void __cdecl flip32(void *dest_p, const void *src_p);
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length);
void freq_tuning_get_proj_type(); // idb
bool __cdecl freq_tuning_get_max_freq(int *p_max_freq);
void __cdecl freq_tuning_init_freq_info(freq_tuning_info *freq_info);
freq_tuning_info *freq_tuning_create_info(); // idb
void __cdecl freq_tuning_domain_nonce_dump(int chain);
void __cdecl freq_tuning_parameter_dump(freq_tuning_info *freq_info);
void freq_tuning_config_dump(); // idb
int __cdecl freq_tuning_get_work_for_one_core(FILE **fp, int asic, int core, int count);
int freq_tuning_prepare_works(); // idb
void freq_tuning_reset_global_arg(); // idb
void __cdecl freq_tuning_env_init(bool is_need_read_temp, freq_tuning_info *freq_info);
int __cdecl freq_tuning_get_board_test_voltage_and_freq(int level, int *pVoltage, int *pFreq, int sub_proj_index);
bool __cdecl freq_tuning_get_next_test_voltage_and_freq(freq_tuning_info *freq_info, bool reset_test_level, int sub_proj_index);
void __cdecl freq_tuning_set_vol_all_chain(int sub_proj_index);
void __cdecl freq_tuning_set_freq_all_chain(const freq_tuning_info *freq_info);
void __cdecl freq_tuning_set_time_control_by_freq(int freq);
int __cdecl freq_tuning_get_min_freq(freq_tuning_info *freq_info);
void *__cdecl freq_tuning_send_work_one_chain(void *args);
void __cdecl freq_tuning_send_work(freq_tuning_info *freq_info);
void freq_tuning_get_domain_nonce_statistics(); // idb
bool freq_tuning_check_domain_unbalance(); // idb
void __cdecl freq_tuning_wait_recv_nonce(freq_tuning_info *freq_info);
int __cdecl freq_tuning_get_scan_level_index(freq_tuning_info *freq_info, int freq);
void __cdecl freq_tuning_init_chip_rate_table(freq_tuning_info *freq_info, int *recv_nonce_num_table, int chain);
void __cdecl freq_tuning_send_work_and_check_result_all_chain(freq_tuning_info *freq_info);
int __cdecl freq_tuning_check_hw(freq_tuning_work *work, uint32_t nonce);
void *__cdecl freq_tuning_recv_nonce_and_register(void *arg);
bool __cdecl freq_tuning_check_if_test_done(freq_tuning_info *freq_info);
void __cdecl freq_tuning_calc_sum_of_all_freq(const freq_tuning_info *freq_info, int *sum, int chain);
void __cdecl freq_tuning_sort_array(int *src, int *rate, unsigned int len);
void __cdecl freq_tuning_set_asic_quality_per_domain(freq_tuning_info *freq_info, int chain);
int __cdecl freq_tuning_get_max_index(int *array, unsigned int len);
void __cdecl freq_tuning_set_freq_table(freq_tuning_info *freq_info, int chain);
void __cdecl freq_tuning_print_chip_rate_table(freq_tuning_info *freq_info);
void __cdecl freq_tuning_print_freq_table(freq_tuning_info *freq_info);
void __cdecl freq_tuning_increase_final_freq_slowly(freq_tuning_info *freq_info, int init_freq, int freq_step);
void __cdecl freq_tuning_hash_board_init(freq_tuning_info *freq_info);
void __fastcall freq_tuning_single_pre_test_prepare(double); // idb
bool __cdecl freq_tuning_single_pre_test(freq_tuning_info *freq_info);
void __cdecl freq_tuning_pre_test(freq_tuning_info *freq_info);
void __cdecl freq_tuning_pre_open_core(freq_tuning_info *freq_info);
void __cdecl freq_tuning_get_ideal_hash_rate(freq_tuning_info *freq_info, int sub_proj_index);
int __cdecl freq_tuning_get_hash_rate_MH(freq_tuning_info *freq_info);
void __cdecl freq_tuning_adjust_result_for_low_temperature(freq_tuning_info *freq_info, int sub_proj_index);
void __cdecl freq_tuning_adjust_result_according_to_distance_to_air_in(freq_tuning_info *freq_info, int chain);
void __cdecl freq_tuning_adjust_result_for_poor_heat_dissipation(freq_tuning_info *freq_info, int sub_proj_index);
int __cdecl freq_tuning_adjust_result_according_to_hash_rate(freq_tuning_info *freq_info, int hash_rate_target_MH, bool is_rounding_TH);
void __cdecl freq_tuning_adjust_result_for_high_temperature(freq_tuning_info *freq_info, int sub_proj_index);
void __cdecl freq_tuning_adjust_result_for_J_TH(freq_tuning_info *freq_info, int sub_proj_index);
void __cdecl freq_tuning_adjust_result_for_hash_rate_threshold_S15_H(freq_tuning_info *freq_info, int sub_proj_index);
void __cdecl freq_tuning_adjust_result_for_hash_rate_threshold(freq_tuning_info *freq_info, int sub_proj_index);
void __cdecl freq_tuning_save_result(freq_tuning_info *freq_info, int sub_proj_index);
void __cdecl freq_tuning_mark_unbalance_chain(freq_tuning_info *freq_info);
int freq_tuning_already_done(); // idb
void freq_tuning_done_mark(); // idb
void __cdecl freq_tuning_set_fake_done_for_other_chain(freq_tuning_info *freq_info, int chain);
void __cdecl freq_tuning_clear_fake_done(freq_tuning_info *freq_info);
void __cdecl freq_tuning_pattern_test_serial(freq_tuning_info *freq_info, int chain, int level_start, int level_cnt, int sub_proj_index);
int __cdecl freq_tuning_get_hash_rate_GH(freq_tuning_info *freq_info);
void __cdecl freq_tuning_set_pass_or_not(freq_tuning_info *freq_info, int sub_proj_index);
void __cdecl freq_tuning_pattern_test(freq_tuning_info *freq_info, int sub_proj_index);
void freq_tuning_test_based_voltage_domain(); // idb
void freq_tuning_free_works_buffer(); // idb
bool freq_tuning_alloc_works_buffer(); // idb
void do_freq_tuning(); // idb
unsigned int __cdecl check_asic_reg_with_addr(unsigned int reg, unsigned __int8 chip_addr, unsigned int chain, int check_num);
unsigned int __cdecl wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update);
uint8_t __cdecl check_reg_temp(uint8_t reg, uint8_t data, uint8_t write, uint8_t chip_addr, int chain);
int16_t __cdecl get_local(int16_t local);
void __cdecl get_temp_info_from_default_by_chain(uint32_t chain);
void __cdecl update_middle_offset(int chain, int temp_id);
int32_t __cdecl calibration_sensor_offset(int32_t chain);
void do_calibration_temperature_sensor(); // idb
void __cdecl set_pwm(unsigned __int8 pwm_percent);
int __cdecl get_target_airout_pcb_temp(int airin_pcb_temp);
int set_pwm_by_pid_method(); // idb
int __cdecl set_pwm_by_airin_temp(int air_in_lowest_temp);
bool is_hashboard_dead(); // idb
void temp_get_local_and_remote_temp(); // idb
int temp_is_air_out_too_high(); // idb
void temp_get_statistics(); // idb
bool is_full_speed_fan();
void set_pwm_by_temp(); // idb
void __noreturn read_temp_func(); // idb
void update_error_status(); // idb
void check_error_protect(); // idb
void killall_hashboard(); // idb
STATUS_CODE get_error_type(); // idb
bool is_in_error();
void __cdecl set_status(STATUS_CODE err);
int __cdecl temp_get_local_temp(float *p_temp);
void temp_get_environment_temp(); // idb
unsigned int __cdecl _bswap_32(unsigned int __bsx);
__uint64_t __cdecl _uint64_identity(__uint64_t __x);
uint32_t __cdecl swab32_0(uint32_t v);
void __cdecl flip32_0(void *dest_p, const void *src_p);
void __cdecl mutex_lock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl flip_swab_0(void *dest_p, const void *src_p, unsigned int length);
int __cdecl get_index_from_pll_B1391(int pll);
void __cdecl get_plldata_from_index(int index, uint8_t *vil_pll);
int __cdecl get_pllparam_divider(float freq, uint32_t *pll_param, uint8_t *divider, float *pll_freq);
bool is_fixed_freq_mode(); // idb
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len);
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len);
uint32_t __cdecl get_core_id(nonce_format_t nonce);
uint32_t __cdecl get_asic_id(nonce_format_t nonce);
void __noreturn get_hash_rate(); // idb
int bitmain_axi_init(); // idb
void check_chain(); // idb
int check_fan(); // idb
int __cdecl get_index_from_high_pll(int freq);
int get_eeprom_total_hash_rate(); // idb
int get_fixed_total_hash_rate(); // idb
int get_total_rate(); // idb
int get_ideal_hash_rate_fixed(); // idb
int get_ideal_hash_rate(); // idb
uint32_t do_get_ideal_max_hash_rate(); // idb
int get_ideal_hash_rate_max(); // idb
int __cdecl convirt_total_rate(int totalRate);
void clear_register_value_buf(); // idb
void __cdecl suffix_string_soc(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display);
bool __cdecl check_single_asic_reg(unsigned int reg);
bool __cdecl check_asic_reg_oneChain(int chainIndex, unsigned int reg, bool core_response);
int __cdecl calculate_core_number(unsigned int actual_core_number);
void __cdecl set_addr_one_chain(const uint8_t chain);
void software_set_address(); // idb
void __cdecl set_baud(int baud, int no_use);
void init_uart_baud(); // idb
void init_led(); // idb
void set_led(); // idb
void *__cdecl heart_beat_func_one_chain(void *arg);
void *__cdecl pic_heart_beat_func(void *arg);
int __cdecl get_asic_nonce_num(int chain, int asic, int timeslice);
void __cdecl get_lastn_nonce_num(unsigned __int8 *dest, int n);
uint32_t __cdecl get_domain_nounce_number(uint32_t chain, uint32_t domain);
void dump_nonce_info_all_domain(); // idb
int is_domain_unbalance(); // idb
void dump_nonce_info_all_asic(); // idb
void __cdecl dump_nonce_info_one_asic(uint32_t chain, uint32_t asic_id);
void dump_nonce_info_all_core(); // idb
void __cdecl save_test_ID(int testID);
int read_test_ID(); // idb
void __cdecl dump_asic_reg(uint32_t value);
void __cdecl dump_core_reg(uint32_t value);
void process_TEST(); // idb
void disable_pic_circuit(); // idb
void __noreturn check_system_work(); // idb
void __cdecl pre_open_core_one_chain(uint32_t num, const uint8_t chain);
void __cdecl open_core_BM1391_pre_open(int chain, unsigned int num, unsigned __int8 set);
void __cdecl set_clock_delay_control(const uint8_t chain);
void __cdecl open_core_bm1391(bool set, uint8_t chain_mode);
void __cdecl nonce_calc(int chain, unsigned int buf);
void __noreturn get_nonce_and_register(); // idb
void __cdecl change_high_pll_test(uint8_t chain, float freq, int index);
void __cdecl change_high_pll_by_aisc(uint32_t chain, uint32_t asic, float freq, int index);
void __cdecl set_pll(float pll_value);
void __cdecl increase_freq_slowly(float init_freq, float final_freq, float freq_step, uint8_t chain);
unsigned __int8 __cdecl c2hex(unsigned __int8 value);
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __cdecl s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen);
void __cdecl init_pic_one_chain(const int chain);
int init_pic(); // idb
void __cdecl set_timeout(int final_freq, int percent);
void __fastcall set_target_freq(int, float, float); // idb
int __cdecl get_physical_chip_no(int logical_row, int logical_col);
int __cdecl get_logical_column_by_chip_no(int chip);
void __cdecl get_statistics_of_asic_freq(uint32_t *asic_freq, uint32_t *min, uint32_t *max, uint32_t *total);
void __cdecl increase_asic_diff_freq_slowly_one_chain(uint32_t *asic_diff_freq, uint32_t start_freq, int freq_step, int chain);
uint16_t __cdecl increase_freq_by_eeprom_slowly(int init_freq, int freq_step);
unsigned int __cdecl check_asic_reg_without_read(unsigned int reg, unsigned __int8 mode, unsigned __int8 chip_addr, unsigned int chain, int check_num);
void read_clock_delay_control_single_core(); // idb
const unsigned __int8 *__cdecl get_asic_reg_string(unsigned __int8 reg);
const unsigned __int8 *__cdecl get_asic_core_reg_string(unsigned __int8 reg);
void dump_all_asic_reg(); // idb
void __cdecl power_off_hash_board(int chain);
void balance_domain_voltage(); // idb
void init_freq_mode(); // idb
void init_phy_mem_nonce2_jobid_address(); // idb
int __cdecl init_global_config_parameter(init_config config);
void check_fan_multi(); // idb
void init_dev_frequency(); // idb
int start_read_nonce_reg_thread(); // idb
void init_miner_version(); // idb
void dump_pcb_bom_version(); // idb
void calculate_timeout(); // idb
void set_timeout_control(); // idb
void __fastcall set_freq_and_get_max_freq(int, float, float); // idb
void init_asic_status_and_nonce_count(); // idb
int start_read_temp_thread(); // idb
int start_read_hash_rate_thread(); // idb
int start_check_system_work_thread(); // idb
void set_working_voltage_by_eeprom(); // idb
void init_working_voltage(); // idb
void show_sn(); // idb
void show_mode(); // idb
void get_freq_from_eeprom(); // idb
void hash_board_power_on_with_reset(); // idb
void check_asic_number(); // idb
void set_order_clock(); // idb
int __cdecl bitmain_soc_init(init_config config);
bool is_re_open_core_now(); // idb
int __cdecl parse_job_to_soc(unsigned __int8 **buf, pool *pool, uint32_t id);
int __cdecl send_job(unsigned __int8 *buf, pool *pool);
void __cdecl copy_pool_stratum(pool *pool_stratum, pool *pool);
bool __cdecl bitmain_soc_prepare(thr_info *thr);
void __cdecl bitmain_soc_reinit_device(cgpu_info *bitmain);
void __cdecl bitmain_soc_detect(bool hotplug);
uint64_t __cdecl hashtest_submit(thr_info *thr, work *work, uint32_t nonce, uint8_t *midstate, pool *pool, uint64_t nonce2, uint32_t chain_id);
void *__cdecl bitmain_scanhash(void *arg);
int64_t __cdecl bitmain_soc_scanhash(thr_info *thr);
void __cdecl bitmain_soc_update(cgpu_info *bitmain_soc);
void __cdecl get_bitmain_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *bitmain_soc);
void __cdecl restore_syslog_file(LOG_FILE_BACKUP *backlog);
void __cdecl backup_syslog_file(LOG_FILE_BACKUP *backlog);
void __cdecl set_privite_log_file(unsigned __int8 *logfile_name, LOG_FILE_BACKUP *backlog);
void __cdecl get_miner_info(unsigned __int8 *infoStr);
api_data *__cdecl bitmain_api_stats(cgpu_info *cgpu);
void __cdecl bitmain_soc_shutdown(thr_info *thr);
void __cdecl stop_scan(FREQ_SCAN_ERRNO error_num, uint8_t chain);
void __cdecl stop_mining(const unsigned __int8 *str);
void power_on(); // idb
void power_check_protocal_type(); // idb
void power_init(); // idb
void __cdecl set_working_voltage(double working_voltage);
void get_working_voltage(); // idb
void get_current_voltage(); // idb
bool power_is_support_cmd_package(); // idb
bool __cdecl power_check_reply(uint8_t *cmd, uint8_t *reply_buf, uint8_t reply_len);
bool __cdecl power_send_cmd(uint8_t *cmd, uint8_t len, uint8_t *reply_buf, uint8_t reply_len);
void __cdecl power_set_da_value(uint8_t da_value);
uint8_t __cdecl power_set_da_value_simple(uint8_t data);
void __cdecl power_set_voltage(uint8_t da_value);
uint8_t __cdecl get_power_iic_value_from_voltage(double voltage);
double __cdecl get_power_voltage_from_iic_value(uint8_t data);
bool __cdecl set_iic_power_by_voltage(double target_vol, power_info_t *power);
bool __cdecl set_iic_power_by_iic_data(uint8_t target_data, power_info_t *power);
int __fastcall set_iic_power_to_highest_voltage(double); // idb
bool __cdecl slowly_adapt_voltage(double target_vol, uint32_t ms_delay);
int slowly_set_iic_power_to_working_voltage(); // idb
bool __cdecl check_pic_crc(unsigned __int8 *buf);
double __cdecl decode_an_voltage_buf(unsigned __int8 *buf);
double __cdecl dsPIC33EP16GS202_pic_get_an_voltage2(unsigned __int8 which_iic);
void get_average_voltage(); // idb
__uint32_t __cdecl _uint32_identity(__uint32_t __x);
void __cdecl json_decref(json_t_0 *json);
void __cdecl _list_add(list_head *new, list_head *prev, list_head *next);
void __cdecl list_add_tail(list_head *new, list_head *head);
void __cdecl _list_del(list_head *prev, list_head *next);
void __cdecl list_del(list_head *entry);
int __cdecl list_empty(list_head *head);
int sock_blocks();
bool sock_timeout(); // idb
bool interrupted(); // idb
void __cdecl align_len(size_t *len);
uint32_t __cdecl swab32_1(uint32_t v);
void __cdecl swab256(void *dest_p, const void *src_p);
void __cdecl mutex_lock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl mutex_trylock(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int no_yield(); // idb
void __cdecl keep_sockalive(int fd);
void *__cdecl cgmalloc(uint32_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__cdecl cgcalloc(int memb, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void *__cdecl cgrealloc(void *ptr, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
const unsigned __int8 *__cdecl proxytype(proxytypes_t proxytype);
unsigned __int8 *__cdecl get_proxy(unsigned __int8 *url, pool *pool);
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len);
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len);
bool __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len);
bool __cdecl valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl valid_ascii(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl fulltest(const unsigned __int8 *hash, const unsigned __int8 *target);
thread_q *tq_new(); // idb
void __cdecl tq_freezethaw(thread_q *tq, bool frozen);
void __cdecl tq_freeze(thread_q *tq);
bool __cdecl tq_push(thread_q *tq, void *data);
void *__cdecl tq_pop(thread_q *tq, const timespec *abstime);
int __cdecl thr_info_create(thr_info *thr, pthread_attr_t_0 *attr, void *(*start)(void *), void *arg);
void __cdecl thr_info_cancel(thr_info *thr);
void __cdecl subtime(timeval *a, timeval *b);
void __cdecl addtime(timeval *a, timeval *b);
bool __cdecl time_more(timeval *a, timeval *b);
bool __cdecl time_less(timeval *a, timeval *b);
void __cdecl copy_time(timeval *dest, const timeval *src);
void __cdecl timeval_to_spec(timespec *spec, const timeval *val);
void __cdecl us_to_timespec(timespec *spec, int64_t us);
void __cdecl ms_to_timespec(timespec *spec, int64_t ms);
void __cdecl spec_nscheck(timespec *ts);
void __cdecl timeraddspec(timespec *a, const timespec *b);
void __cdecl cgtime(timeval *tv);
void __cdecl cgtimer_time(cgtimer_t *ts_start);
void __cdecl nanosleep_abstime(timespec *ts_end);
void __cdecl cgsleep_ms_r(cgtimer_t *ts_start, int ms);
void __cdecl cgsleep_us_r(cgtimer_t *ts_start, int64_t us);
void __cdecl cgsleep_ms(int ms);
void __cdecl cgsleep_us(int64_t us);
double __cdecl tdiff(timeval *end, timeval *start);
bool __cdecl extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port);
send_ret __cdecl _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
bool __cdecl stratum_send(pool *pool, unsigned __int8 *s, ssize_t len);
bool __cdecl socket_full(pool *pool, int wait);
bool __cdecl sock_full(pool *pool);
void __cdecl clear_sockbuf(pool *pool);
void __cdecl clear_sock(pool *pool);
void __cdecl recalloc_sock(pool *pool, size_t len);
unsigned __int8 *__cdecl recv_line(pool *pool);
unsigned __int8 *__cdecl _json_array_string(json_t_0 *val, unsigned int entry);
unsigned __int8 *__cdecl json_array_string(json_t_0 *val, unsigned int entry);
bool __cdecl parse_notify(pool *pool, json_t_0 *val);
uint32_t __cdecl real_mask(uint32_t mask, int need_bit);
void __cdecl process_version_mask(pool *pool, unsigned __int8 *mask);
bool __cdecl parse_version_mask(pool *pool, json_t_0 *val);
bool __cdecl parse_version_rolling_mask(pool *pool, unsigned __int8 *sret);
bool __cdecl parse_version(pool *pool, json_t_0 *val);
bool __cdecl parse_diff(pool *pool, json_t_0 *val);
bool __cdecl parse_extranonce(pool *pool, json_t_0 *val);
void __cdecl _suspend_stratum(pool *pool);
bool __cdecl parse_reconnect(pool *pool, json_t_0 *val);
bool __cdecl send_version(pool *pool, json_t_0 *val);
bool __cdecl send_pong(pool *pool, json_t_0 *val);
bool __cdecl show_message(pool *pool, json_t_0 *val);
bool __cdecl parse_method(pool *pool, unsigned __int8 *s);
bool __cdecl subscribe_extranonce(pool *pool);
bool __cdecl auth_stratum(pool *pool);
int __cdecl recv_byte(int sockd);
bool __cdecl http_negotiate(pool *pool, int sockd, bool http0);
bool __cdecl socks5_negotiate(pool *pool, int sockd);
bool __cdecl socks4_negotiate(pool *pool, int sockd, bool socks4a);
void __cdecl noblock_socket(int fd);
void __cdecl block_socket(int fd);
bool sock_connecting(); // idb
bool __cdecl setup_stratum_socket(pool *pool);
unsigned __int8 *__cdecl get_sessionid(json_t_0 *val);
void __cdecl suspend_stratum(pool *pool);
bool __cdecl initiate_stratum(pool *pool);
bool __cdecl restart_stratum(pool *pool);
void __cdecl dev_error(cgpu_info *dev, dev_reason reason);
void __cdecl RenameThread(const unsigned __int8 *name);
void __cdecl cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl cgsem_mswait(cgsem_t *cgsem, int ms, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cgsem_destroy(cgsem_t *cgsem);
void *__cdecl completion_thread(void *arg);
bool __cdecl cg_completion_timeout(void *fn, void *fnarg, int timeout);
void __cdecl cg_memcpy(void *dest, const void *src, unsigned int n, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rev(unsigned __int8 *s, size_t l);
unsigned int get_iic(); // idb
unsigned __int8 __cdecl set_iic(unsigned int data);
uint8_t __cdecl znyq_set_iic(unsigned __int8 dev_addr, unsigned __int8 which_iic, bool read, bool reg_addr_valid, unsigned __int8 reg_addr, unsigned __int8 data);
void __cdecl read_fpga_id(unsigned __int8 *pFpgaID);
unsigned int get_nonce2_and_job_id_store_address(); // idb
void __cdecl set_nonce2_and_job_id_store_address(unsigned int value);
int get_job_start_address(); // idb
void __cdecl set_job_start_address(unsigned int value);
int get_QN_write_data_command(); // idb
void __cdecl set_QN_write_data_command(unsigned int value);
void __cdecl set_reset_hashboard(int chainIndex, int resetBit);
int get_fan_control(); // idb
void __cdecl set_fan_control(unsigned int value);
int get_hash_on_plug(); // idb
unsigned int get_crc_count(); // idb
int get_hardware_version(); // idb
void __cdecl set_Hardware_version(unsigned int value);
int __cdecl get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed);
int get_time_out_control(); // idb
void __cdecl set_time_out_control(unsigned int value);
int get_bt8d_control(); // idb
void __cdecl set_bt8d_control(unsigned int value);
int __cdecl get_BC_command_buffer(unsigned int *buf);
void __cdecl set_BC_command_buffer(unsigned int *value);
int get_BC_write_command(); // idb
unsigned int get_nonce_number_in_fifo(); // idb
int __cdecl get_return_nonce(unsigned int *buf);
void __cdecl set_BC_write_command(unsigned int value);
int get_ticket_mask(); // idb
void __cdecl set_ticket_mask(unsigned int value);
int get_job_id(); // idb
void __cdecl set_job_id(unsigned int value);
void __cdecl set_job_length(unsigned int value);
int get_block_header_version(); // idb
int get_block_header_version_1(); // idb
int get_block_header_version_2(); // idb
int get_block_header_version_3(); // idb
void __cdecl set_block_header_version(unsigned int value);
void __cdecl set_block_header_version_1(uint32_t value);
void __cdecl set_block_header_version_2(uint32_t value);
void __cdecl set_block_header_version_3(uint32_t value);
int get_time_stamp(); // idb
void __cdecl set_time_stamp(unsigned int value);
int get_target_bits(); // idb
void __cdecl set_target_bits(unsigned int value);
void __cdecl set_pre_header_hash(unsigned int *value);
int get_coinbase_length_and_nonce2_length(); // idb
void __cdecl set_coinbase_length_and_nonce2_length(unsigned int value);
int __cdecl get_work_nonce2(unsigned int *buf);
void __cdecl set_work_nonce2(unsigned int *value);
int get_merkle_bin_number(); // idb
void __cdecl set_merkle_bin_number(unsigned int value);
int get_nonce_fifo_interrupt(); // idb
void __cdecl set_nonce_fifo_interrupt(unsigned int value);
int get_dhash_acc_control(); // idb
void __cdecl set_dhash_acc_control(unsigned int value);
void __cdecl set_TW_write_command_vil(unsigned int *value);
unsigned int get_buffer_space(); // idb
int get_hash_counting_number(); // idb
void __cdecl set_hash_counting_number(unsigned int value);
void reset_fpga_and_hash_board(); // idb
unsigned int __cdecl _bswap_32_0(unsigned int __bsx);
__uint32_t __cdecl _uint32_identity_0(__uint32_t __x);
__uint64_t __cdecl _uint64_identity_0(__uint64_t __x);
void __cdecl json_decref_0(json_t_0 *json);
void __cdecl _list_del_0(list_head *prev, list_head *next);
void __cdecl list_del_0(list_head *entry);
uint32_t __cdecl swab32_2(uint32_t v);
void __cdecl swap256(void *dest_p, const void *src_p);
void __cdecl swab256_0(void *dest_p, const void *src_p);
void __cdecl flip32_1(void *dest_p, const void *src_p);
void __cdecl flip64(void *dest_p, const void *src_p);
void __cdecl flip80(void *dest_p, const void *src_p);
void __cdecl endian_flip32(void *dest_p, const void *src_p);
void __cdecl mutex_lock_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl wr_trylock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init_0(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_dwlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
bool __cdecl time_before(tm *tm1, tm *tm2);
bool should_run(); // idb
void __cdecl get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv);
void __cdecl get_timestamp(unsigned __int8 *f, size_t fsiz, timeval *tv);
void applog_and_exit(const unsigned __int8 *fmt, ...);
thr_info *__cdecl _get_thread(int thr_id);
thr_info *__cdecl get_thread(int thr_id);
cgpu_info *__cdecl get_thr_cgpu(int thr_id);
cgpu_info *__cdecl get_devices(int id);
void __cdecl sharelog(const unsigned __int8 *disposition, const work *work);
void adjust_quota_gcd(); // idb
pool *add_pool(); // idb
bool __cdecl pool_tset(pool *pool, bool *var);
bool __cdecl pool_tclear(pool *pool, bool *var);
pool *current_pool(); // idb
unsigned __int8 *__cdecl set_int_range(const unsigned __int8 *arg, int *i, int min, int max);
unsigned __int8 *__cdecl set_int_0_to_9999(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_65535(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_10(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_100(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_255(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_7680(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_200(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_32_to_63(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_22_to_75(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_42_to_85(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_22_to_55(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_42_to_65(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_1_to_10(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_int_0_to_4(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl set_balance(pool_strategy *strategy);
unsigned __int8 *__cdecl set_loadbalance(pool_strategy *strategy);
unsigned __int8 *__cdecl set_rotate(const unsigned __int8 *arg, unsigned __int8 *i);
unsigned __int8 *__cdecl set_rr(pool_strategy *strategy);
bool __cdecl detect_stratum(pool *pool, unsigned __int8 *url);
pool *add_url(); // idb
unsigned __int8 *__cdecl setup_url(pool *pool, unsigned __int8 *arg);
unsigned __int8 *__cdecl set_url(unsigned __int8 *arg);
unsigned __int8 *__cdecl set_quota(unsigned __int8 *arg);
unsigned __int8 *__cdecl set_user(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_pass(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_userpass(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_extranonce_subscribe(unsigned __int8 *arg);
unsigned __int8 *__cdecl enable_debug(bool *flag);
unsigned __int8 *__cdecl set_schedtime(const unsigned __int8 *arg, schedtime *st);
unsigned __int8 *__cdecl set_sched_start(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_sched_stop(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_sharelog(unsigned __int8 *arg);
void load_temp_cutoffs(); // idb
unsigned __int8 *__cdecl set_logfile_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logfile_openflag(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logwork_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_logwork_asicnum(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_float_125_to_500(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_float_100_to_250(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_float_0_to_500(const unsigned __int8 *arg, float *i);
unsigned __int8 *__cdecl set_null(const unsigned __int8 *arg);
unsigned __int8 *__cdecl set_version_path(const unsigned __int8 *arg);
unsigned __int8 *__cdecl parse_config(json_t_0 *config, bool fileconf);
unsigned __int8 *__cdecl load_config(const unsigned __int8 *arg, void *unused);
unsigned __int8 *__cdecl set_default_config(const unsigned __int8 *arg);
void load_default_config(); // idb
unsigned __int8 *__cdecl opt_verusage_and_exit(const unsigned __int8 *extra);
void __cdecl calc_midstate(work *work);
int total_work_inc(); // idb
work *make_work(); // idb
void __cdecl clean_work(work *work);
void __cdecl free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl decay_time(double *f, double fadd, double fsecs, double interval);
unsigned int _total_staged(); // idb
void __cdecl suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits);
double __cdecl cgpu_runtime(cgpu_info *cgpu);
void __cdecl get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
bool shared_strategy();
void __cdecl enable_pool(pool *pool);
void __cdecl reject_pool(pool *pool);
void __cdecl share_result(json_t_0 *val, json_t_0 *res, json_t_0 *err, const work *work, unsigned __int8 *hashshow, bool resubmit, unsigned __int8 *worktime);
void __cdecl show_hash(work *work, unsigned __int8 *hashshow);
bool __cdecl pool_unusable(pool *pool);
pool *__cdecl select_balanced(pool *cp);
pool *select_pool(); // idb
double __cdecl le256todouble(const void *target);
double __cdecl diff_from_target(void *target);
void __cdecl calc_diff(work *work, double known);
void __cdecl get_benchmark_work(work *work);
void __cdecl benchfile_dspwork(work *work, uint32_t nonce);
bool __cdecl benchfile_get_work(work *work);
void __cdecl get_benchfile_work(work *work);
void __cdecl kill_timeout(thr_info *thr);
void kill_mining(); // idb
void _kill_work(); // idb
void __noreturn kill_work(); // idb
void __fastcall sub_4DAA8(int a1, int a2, int a3, int a4, int a5, int a6);
void app_restart(); // idb
void __cdecl sighandler(int sig);
void __fastcall sub_4DC90(int a1, int a2, int a3, int a4, int a5, int a6);
void *__cdecl submit_work_thread(void *userdata);
unsigned __int8 *__cdecl offset_ntime(const unsigned __int8 *ntime, int noffset);
void __cdecl copy_work(work *work, const work *base_work, int noffset);
work *__cdecl copy_work_noffset(work *base_work, int noffset);
void __cdecl pool_died(pool *pool);
bool __cdecl stale_work(work *work, bool share);
uint64_t __cdecl share_diff(const work *work);
void __cdecl regen_hash(work *work);
pool *__cdecl priority_pool(int choice);
void __cdecl switch_pools(pool *selected);
void __cdecl discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void wake_gws(); // idb
void discard_stale(); // idb
void *__cdecl restart_thread(void *arg);
void restart_threads(); // idb
void signal_work_update(); // idb
void __cdecl set_curblock(const unsigned __int8 *hexstr, const unsigned __int8 *bedata);
int __cdecl block_sort(block *blocka, block *blockb);
void __cdecl set_blockdiff(const work *work);
bool __cdecl block_exists(const unsigned __int8 *hexstr, const unsigned __int8 *bedata, const work *work);
bool __cdecl test_work_current(work *work);
int __cdecl tv_sort(work *worka, work *workb);
bool __cdecl work_rollable(work *work);
bool __cdecl hash_push(work *work);
void __cdecl stage_work(work *work);
void __cdecl remove_pool(pool *pool);
void json_escape_free(); // idb
unsigned __int8 *__cdecl json_escape(unsigned __int8 *str);
void __cdecl write_config(FILE *fcfg);
void zero_bestshare(); // idb
void zero_stats(); // idb
void set_highprio(); // idb
void set_lowprio(); // idb
void __cdecl default_save_file(unsigned __int8 *filename);
void *__cdecl api_thread(void *userdata);
void __cdecl thread_reportin(thr_info *thr);
void __cdecl thread_reportout(thr_info *thr);
void __cdecl hashmeter(int thr_id, uint64_t hashes_done);
void __cdecl stratum_share_result(json_t_0 *val, json_t_0 *res_val, json_t_0 *err_val, stratum_share *sshare);
bool __cdecl parse_stratum_response(pool *pool, unsigned __int8 *s);
void __cdecl clear_stratum_shares(pool *pool);
void __cdecl clear_pool_work(pool *pool);
int cp_prio(); // idb
bool __cdecl cnx_needed(pool *pool);
void __cdecl stratum_resumed(pool *pool);
bool __cdecl supports_resume(pool *pool);
void *__cdecl stratum_rthread(void *userdata);
void *__cdecl stratum_sthread(void *userdata);
void __cdecl init_stratum_threads(pool *pool);
bool __cdecl stratum_works(pool *pool);
bool __cdecl setup_gbt_solo(CURL *curl, pool *pool);
void __cdecl pool_start_lp(pool *pool);
bool __cdecl pool_active(pool *pool, bool pinging);
void __cdecl pool_resus(pool *pool);
work *__cdecl hash_pop(bool blocking);
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len);
void __cdecl set_target(unsigned __int8 *dest_target, double diff);
void __cdecl get_work_by_nonce2(thr_info *thr, work **work, pool *pool, pool *real_pool, uint64_t nonce2, uint32_t version);
void __cdecl gen_stratum_work(pool *pool, work *work);
void __cdecl set_benchmark_work(cgpu_info *cgpu, work *work);
work *__cdecl get_work(thr_info *thr, const int thr_id);
void __cdecl submit_work_async(work *work);
void __cdecl inc_hw_errors(thr_info *thr);
void __cdecl rebuild_nonce(work *work, uint32_t nonce);
bool __cdecl test_nonce(work *work, uint32_t nonce);
void __cdecl update_work_stats(thr_info *thr, work *work);
bool __cdecl submit_tested_work(thr_info *thr, work *work);
bool __cdecl new_nonce(thr_info *thr, uint32_t nonce);
bool __cdecl submit_nonce(thr_info *thr, work *work, uint32_t nonce);
bool __cdecl abandon_work(work *work, timeval *wdiff, uint64_t hashes);
void __cdecl mt_disable(thr_info *mythr, const int thr_id, device_drv *drv);
void __cdecl hash_sole_work(thr_info *mythr);
void __cdecl flush_queue(cgpu_info *cgpu);
void __cdecl hash_driver_work(thr_info *mythr);
void *__cdecl miner_thread(void *userdata);
void __cdecl wait_lpcurrent(pool *pool);
void *__cdecl longpoll_thread(void *userdata);
void __cdecl reinit_device(cgpu_info *cgpu);
void __cdecl reap_curl(pool *pool);
void __cdecl prune_stratum_shares(pool *pool);
void *__cdecl watchpool_thread(void *userdata);
void *__cdecl watchdog_thread(void *userdata);
void __cdecl log_print_status(cgpu_info *cgpu);
void print_summary(); // idb
void __cdecl clean_up(bool restarting);
void *__cdecl killall_thread(void *arg);
void __cdecl _quit(int status, bool clean);
void __cdecl quit(int status);
void __fastcall sub_61BC8(int a1, int a2, int a3, int a4, int a5, int a6);
void *__cdecl test_pool_thread(void *arg);
bool __cdecl add_pool_details(pool *pool, bool live, unsigned __int8 *url, unsigned __int8 *user, unsigned __int8 *pass);
void fork_monitor(); // idb
void __cdecl noop_reinit_device(cgpu_info *cgpu);
void __cdecl blank_get_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
void __cdecl noop_get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu);
bool __cdecl noop_get_stats(cgpu_info *cgpu);
bool __cdecl noop_thread_prepare(thr_info *thr);
bool __cdecl noop_thread_init(thr_info *thr);
bool __cdecl noop_prepare_work(thr_info *thr, work *work);
void __cdecl noop_hw_error(thr_info *thr);
void __cdecl noop_thread_shutdown(thr_info *thr);
void __cdecl noop_thread_enable(thr_info *thr);
void __cdecl noop_detect(bool hotplug);
void __cdecl generic_zero_stats(cgpu_info *cgpu);
void __cdecl fill_device_drv(device_drv *drv);
void __cdecl enable_device(cgpu_info *cgpu);
void adjust_mostdevs(); // idb
bool __cdecl add_cgpu(cgpu_info *cgpu);
void probe_pools(); // idb
void set_start_time_point(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
void __cdecl register_parse_clock_delay_ctrl(reg_status_t *reg_status);
void __cdecl register_parse_process_monitor_ctrl(reg_status_t *reg_status);
void __cdecl register_parse_process_monitor_data(reg_status_t *reg_status);
void __cdecl register_parse_core_error(reg_status_t *reg_status);
void __cdecl register_parse_core_enable(reg_status_t *reg_status);
void __cdecl register_parse_hash_clock_ctrl(reg_status_t *reg_status);
void __cdecl register_parse_hash_clock_counter(reg_status_t *reg_status);
void __cdecl register_parse_sweep_freq_ctrl(reg_status_t *reg_status);
void __cdecl register_parse_chip_address(reg_status_t *reg_status);
void __cdecl register_parse_hash_rate(reg_status_t *reg_status);
void __cdecl register_parse_pll0_parameter(reg_status_t *reg_status);
void __cdecl register_parse_chip_nonce_offset(reg_status_t *reg_status);
void __cdecl register_parse_hash_counting_number(reg_status_t *reg_status);
void __cdecl register_parse_ticket_mask(reg_status_t *reg_status);
void __cdecl register_parse_misc_control(reg_status_t *reg_status);
void __cdecl register_parse_ordered_clock_enable(reg_status_t *reg_status);
void __cdecl register_parse_ticket_mask2(reg_status_t *reg_status);
void __cdecl register_parse_external_temperature_sensor_read(reg_status_t *reg_status);
void __cdecl register_parse_error_flag(reg_status_t *reg_status);
void __cdecl register_parse_nonce_error_counter(reg_status_t *reg_status);
void __cdecl register_parse_nonce_overflow_counter(reg_status_t *reg_status);
void __cdecl register_parse_analog_mux_control(reg_status_t *reg_status);
void __cdecl register_parse_io_drive_strength_configuration(reg_status_t *reg_status);
void __cdecl register_parse_time_out(reg_status_t *reg_status);
void __cdecl register_parse_pll1_parameter(reg_status_t *reg_status);
void __cdecl register_parse_pll2_parameter(reg_status_t *reg_status);
void __cdecl register_parse_pll3_parameter(reg_status_t *reg_status);
void __cdecl register_parse_ordered_clock_monitor(reg_status_t *reg_status);
void __cdecl register_parse_pll0_divider(reg_status_t *reg_status);
void __cdecl register_parse_pll1_divider(reg_status_t *reg_status);
void __cdecl register_parse_pll2_divider(reg_status_t *reg_status);
void __cdecl register_parse_pll3_divider(reg_status_t *reg_status);
void __cdecl register_parse_clock_order_0(reg_status_t *reg_status);
void __cdecl register_parse_clock_order_1(reg_status_t *reg_status);
void __cdecl register_parse_frequency_sweep_control(reg_status_t *reg_status);
void __cdecl register_parse_golden_nonce_for_sweep_return(reg_status_t *reg_status);
void __cdecl register_parse_returned_group_pattern_status(reg_status_t *reg_status);
void __cdecl register_parse_nonce_returned_timeout(reg_status_t *reg_status);
void __cdecl register_parse_returned_single_pattern_status(reg_status_t *reg_status);
void __cdecl register_build_core_command_read_one(core_command_t *core_cmd, uint32_t core_id, uint8_t reg);
void __cdecl register_build_get_status_command(get_status_t *get_st, uint8_t asic, uint8_t reg);
void __cdecl register_build_set_config_command(set_config_t *set_cfg, uint8_t asic, core_command_t *core_cmd);
void __cdecl register_build_bc_command(uint32_t *bc_cmd, uint8_t *cmd, int len);
bool __cdecl register_process_asic_response(int chain, uint8_t asic, uint8_t reg, uint32_t *response);
void __cdecl register_receive_asic_response(int chain, uint8_t asic, uint8_t reg, reg_status_t *reg_status);
void __cdecl register_send_core_cmd_read_one(int chain, uint8_t asic, uint32_t core_id, uint8_t core_reg);
void __cdecl register_send_asic_cmd_read_one(int chain, uint8_t asic, uint8_t asic_reg);
void __cdecl register_dump_core_reg(uint8_t core_reg, reg_status_t *reg_status);
void __cdecl register_dump_asic_reg(uint8_t asic_reg, reg_status_t *reg_status);
bool __cdecl register_is_param_valid(int chain, uint8_t asic, uint8_t core);
void __cdecl do_dump_core_reg(int chain, uint8_t asic, uint32_t core);
void __cdecl do_dump_asic_reg(int chain, uint8_t asic);
int __cdecl my_system(const unsigned __int8 *cmd);
int __cdecl log_update_name(const _log_ctx *ctx, const unsigned __int8 *prefix, const unsigned __int8 *path, const unsigned __int8 *ts);
int __cdecl log_rotate(const _log_ctx *ctx);
int __cdecl log_generate_symbol_link(const _log_ctx *ctx, const unsigned __int8 *prefix, const unsigned __int8 *path);
int __cdecl log_remount(const _log_ctx *ctx);
void *__cdecl log_thread_routine(void *arg);
void log_init(); // idb
void __cdecl set_log_level(unsigned int level);
void __cdecl clear_log(unsigned __int8 *file);
void __cdecl copy_log_to_latest(unsigned __int8 *file);
void __cdecl print_crt_time_to_file(const unsigned __int8 *file, unsigned int level);
void __cdecl dump_mem(unsigned __int8 *desc, void *addr, int len);
uint8_t __cdecl eeprom_write_iic(uint8_t chain, uint8_t reg_addr, uint8_t data);
uint8_t __cdecl eeprom_read_iic(uint8_t chain, uint8_t reg_addr);
int __cdecl eeprom_write_iic_bytes(uint8_t chain, int reg_addr_start, int reg_count, uint8_t *buf);
int __cdecl eeprom_read_iic_bytes(uint8_t chain, int reg_addr_start, int reg_count, uint8_t *buf);
void __cdecl eeprom_dump_raw(uint8_t *buf, int len);
void __cdecl eeprom_dump_fileds(eeprom_layout_t *eeprom_buf);
void __cdecl eeprom_dump(eeprom_layout_t *eeprom_buf);
bool __cdecl eeprom_is_fixture_crc_pass(eeprom_layout_t *eeprom_buf);
bool __cdecl eeprom_is_cgminer_crc_pass(eeprom_layout_t *eeprom_buf);
bool __cdecl eeprom_is_fixture_header_pass(eeprom_layout_t *eeprom_buf);
bool __cdecl eeprom_is_cgminer_header_pass(eeprom_layout_t *eeprom_buf);
int __cdecl eeprom_load_one_chain(int chain, eeprom_layout_t *eeprom_buf);
int __cdecl eeprom_flush_one_chain(int chain, eeprom_layout_t *eeprom_buf);
void eeprom_load(); // idb
void eeprom_dump(); // idb
int eeprom_flush(); // idb
uint16_t __cdecl eeprom_get_pcb_version(int chain);
uint16_t __cdecl eeprom_get_bom_version(int chain);
int eeprom_get_freq_store_step(); // idb
int __cdecl eeprom_get_freq(int chain, int mode, uint32_t *buf, int len);
int __cdecl eeprom_get_voltage(int chain, int mode, int *voltage);
int __cdecl eeprom_get_hash_rate(int chain, int mode, uint32_t *hash_rate);
int __cdecl eeprom_set_freq(int chain, int mode, int *buf, uint8_t len);
int __cdecl eeprom_set_voltage(int chain, int mode, uint16_t voltage);
int __cdecl eeprom_set_hash_rate(int chain, int mode, uint32_t hash_rate);
uint8_t __cdecl write_pic_iic(uint8_t chain, uint8_t data);
uint8_t __cdecl read_pic_iic(uint8_t chain);
void __cdecl send_pic_cmd(uint8_t chain, uint8_t cmd, uint8_t len, uint8_t *crc, uint8_t *reply_buf, uint8_t reply_len);
int __cdecl volt_clamp(uint8_t chain, uint8_t enable);
int __cdecl pic_voltage_clamp_disable(uint8_t chain);
int __cdecl hashboard_power_cntl(uint8_t chain, uint8_t enable);
int __cdecl hashboard_power_on(uint8_t chain);
int __cdecl hashboard_power_off(uint8_t chain);
int __cdecl pic_reset(uint8_t chain);
int __cdecl pic_set_heart_beat(uint8_t chain);
int __cdecl jump_to_app_from_loader(uint32_t chain);
int __cdecl pic_init(uint8_t chain);
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
void __cdecl sha256_init(sha256_ctx *ctx);
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __cdecl mutex_init_1(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rwlock_init_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cglock_init_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_LIST *__cdecl k_new_list(const unsigned __int8 *name, size_t siz, int allocate, int limit, bool do_tail, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
K_ITEM *__cdecl k_unlink_head(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl k_add_head(K_LIST *list, K_ITEM *item, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int is_S15();
int is_T15();
void __cdecl send_set_config_command(int chain, uint8_t mode, uint8_t chip_addr, uint8_t reg_addr, uint32_t reg_data);
void __cdecl send_set_config_command_all_chain(uint8_t mode, uint8_t dev_addr, uint8_t reg_addr, uint32_t reg_data);
void __cdecl chain_inactive(unsigned __int8 chain);
void __cdecl set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address);
void __cdecl set_asic_ticket_mask(unsigned int ticket_mask);
void __cdecl set_baud_ext(int chain);
int __cdecl get_bt8d_chip_divider(int baud);
int __cdecl get_bt8d_fpga_divider(int baud);
void __cdecl set_baud_fpga(int baud);
void __cdecl set_baud_one_chain(int baud, int change_fpga_baud, const unsigned __int8 chain);
void __cdecl enable_core_clock_BM1391(unsigned int core_id, unsigned __int8 mode, unsigned __int8 chain);
void __cdecl set_core_cmd_BM1391(core_cmd *core);
void __cdecl set_config_BM1391_t(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 mode, unsigned __int8 reg, unsigned int reg_data);
void __cdecl read_asic_register(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 chip_addr, unsigned __int8 reg_addr);
void __cdecl read_temp(unsigned __int8 device, unsigned int reg, unsigned __int8 data, unsigned __int8 write, unsigned __int8 chip_addr, int chain);
void __cdecl set_misc_control(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 addr, int i2c);
void __cdecl mutex_lock_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
int __cdecl mutex_trylock_0(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force);
void __cdecl applog(int prio, const unsigned __int8 *str, bool force);
void *__cdecl statusServiceThread(void *param);
void *__cdecl httpListenThread(void *param);
void start_http_thread(); // idb
void __cdecl json_decref_1(json_t_0 *json);
int sock_blocks_0();
void __cdecl mutex_lock_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_noyield_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_unlock_3(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_lock_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_lock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rw_unlock_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl wr_unlock_noyield_2(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl rd_unlock_1(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl mutex_init_2(pthread_mutex_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_rlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_runlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl cg_wunlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line);
void __cdecl io_reinit(io_data *io_data);
io_data *__cdecl io_new(size_t initial, bool socket_buf);
bool __cdecl io_add(io_data *io_data, unsigned __int8 *buf);
bool __cdecl io_put(io_data *io_data, unsigned __int8 *buf);
void __cdecl io_close(io_data *io_data);
void io_free(); // idb
unsigned __int8 *__cdecl escape_string(unsigned __int8 *str, bool isjson);
api_data *__cdecl api_add_extra(api_data *root, api_data *extra);
api_data *__cdecl api_add_data_full(api_data *root, unsigned __int8 *name, api_data_type type, void *data, bool copy_data);
api_data *__cdecl api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data);
api_data *__cdecl api_add_uint8(api_data *root, unsigned __int8 *name, uint8_t *data, bool copy_data);
api_data *__cdecl api_add_int16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data);
api_data *__cdecl api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data);
api_data *__cdecl api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data);
api_data *__cdecl api_add_uint32(api_data *root, unsigned __int8 *name, uint32_t *data, bool copy_data);
api_data *__cdecl api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data);
api_data *__cdecl api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data);
api_data *__cdecl api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data);
api_data *__cdecl api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data);
api_data *__cdecl api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data);
api_data *__cdecl api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data);
api_data *__cdecl api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
api_data *__cdecl api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data);
void __cdecl add_item_buf(K_ITEM *item, const unsigned __int8 *str);
api_data *__cdecl print_data(io_data *io_data, api_data *root, bool isjson, bool precom);
int numascs(); // idb
int __cdecl ascdevice(int ascid);
void __cdecl message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson);
void __cdecl lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
const unsigned __int8 *__cdecl status2str(alive status);
void __cdecl ascstatus(io_data *io_data, int asc, bool isjson, bool precom);
void __cdecl devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void get_AVG_hashrate(); // idb
void get_total_hashs(); // idb
void get_total_secs();
void __cdecl lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl copyadvanceafter(unsigned __int8 ch, unsigned __int8 **param, unsigned __int8 **buf);
bool __cdecl pooldetails(unsigned __int8 *param, unsigned __int8 **url, unsigned __int8 **user, unsigned __int8 **pass);
void __cdecl addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group);
void __cdecl notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
int __cdecl itemstats(io_data *io_data, int i, unsigned __int8 *id, cgminer_stats *stats, cgminer_pool_stats *pool_stats, api_data *extra, cgpu_info *cgpu, bool isjson);
void __cdecl minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascdev(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascenable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascdisable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascidentify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl ascset(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group);
void __cdecl head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin);
void __cdecl tail_join(io_data *io_data, bool isjson);
void __cdecl send_result(io_data *io_data, int c, bool isjson);
void __cdecl tidyup(void *arg);
void setup_groups(); // idb
void setup_ipaccess(); // idb
void *__cdecl quit_thread(void *userdata);
void __fastcall sub_858F0(int a1, int a2, int a3, int a4, int a5, int a6);
void *__cdecl restart_thread_0(void *userdata);
bool __cdecl check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group);
void mcast(); // idb
void *__cdecl mcast_thread(void *userdata);
void mcast_init(); // idb
void re_calculate_AVG(); // idb
void __cdecl api(int api_thr_id);
void __cdecl sha2_starts(sha2_context *ctx);
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
unsigned __int8 *__cdecl arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg);
unsigned __int8 *__cdecl opt_set_bool(bool *b);
unsigned __int8 *__cdecl opt_set_false(bool *b);
unsigned __int8 *__cdecl opt_set_invbool(bool *b);
unsigned __int8 *__cdecl opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p);
unsigned __int8 *__cdecl opt_set_intval(const unsigned __int8 *arg, int *i);
unsigned __int8 *__cdecl opt_set_floatval(const unsigned __int8 *arg, float *f);
unsigned __int8 *__cdecl opt_set_longval(const unsigned __int8 *arg, int *l);
unsigned __int8 *__cdecl opt_version_and_exit(const unsigned __int8 *version);
unsigned __int8 *__cdecl opt_usage_and_exit(const unsigned __int8 *extra);
void __cdecl opt_show_intval(unsigned __int8 *buf, const int *i);
void __cdecl opt_show_floatval(unsigned __int8 *buf, const float *f);
const unsigned __int8 *__cdecl first_name(const unsigned __int8 *names, unsigned int *len);
const unsigned __int8 *__cdecl next_name(const unsigned __int8 *names, unsigned int *len);
const unsigned __int8 *__cdecl first_opt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl first_lopt(unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len);
const unsigned __int8 *__cdecl first_sopt(unsigned int *i);
const unsigned __int8 *__cdecl next_sopt(const unsigned __int8 *p, unsigned int *i);
void __cdecl check_opt(const opt_table *entry);
void __cdecl add_opt(const opt_table *entry);
void __cdecl opt_register_table(const opt_table *entry, const unsigned __int8 *desc);
bool __cdecl opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...));
unsigned int __cdecl write_short_options(unsigned __int8 *str);
unsigned __int8 *__cdecl opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra);
int __cdecl parse_err(void (*errlog)(const unsigned __int8 *, ...), const unsigned __int8 *argv0, const unsigned __int8 *arg, unsigned int len, const unsigned __int8 *problem);
void __cdecl consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum);
int __cdecl parse_one(int *argc, unsigned __int8 **argv, unsigned int *offset, void (*errlog)(const unsigned __int8 *, ...));
int __cdecl strbuffer_init(strbuffer_t *strbuff);
void __cdecl strbuffer_close(strbuffer_t *strbuff);
void __cdecl strbuffer_clear(strbuffer_t *strbuff);
const unsigned __int8 *__cdecl strbuffer_value(const strbuffer_t *strbuff);
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte);
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size);
unsigned __int8 __cdecl strbuffer_pop(strbuffer_t *strbuff);
void __cdecl jsonp_error_init(json_error_t *error, const unsigned __int8 *source);
void __cdecl jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source);
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...);
void __cdecl jsonp_error_vset(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, va_list ap);
void __cdecl to_locale(strbuffer_t *strbuffer);
void __cdecl from_locale(unsigned __int8 *buffer);
int __cdecl jsonp_strtod(strbuffer_t *strbuffer, double *out);
int __cdecl jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value, int precision);
void __cdecl json_decref_2(json_t_0 *json);
void __cdecl json_init(json_t_0 *json, json_type type);
json_object_t *json_object(); // idb
void __cdecl json_delete_object(json_object_t *object);
size_t __cdecl json_object_size(const json_t_0 *json);
json_t_0 *__cdecl json_object_get(const json_t_0 *json, const unsigned __int8 *key);
int __cdecl json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value);
void *__cdecl json_object_iter(json_t_0 *json);
void *__cdecl json_object_iter_next(json_t_0 *json, void *iter);
const unsigned __int8 *__cdecl json_object_iter_key(void *iter);
json_t_0 *__cdecl json_object_iter_value(void *iter);
void *__cdecl json_object_key_to_iter(const unsigned __int8 *key);
json_array_t *json_array(); // idb
void __cdecl json_delete_array(json_array_t *array);
size_t __cdecl json_array_size(const json_t_0 *json);
json_t_0 *__cdecl json_array_get(const json_t_0 *json, size_t index);
void __cdecl array_copy(json_t_0 **dest, size_t dpos, json_t_0 **src, size_t spos, size_t count);
json_t_0 **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy);
int __cdecl json_array_append_new(json_t_0 *json, json_t_0 *value);
json_t_0 *__cdecl string_create(const unsigned __int8 *value, size_t len, int own);
json_t_0 *__cdecl jsonp_stringn_nocheck_own(const unsigned __int8 *value, size_t len);
const unsigned __int8 *__cdecl json_string_value(const json_t_0 *json);
size_t __cdecl json_string_length(const json_t_0 *json);
void __cdecl json_delete_string(json_string_t *string);
json_t_0 *__cdecl json_integer(json_int_t value);
json_int_t __cdecl json_integer_value(const json_t_0 *json);
void __cdecl json_delete_integer(json_integer_t *integer);
json_t_0 *__cdecl json_real(double value);
double __cdecl json_real_value(const json_t_0 *json);
void __cdecl json_delete_real(json_real_t *real);
double __cdecl json_number_value(const json_t_0 *json);
json_t_0 *json_true(); // idb
json_t_0 *json_false(); // idb
json_t_0 *json_null(); // idb
void __cdecl json_delete(json_t_0 *json);
int __cdecl seed_from_timestamp_and_pid(uint32_t *seed);
uint32_t generate_seed(); // idb
void __cdecl json_object_seed(size_t seed);
json_t_0 *__cdecl json_incref(json_t_0 *json);
void __cdecl json_decref_3(json_t_0 *json);
int __cdecl json_object_set_nocheck(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value);
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value);
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *msg, ...);
void __cdecl stream_init(stream_t *stream, get_func get, void *data);
int __cdecl stream_get(stream_t *stream, json_error_t *error);
void __cdecl stream_unget(stream_t *stream, int c);
int __cdecl lex_get(lex_t *lex, json_error_t *error);
void __cdecl lex_save(lex_t *lex, int c);
int __cdecl lex_get_save(lex_t *lex, json_error_t *error);
void __cdecl lex_unget(lex_t *lex, int c);
void __cdecl lex_unget_unsave(lex_t *lex, int c);
void __cdecl lex_save_cached(lex_t *lex);
void __cdecl lex_free_string(lex_t *lex);
int32_t __cdecl decode_unicode_escape(const unsigned __int8 *str);
void __cdecl lex_scan_string(lex_t *lex, json_error_t *error);
int __cdecl lex_scan_number(lex_t *lex, int c, json_error_t *error);
int __cdecl lex_scan(lex_t *lex, json_error_t *error);
unsigned __int8 *__cdecl lex_steal_string(lex_t *lex, size_t *out_len);
int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data);
void __cdecl lex_close(lex_t *lex);
json_t_0 *__cdecl parse_object(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_array(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_value(lex_t *lex, size_t flags, json_error_t *error);
json_t_0 *__cdecl parse_json(lex_t *lex, size_t flags, json_error_t *error);
int __cdecl string_get(void *data);
json_t_0 *__cdecl json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error);
int __cdecl buffer_get(void *data);
json_t_0 *__cdecl json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error);
json_t_0 *__cdecl json_loadf(FILE *input, size_t flags, json_error_t *error);
json_t_0 *__cdecl json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error);
int __cdecl dump_to_strbuffer(const unsigned __int8 *buffer, size_t size, void *data);
int __cdecl dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data);
int __cdecl dump_string(const unsigned __int8 *str, size_t len, json_dump_callback_t dump, void *data, size_t flags);
int __cdecl compare_keys(const void *key1, const void *key2);
int __cdecl do_dump(const json_t_0 *json, size_t flags, int depth, json_dump_callback_t dump, void *data);
unsigned __int8 *__cdecl json_dumps(const json_t_0 *json, size_t flags);
int __cdecl json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags);
void *__cdecl jsonp_malloc(size_t size);
void __cdecl jsonp_free(void *ptr);
unsigned __int8 *__cdecl jsonp_strdup(const unsigned __int8 *str);
unsigned __int8 *__cdecl jsonp_strndup(const unsigned __int8 *str, size_t len);
int __cdecl utf8_encode(int32_t codepoint, unsigned __int8 *buffer, size_t *size);
size_t __cdecl utf8_check_first(unsigned __int8 byte);
size_t __cdecl utf8_check_full(const unsigned __int8 *buffer, size_t size, int32_t *codepoint);
const unsigned __int8 *__cdecl utf8_iterate(const unsigned __int8 *buffer, size_t bufsize, int32_t *codepoint);
void __cdecl json_decref_4(json_t_0 *json);
uint32_t __cdecl hashlittle(const void *key, size_t length, uint32_t initval);
void __cdecl list_init(list_t *list);
void __cdecl list_insert(list_t *list, list_t *node);
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket);
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list);
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const unsigned __int8 *key, size_t hash);
void __cdecl hashtable_do_clear(hashtable_t *hashtable);
int __cdecl hashtable_do_rehash(hashtable_t *hashtable);
int __cdecl hashtable_init(hashtable_t *hashtable);
void __cdecl hashtable_close(hashtable_t *hashtable);
int __cdecl hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, json_t_0 *value);
void *__cdecl hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key);
void *__cdecl hashtable_iter(hashtable_t *hashtable);
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter);
void *__cdecl hashtable_iter_key(void *iter);
void *__cdecl hashtable_iter_value(void *iter);
void *__cdecl rpl_memchr(const void *s, int c_in, size_t n);
size_t __cdecl critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period);
void *__cdecl two_way_short_needle(const unsigned __int8 *haystack, size_t haystack_len, const unsigned __int8 *needle, size_t needle_len);
void *__cdecl two_way_long_needle(const unsigned __int8 *haystack, size_t haystack_len, const unsigned __int8 *needle, size_t needle_len);
void *__cdecl memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len);
int __fastcall divsi3_skip_div0_test(int result, unsigned int); // idb
int _aeabi_ldiv0();
int __fastcall _udivmoddi4(unsigned __int64, unsigned __int64, unsigned __int64 *); // idb
void __fastcall _libc_csu_init(int, int, int); // idb
int _libc_csu_fini(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_97384; // weak
void *off_97F50 = (void *)0x353154; // weak
const unsigned __int8 _FUNCTION___12783[25] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  103u,
  101u,
  116u,
  95u,
  109u,
  97u,
  120u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _func___12822[24] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  99u,
  114u,
  101u,
  97u,
  116u,
  101u,
  95u,
  105u,
  110u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12824[24] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  99u,
  114u,
  101u,
  97u,
  116u,
  101u,
  95u,
  105u,
  110u,
  102u,
  111u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12863[27] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  97u,
  114u,
  97u,
  109u,
  101u,
  116u,
  101u,
  114u,
  95u,
  100u,
  117u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12903[24] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  95u,
  100u,
  117u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12952[26] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  95u,
  119u,
  111u,
  114u,
  107u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12968[21] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  101u,
  110u,
  118u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12983[44] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  103u,
  101u,
  116u,
  95u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  116u,
  101u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  97u,
  110u,
  100u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13041[32] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13074[22] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13115[35] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  95u,
  117u,
  110u,
  98u,
  97u,
  108u,
  97u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13146[28] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  119u,
  97u,
  105u,
  116u,
  95u,
  114u,
  101u,
  99u,
  118u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___13257[40] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  115u,
  101u,
  116u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  113u,
  117u,
  97u,
  108u,
  105u,
  116u,
  121u,
  95u,
  112u,
  101u,
  114u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___13283[27] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  97u,
  98u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13303[34] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  114u,
  105u,
  110u,
  116u,
  95u,
  99u,
  104u,
  105u,
  112u,
  95u,
  114u,
  97u,
  116u,
  101u,
  95u,
  116u,
  97u,
  98u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13329[29] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  114u,
  105u,
  110u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  97u,
  98u,
  108u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13357[39] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  105u,
  110u,
  97u,
  108u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13386[28] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  112u,
  114u,
  101u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13401[21] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  114u,
  101u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13458[32] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  103u,
  101u,
  116u,
  95u,
  105u,
  100u,
  101u,
  97u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13502[46] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  102u,
  111u,
  114u,
  95u,
  108u,
  111u,
  119u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13530[52] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  102u,
  111u,
  114u,
  95u,
  112u,
  111u,
  111u,
  114u,
  95u,
  104u,
  101u,
  97u,
  116u,
  95u,
  100u,
  105u,
  115u,
  115u,
  105u,
  112u,
  97u,
  116u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13556[49] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  97u,
  99u,
  99u,
  111u,
  114u,
  100u,
  105u,
  110u,
  103u,
  95u,
  116u,
  111u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13595[47] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  102u,
  111u,
  114u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  116u,
  101u,
  109u,
  112u,
  101u,
  114u,
  97u,
  116u,
  117u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13610[35] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  102u,
  111u,
  114u,
  95u,
  74u,
  95u,
  84u,
  72u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13632[56] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  102u,
  111u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  95u,
  116u,
  104u,
  114u,
  101u,
  115u,
  104u,
  111u,
  108u,
  100u,
  95u,
  83u,
  49u,
  53u,
  95u,
  72u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13662[50] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  100u,
  106u,
  117u,
  115u,
  116u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  95u,
  102u,
  111u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  95u,
  116u,
  104u,
  114u,
  101u,
  115u,
  104u,
  111u,
  108u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13672[24] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  115u,
  97u,
  118u,
  101u,
  95u,
  114u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13692[33] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  109u,
  97u,
  114u,
  107u,
  95u,
  117u,
  110u,
  98u,
  97u,
  108u,
  97u,
  110u,
  99u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13738[32] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  97u,
  116u,
  116u,
  101u,
  114u,
  110u,
  95u,
  116u,
  101u,
  115u,
  116u,
  95u,
  115u,
  101u,
  114u,
  105u,
  97u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13748[29] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  95u,
  71u,
  72u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13763[25] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  112u,
  97u,
  116u,
  116u,
  101u,
  114u,
  110u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13783[38] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  116u,
  101u,
  115u,
  116u,
  95u,
  98u,
  97u,
  115u,
  101u,
  100u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _func___13802[31] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  108u,
  108u,
  111u,
  99u,
  95u,
  119u,
  111u,
  114u,
  107u,
  115u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13804[31] =
{
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  95u,
  97u,
  108u,
  108u,
  111u,
  99u,
  95u,
  119u,
  111u,
  114u,
  107u,
  115u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13815[15] =
{
  100u,
  111u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  116u,
  117u,
  110u,
  105u,
  110u,
  103u,
  0u
}; // idb
const fan_speed_temp_args_t fan_speed_temp_arg[4][5] =
{
  { { 10, 20 }, { 30, 40 }, { 45, 60 }, { 100, 100 }, { 0, 0 } },
  { { 10, 20 }, { 30, 40 }, { 44, 60 }, { 100, 100 }, { 0, 0 } },
  { { 13, 20 }, { 33, 60 }, { 47, 100 }, { 100, 100 }, { 0, 0 } },
  { { 10, 20 }, { 32, 40 }, { 46, 60 }, { 100, 100 }, { 0, 0 } }
}; // idb
const target_temp_args_t target_temp_arg[2][4] =
{
  { { 2, 30 }, { 25, 47 }, { 31, 47 }, { 42, 68 } },
  { { 5, 38 }, { 27, 53 }, { 32, 53 }, { 42, 68 } }
}; // idb
const unsigned __int8 _FUNCTION___11116[25] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  119u,
  105u,
  116u,
  104u,
  95u,
  97u,
  100u,
  100u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11190[26] =
{
  99u,
  97u,
  108u,
  105u,
  98u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  115u,
  101u,
  110u,
  115u,
  111u,
  114u,
  95u,
  111u,
  102u,
  102u,
  115u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11233[22] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  119u,
  109u,
  95u,
  98u,
  121u,
  95u,
  112u,
  105u,
  100u,
  95u,
  109u,
  101u,
  116u,
  104u,
  111u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11247[22] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  119u,
  109u,
  95u,
  98u,
  121u,
  95u,
  97u,
  105u,
  114u,
  105u,
  110u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11287[31] =
{
  116u,
  101u,
  109u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  108u,
  111u,
  99u,
  97u,
  108u,
  95u,
  97u,
  110u,
  100u,
  95u,
  114u,
  101u,
  109u,
  111u,
  116u,
  101u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11307[25] =
{
  116u,
  101u,
  109u,
  112u,
  95u,
  105u,
  115u,
  95u,
  97u,
  105u,
  114u,
  95u,
  111u,
  117u,
  116u,
  95u,
  116u,
  111u,
  111u,
  95u,
  104u,
  105u,
  103u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11321[20] =
{
  116u,
  101u,
  109u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  115u,
  116u,
  97u,
  116u,
  105u,
  115u,
  116u,
  105u,
  99u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11341[16] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  119u,
  109u,
  95u,
  98u,
  121u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11351[15] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  102u,
  117u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11361[20] =
{
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11370[20] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  95u,
  112u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___11375[20] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  95u,
  112u,
  114u,
  111u,
  116u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11387[18] =
{
  107u,
  105u,
  108u,
  108u,
  97u,
  108u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11418[21] =
{
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  108u,
  111u,
  99u,
  97u,
  108u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11435[26] =
{
  116u,
  101u,
  109u,
  112u,
  95u,
  103u,
  101u,
  116u,
  95u,
  101u,
  110u,
  118u,
  105u,
  114u,
  111u,
  110u,
  109u,
  101u,
  110u,
  116u,
  95u,
  116u,
  101u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 g_miner_type_const[4] = { 83u, 49u, 55u, 0u }; // idb
const uint8_t chCRCHTalbe[256] =
{
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u,
  1u,
  192u,
  128u,
  65u,
  1u,
  192u,
  128u,
  65u,
  0u,
  193u,
  129u,
  64u
}; // idb
const uint8_t chCRCLTalbe[256] =
{
  0u,
  192u,
  193u,
  1u,
  195u,
  3u,
  2u,
  194u,
  198u,
  6u,
  7u,
  199u,
  5u,
  197u,
  196u,
  4u,
  204u,
  12u,
  13u,
  205u,
  15u,
  207u,
  206u,
  14u,
  10u,
  202u,
  203u,
  11u,
  201u,
  9u,
  8u,
  200u,
  216u,
  24u,
  25u,
  217u,
  27u,
  219u,
  218u,
  26u,
  30u,
  222u,
  223u,
  31u,
  221u,
  29u,
  28u,
  220u,
  20u,
  212u,
  213u,
  21u,
  215u,
  23u,
  22u,
  214u,
  210u,
  18u,
  19u,
  211u,
  17u,
  209u,
  208u,
  16u,
  240u,
  48u,
  49u,
  241u,
  51u,
  243u,
  242u,
  50u,
  54u,
  246u,
  247u,
  55u,
  245u,
  53u,
  52u,
  244u,
  60u,
  252u,
  253u,
  61u,
  255u,
  63u,
  62u,
  254u,
  250u,
  58u,
  59u,
  251u,
  57u,
  249u,
  248u,
  56u,
  40u,
  232u,
  233u,
  41u,
  235u,
  43u,
  42u,
  234u,
  238u,
  46u,
  47u,
  239u,
  45u,
  237u,
  236u,
  44u,
  228u,
  36u,
  37u,
  229u,
  39u,
  231u,
  230u,
  38u,
  34u,
  226u,
  227u,
  35u,
  225u,
  33u,
  32u,
  224u,
  160u,
  96u,
  97u,
  161u,
  99u,
  163u,
  162u,
  98u,
  102u,
  166u,
  167u,
  103u,
  165u,
  101u,
  100u,
  164u,
  108u,
  172u,
  173u,
  109u,
  175u,
  111u,
  110u,
  174u,
  170u,
  106u,
  107u,
  171u,
  105u,
  169u,
  168u,
  104u,
  120u,
  184u,
  185u,
  121u,
  187u,
  123u,
  122u,
  186u,
  190u,
  126u,
  127u,
  191u,
  125u,
  189u,
  188u,
  124u,
  180u,
  116u,
  117u,
  181u,
  119u,
  183u,
  182u,
  118u,
  114u,
  178u,
  179u,
  115u,
  177u,
  113u,
  112u,
  176u,
  80u,
  144u,
  145u,
  81u,
  147u,
  83u,
  82u,
  146u,
  150u,
  86u,
  87u,
  151u,
  85u,
  149u,
  148u,
  84u,
  156u,
  92u,
  93u,
  157u,
  95u,
  159u,
  158u,
  94u,
  90u,
  154u,
  155u,
  91u,
  153u,
  89u,
  88u,
  152u,
  136u,
  72u,
  73u,
  137u,
  75u,
  139u,
  138u,
  74u,
  78u,
  142u,
  143u,
  79u,
  141u,
  77u,
  76u,
  140u,
  68u,
  132u,
  133u,
  69u,
  135u,
  71u,
  70u,
  134u,
  130u,
  66u,
  67u,
  131u,
  65u,
  129u,
  128u,
  64u
}; // idb
const unsigned __int8 _FUNCTION___14555[23] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  108u,
  108u,
  100u,
  97u,
  116u,
  97u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  105u,
  110u,
  100u,
  101u,
  120u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14793[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  97u,
  120u,
  105u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14823[12] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 104u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___14835[10] = { 99u, 104u, 101u, 99u, 107u, 95u, 102u, 97u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___14903[24] =
{
  103u,
  101u,
  116u,
  95u,
  105u,
  110u,
  100u,
  101u,
  120u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  112u,
  108u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___14922[27] =
{
  103u,
  101u,
  116u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15236[22] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  115u,
  105u,
  110u,
  103u,
  108u,
  101u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15270[24] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  111u,
  110u,
  101u,
  67u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15325[19] =
{
  115u,
  101u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15367[26] =
{
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  95u,
  102u,
  117u,
  110u,
  99u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15398[20] =
{
  103u,
  101u,
  116u,
  95u,
  108u,
  97u,
  115u,
  116u,
  110u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  110u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15469[20] =
{
  105u,
  115u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  95u,
  117u,
  110u,
  98u,
  97u,
  108u,
  97u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15555[13] = { 114u, 101u, 97u, 100u, 95u, 116u, 101u, 115u, 116u, 95u, 73u, 68u, 0u }; // idb
const unsigned __int8 _FUNCTION___15562[14] = { 100u, 117u, 109u, 112u, 95u, 97u, 115u, 105u, 99u, 95u, 114u, 101u, 103u, 0u }; // idb
const unsigned __int8 _FUNCTION___15570[14] =
{
  100u,
  117u,
  109u,
  112u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15576[13] = { 112u, 114u, 111u, 99u, 101u, 115u, 115u, 95u, 84u, 69u, 83u, 84u, 0u }; // idb
const unsigned __int8 _FUNCTION___15623[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  115u,
  121u,
  115u,
  116u,
  101u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15650[24] =
{
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15664[26] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  66u,
  77u,
  49u,
  51u,
  57u,
  49u,
  95u,
  112u,
  114u,
  101u,
  95u,
  111u,
  112u,
  101u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15699[24] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  108u,
  111u,
  99u,
  107u,
  95u,
  100u,
  101u,
  108u,
  97u,
  121u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15722[17] =
{
  111u,
  112u,
  101u,
  110u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  98u,
  109u,
  49u,
  51u,
  57u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15776[11] = { 110u, 111u, 110u, 99u, 101u, 95u, 99u, 97u, 108u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___15814[23] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  97u,
  110u,
  100u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15860[21] =
{
  99u,
  104u,
  97u,
  110u,
  103u,
  101u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  112u,
  108u,
  108u,
  95u,
  116u,
  101u,
  115u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15875[24] =
{
  99u,
  104u,
  97u,
  110u,
  103u,
  101u,
  95u,
  104u,
  105u,
  103u,
  104u,
  95u,
  112u,
  108u,
  108u,
  95u,
  98u,
  121u,
  95u,
  97u,
  105u,
  115u,
  99u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15912[21] =
{
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15946[6] = { 99u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 _FUNCTION___15963[6] = { 115u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 _FUNCTION___16047[19] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  112u,
  105u,
  99u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16309[12] = { 115u, 101u, 116u, 95u, 116u, 105u, 109u, 101u, 111u, 117u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___16339[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16448[31] =
{
  105u,
  110u,
  99u,
  114u,
  101u,
  97u,
  115u,
  101u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  98u,
  121u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16470[28] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  95u,
  119u,
  105u,
  116u,
  104u,
  111u,
  117u,
  116u,
  95u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16607[18] =
{
  100u,
  117u,
  109u,
  112u,
  95u,
  97u,
  108u,
  108u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16654[23] =
{
  98u,
  97u,
  108u,
  97u,
  110u,
  99u,
  101u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16715[21] =
{
  100u,
  117u,
  109u,
  112u,
  95u,
  112u,
  99u,
  98u,
  95u,
  98u,
  111u,
  109u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16769[30] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  121u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16786[9] = { 95u, 115u, 104u, 111u, 119u, 95u, 115u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___16804[22] =
{
  95u,
  103u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16826[18] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16840[16] =
{
  115u,
  101u,
  116u,
  95u,
  111u,
  114u,
  100u,
  101u,
  114u,
  95u,
  99u,
  108u,
  111u,
  99u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16851[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  105u,
  110u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16667[15] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  95u,
  109u,
  111u,
  100u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16673[34] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  112u,
  104u,
  121u,
  95u,
  109u,
  101u,
  109u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  106u,
  111u,
  98u,
  105u,
  100u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16681[29] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  103u,
  108u,
  111u,
  98u,
  97u,
  108u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  95u,
  112u,
  97u,
  114u,
  97u,
  109u,
  101u,
  116u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16689[16] =
{
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  102u,
  97u,
  110u,
  95u,
  109u,
  117u,
  108u,
  116u,
  105u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16697[19] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  100u,
  101u,
  118u,
  95u,
  102u,
  114u,
  101u,
  113u,
  117u,
  101u,
  110u,
  99u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16702[28] =
{
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  114u,
  101u,
  103u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16708[19] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  109u,
  105u,
  110u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16778[21] =
{
  105u,
  110u,
  105u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16724[18] =
{
  99u,
  97u,
  108u,
  99u,
  117u,
  108u,
  97u,
  116u,
  101u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16748[23] =
{
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16753[28] =
{
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16758[31] =
{
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  115u,
  121u,
  115u,
  116u,
  101u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16916[9] = { 115u, 101u, 110u, 100u, 95u, 106u, 111u, 98u, 0u }; // idb
const unsigned __int8 _func___16961[18] =
{
  99u,
  111u,
  112u,
  121u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___16973[20] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  112u,
  114u,
  101u,
  112u,
  97u,
  114u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___16984[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  100u,
  101u,
  116u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___17082[16] =
{
  104u,
  97u,
  115u,
  104u,
  116u,
  101u,
  115u,
  116u,
  95u,
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___17108[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___17121[17] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  99u,
  97u,
  110u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _func___17153[19] =
{
  98u,
  105u,
  116u,
  109u,
  97u,
  105u,
  110u,
  95u,
  115u,
  111u,
  99u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13485[10] = { 115u, 116u, 111u, 112u, 95u, 115u, 99u, 97u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___12445[12] = { 115u, 116u, 111u, 112u, 95u, 109u, 105u, 110u, 105u, 110u, 103u, 0u }; // idb
const unsigned __int8 _FUNCTION___12466[9] = { 112u, 111u, 119u, 101u, 114u, 95u, 111u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___12475[26] =
{
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  112u,
  114u,
  111u,
  116u,
  111u,
  99u,
  97u,
  108u,
  95u,
  116u,
  121u,
  112u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12483[11] = { 112u, 111u, 119u, 101u, 114u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___12488[20] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12515[18] =
{
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  99u,
  104u,
  101u,
  99u,
  107u,
  95u,
  114u,
  101u,
  112u,
  108u,
  121u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12549[15] =
{
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  115u,
  101u,
  110u,
  100u,
  95u,
  99u,
  109u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12652[33] =
{
  103u,
  101u,
  116u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  105u,
  105u,
  99u,
  95u,
  118u,
  97u,
  108u,
  117u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12659[25] =
{
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  98u,
  121u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12667[26] =
{
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  98u,
  121u,
  95u,
  105u,
  105u,
  99u,
  95u,
  100u,
  97u,
  116u,
  97u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12681[33] =
{
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  104u,
  105u,
  103u,
  104u,
  101u,
  115u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12724[40] =
{
  115u,
  108u,
  111u,
  119u,
  108u,
  121u,
  95u,
  115u,
  101u,
  116u,
  95u,
  105u,
  105u,
  99u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  116u,
  111u,
  95u,
  119u,
  111u,
  114u,
  107u,
  105u,
  110u,
  103u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12798[14] = { 99u, 104u, 101u, 99u, 107u, 95u, 112u, 105u, 99u, 95u, 99u, 114u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___12803[22] =
{
  100u,
  101u,
  99u,
  111u,
  100u,
  101u,
  95u,
  97u,
  110u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  95u,
  98u,
  117u,
  102u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12819[37] =
{
  100u,
  115u,
  80u,
  73u,
  67u,
  51u,
  51u,
  69u,
  80u,
  49u,
  54u,
  71u,
  83u,
  50u,
  48u,
  50u,
  95u,
  112u,
  105u,
  99u,
  95u,
  103u,
  101u,
  116u,
  95u,
  97u,
  110u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12836[20] =
{
  103u,
  101u,
  116u,
  95u,
  97u,
  118u,
  101u,
  114u,
  97u,
  103u,
  101u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const int hex2bin_tbl[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // idb
const unsigned __int8 _func___11478[10] = { 103u, 101u, 116u, 95u, 112u, 114u, 111u, 120u, 121u, 0u }; // idb
const unsigned __int8 hex_11488[16] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u
}; // idb
const unsigned __int8 _func___11498[8] = { 98u, 105u, 110u, 50u, 104u, 101u, 120u, 0u }; // idb
const unsigned __int8 _func___11610[7] = { 116u, 113u, 95u, 110u, 101u, 119u, 0u }; // idb
const unsigned __int8 _func___11623[14] =
{
  116u,
  113u,
  95u,
  102u,
  114u,
  101u,
  101u,
  122u,
  101u,
  116u,
  104u,
  97u,
  119u,
  0u
}; // idb
const unsigned __int8 _func___11636[8] = { 116u, 113u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _FUNCTION___11638[8] = { 116u, 113u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _FUNCTION___11649[7] = { 116u, 113u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___11650[7] = { 116u, 113u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___11662[16] =
{
  116u,
  104u,
  114u,
  95u,
  105u,
  110u,
  102u,
  111u,
  95u,
  99u,
  114u,
  101u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___11864[13] = { 115u, 116u, 114u, 97u, 116u, 117u, 109u, 95u, 115u, 101u, 110u, 100u, 0u }; // idb
const unsigned __int8 _func___11896[11] = { 99u, 108u, 101u, 97u, 114u, 95u, 115u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___11913[14] = { 114u, 101u, 99u, 97u, 108u, 108u, 111u, 99u, 95u, 115u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___11969[13] = { 112u, 97u, 114u, 115u, 101u, 95u, 110u, 111u, 116u, 105u, 102u, 121u, 0u }; // idb
const unsigned __int8 _FUNCTION___12009[21] =
{
  112u,
  114u,
  111u,
  99u,
  101u,
  115u,
  115u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___12048[11] = { 112u, 97u, 114u, 115u, 101u, 95u, 100u, 105u, 102u, 102u, 0u }; // idb
const unsigned __int8 _func___12059[17] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  101u,
  120u,
  116u,
  114u,
  97u,
  110u,
  111u,
  110u,
  99u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___12084[16] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  114u,
  101u,
  99u,
  111u,
  110u,
  110u,
  101u,
  99u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___12199[17] =
{
  115u,
  111u,
  99u,
  107u,
  115u,
  53u,
  95u,
  110u,
  101u,
  103u,
  111u,
  116u,
  105u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___12227[17] =
{
  115u,
  111u,
  99u,
  107u,
  115u,
  52u,
  95u,
  110u,
  101u,
  103u,
  111u,
  116u,
  105u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___12252[21] =
{
  115u,
  101u,
  116u,
  117u,
  112u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  111u,
  99u,
  107u,
  101u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___12304[16] =
{
  115u,
  117u,
  115u,
  112u,
  101u,
  110u,
  100u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___12353[17] =
{
  105u,
  110u,
  105u,
  116u,
  105u,
  97u,
  116u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  0u
}; // idb
const unsigned __int8 _func___12457[18] =
{
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___12466[22] =
{
  99u,
  103u,
  95u,
  99u,
  111u,
  109u,
  112u,
  108u,
  101u,
  116u,
  105u,
  111u,
  110u,
  95u,
  116u,
  105u,
  109u,
  101u,
  111u,
  117u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___10983[8] = { 115u, 101u, 116u, 95u, 105u, 105u, 99u, 0u }; // idb
const unsigned __int8 _FUNCTION___11021[36] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  97u,
  110u,
  100u,
  95u,
  106u,
  111u,
  98u,
  95u,
  105u,
  100u,
  95u,
  115u,
  116u,
  111u,
  114u,
  101u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11027[22] =
{
  103u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11032[22] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  97u,
  100u,
  100u,
  114u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11044[26] =
{
  103u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11049[26] =
{
  115u,
  101u,
  116u,
  95u,
  81u,
  78u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11057[20] =
{
  115u,
  101u,
  116u,
  95u,
  114u,
  101u,
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  98u,
  111u,
  97u,
  114u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11078[16] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11083[16] =
{
  115u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11089[17] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  111u,
  110u,
  95u,
  112u,
  108u,
  117u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11098[21] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  114u,
  100u,
  119u,
  97u,
  114u,
  101u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11108[14] =
{
  103u,
  101u,
  116u,
  95u,
  102u,
  97u,
  110u,
  95u,
  115u,
  112u,
  101u,
  101u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11130[21] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11135[21] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  111u,
  117u,
  116u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11141[17] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  116u,
  56u,
  100u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11146[17] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  116u,
  56u,
  100u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11152[22] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11158[22] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  95u,
  98u,
  117u,
  102u,
  102u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11164[21] =
{
  103u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11190_0[21] =
{
  115u,
  101u,
  116u,
  95u,
  66u,
  67u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11199[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11204[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  99u,
  107u,
  101u,
  116u,
  95u,
  109u,
  97u,
  115u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11210[11] = { 103u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___11215[11] = { 115u, 101u, 116u, 95u, 106u, 111u, 98u, 95u, 105u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___11226[15] =
{
  115u,
  101u,
  116u,
  95u,
  106u,
  111u,
  98u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11232[25] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11238[27] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11244[27] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11250[27] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  51u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11255[25] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11260[27] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  49u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11265[27] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11270[27] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  108u,
  111u,
  99u,
  107u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  95u,
  51u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11275[15] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11280[15] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  105u,
  109u,
  101u,
  95u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11286[16] =
{
  103u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11291[16] =
{
  115u,
  101u,
  116u,
  95u,
  116u,
  97u,
  114u,
  103u,
  101u,
  116u,
  95u,
  98u,
  105u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11302[20] =
{
  115u,
  101u,
  116u,
  95u,
  112u,
  114u,
  101u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  104u,
  97u,
  115u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11308[38] =
{
  103u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11313[38] =
{
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  105u,
  110u,
  98u,
  97u,
  115u,
  101u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  95u,
  97u,
  110u,
  100u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  95u,
  108u,
  101u,
  110u,
  103u,
  116u,
  104u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11319[16] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11325[16] =
{
  115u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11331[22] =
{
  103u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11336[22] =
{
  115u,
  101u,
  116u,
  95u,
  109u,
  101u,
  114u,
  107u,
  108u,
  101u,
  95u,
  98u,
  105u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11342[25] =
{
  103u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11347[25] =
{
  115u,
  101u,
  116u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  95u,
  102u,
  105u,
  102u,
  111u,
  95u,
  105u,
  110u,
  116u,
  101u,
  114u,
  114u,
  117u,
  112u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11353[22] =
{
  103u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11359[22] =
{
  115u,
  101u,
  116u,
  95u,
  100u,
  104u,
  97u,
  115u,
  104u,
  95u,
  97u,
  99u,
  99u,
  95u,
  99u,
  111u,
  110u,
  116u,
  114u,
  111u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11387_0[25] =
{
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11392[25] =
{
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  99u,
  111u,
  117u,
  110u,
  116u,
  105u,
  110u,
  103u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
unsigned __int8 byte_A1BD4[4] = { 0u, 0u, 0u, 0u }; // weak
char a0_0[2] = "0"; // weak
const unsigned __int8 bench_hidiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    50u,
    98u,
    49u,
    53u,
    49u,
    52u,
    101u,
    55u,
    98u,
    54u,
    53u,
    54u,
    53u,
    57u,
    52u,
    49u,
    101u,
    53u,
    56u,
    50u,
    52u,
    102u,
    48u,
    56u,
    52u,
    50u,
    57u,
    50u,
    49u,
    54u,
    52u,
    101u,
    99u,
    53u,
    102u,
    57u,
    55u,
    101u,
    55u,
    101u,
    97u,
    50u,
    48u,
    99u,
    52u,
    57u,
    52u,
    98u,
    100u,
    57u,
    54u,
    101u,
    53u,
    50u,
    52u,
    100u,
    52u,
    55u,
    56u,
    57u,
    55u,
    55u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    50u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    98u,
    49u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    101u,
    52u,
    101u,
    51u,
    98u,
    101u,
    99u,
    99u,
    48u,
    49u,
    48u,
    54u,
    52u,
    100u,
    56u,
    48u,
    56u,
    50u,
    54u,
    57u,
    98u,
    51u,
    51u,
    48u,
    102u,
    52u,
    48u,
    102u,
    52u,
    100u,
    101u,
    56u,
    50u,
    100u,
    99u,
    57u,
    50u,
    101u,
    56u,
    57u,
    52u,
    100u,
    54u,
    51u,
    53u,
    48u,
    50u,
    53u,
    100u,
    97u,
    97u,
    51u,
    101u,
    50u,
    101u,
    50u,
    99u,
    52u,
    49u,
    48u,
    98u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    57u,
    101u,
    98u,
    98u,
    99u,
    101u,
    50u,
    102u,
    53u,
    102u,
    48u,
    100u,
    54u,
    99u,
    99u,
    48u,
    97u,
    99u,
    97u,
    50u,
    56u,
    52u,
    101u,
    99u,
    98u,
    49u,
    48u,
    53u,
    57u,
    99u,
    56u,
    53u,
    54u,
    101u,
    102u,
    50u,
    102u,
    55u,
    102u,
    52u,
    50u,
    101u,
    55u,
    101u,
    100u,
    100u,
    52u,
    48u,
    51u,
    100u,
    50u,
    52u,
    54u,
    55u,
    53u,
    52u,
    101u,
    101u,
    52u,
    99u,
    57u,
    48u,
    53u,
    97u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    102u,
    100u,
    97u,
    48u,
    51u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    55u,
    56u,
    100u,
    97u,
    102u,
    49u,
    98u,
    53u,
    101u,
    98u,
    51u,
    51u,
    57u,
    55u,
    97u,
    102u,
    49u,
    99u,
    48u,
    48u,
    100u,
    98u,
    100u,
    57u,
    98u,
    48u,
    54u,
    54u,
    53u,
    57u,
    99u,
    100u,
    99u,
    48u,
    52u,
    49u,
    56u,
    51u,
    99u,
    56u,
    98u,
    97u,
    97u,
    102u,
    53u,
    98u,
    101u,
    49u,
    100u,
    98u,
    102u,
    51u,
    50u,
    102u,
    55u,
    57u,
    101u,
    48u,
    48u,
    52u,
    53u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    48u,
    52u,
    54u,
    53u,
    48u,
    97u,
    56u,
    101u,
    55u,
    52u,
    56u,
    100u,
    50u,
    101u,
    54u,
    102u,
    100u,
    101u,
    56u,
    54u,
    97u,
    56u,
    97u,
    57u,
    50u,
    48u,
    98u,
    50u,
    56u,
    53u,
    102u,
    51u,
    101u,
    50u,
    50u,
    51u,
    57u,
    56u,
    102u,
    53u,
    56u,
    51u,
    55u,
    48u,
    48u,
    50u,
    51u,
    54u,
    57u,
    53u,
    56u,
    51u,
    50u,
    51u,
    101u,
    102u,
    57u,
    101u,
    97u,
    56u,
    51u,
    50u,
    49u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    52u,
    53u,
    55u,
    48u,
    101u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    49u,
    100u,
    54u,
    53u,
    52u,
    97u,
    101u,
    50u,
    98u,
    48u,
    54u,
    102u,
    50u,
    49u,
    57u,
    99u,
    99u,
    102u,
    52u,
    54u,
    48u,
    49u,
    57u,
    51u,
    51u,
    102u,
    97u,
    98u,
    52u,
    48u,
    56u,
    100u,
    101u,
    49u,
    99u,
    51u,
    98u,
    55u,
    99u,
    56u,
    99u,
    57u,
    99u,
    56u,
    53u,
    101u,
    48u,
    51u,
    50u,
    51u,
    49u,
    100u,
    52u,
    97u,
    97u,
    102u,
    53u,
    97u,
    50u,
    54u,
    99u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    52u,
    98u,
    51u,
    57u,
    49u,
    51u,
    52u,
    99u,
    50u,
    57u,
    51u,
    48u,
    100u,
    50u,
    102u,
    50u,
    101u,
    55u,
    51u,
    51u,
    57u,
    102u,
    57u,
    100u,
    53u,
    48u,
    50u,
    99u,
    55u,
    55u,
    54u,
    99u,
    52u,
    52u,
    100u,
    54u,
    101u,
    101u,
    53u,
    57u,
    57u,
    102u,
    55u,
    101u,
    102u,
    101u,
    98u,
    101u,
    99u,
    54u,
    99u,
    57u,
    98u,
    98u,
    100u,
    48u,
    52u,
    55u,
    56u,
    55u,
    97u,
    97u,
    101u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    50u,
    55u,
    49u,
    48u,
    102u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    57u,
    52u,
    101u,
    54u,
    48u,
    99u,
    49u,
    49u,
    56u,
    48u,
    48u,
    50u,
    50u,
    102u,
    51u,
    51u,
    55u,
    50u,
    51u,
    50u,
    97u,
    98u,
    51u,
    100u,
    50u,
    57u,
    56u,
    102u,
    56u,
    51u,
    56u,
    51u,
    48u,
    52u,
    98u,
    54u,
    48u,
    48u,
    56u,
    97u,
    98u,
    50u,
    51u,
    55u,
    99u,
    102u,
    55u,
    101u,
    49u,
    55u,
    49u,
    55u,
    102u,
    49u,
    57u,
    51u,
    51u,
    52u,
    48u,
    55u,
    101u,
    53u,
    57u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    53u,
    98u,
    56u,
    50u,
    49u,
    102u,
    98u,
    48u,
    98u,
    50u,
    54u,
    100u,
    54u,
    51u,
    98u,
    48u,
    48u,
    99u,
    99u,
    50u,
    54u,
    101u,
    55u,
    97u,
    99u,
    52u,
    100u,
    54u,
    99u,
    102u,
    100u,
    49u,
    100u,
    51u,
    102u,
    99u,
    49u,
    48u,
    57u,
    98u,
    48u,
    100u,
    98u,
    49u,
    56u,
    56u,
    101u,
    55u,
    101u,
    55u,
    57u,
    50u,
    101u,
    51u,
    100u,
    49u,
    56u,
    51u,
    52u,
    50u,
    57u,
    49u,
    57u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    53u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    100u,
    52u,
    56u,
    48u,
    53u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    57u,
    48u,
    101u,
    97u,
    99u,
    54u,
    49u,
    54u,
    52u,
    50u,
    57u,
    52u,
    57u,
    99u,
    48u,
    48u,
    100u,
    49u,
    55u,
    102u,
    55u,
    99u,
    100u,
    53u,
    57u,
    56u,
    48u,
    97u,
    98u,
    101u,
    100u,
    98u,
    56u,
    54u,
    52u,
    55u,
    102u,
    99u,
    53u,
    100u,
    102u,
    57u,
    57u,
    53u,
    53u,
    100u,
    99u,
    102u,
    101u,
    52u,
    100u,
    53u,
    54u,
    97u,
    53u,
    48u,
    97u,
    48u,
    99u,
    53u,
    54u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    55u,
    57u,
    48u,
    99u,
    50u,
    51u,
    57u,
    56u,
    55u,
    49u,
    56u,
    49u,
    57u,
    53u,
    48u,
    101u,
    101u,
    98u,
    49u,
    52u,
    52u,
    53u,
    57u,
    49u,
    99u,
    51u,
    97u,
    99u,
    52u,
    100u,
    48u,
    54u,
    99u,
    48u,
    55u,
    48u,
    53u,
    102u,
    50u,
    56u,
    48u,
    49u,
    100u,
    48u,
    57u,
    55u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    101u,
    57u,
    100u,
    57u,
    52u,
    98u,
    102u,
    53u,
    97u,
    48u,
    97u,
    98u,
    55u,
    98u,
    50u,
    48u,
    50u,
    100u,
    51u,
    57u,
    101u,
    49u,
    50u,
    48u,
    48u,
    97u,
    102u,
    57u,
    54u,
    48u,
    55u,
    52u,
    101u,
    52u,
    102u,
    54u,
    52u,
    49u,
    102u,
    52u,
    101u,
    53u,
    53u,
    101u,
    51u,
    101u,
    57u,
    101u,
    51u,
    97u,
    101u,
    101u,
    55u,
    50u,
    97u,
    97u,
    48u,
    48u,
    97u,
    55u,
    48u,
    101u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    97u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    48u,
    102u,
    55u,
    48u,
    49u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    52u,
    55u,
    55u,
    99u,
    97u,
    56u,
    53u,
    51u,
    54u,
    55u,
    48u,
    50u,
    101u,
    97u,
    99u,
    98u,
    100u,
    54u,
    53u,
    97u,
    54u,
    97u,
    49u,
    54u,
    50u,
    99u,
    102u,
    101u,
    57u,
    48u,
    100u,
    54u,
    50u,
    48u,
    49u,
    54u,
    97u,
    49u,
    52u,
    102u,
    102u,
    101u,
    53u,
    56u,
    100u,
    53u,
    50u,
    98u,
    55u,
    100u,
    100u,
    52u,
    99u,
    51u,
    54u,
    50u,
    56u,
    97u,
    50u,
    55u,
    101u,
    53u,
    98u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    98u,
    98u,
    98u,
    50u,
    53u,
    48u,
    102u,
    50u,
    100u,
    99u,
    50u,
    51u,
    55u,
    49u,
    55u,
    101u,
    56u,
    49u,
    57u,
    50u,
    99u,
    48u,
    98u,
    56u,
    98u,
    101u,
    99u,
    54u,
    97u,
    49u,
    55u,
    53u,
    99u,
    100u,
    48u,
    53u,
    57u,
    101u,
    52u,
    48u,
    56u,
    57u,
    100u,
    51u,
    50u,
    53u,
    48u,
    48u,
    54u,
    101u,
    97u,
    101u,
    101u,
    51u,
    52u,
    52u,
    54u,
    50u,
    53u,
    52u,
    99u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    57u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    54u,
    57u,
    56u,
    48u,
    99u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    56u,
    100u,
    98u,
    53u,
    57u,
    57u,
    100u,
    54u,
    98u,
    55u,
    97u,
    53u,
    53u,
    102u,
    100u,
    54u,
    49u,
    100u,
    52u,
    50u,
    52u,
    52u,
    97u,
    51u,
    100u,
    102u,
    97u,
    52u,
    54u,
    53u,
    48u,
    53u,
    53u,
    101u,
    97u,
    100u,
    54u,
    98u,
    53u,
    99u,
    48u,
    97u,
    51u,
    55u,
    99u,
    55u,
    97u,
    51u,
    100u,
    52u,
    53u,
    53u,
    53u,
    98u,
    53u,
    56u,
    101u,
    57u,
    57u,
    48u,
    54u,
    53u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    101u,
    57u,
    49u,
    102u,
    99u,
    101u,
    55u,
    51u,
    48u,
    48u,
    97u,
    55u,
    57u,
    50u,
    98u,
    102u,
    98u,
    97u,
    97u,
    48u,
    99u,
    55u,
    54u,
    101u,
    49u,
    97u,
    97u,
    53u,
    102u,
    57u,
    98u,
    53u,
    52u,
    54u,
    99u,
    49u,
    100u,
    98u,
    53u,
    56u,
    50u,
    97u,
    101u,
    101u,
    52u,
    102u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    50u,
    101u,
    49u,
    55u,
    98u,
    97u,
    98u,
    100u,
    52u,
    48u,
    56u,
    57u,
    98u,
    50u,
    48u,
    52u,
    55u,
    57u,
    55u,
    99u,
    101u,
    98u,
    100u,
    97u,
    55u,
    100u,
    99u,
    54u,
    101u,
    50u,
    55u,
    55u,
    57u,
    53u,
    48u,
    101u,
    97u,
    98u,
    49u,
    98u,
    50u,
    57u,
    48u,
    56u,
    57u,
    57u,
    49u,
    97u,
    101u,
    49u,
    100u,
    55u,
    50u,
    51u,
    51u,
    53u,
    102u,
    56u,
    50u,
    100u,
    50u,
    48u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    102u,
    52u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    102u,
    50u,
    100u,
    48u,
    57u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    99u,
    55u,
    100u,
    54u,
    48u,
    49u,
    99u,
    101u,
    51u,
    98u,
    48u,
    49u,
    101u,
    53u,
    54u,
    57u,
    97u,
    52u,
    57u,
    53u,
    48u,
    56u,
    100u,
    53u,
    52u,
    49u,
    98u,
    98u,
    99u,
    98u,
    97u,
    57u,
    98u,
    51u,
    99u,
    56u,
    51u,
    57u,
    52u,
    98u,
    49u,
    56u,
    51u,
    52u,
    53u,
    50u,
    51u,
    101u,
    102u,
    49u,
    101u,
    53u,
    99u,
    98u,
    50u,
    99u,
    54u,
    48u,
    98u,
    100u,
    51u,
    52u,
    97u,
    51u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    56u,
    56u,
    98u,
    54u,
    102u,
    48u,
    50u,
    50u,
    49u,
    52u,
    52u,
    100u,
    98u,
    49u,
    51u,
    52u,
    97u,
    102u,
    49u,
    98u,
    99u,
    56u,
    101u,
    54u,
    49u,
    98u,
    51u,
    56u,
    53u,
    99u,
    97u,
    51u,
    55u,
    99u,
    97u,
    101u,
    48u,
    51u,
    56u,
    99u,
    49u,
    100u,
    49u,
    54u,
    53u,
    97u,
    101u,
    57u,
    56u,
    99u,
    52u,
    57u,
    54u,
    98u,
    51u,
    98u,
    52u,
    49u,
    101u,
    56u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    48u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    97u,
    56u,
    101u,
    97u,
    48u,
    101u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    52u,
    49u,
    48u,
    55u,
    54u,
    49u,
    101u,
    57u,
    55u,
    101u,
    54u,
    55u,
    98u,
    52u,
    57u,
    52u,
    102u,
    100u,
    53u,
    52u,
    55u,
    99u,
    102u,
    101u,
    57u,
    102u,
    102u,
    98u,
    98u,
    51u,
    54u,
    56u,
    57u,
    51u,
    100u,
    97u,
    55u,
    97u,
    101u,
    99u,
    55u,
    53u,
    99u,
    54u,
    98u,
    53u,
    49u,
    98u,
    56u,
    100u,
    53u,
    102u,
    51u,
    56u,
    102u,
    56u,
    55u,
    98u,
    53u,
    100u,
    54u,
    51u,
    99u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    54u,
    98u,
    102u,
    52u,
    54u,
    57u,
    97u,
    98u,
    101u,
    52u,
    97u,
    100u,
    51u,
    55u,
    54u,
    48u,
    53u,
    99u,
    48u,
    57u,
    55u,
    97u,
    56u,
    54u,
    48u,
    99u,
    102u,
    102u,
    51u,
    99u,
    102u,
    53u,
    99u,
    49u,
    101u,
    102u,
    52u,
    51u,
    55u,
    55u,
    54u,
    49u,
    56u,
    102u,
    55u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    49u,
    102u,
    48u,
    99u,
    102u,
    100u,
    102u,
    53u,
    97u,
    100u,
    56u,
    50u,
    52u,
    56u,
    102u,
    99u,
    52u,
    53u,
    50u,
    48u,
    102u,
    51u,
    98u,
    98u,
    48u,
    98u,
    50u,
    48u,
    52u,
    48u,
    50u,
    50u,
    54u,
    52u,
    51u,
    48u,
    51u,
    52u,
    56u,
    99u,
    100u,
    100u,
    101u,
    102u,
    102u,
    53u,
    99u,
    97u,
    57u,
    49u,
    56u,
    49u,
    98u,
    101u,
    101u,
    98u,
    55u,
    56u,
    56u,
    55u,
    48u,
    100u,
    53u,
    51u,
    54u,
    100u,
    100u,
    50u,
    49u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    48u,
    100u,
    54u,
    48u,
    48u,
    102u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    49u,
    97u,
    56u,
    100u,
    51u,
    53u,
    52u,
    97u,
    55u,
    101u,
    56u,
    98u,
    49u,
    51u,
    101u,
    99u,
    52u,
    55u,
    102u,
    52u,
    99u,
    51u,
    100u,
    57u,
    48u,
    55u,
    100u,
    48u,
    48u,
    57u,
    52u,
    53u,
    97u,
    54u,
    49u,
    101u,
    56u,
    54u,
    48u,
    53u,
    57u,
    102u,
    52u,
    57u,
    52u,
    51u,
    101u,
    52u,
    50u,
    99u,
    49u,
    101u,
    53u,
    50u,
    51u,
    57u,
    56u,
    101u,
    98u,
    97u,
    53u,
    100u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    50u,
    51u,
    50u,
    97u,
    49u,
    54u,
    100u,
    51u,
    56u,
    99u,
    99u,
    48u,
    101u,
    49u,
    51u,
    101u,
    52u,
    98u,
    49u,
    54u,
    100u,
    57u,
    49u,
    55u,
    98u,
    102u,
    102u,
    52u,
    99u,
    51u,
    52u,
    55u,
    50u,
    55u,
    100u,
    101u,
    98u,
    51u,
    98u,
    53u,
    99u,
    53u,
    48u,
    101u,
    52u,
    50u,
    52u,
    102u,
    98u,
    56u,
    52u,
    53u,
    51u,
    102u,
    102u,
    57u,
    98u,
    50u,
    97u,
    100u,
    99u,
    98u,
    52u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    50u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    102u,
    49u,
    48u,
    48u,
    50u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    99u,
    54u,
    55u,
    100u,
    51u,
    56u,
    102u,
    51u,
    49u,
    102u,
    53u,
    56u,
    57u,
    98u,
    49u,
    56u,
    98u,
    57u,
    100u,
    56u,
    101u,
    53u,
    51u,
    49u,
    98u,
    57u,
    57u,
    52u,
    99u,
    101u,
    53u,
    55u,
    51u,
    51u,
    99u,
    48u,
    50u,
    49u,
    97u,
    48u,
    51u,
    100u,
    56u,
    56u,
    100u,
    51u,
    56u,
    54u,
    49u,
    49u,
    101u,
    101u,
    54u,
    98u,
    52u,
    99u,
    50u,
    55u,
    49u,
    48u,
    97u,
    53u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    50u,
    56u,
    54u,
    48u,
    52u,
    55u,
    49u,
    50u,
    55u,
    55u,
    98u,
    52u,
    97u,
    57u,
    51u,
    102u,
    101u,
    97u,
    50u,
    97u,
    56u,
    98u,
    54u,
    100u,
    56u,
    99u,
    50u,
    56u,
    49u,
    102u,
    97u,
    98u,
    55u,
    98u,
    100u,
    101u,
    51u,
    98u,
    55u,
    56u,
    102u,
    50u,
    97u,
    99u,
    100u,
    49u,
    98u,
    102u,
    100u,
    99u,
    56u,
    57u,
    100u,
    52u,
    54u,
    52u,
    101u,
    100u,
    51u,
    98u,
    98u,
    51u,
    99u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    53u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    100u,
    51u,
    48u,
    48u,
    52u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    51u,
    55u,
    54u,
    56u,
    54u,
    99u,
    54u,
    49u,
    49u,
    97u,
    97u,
    101u,
    52u,
    51u,
    57u,
    55u,
    99u,
    55u,
    99u,
    48u,
    52u,
    98u,
    50u,
    99u,
    49u,
    57u,
    48u,
    55u,
    48u,
    56u,
    52u,
    53u,
    51u,
    100u,
    48u,
    48u,
    101u,
    56u,
    99u,
    57u,
    53u,
    54u,
    51u,
    53u,
    50u,
    53u,
    54u,
    49u,
    48u,
    99u,
    51u,
    49u,
    98u,
    97u,
    52u,
    54u,
    101u,
    56u,
    48u,
    100u,
    98u,
    99u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    51u,
    55u,
    48u,
    50u,
    51u,
    48u,
    54u,
    48u,
    55u,
    57u,
    57u,
    56u,
    102u,
    98u,
    98u,
    100u,
    49u,
    48u,
    50u,
    55u,
    53u,
    99u,
    53u,
    56u,
    57u,
    48u,
    56u,
    56u,
    53u,
    102u,
    99u,
    100u,
    56u,
    49u,
    98u,
    54u,
    56u,
    48u,
    49u,
    56u,
    98u,
    97u,
    50u,
    51u,
    55u,
    51u,
    97u,
    98u,
    102u,
    48u,
    102u,
    57u,
    51u,
    97u,
    48u,
    54u,
    100u,
    48u,
    50u,
    97u,
    98u,
    50u,
    56u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    51u,
    101u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    51u,
    55u,
    55u,
    53u,
    48u,
    98u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    102u,
    100u,
    100u,
    97u,
    57u,
    53u,
    50u,
    100u,
    97u,
    54u,
    97u,
    98u,
    100u,
    55u,
    48u,
    48u,
    50u,
    50u,
    97u,
    54u,
    101u,
    53u,
    102u,
    50u,
    98u,
    57u,
    100u,
    99u,
    53u,
    101u,
    49u,
    98u,
    54u,
    54u,
    48u,
    49u,
    49u,
    49u,
    50u,
    56u,
    99u,
    51u,
    102u,
    97u,
    50u,
    52u,
    57u,
    102u,
    48u,
    98u,
    55u,
    52u,
    51u,
    57u,
    102u,
    48u,
    48u,
    100u,
    53u,
    57u,
    52u,
    51u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    97u,
    50u,
    99u,
    57u,
    49u,
    102u,
    99u,
    52u,
    49u,
    50u,
    53u,
    52u,
    53u,
    51u,
    57u,
    97u,
    53u,
    98u,
    50u,
    97u,
    50u,
    55u,
    98u,
    101u,
    50u,
    56u,
    100u,
    101u,
    50u,
    97u,
    54u,
    49u,
    56u,
    55u,
    101u,
    50u,
    97u,
    102u,
    51u,
    102u,
    49u,
    50u,
    57u,
    100u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    52u,
    53u,
    102u,
    102u,
    99u,
    53u,
    49u,
    50u,
    100u,
    53u,
    99u,
    97u,
    51u,
    98u,
    99u,
    52u,
    100u,
    50u,
    48u,
    54u,
    51u,
    100u,
    100u,
    51u,
    97u,
    102u,
    49u,
    54u,
    54u,
    57u,
    99u,
    50u,
    57u,
    54u,
    97u,
    101u,
    49u,
    50u,
    54u,
    97u,
    53u,
    97u,
    50u,
    101u,
    102u,
    56u,
    57u,
    54u,
    100u,
    49u,
    101u,
    49u,
    57u,
    48u,
    99u,
    101u,
    100u,
    102u,
    54u,
    55u,
    98u,
    57u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    53u,
    53u,
    98u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    48u,
    57u,
    52u,
    100u,
    54u,
    99u,
    98u,
    101u,
    55u,
    54u,
    53u,
    51u,
    56u,
    97u,
    56u,
    56u,
    54u,
    49u,
    50u,
    54u,
    50u,
    52u,
    102u,
    99u,
    53u,
    101u,
    54u,
    53u,
    53u,
    99u,
    99u,
    52u,
    48u,
    53u,
    99u,
    98u,
    56u,
    49u,
    57u,
    56u,
    100u,
    99u,
    97u,
    100u,
    53u,
    49u,
    54u,
    98u,
    56u,
    56u,
    100u,
    98u,
    97u,
    99u,
    53u,
    98u,
    102u,
    56u,
    98u,
    57u,
    48u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    99u,
    53u,
    52u,
    56u,
    56u,
    49u,
    53u,
    49u,
    50u,
    55u,
    99u,
    49u,
    50u,
    53u,
    49u,
    52u,
    55u,
    97u,
    102u,
    57u,
    49u,
    99u,
    51u,
    53u,
    54u,
    99u,
    50u,
    57u,
    51u,
    102u,
    48u,
    100u,
    101u,
    102u,
    98u,
    100u,
    50u,
    55u,
    55u,
    49u,
    102u,
    56u,
    100u,
    99u,
    51u,
    98u,
    49u,
    49u,
    52u,
    50u,
    98u,
    51u,
    54u,
    55u,
    53u,
    50u,
    56u,
    54u,
    53u,
    54u,
    100u,
    98u,
    53u,
    51u,
    54u,
    100u,
    100u,
    51u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    54u,
    55u,
    55u,
    48u,
    97u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    98u,
    100u,
    98u,
    98u,
    51u,
    98u,
    49u,
    98u,
    101u,
    55u,
    50u,
    49u,
    54u,
    56u,
    55u,
    50u,
    101u,
    97u,
    55u,
    56u,
    55u,
    54u,
    50u,
    55u,
    98u,
    48u,
    51u,
    99u,
    51u,
    56u,
    57u,
    97u,
    53u,
    50u,
    55u,
    52u,
    53u,
    49u,
    102u,
    54u,
    100u,
    100u,
    56u,
    51u,
    50u,
    100u,
    56u,
    53u,
    52u,
    48u,
    56u,
    55u,
    52u,
    51u,
    48u,
    54u,
    102u,
    57u,
    99u,
    48u,
    55u,
    99u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    57u,
    52u,
    98u,
    98u,
    53u,
    98u,
    52u,
    102u,
    56u,
    97u,
    99u,
    51u,
    51u,
    57u,
    50u,
    102u,
    98u,
    100u,
    54u,
    54u,
    102u,
    51u,
    100u,
    100u,
    51u,
    101u,
    57u,
    100u,
    99u,
    100u,
    98u,
    50u,
    50u,
    51u,
    55u,
    48u,
    101u,
    51u,
    56u,
    48u,
    56u,
    51u,
    55u,
    102u,
    101u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    97u,
    100u,
    101u,
    102u,
    55u,
    53u,
    56u,
    55u,
    55u,
    48u,
    98u,
    98u,
    57u,
    48u,
    99u,
    53u,
    98u,
    49u,
    51u,
    55u,
    54u,
    57u,
    99u,
    53u,
    98u,
    54u,
    49u,
    97u,
    102u,
    102u,
    98u,
    51u,
    50u,
    50u,
    98u,
    50u,
    52u,
    99u,
    55u,
    52u,
    55u,
    53u,
    55u,
    51u,
    98u,
    51u,
    56u,
    101u,
    98u,
    101u,
    50u,
    101u,
    101u,
    56u,
    49u,
    55u,
    52u,
    56u,
    100u,
    48u,
    98u,
    53u,
    53u,
    55u,
    53u,
    51u,
    54u,
    100u,
    100u,
    52u,
    48u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    57u,
    102u,
    48u,
    48u,
    49u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    97u,
    99u,
    56u,
    101u,
    101u,
    97u,
    54u,
    51u,
    50u,
    56u,
    53u,
    51u,
    53u,
    51u,
    57u,
    52u,
    52u,
    101u,
    52u,
    48u,
    101u,
    101u,
    99u,
    53u,
    52u,
    100u,
    50u,
    100u,
    100u,
    54u,
    99u,
    100u,
    48u,
    57u,
    57u,
    52u,
    98u,
    52u,
    52u,
    55u,
    52u,
    50u,
    57u,
    98u,
    98u,
    48u,
    101u,
    100u,
    48u,
    53u,
    57u,
    56u,
    100u,
    51u,
    56u,
    102u,
    52u,
    50u,
    100u,
    97u,
    48u,
    101u,
    50u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
const unsigned __int8 bench_lodiffs[16][324] =
{
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    99u,
    48u,
    49u,
    102u,
    53u,
    48u,
    50u,
    99u,
    98u,
    51u,
    101u,
    57u,
    102u,
    100u,
    98u,
    48u,
    53u,
    51u,
    50u,
    51u,
    48u,
    101u,
    99u,
    49u,
    50u,
    97u,
    52u,
    57u,
    53u,
    52u,
    99u,
    49u,
    48u,
    50u,
    49u,
    97u,
    54u,
    98u,
    51u,
    53u,
    56u,
    54u,
    50u,
    98u,
    53u,
    101u,
    50u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    52u,
    100u,
    49u,
    98u,
    56u,
    51u,
    97u,
    101u,
    52u,
    52u,
    48u,
    53u,
    55u,
    48u,
    50u,
    53u,
    101u,
    56u,
    99u,
    53u,
    98u,
    53u,
    55u,
    53u,
    54u,
    98u,
    52u,
    52u,
    102u,
    48u,
    52u,
    100u,
    102u,
    53u,
    102u,
    102u,
    102u,
    101u,
    52u,
    97u,
    55u,
    97u,
    51u,
    48u,
    101u,
    53u,
    99u,
    49u,
    50u,
    100u,
    49u,
    50u,
    97u,
    57u,
    55u,
    97u,
    55u,
    97u,
    52u,
    99u,
    50u,
    101u,
    97u,
    53u,
    51u,
    54u,
    100u,
    99u,
    101u,
    52u,
    51u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    98u,
    54u,
    100u,
    54u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    48u,
    56u,
    102u,
    55u,
    101u,
    49u,
    52u,
    99u,
    53u,
    48u,
    100u,
    97u,
    100u,
    55u,
    55u,
    100u,
    99u,
    50u,
    51u,
    56u,
    98u,
    52u,
    100u,
    98u,
    50u,
    57u,
    48u,
    49u,
    97u,
    48u,
    53u,
    55u,
    56u,
    101u,
    54u,
    53u,
    55u,
    98u,
    49u,
    57u,
    53u,
    52u,
    55u,
    55u,
    57u,
    97u,
    98u,
    57u,
    99u,
    100u,
    56u,
    50u,
    97u,
    55u,
    51u,
    56u,
    50u,
    57u,
    101u,
    100u,
    102u,
    55u,
    102u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    99u,
    49u,
    97u,
    49u,
    55u,
    52u,
    50u,
    53u,
    52u,
    97u,
    54u,
    53u,
    57u,
    51u,
    102u,
    102u,
    98u,
    97u,
    57u,
    56u,
    55u,
    102u,
    54u,
    56u,
    102u,
    101u,
    50u,
    54u,
    101u,
    55u,
    49u,
    54u,
    101u,
    51u,
    99u,
    49u,
    50u,
    57u,
    97u,
    55u,
    102u,
    51u,
    51u,
    97u,
    57u,
    99u,
    52u,
    51u,
    97u,
    101u,
    55u,
    101u,
    99u,
    102u,
    57u,
    48u,
    99u,
    56u,
    99u,
    100u,
    48u,
    100u,
    50u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    101u,
    54u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    102u,
    56u,
    49u,
    48u,
    48u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    54u,
    55u,
    48u,
    48u,
    97u,
    101u,
    101u,
    100u,
    97u,
    100u,
    97u,
    50u,
    98u,
    51u,
    56u,
    55u,
    55u,
    57u,
    48u,
    48u,
    98u,
    53u,
    56u,
    97u,
    49u,
    56u,
    51u,
    99u,
    52u,
    50u,
    99u,
    52u,
    48u,
    57u,
    52u,
    57u,
    57u,
    53u,
    54u,
    98u,
    98u,
    56u,
    98u,
    52u,
    97u,
    56u,
    100u,
    50u,
    49u,
    52u,
    56u,
    49u,
    102u,
    56u,
    57u,
    51u,
    54u,
    98u,
    53u,
    55u,
    50u,
    57u,
    50u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    51u,
    56u,
    99u,
    102u,
    52u,
    98u,
    54u,
    49u,
    100u,
    102u,
    102u,
    55u,
    52u,
    101u,
    51u,
    99u,
    50u,
    54u,
    98u,
    50u,
    100u,
    56u,
    48u,
    48u,
    52u,
    53u,
    48u,
    54u,
    52u,
    101u,
    56u,
    97u,
    98u,
    52u,
    56u,
    48u,
    50u,
    53u,
    50u,
    49u,
    98u,
    97u,
    98u,
    50u,
    99u,
    100u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    49u,
    101u,
    101u,
    102u,
    54u,
    52u,
    97u,
    55u,
    101u,
    102u,
    52u,
    101u,
    52u,
    55u,
    99u,
    100u,
    97u,
    49u,
    54u,
    101u,
    57u,
    54u,
    54u,
    55u,
    51u,
    49u,
    57u,
    55u,
    100u,
    51u,
    54u,
    99u,
    55u,
    50u,
    51u,
    53u,
    97u,
    52u,
    97u,
    97u,
    100u,
    100u,
    50u,
    51u,
    99u,
    50u,
    49u,
    97u,
    51u,
    56u,
    99u,
    101u,
    53u,
    51u,
    56u,
    50u,
    55u,
    100u,
    49u,
    102u,
    56u,
    98u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    55u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    57u,
    54u,
    98u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    55u,
    51u,
    48u,
    99u,
    102u,
    55u,
    97u,
    54u,
    98u,
    56u,
    97u,
    56u,
    53u,
    101u,
    98u,
    49u,
    99u,
    99u,
    48u,
    49u,
    55u,
    98u,
    49u,
    48u,
    57u,
    100u,
    50u,
    51u,
    99u,
    51u,
    57u,
    50u,
    52u,
    54u,
    52u,
    102u,
    57u,
    57u,
    97u,
    97u,
    56u,
    99u,
    48u,
    50u,
    48u,
    101u,
    97u,
    49u,
    48u,
    55u,
    99u,
    53u,
    50u,
    53u,
    98u,
    54u,
    55u,
    49u,
    97u,
    100u,
    100u,
    101u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    102u,
    101u,
    50u,
    99u,
    54u,
    98u,
    57u,
    50u,
    54u,
    52u,
    54u,
    56u,
    53u,
    54u,
    53u,
    101u,
    53u,
    50u,
    52u,
    97u,
    98u,
    55u,
    99u,
    50u,
    102u,
    49u,
    49u,
    49u,
    48u,
    51u,
    53u,
    100u,
    99u,
    100u,
    101u,
    55u,
    99u,
    54u,
    48u,
    57u,
    53u,
    53u,
    56u,
    52u,
    50u,
    49u,
    49u,
    49u,
    57u,
    51u,
    48u,
    53u,
    56u,
    57u,
    101u,
    99u,
    99u,
    98u,
    52u,
    49u,
    48u,
    102u,
    56u,
    51u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    54u,
    98u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    102u,
    52u,
    50u,
    57u,
    48u,
    48u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    55u,
    100u,
    98u,
    98u,
    51u,
    55u,
    52u,
    97u,
    57u,
    55u,
    102u,
    49u,
    53u,
    99u,
    53u,
    57u,
    53u,
    56u,
    55u,
    50u,
    53u,
    54u,
    54u,
    54u,
    50u,
    102u,
    51u,
    54u,
    57u,
    48u,
    52u,
    100u,
    48u,
    55u,
    53u,
    100u,
    48u,
    101u,
    54u,
    49u,
    102u,
    55u,
    52u,
    57u,
    54u,
    49u,
    56u,
    49u,
    56u,
    50u,
    55u,
    49u,
    49u,
    50u,
    56u,
    56u,
    97u,
    99u,
    54u,
    49u,
    55u,
    99u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    48u,
    55u,
    51u,
    51u,
    56u,
    53u,
    101u,
    48u,
    53u,
    99u,
    50u,
    57u,
    102u,
    48u,
    52u,
    51u,
    53u,
    97u,
    54u,
    48u,
    48u,
    49u,
    99u,
    56u,
    101u,
    99u,
    97u,
    57u,
    99u,
    56u,
    100u,
    53u,
    54u,
    48u,
    50u,
    56u,
    57u,
    48u,
    97u,
    101u,
    102u,
    102u,
    57u,
    100u,
    52u,
    100u,
    49u,
    48u,
    51u,
    100u,
    51u,
    51u,
    56u,
    51u,
    99u,
    102u,
    56u,
    48u,
    100u,
    97u,
    101u,
    53u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    55u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    56u,
    50u,
    49u,
    100u,
    48u,
    48u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    55u,
    100u,
    97u,
    51u,
    98u,
    57u,
    55u,
    101u,
    56u,
    50u,
    99u,
    48u,
    99u,
    51u,
    49u,
    50u,
    53u,
    97u,
    53u,
    56u,
    100u,
    97u,
    100u,
    56u,
    97u,
    48u,
    100u,
    49u,
    100u,
    48u,
    51u,
    54u,
    57u,
    50u,
    52u,
    52u,
    55u,
    51u,
    49u,
    102u,
    51u,
    98u,
    48u,
    57u,
    54u,
    101u,
    57u,
    55u,
    50u,
    52u,
    56u,
    52u,
    50u,
    57u,
    56u,
    100u,
    49u,
    53u,
    98u,
    56u,
    52u,
    51u,
    100u,
    57u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    98u,
    53u,
    98u,
    52u,
    100u,
    49u,
    57u,
    99u,
    50u,
    48u,
    97u,
    55u,
    102u,
    99u,
    50u,
    98u,
    49u,
    55u,
    52u,
    102u,
    102u,
    54u,
    55u,
    51u,
    99u,
    48u,
    48u,
    54u,
    101u,
    100u,
    100u,
    50u,
    50u,
    52u,
    55u,
    99u,
    52u,
    98u,
    50u,
    51u,
    51u,
    54u,
    53u,
    55u,
    49u,
    56u,
    54u,
    52u,
    100u,
    102u,
    57u,
    51u,
    101u,
    98u,
    55u,
    101u,
    99u,
    48u,
    99u,
    56u,
    99u,
    50u,
    55u,
    54u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    48u,
    52u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    101u,
    54u,
    51u,
    99u,
    48u,
    48u,
    53u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    49u,
    53u,
    49u,
    52u,
    98u,
    100u,
    53u,
    56u,
    54u,
    53u,
    49u,
    49u,
    101u,
    53u,
    51u,
    49u,
    101u,
    50u,
    98u,
    54u,
    50u,
    55u,
    55u,
    97u,
    54u,
    100u,
    49u,
    49u,
    50u,
    98u,
    49u,
    55u,
    49u,
    102u,
    57u,
    101u,
    48u,
    48u,
    56u,
    100u,
    53u,
    54u,
    101u,
    102u,
    52u,
    97u,
    57u,
    55u,
    49u,
    101u,
    54u,
    49u,
    57u,
    97u,
    99u,
    102u,
    50u,
    50u,
    101u,
    55u,
    53u,
    48u,
    55u,
    50u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    51u,
    101u,
    51u,
    48u,
    51u,
    48u,
    54u,
    50u,
    57u,
    102u,
    102u,
    52u,
    50u,
    53u,
    56u,
    48u,
    53u,
    54u,
    100u,
    99u,
    57u,
    101u,
    102u,
    97u,
    102u,
    57u,
    50u,
    50u,
    98u,
    100u,
    49u,
    55u,
    51u,
    97u,
    54u,
    53u,
    102u,
    54u,
    53u,
    101u,
    101u,
    55u,
    57u,
    57u,
    98u,
    48u,
    99u,
    55u,
    54u,
    53u,
    48u,
    57u,
    55u,
    100u,
    51u,
    100u,
    101u,
    101u,
    100u,
    100u,
    101u,
    102u,
    49u,
    48u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    100u,
    56u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    52u,
    51u,
    48u,
    48u,
    54u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    98u,
    55u,
    55u,
    97u,
    57u,
    99u,
    51u,
    54u,
    100u,
    56u,
    57u,
    52u,
    100u,
    50u,
    100u,
    98u,
    99u,
    51u,
    49u,
    52u,
    51u,
    55u,
    101u,
    53u,
    99u,
    50u,
    97u,
    49u,
    53u,
    54u,
    52u,
    101u,
    57u,
    50u,
    55u,
    57u,
    51u,
    55u,
    56u,
    52u,
    56u,
    101u,
    97u,
    50u,
    101u,
    98u,
    50u,
    48u,
    98u,
    51u,
    56u,
    54u,
    51u,
    56u,
    97u,
    102u,
    99u,
    54u,
    52u,
    98u,
    57u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    49u,
    51u,
    99u,
    50u,
    50u,
    98u,
    98u,
    57u,
    57u,
    101u,
    57u,
    100u,
    97u,
    97u,
    57u,
    57u,
    51u,
    54u,
    98u,
    48u,
    100u,
    102u,
    53u,
    100u,
    99u,
    101u,
    54u,
    52u,
    100u,
    55u,
    55u,
    51u,
    55u,
    101u,
    51u,
    55u,
    48u,
    54u,
    98u,
    101u,
    57u,
    57u,
    101u,
    53u,
    48u,
    57u,
    56u,
    100u,
    49u,
    49u,
    50u,
    48u,
    48u,
    50u,
    52u,
    57u,
    50u,
    99u,
    102u,
    56u,
    49u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    54u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    100u,
    52u,
    52u,
    49u,
    48u,
    48u,
    55u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    100u,
    56u,
    57u,
    54u,
    50u,
    54u,
    55u,
    102u,
    100u,
    97u,
    53u,
    100u,
    100u,
    97u,
    48u,
    102u,
    56u,
    53u,
    51u,
    48u,
    56u,
    101u,
    55u,
    55u,
    102u,
    55u,
    53u,
    52u,
    99u,
    56u,
    98u,
    57u,
    52u,
    98u,
    55u,
    98u,
    56u,
    56u,
    101u,
    51u,
    99u,
    98u,
    51u,
    49u,
    53u,
    52u,
    55u,
    53u,
    99u,
    100u,
    57u,
    101u,
    102u,
    100u,
    49u,
    54u,
    52u,
    48u,
    49u,
    101u,
    51u,
    99u,
    101u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    52u,
    97u,
    102u,
    53u,
    99u,
    102u,
    102u,
    100u,
    55u,
    101u,
    53u,
    97u,
    55u,
    48u,
    56u,
    55u,
    102u,
    49u,
    98u,
    52u,
    56u,
    52u,
    98u,
    53u,
    50u,
    54u,
    99u,
    55u,
    51u,
    53u,
    48u,
    99u,
    56u,
    54u,
    100u,
    56u,
    51u,
    56u,
    57u,
    50u,
    56u,
    51u,
    53u,
    48u,
    57u,
    99u,
    97u,
    56u,
    55u,
    56u,
    53u,
    48u,
    50u,
    102u,
    55u,
    57u,
    50u,
    49u,
    49u,
    53u,
    101u,
    56u,
    100u,
    99u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    97u,
    100u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    57u,
    57u,
    100u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    51u,
    51u,
    57u,
    51u,
    53u,
    52u,
    53u,
    54u,
    56u,
    102u,
    53u,
    48u,
    54u,
    97u,
    99u,
    51u,
    99u,
    100u,
    54u,
    57u,
    98u,
    98u,
    52u,
    50u,
    55u,
    98u,
    49u,
    97u,
    102u,
    56u,
    51u,
    97u,
    48u,
    52u,
    55u,
    51u,
    98u,
    56u,
    55u,
    99u,
    49u,
    54u,
    98u,
    102u,
    51u,
    98u,
    53u,
    54u,
    50u,
    97u,
    57u,
    51u,
    100u,
    48u,
    97u,
    50u,
    102u,
    102u,
    99u,
    53u,
    51u,
    101u,
    53u,
    52u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    50u,
    53u,
    97u,
    54u,
    50u,
    52u,
    101u,
    53u,
    99u,
    56u,
    52u,
    102u,
    57u,
    54u,
    100u,
    50u,
    99u,
    51u,
    52u,
    100u,
    99u,
    101u,
    51u,
    98u,
    54u,
    97u,
    55u,
    51u,
    54u,
    97u,
    100u,
    100u,
    98u,
    56u,
    57u,
    49u,
    55u,
    50u,
    52u,
    98u,
    52u,
    56u,
    97u,
    51u,
    54u,
    51u,
    50u,
    48u,
    99u,
    55u,
    52u,
    57u,
    52u,
    52u,
    51u,
    53u,
    102u,
    57u,
    99u,
    57u,
    49u,
    53u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    54u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    49u,
    52u,
    102u,
    98u,
    48u,
    48u,
    57u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    56u,
    51u,
    54u,
    50u,
    48u,
    48u,
    57u,
    99u,
    48u,
    55u,
    99u,
    102u,
    52u,
    56u,
    50u,
    52u,
    57u,
    102u,
    52u,
    56u,
    49u,
    98u,
    101u,
    54u,
    98u,
    55u,
    57u,
    101u,
    54u,
    55u,
    50u,
    52u,
    55u,
    99u,
    97u,
    98u,
    49u,
    100u,
    50u,
    48u,
    48u,
    53u,
    48u,
    99u,
    102u,
    49u,
    49u,
    99u,
    50u,
    55u,
    54u,
    48u,
    56u,
    53u,
    98u,
    57u,
    48u,
    55u,
    51u,
    50u,
    49u,
    49u,
    48u,
    99u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    101u,
    49u,
    53u,
    53u,
    102u,
    48u,
    55u,
    101u,
    54u,
    53u,
    50u,
    101u,
    52u,
    100u,
    54u,
    55u,
    49u,
    99u,
    97u,
    52u,
    100u,
    98u,
    53u,
    49u,
    98u,
    98u,
    100u,
    101u,
    49u,
    52u,
    100u,
    50u,
    98u,
    53u,
    97u,
    101u,
    51u,
    52u,
    101u,
    101u,
    54u,
    55u,
    101u,
    99u,
    99u,
    55u,
    52u,
    52u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    54u,
    57u,
    102u,
    49u,
    100u,
    54u,
    53u,
    48u,
    55u,
    102u,
    52u,
    98u,
    55u,
    98u,
    53u,
    48u,
    57u,
    56u,
    48u,
    57u,
    51u,
    48u,
    102u,
    55u,
    100u,
    56u,
    48u,
    56u,
    57u,
    56u,
    51u,
    52u,
    102u,
    98u,
    101u,
    54u,
    53u,
    102u,
    48u,
    57u,
    56u,
    48u,
    98u,
    56u,
    53u,
    57u,
    50u,
    100u,
    53u,
    51u,
    99u,
    100u,
    100u,
    97u,
    48u,
    56u,
    101u,
    53u,
    48u,
    100u,
    50u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    55u,
    100u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    53u,
    101u,
    101u,
    98u,
    48u,
    48u,
    97u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    50u,
    49u,
    101u,
    52u,
    102u,
    54u,
    53u,
    52u,
    100u,
    50u,
    54u,
    97u,
    98u,
    56u,
    99u,
    57u,
    49u,
    54u,
    52u,
    102u,
    102u,
    51u,
    49u,
    49u,
    54u,
    53u,
    55u,
    97u,
    57u,
    102u,
    57u,
    99u,
    52u,
    99u,
    100u,
    99u,
    48u,
    101u,
    56u,
    97u,
    48u,
    57u,
    51u,
    51u,
    52u,
    57u,
    50u,
    53u,
    102u,
    55u,
    99u,
    48u,
    50u,
    49u,
    51u,
    56u,
    56u,
    49u,
    57u,
    100u,
    55u,
    101u,
    54u,
    49u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    54u,
    52u,
    57u,
    50u,
    51u,
    98u,
    54u,
    51u,
    102u,
    53u,
    51u,
    99u,
    55u,
    50u,
    99u,
    48u,
    52u,
    101u,
    98u,
    101u,
    54u,
    99u,
    49u,
    99u,
    57u,
    49u,
    52u,
    48u,
    98u,
    54u,
    51u,
    55u,
    55u,
    49u,
    51u,
    50u,
    98u,
    54u,
    101u,
    53u,
    48u,
    56u,
    54u,
    53u,
    56u,
    49u,
    52u,
    102u,
    101u,
    53u,
    54u,
    50u,
    50u,
    57u,
    49u,
    98u,
    100u,
    48u,
    50u,
    51u,
    100u,
    51u,
    52u,
    56u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    53u,
    97u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    99u,
    53u,
    50u,
    101u,
    48u,
    48u,
    98u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    53u,
    100u,
    98u,
    57u,
    49u,
    97u,
    50u,
    53u,
    52u,
    48u,
    49u,
    97u,
    56u,
    57u,
    100u,
    97u,
    102u,
    57u,
    102u,
    102u,
    55u,
    100u,
    55u,
    57u,
    53u,
    52u,
    98u,
    97u,
    98u,
    55u,
    50u,
    50u,
    98u,
    56u,
    57u,
    52u,
    98u,
    97u,
    52u,
    56u,
    48u,
    102u,
    101u,
    102u,
    97u,
    102u,
    49u,
    102u,
    48u,
    97u,
    57u,
    53u,
    97u,
    97u,
    102u,
    53u,
    102u,
    54u,
    48u,
    48u,
    53u,
    54u,
    55u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    101u,
    57u,
    56u,
    49u,
    55u,
    49u,
    54u,
    48u,
    101u,
    51u,
    53u,
    100u,
    52u,
    52u,
    49u,
    48u,
    54u,
    48u,
    49u,
    99u,
    56u,
    100u,
    99u,
    55u,
    52u,
    49u,
    99u,
    49u,
    97u,
    56u,
    49u,
    48u,
    99u,
    52u,
    56u,
    53u,
    102u,
    51u,
    98u,
    52u,
    48u,
    97u,
    48u,
    56u,
    53u,
    57u,
    98u,
    101u,
    53u,
    102u,
    53u,
    56u,
    102u,
    48u,
    98u,
    102u,
    54u,
    101u,
    102u,
    49u,
    54u,
    57u,
    52u,
    53u,
    51u,
    54u,
    100u,
    99u,
    54u,
    51u,
    50u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    54u,
    101u,
    49u,
    102u,
    48u,
    48u,
    99u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    97u,
    101u,
    50u,
    49u,
    53u,
    55u,
    56u,
    53u,
    49u,
    55u,
    56u,
    102u,
    102u,
    54u,
    51u,
    53u,
    48u,
    48u,
    54u,
    52u,
    48u,
    54u,
    48u,
    101u,
    98u,
    98u,
    98u,
    50u,
    49u,
    57u,
    97u,
    55u,
    49u,
    55u,
    49u,
    54u,
    97u,
    49u,
    48u,
    101u,
    56u,
    56u,
    53u,
    50u,
    56u,
    102u,
    99u,
    52u,
    98u,
    98u,
    49u,
    99u,
    98u,
    53u,
    99u,
    56u,
    102u,
    100u,
    100u,
    48u,
    99u,
    102u,
    54u,
    48u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    57u,
    99u,
    97u,
    53u,
    53u,
    101u,
    53u,
    102u,
    49u,
    98u,
    99u,
    48u,
    51u,
    50u,
    56u,
    99u,
    56u,
    52u,
    102u,
    51u,
    53u,
    56u,
    102u,
    100u,
    100u,
    97u,
    100u,
    99u,
    49u,
    51u,
    99u,
    98u,
    50u,
    51u,
    50u,
    53u,
    57u,
    57u,
    98u,
    99u,
    50u,
    99u,
    97u,
    57u,
    100u,
    98u,
    101u,
    49u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    49u,
    101u,
    53u,
    49u,
    52u,
    99u,
    102u,
    55u,
    51u,
    56u,
    52u,
    53u,
    53u,
    97u,
    53u,
    52u,
    102u,
    48u,
    48u,
    52u,
    101u,
    99u,
    56u,
    54u,
    101u,
    100u,
    97u,
    102u,
    99u,
    102u,
    100u,
    57u,
    102u,
    100u,
    50u,
    48u,
    50u,
    50u,
    48u,
    49u,
    55u,
    98u,
    98u,
    51u,
    49u,
    99u,
    50u,
    52u,
    53u,
    51u,
    52u,
    48u,
    51u,
    53u,
    51u,
    57u,
    49u,
    49u,
    55u,
    52u,
    52u,
    102u,
    98u,
    55u,
    53u,
    51u,
    54u,
    100u,
    102u,
    101u,
    49u,
    102u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    50u,
    54u,
    53u,
    102u,
    48u,
    48u,
    100u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    100u,
    99u,
    97u,
    102u,
    97u,
    97u,
    56u,
    54u,
    100u,
    101u,
    102u,
    101u,
    56u,
    53u,
    48u,
    98u,
    48u,
    53u,
    55u,
    97u,
    101u,
    55u,
    52u,
    102u,
    55u,
    50u,
    49u,
    56u,
    97u,
    55u,
    57u,
    98u,
    48u,
    101u,
    100u,
    101u,
    48u,
    56u,
    54u,
    97u,
    49u,
    57u,
    54u,
    102u,
    49u,
    56u,
    102u,
    48u,
    101u,
    55u,
    99u,
    53u,
    56u,
    53u,
    101u,
    98u,
    56u,
    56u,
    100u,
    49u,
    49u,
    51u,
    57u,
    97u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    100u,
    98u,
    100u,
    53u,
    51u,
    102u,
    99u,
    99u,
    54u,
    52u,
    56u,
    53u,
    48u,
    98u,
    53u,
    51u,
    51u,
    52u,
    54u,
    55u,
    56u,
    49u,
    57u,
    57u,
    100u,
    55u,
    54u,
    57u,
    53u,
    49u,
    52u,
    56u,
    49u,
    56u,
    102u,
    98u,
    99u,
    99u,
    55u,
    57u,
    56u,
    54u,
    49u,
    102u,
    99u,
    55u,
    55u,
    101u,
    53u,
    55u,
    50u,
    98u,
    98u,
    52u,
    55u,
    53u,
    51u,
    98u,
    55u,
    102u,
    101u,
    50u,
    53u,
    51u,
    54u,
    100u,
    99u,
    53u,
    100u,
    57u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    51u,
    56u,
    57u,
    48u,
    48u,
    101u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    53u,
    101u,
    54u,
    53u,
    51u,
    100u,
    102u,
    53u,
    57u,
    53u,
    54u,
    101u,
    99u,
    101u,
    53u,
    49u,
    56u,
    97u,
    55u,
    56u,
    97u,
    53u,
    100u,
    49u,
    49u,
    50u,
    57u,
    55u,
    52u,
    51u,
    49u,
    97u,
    102u,
    57u,
    52u,
    99u,
    101u,
    56u,
    98u,
    97u,
    57u,
    49u,
    100u,
    56u,
    48u,
    99u,
    102u,
    98u,
    50u,
    97u,
    97u,
    56u,
    99u,
    53u,
    98u,
    51u,
    48u,
    57u,
    53u,
    102u,
    97u,
    50u,
    53u,
    54u,
    0u,
    0u,
    0u,
    0u
  },
  {
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    50u,
    51u,
    98u,
    102u,
    53u,
    51u,
    101u,
    102u,
    51u,
    52u,
    51u,
    97u,
    53u,
    48u,
    102u,
    55u,
    53u,
    57u,
    57u,
    54u,
    48u,
    49u,
    102u,
    56u,
    52u,
    57u,
    99u,
    57u,
    51u,
    101u,
    99u,
    99u,
    101u,
    54u,
    51u,
    53u,
    51u,
    48u,
    98u,
    48u,
    98u,
    52u,
    52u,
    57u,
    97u,
    52u,
    52u,
    54u,
    51u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    53u,
    57u,
    54u,
    102u,
    99u,
    52u,
    97u,
    97u,
    53u,
    100u,
    97u,
    56u,
    51u,
    57u,
    98u,
    97u,
    50u,
    54u,
    55u,
    99u,
    51u,
    54u,
    97u,
    97u,
    49u,
    97u,
    53u,
    98u,
    50u,
    57u,
    100u,
    56u,
    49u,
    51u,
    55u,
    52u,
    55u,
    98u,
    50u,
    50u,
    55u,
    51u,
    100u,
    99u,
    48u,
    51u,
    97u,
    97u,
    57u,
    101u,
    52u,
    48u,
    52u,
    99u,
    52u,
    100u,
    97u,
    48u,
    50u,
    51u,
    56u,
    101u,
    50u,
    98u,
    53u,
    51u,
    54u,
    100u,
    99u,
    52u,
    99u,
    99u,
    49u,
    57u,
    48u,
    48u,
    56u,
    57u,
    54u,
    99u,
    57u,
    101u,
    55u,
    48u,
    48u,
    48u,
    102u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    48u,
    56u,
    48u,
    48u,
    50u,
    48u,
    48u,
    48u,
    48u,
    48u,
    101u,
    50u,
    51u,
    56u,
    48u,
    54u,
    97u,
    53u,
    51u,
    51u,
    98u,
    100u,
    57u,
    53u,
    54u,
    55u,
    56u,
    55u,
    101u,
    101u,
    102u,
    53u,
    50u,
    100u,
    100u,
    56u,
    101u,
    100u,
    101u,
    101u,
    52u,
    53u,
    54u,
    99u,
    54u,
    48u,
    100u,
    54u,
    99u,
    101u,
    99u,
    98u,
    98u,
    54u,
    49u,
    55u,
    53u,
    52u,
    53u,
    56u,
    101u,
    101u,
    53u,
    51u,
    102u,
    99u,
    56u,
    99u,
    54u,
    99u,
    56u,
    49u,
    51u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
const unsigned __int8 _func___14216[11] = { 103u, 101u, 116u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___14225[12] = { 103u, 101u, 116u, 95u, 100u, 101u, 118u, 105u, 99u, 101u, 115u, 0u }; // idb
const unsigned __int8 _func___14241[9] = { 115u, 104u, 97u, 114u, 101u, 108u, 111u, 103u, 0u }; // idb
const unsigned __int8 _func___14273[9] = { 97u, 100u, 100u, 95u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___14281[10] = { 112u, 111u, 111u, 108u, 95u, 116u, 115u, 101u, 116u, 0u }; // idb
const unsigned __int8 _func___14287[12] = { 112u, 111u, 111u, 108u, 95u, 116u, 99u, 108u, 101u, 97u, 114u, 0u }; // idb
const unsigned __int8 _func___14292[13] = { 99u, 117u, 114u, 114u, 101u, 110u, 116u, 95u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___14391[10] = { 115u, 101u, 116u, 117u, 112u, 95u, 117u, 114u, 108u, 0u }; // idb
const unsigned __int8 _func___14463[18] =
{
  108u,
  111u,
  97u,
  100u,
  95u,
  116u,
  101u,
  109u,
  112u,
  95u,
  99u,
  117u,
  116u,
  111u,
  102u,
  102u,
  115u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___14967[13] = { 112u, 97u, 114u, 115u, 101u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _func___14992[12] = { 108u, 111u, 97u, 100u, 95u, 99u, 111u, 110u, 102u, 105u, 103u, 0u }; // idb
const unsigned __int8 _func___15001[20] =
{
  108u,
  111u,
  97u,
  100u,
  95u,
  100u,
  101u,
  102u,
  97u,
  117u,
  108u,
  116u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  0u
}; // idb
const unsigned __int8 _func___15035[14] = { 99u, 97u, 108u, 99u, 95u, 109u, 105u, 100u, 115u, 116u, 97u, 116u, 101u, 0u }; // idb
const unsigned __int8 _func___15040[15] =
{
  116u,
  111u,
  116u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  105u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _func___15045[10] = { 109u, 97u, 107u, 101u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___15133[13] = { 103u, 101u, 116u, 95u, 115u, 116u, 97u, 116u, 108u, 105u, 110u, 101u, 0u }; // idb
const unsigned __int8 _func___15156[13] = { 115u, 104u, 97u, 114u, 101u, 95u, 114u, 101u, 115u, 117u, 108u, 116u, 0u }; // idb
const unsigned __int8 _func___15255[19] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  101u,
  110u,
  99u,
  104u,
  109u,
  97u,
  114u,
  107u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___15378[11] = { 95u, 99u, 111u, 112u, 121u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___15409[11] = { 115u, 116u, 97u, 108u, 101u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___15420[11] = { 115u, 104u, 97u, 114u, 101u, 95u, 100u, 105u, 102u, 102u, 0u }; // idb
const unsigned __int8 _func___15455[13] = { 115u, 119u, 105u, 116u, 99u, 104u, 95u, 112u, 111u, 111u, 108u, 115u, 0u }; // idb
const unsigned __int8 _func___15488[9] = { 119u, 97u, 107u, 101u, 95u, 103u, 119u, 115u, 0u }; // idb
const unsigned __int8 _func___15495[14] = { 100u, 105u, 115u, 99u, 97u, 114u, 100u, 95u, 115u, 116u, 97u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___15518[15] =
{
  114u,
  101u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___15533[19] =
{
  115u,
  105u,
  103u,
  110u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___15535[19] =
{
  115u,
  105u,
  103u,
  110u,
  97u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___15544[13] = { 115u, 101u, 116u, 95u, 99u, 117u, 114u, 98u, 108u, 111u, 99u, 107u, 0u }; // idb
const unsigned __int8 _func___15570[13] = { 98u, 108u, 111u, 99u, 107u, 95u, 101u, 120u, 105u, 115u, 116u, 115u, 0u }; // idb
const unsigned __int8 _func___15665[18] =
{
  116u,
  101u,
  115u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___15686[10] = { 104u, 97u, 115u, 104u, 95u, 112u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _func___15772[12] = { 106u, 115u, 111u, 110u, 95u, 101u, 115u, 99u, 97u, 112u, 101u, 0u }; // idb
const unsigned __int8 _func___15819[11] = { 122u, 101u, 114u, 111u, 95u, 115u, 116u, 97u, 116u, 115u, 0u }; // idb
const unsigned __int8 _func___15865[10] = { 104u, 97u, 115u, 104u, 109u, 101u, 116u, 101u, 114u, 0u }; // idb
const unsigned __int8 _func___15913[23] =
{
  112u,
  97u,
  114u,
  115u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  114u,
  101u,
  115u,
  112u,
  111u,
  110u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___15949[21] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  104u,
  97u,
  114u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___15962[16] =
{
  99u,
  108u,
  101u,
  97u,
  114u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___15973[8] = { 99u, 112u, 95u, 112u, 114u, 105u, 111u, 0u }; // idb
const unsigned __int8 _func___15993[16] =
{
  115u,
  117u,
  112u,
  112u,
  111u,
  114u,
  116u,
  115u,
  95u,
  114u,
  101u,
  115u,
  117u,
  109u,
  101u,
  0u
}; // idb
const unsigned __int8 _func___16021[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  114u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16032[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___16047[16] =
{
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___16153[12] = { 112u, 111u, 111u, 108u, 95u, 97u, 99u, 116u, 105u, 118u, 101u, 0u }; // idb
const unsigned __int8 _func___16174[9] = { 104u, 97u, 115u, 104u, 95u, 112u, 111u, 112u, 0u }; // idb
const unsigned __int8 _func___16206[11] = { 115u, 101u, 116u, 95u, 116u, 97u, 114u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _func___16216[19] =
{
  103u,
  101u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  98u,
  121u,
  95u,
  110u,
  111u,
  110u,
  99u,
  101u,
  50u,
  0u
}; // idb
const unsigned __int8 _func___16227[17] =
{
  103u,
  101u,
  110u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16243[19] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  101u,
  110u,
  99u,
  104u,
  109u,
  97u,
  114u,
  107u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16252[9] = { 103u, 101u, 116u, 95u, 119u, 111u, 114u, 107u, 0u }; // idb
const unsigned __int8 _func___16264[18] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  97u,
  115u,
  121u,
  110u,
  99u,
  0u
}; // idb
const unsigned __int8 _func___16278[14] =
{
  105u,
  110u,
  99u,
  95u,
  104u,
  119u,
  95u,
  101u,
  114u,
  114u,
  111u,
  114u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___16313[18] =
{
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  119u,
  111u,
  114u,
  107u,
  95u,
  115u,
  116u,
  97u,
  116u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___16326[19] =
{
  115u,
  117u,
  98u,
  109u,
  105u,
  116u,
  95u,
  116u,
  101u,
  115u,
  116u,
  101u,
  100u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16403[11] = { 109u, 116u, 95u, 100u, 105u, 115u, 97u, 98u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___16435[15] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  115u,
  111u,
  108u,
  101u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16601[12] = { 102u, 108u, 117u, 115u, 104u, 95u, 113u, 117u, 101u, 117u, 101u, 0u }; // idb
const unsigned __int8 _func___16631[17] =
{
  104u,
  97u,
  115u,
  104u,
  95u,
  100u,
  114u,
  105u,
  118u,
  101u,
  114u,
  95u,
  119u,
  111u,
  114u,
  107u,
  0u
}; // idb
const unsigned __int8 _func___16644[13] = { 109u, 105u, 110u, 101u, 114u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___16652[15] =
{
  119u,
  97u,
  105u,
  116u,
  95u,
  108u,
  112u,
  99u,
  117u,
  114u,
  114u,
  101u,
  110u,
  116u,
  0u
}; // idb
const unsigned __int8 _func___16670[10] = { 114u, 101u, 97u, 112u, 95u, 99u, 117u, 114u, 108u, 0u }; // idb
const unsigned __int8 _func___16682[21] =
{
  112u,
  114u,
  117u,
  110u,
  101u,
  95u,
  115u,
  116u,
  114u,
  97u,
  116u,
  117u,
  109u,
  95u,
  115u,
  104u,
  97u,
  114u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___16715[16] =
{
  119u,
  97u,
  116u,
  99u,
  104u,
  100u,
  111u,
  103u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___16839[17] =
{
  116u,
  101u,
  115u,
  116u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___16849[17] =
{
  97u,
  100u,
  100u,
  95u,
  112u,
  111u,
  111u,
  108u,
  95u,
  100u,
  101u,
  116u,
  97u,
  105u,
  108u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___16943[14] = { 101u, 110u, 97u, 98u, 108u, 101u, 95u, 100u, 101u, 118u, 105u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___16979[9] = { 97u, 100u, 100u, 95u, 99u, 103u, 112u, 117u, 0u }; // idb
const unsigned __int8 _func___17046[5] = { 109u, 97u, 105u, 110u, 0u }; // idb
const unsigned __int8 _FUNCTION___13303_0[34] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  98u,
  117u,
  105u,
  108u,
  100u,
  95u,
  103u,
  101u,
  116u,
  95u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13310[34] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  98u,
  117u,
  105u,
  108u,
  100u,
  95u,
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13334[31] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  112u,
  114u,
  111u,
  99u,
  101u,
  115u,
  115u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  115u,
  112u,
  111u,
  110u,
  115u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13386_0[23] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  100u,
  117u,
  109u,
  112u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13392[23] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  100u,
  117u,
  109u,
  112u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13399[24] =
{
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  95u,
  105u,
  115u,
  95u,
  112u,
  97u,
  114u,
  97u,
  109u,
  95u,
  118u,
  97u,
  108u,
  105u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13410[17] =
{
  100u,
  111u,
  95u,
  100u,
  117u,
  109u,
  112u,
  95u,
  99u,
  111u,
  114u,
  101u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___13422[17] =
{
  100u,
  111u,
  95u,
  100u,
  117u,
  109u,
  112u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8218[10] = { 109u, 121u, 95u, 115u, 121u, 115u, 116u, 101u, 109u, 0u }; // idb
const unsigned __int8 _FUNCTION___8235[17] =
{
  95u,
  108u,
  111u,
  103u,
  95u,
  117u,
  112u,
  100u,
  97u,
  116u,
  101u,
  95u,
  110u,
  97u,
  109u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8245[11] = { 108u, 111u, 103u, 95u, 114u, 111u, 116u, 97u, 116u, 101u, 0u }; // idb
const unsigned __int8 _FUNCTION___8257[26] =
{
  95u,
  108u,
  111u,
  103u,
  95u,
  103u,
  101u,
  110u,
  101u,
  114u,
  97u,
  116u,
  101u,
  95u,
  115u,
  121u,
  109u,
  98u,
  111u,
  108u,
  95u,
  108u,
  105u,
  110u,
  107u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___8265[13] = { 95u, 108u, 111u, 103u, 95u, 114u, 101u, 109u, 111u, 117u, 110u, 116u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___8280[19] =
{
  108u,
  111u,
  103u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  95u,
  114u,
  111u,
  117u,
  116u,
  105u,
  110u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___8291[9] = { 108u, 111u, 103u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___12462[24] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  119u,
  114u,
  105u,
  116u,
  101u,
  95u,
  105u,
  105u,
  99u,
  95u,
  98u,
  121u,
  116u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12474[23] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  114u,
  101u,
  97u,
  100u,
  95u,
  105u,
  105u,
  99u,
  95u,
  98u,
  121u,
  116u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12539[28] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  105u,
  115u,
  95u,
  102u,
  105u,
  120u,
  116u,
  117u,
  114u,
  101u,
  95u,
  99u,
  114u,
  99u,
  95u,
  112u,
  97u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12548[28] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  105u,
  115u,
  95u,
  99u,
  103u,
  109u,
  105u,
  110u,
  101u,
  114u,
  95u,
  99u,
  114u,
  99u,
  95u,
  112u,
  97u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12553[31] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  105u,
  115u,
  95u,
  102u,
  105u,
  120u,
  116u,
  117u,
  114u,
  101u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  112u,
  97u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12558[31] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  105u,
  115u,
  95u,
  99u,
  103u,
  109u,
  105u,
  110u,
  101u,
  114u,
  95u,
  104u,
  101u,
  97u,
  100u,
  101u,
  114u,
  95u,
  112u,
  97u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12575[24] =
{
  95u,
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  102u,
  108u,
  117u,
  115u,
  104u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12581[12] = { 101u, 101u, 112u, 114u, 111u, 109u, 95u, 108u, 111u, 97u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___12604[13] = { 101u, 101u, 112u, 114u, 111u, 109u, 95u, 102u, 108u, 117u, 115u, 104u, 0u }; // idb
const unsigned __int8 _FUNCTION___12618[23] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  103u,
  101u,
  116u,
  95u,
  112u,
  99u,
  98u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12623[23] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  103u,
  101u,
  116u,
  95u,
  98u,
  111u,
  109u,
  95u,
  118u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12645[16] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  103u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12655[19] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  103u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12662[21] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  103u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12671[16] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  101u,
  116u,
  95u,
  102u,
  114u,
  101u,
  113u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12682[19] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  101u,
  116u,
  95u,
  118u,
  111u,
  108u,
  116u,
  97u,
  103u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___12689[21] =
{
  101u,
  101u,
  112u,
  114u,
  111u,
  109u,
  95u,
  115u,
  101u,
  116u,
  95u,
  104u,
  97u,
  115u,
  104u,
  95u,
  114u,
  97u,
  116u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11107[11] = { 118u, 111u, 108u, 116u, 95u, 99u, 108u, 97u, 109u, 112u, 0u }; // idb
const unsigned __int8 _FUNCTION___11128[21] =
{
  104u,
  97u,
  115u,
  104u,
  98u,
  111u,
  97u,
  114u,
  100u,
  95u,
  112u,
  111u,
  119u,
  101u,
  114u,
  95u,
  99u,
  110u,
  116u,
  108u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11169[10] = { 112u, 105u, 99u, 95u, 114u, 101u, 115u, 101u, 116u, 0u }; // idb
const unsigned __int8 _FUNCTION___11183[19] =
{
  112u,
  105u,
  99u,
  95u,
  115u,
  101u,
  116u,
  95u,
  104u,
  101u,
  97u,
  114u,
  116u,
  95u,
  98u,
  101u,
  97u,
  116u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11197[24] =
{
  106u,
  117u,
  109u,
  112u,
  95u,
  116u,
  111u,
  95u,
  97u,
  112u,
  112u,
  95u,
  102u,
  114u,
  111u,
  109u,
  95u,
  108u,
  111u,
  97u,
  100u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _func___10389[14] = { 107u, 95u, 97u, 108u, 108u, 111u, 99u, 95u, 105u, 116u, 101u, 109u, 115u, 0u }; // idb
const unsigned __int8 _func___10418[12] = { 95u, 107u, 95u, 110u, 101u, 119u, 95u, 108u, 105u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___10453[12] = { 95u, 107u, 95u, 97u, 100u, 100u, 95u, 104u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _FUNCTION___11489[24] =
{
  115u,
  101u,
  110u,
  100u,
  95u,
  115u,
  101u,
  116u,
  95u,
  99u,
  111u,
  110u,
  102u,
  105u,
  103u,
  95u,
  99u,
  111u,
  109u,
  109u,
  97u,
  110u,
  100u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11509[15] =
{
  99u,
  104u,
  97u,
  105u,
  110u,
  95u,
  105u,
  110u,
  97u,
  99u,
  116u,
  105u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11559[22] =
{
  103u,
  101u,
  116u,
  95u,
  98u,
  116u,
  56u,
  100u,
  95u,
  102u,
  112u,
  103u,
  97u,
  95u,
  100u,
  105u,
  118u,
  105u,
  100u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11566[14] = { 115u, 101u, 116u, 95u, 98u, 97u, 117u, 100u, 95u, 102u, 112u, 103u, 97u, 0u }; // idb
const unsigned __int8 _FUNCTION___11575[19] =
{
  115u,
  101u,
  116u,
  95u,
  98u,
  97u,
  117u,
  100u,
  95u,
  111u,
  110u,
  101u,
  95u,
  99u,
  104u,
  97u,
  105u,
  110u,
  0u
}; // idb
const unsigned __int8 _FUNCTION___11619[19] =
{
  114u,
  101u,
  97u,
  100u,
  95u,
  97u,
  115u,
  105u,
  99u,
  95u,
  114u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  0u
}; // idb
void *off_ACB98 = (void *)0xA7325; // weak
const unsigned __int8 _func___10962[14] =
{
  109u,
  121u,
  95u,
  108u,
  111u,
  103u,
  95u,
  99u,
  117u,
  114u,
  115u,
  101u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___11256[8] = { 95u, 105u, 111u, 95u, 110u, 101u, 119u, 0u }; // idb
const unsigned __int8 _func___11265[7] = { 105u, 111u, 95u, 97u, 100u, 100u, 0u }; // idb
const unsigned __int8 _func___11295[14] =
{
  101u,
  115u,
  99u,
  97u,
  112u,
  101u,
  95u,
  115u,
  116u,
  114u,
  105u,
  110u,
  103u,
  0u
}; // idb
const unsigned __int8 _func___11319[18] =
{
  97u,
  112u,
  105u,
  95u,
  97u,
  100u,
  100u,
  95u,
  100u,
  97u,
  116u,
  97u,
  95u,
  102u,
  117u,
  108u,
  108u,
  0u
}; // idb
const unsigned __int8 _func___11521[13] = { 97u, 100u, 100u, 95u, 105u, 116u, 101u, 109u, 95u, 98u, 117u, 102u, 0u }; // idb
const unsigned __int8 _func___11535[11] = { 112u, 114u, 105u, 110u, 116u, 95u, 100u, 97u, 116u, 97u, 0u }; // idb
const unsigned __int8 _func___11574[8] = { 110u, 117u, 109u, 97u, 115u, 99u, 115u, 0u }; // idb
const unsigned __int8 _func___11583[10] = { 97u, 115u, 99u, 100u, 101u, 118u, 105u, 99u, 101u, 0u }; // idb
const unsigned __int8 _func___11773[8] = { 115u, 117u, 109u, 109u, 97u, 114u, 121u, 0u }; // idb
const unsigned __int8 _func___11806[11] = { 115u, 119u, 105u, 116u, 99u, 104u, 112u, 111u, 111u, 108u, 0u }; // idb
const unsigned __int8 _func___11823[12] = { 112u, 111u, 111u, 108u, 100u, 101u, 116u, 97u, 105u, 108u, 115u, 0u }; // idb
const unsigned __int8 _func___12046[9] = { 109u, 105u, 110u, 101u, 99u, 111u, 105u, 110u, 0u }; // idb
const unsigned __int8 _func___12125[10] = { 97u, 115u, 99u, 101u, 110u, 97u, 98u, 108u, 101u, 0u }; // idb
const unsigned __int8 _func___12255[7] = { 116u, 105u, 100u, 121u, 117u, 112u, 0u }; // idb
const unsigned __int8 _func___12271[13] = { 115u, 101u, 116u, 117u, 112u, 95u, 103u, 114u, 111u, 117u, 112u, 115u, 0u }; // idb
const unsigned __int8 _func___12309[15] =
{
  115u,
  101u,
  116u,
  117u,
  112u,
  95u,
  105u,
  112u,
  97u,
  99u,
  99u,
  101u,
  115u,
  115u,
  0u
}; // idb
const unsigned __int8 _func___12344[12] = { 113u, 117u, 105u, 116u, 95u, 116u, 104u, 114u, 101u, 97u, 100u, 0u }; // idb
const unsigned __int8 _func___12349[15] =
{
  114u,
  101u,
  115u,
  116u,
  97u,
  114u,
  116u,
  95u,
  116u,
  104u,
  114u,
  101u,
  97u,
  100u,
  0u
}; // idb
const unsigned __int8 _func___12362[14] = { 99u, 104u, 101u, 99u, 107u, 95u, 99u, 111u, 110u, 110u, 101u, 99u, 116u, 0u }; // idb
const unsigned __int8 _func___12417[6] = { 109u, 99u, 97u, 115u, 116u, 0u }; // idb
const unsigned __int8 _func___12440[11] = { 109u, 99u, 97u, 115u, 116u, 95u, 105u, 110u, 105u, 116u, 0u }; // idb
const unsigned __int8 _func___12478[4] = { 97u, 112u, 105u, 0u }; // idb
const unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
void *off_AEFB8 = (void *)0x203D7C; // weak
_UNKNOWN unk_AF0B8; // weak
const unsigned __int8 _PRETTY_FUNCTION___6518[10] = { 112u, 97u, 114u, 115u, 101u, 95u, 111u, 110u, 101u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___8123[13] = { 106u, 115u, 111u, 110u, 112u, 95u, 115u, 116u, 114u, 116u, 111u, 100u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___7339[11] = { 115u, 116u, 114u, 101u, 97u, 109u, 95u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___7347[13] = { 115u, 116u, 114u, 101u, 97u, 109u, 95u, 117u, 110u, 103u, 101u, 116u, 0u }; // idb
const unsigned __int8 _PRETTY_FUNCTION___7370[17] =
{
  108u,
  101u,
  120u,
  95u,
  117u,
  110u,
  103u,
  101u,
  116u,
  95u,
  117u,
  110u,
  115u,
  97u,
  118u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7385[22] =
{
  100u,
  101u,
  99u,
  111u,
  100u,
  101u,
  95u,
  117u,
  110u,
  105u,
  99u,
  111u,
  100u,
  101u,
  95u,
  101u,
  115u,
  99u,
  97u,
  112u,
  101u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7408[16] =
{
  108u,
  101u,
  120u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  115u,
  116u,
  114u,
  105u,
  110u,
  103u,
  0u
}; // idb
const unsigned __int8 _PRETTY_FUNCTION___7434[16] =
{
  108u,
  101u,
  120u,
  95u,
  115u,
  99u,
  97u,
  110u,
  95u,
  110u,
  117u,
  109u,
  98u,
  101u,
  114u,
  0u
}; // idb
const unsigned __int8 whitespace[33] =
{
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  32u,
  0u
}; // idb
unsigned __int8 byte_AF644[4] = { 10u, 0u, 0u, 0u }; // weak
unsigned __int8 byte_AF648[4] = { 32u, 0u, 0u, 0u }; // weak
unsigned __int8 byte_AF64C[4] = { 34u, 0u, 0u, 0u }; // weak
_UNKNOWN unk_AF650; // weak
_UNKNOWN unk_AF654; // weak
_UNKNOWN unk_AF658; // weak
_UNKNOWN unk_AF65C; // weak
_UNKNOWN unk_AF660; // weak
_UNKNOWN unk_AF664; // weak
_UNKNOWN unk_AF668; // weak
_UNKNOWN unk_AF66C; // weak
const unsigned __int8 _PRETTY_FUNCTION___7378[8] = { 100u, 111u, 95u, 100u, 117u, 109u, 112u, 0u }; // idb
int (*_frame_dummy_init_array_entry[2])() = { &frame_dummy, &_do_global_dtors_aux }; // weak
float g_env_temp = 80.0; // idb
freq_tuning_project_conf g_proj_conf_BHB07601_48[2] =
{
  { 2, 0, 48, 1930, 300, 25, 1950, 9000, 10000, 100, 0 },
  { 2, 1, 48, 1930, 300, 25, 1950, 9000, 10000, 100, 0 }
}; // idb
unsigned __int8 *temp_log = &aVarLogTemp; // idb
int last_airout_pcb_temp_11224 = 50; // idb
device_drv bitmain_soc_drv =
{
  DRIVER_bitmain_soc,
  &aBitmainSoc,
  &aBtmSoc,
  &bitmain_soc_detect,
  &bitmain_soc_reinit_device,
  &get_bitmain_statline_before,
  NULL,
  &bitmain_api_stats,
  NULL,
  NULL,
  NULL,
  &bitmain_soc_prepare,
  NULL,
  NULL,
  NULL,
  &hash_driver_work,
  NULL,
  &bitmain_soc_scanhash,
  NULL,
  &bitmain_soc_update,
  &bitmain_soc_update,
  NULL,
  &bitmain_soc_shutdown,
  NULL,
  NULL,
  false,
  0.0,
  0.0
}; // idb
float init_freq = 50.0; // idb
float freq_step = 25.0; // idb
int freq_scan_status = 1; // idb
int freq_mode = 2; // idb
int ticket_mask = 63; // idb
uint32_t given_id = 2u; // idb
int opt_bitmain_soc_freq = 235; // idb
int opt_bitmain_soc_voltage = 1730; // idb
uint8_t All_Chain = 255u; // idb
unsigned int gBM1391_MISC_CONTROL_reg = 14849u; // idb
freq_pll freq_pll_1391[179] =
{
  { 19, 131136u, 1056u, 2097779u },
  { 22, 131136u, 1056u, 2097763u },
  { 26, 131136u, 1056u, 2097747u },
  { 28, 131136u, 1056u, 2097778u },
  { 33, 131136u, 1056u, 2097731u },
  { 40, 131136u, 1056u, 2097746u },
  { 50, 131136u, 1056u, 2097730u },
  { 57, 131136u, 1056u, 2097777u },
  { 66, 131136u, 1056u, 2097761u },
  { 80, 131136u, 1056u, 2097745u },
  { 100, 131136u, 1056u, 2097729u },
  { 125, 163904u, 1056u, 2622017u },
  { 150, 196672u, 1056u, 7864660u },
  { 175, 229440u, 1056u, 3670593u },
  { 200, 262208u, 1056u, 4194881u },
  { 225, 294976u, 1056u, 4719169u },
  { 250, 327744u, 1056u, 5243457u },
  { 275, 360512u, 1056u, 5767745u },
  { 300, 393280u, 1056u, 7864658u },
  { 303, 393280u, 1056u, 6357569u },
  { 306, 393280u, 1056u, 6423105u },
  { 309, 393280u, 1056u, 6488641u },
  { 312, 393280u, 1056u, 6554177u },
  { 315, 393280u, 1056u, 6619713u },
  { 318, 393280u, 1056u, 6685249u },
  { 321, 393280u, 1056u, 6750785u },
  { 325, 426048u, 1056u, 6816321u },
  { 328, 393280u, 1056u, 6881857u },
  { 331, 393280u, 1056u, 6947393u },
  { 334, 393280u, 1056u, 7012929u },
  { 337, 458816u, 1056u, 7078465u },
  { 340, 393280u, 1056u, 7144001u },
  { 343, 393280u, 1056u, 7209537u },
  { 346, 393280u, 1056u, 7275073u },
  { 350, 426048u, 1056u, 5505330u },
  { 353, 393280u, 1056u, 7406145u },
  { 356, 393280u, 1056u, 7471681u },
  { 359, 393280u, 1056u, 7537217u },
  { 362, 393280u, 1056u, 7602753u },
  { 365, 393280u, 1056u, 7668289u },
  { 368, 393280u, 1056u, 7733825u },
  { 371, 393280u, 1056u, 7799361u },
  { 375, 426048u, 1056u, 7864897u },
  { 378, 393280u, 1056u, 7930433u },
  { 381, 393280u, 1056u, 7995969u },
  { 384, 393280u, 1056u, 8061505u },
  { 387, 458816u, 1056u, 8127041u },
  { 390, 393280u, 1056u, 8192577u },
  { 393, 393280u, 1056u, 8258113u },
  { 396, 393280u, 1056u, 8323649u },
  { 400, 524352u, 1056u, 8389185u },
  { 404, 397376u, 800u, 6357553u },
  { 406, 266304u, 544u, 4260385u },
  { 408, 401472u, 800u, 6423089u },
  { 412, 270400u, 544u, 4325921u },
  { 416, 409664u, 800u, 6554161u },
  { 418, 274496u, 544u, 4391457u },
  { 420, 413760u, 800u, 6619697u },
  { 425, 278592u, 544u, 4456993u },
  { 429, 421952u, 800u, 6750769u },
  { 431, 282688u, 544u, 4522529u },
  { 433, 426048u, 800u, 6816305u },
  { 437, 286784u, 544u, 4588065u },
  { 441, 434240u, 800u, 6947377u },
  { 443, 290880u, 544u, 4653601u },
  { 445, 438336u, 800u, 7012913u },
  { 450, 294976u, 544u, 4719137u },
  { 454, 446528u, 800u, 7143985u },
  { 456, 299072u, 544u, 4784673u },
  { 458, 450624u, 800u, 7209521u },
  { 462, 303168u, 544u, 4850209u },
  { 466, 458816u, 800u, 7340593u },
  { 468, 307264u, 544u, 4915745u },
  { 470, 462912u, 800u, 7406129u },
  { 475, 311360u, 544u, 4981281u },
  { 479, 471104u, 800u, 7537201u },
  { 481, 315456u, 544u, 5046817u },
  { 483, 475200u, 800u, 7602737u },
  { 487, 319552u, 544u, 5112353u },
  { 491, 483392u, 800u, 7733809u },
  { 493, 323648u, 544u, 5177889u },
  { 495, 487488u, 800u, 7799345u },
  { 500, 327744u, 544u, 5243425u },
  { 504, 495680u, 800u, 7930417u },
  { 506, 331840u, 544u, 5308961u },
  { 508, 499776u, 800u, 7995953u },
  { 512, 335936u, 544u, 5374497u },
  { 516, 507968u, 800u, 8127025u },
  { 518, 340032u, 544u, 5440033u },
  { 520, 512064u, 800u, 8192561u },
  { 525, 344128u, 544u, 5505569u },
  { 529, 520256u, 800u, 8323633u },
  { 531, 348224u, 544u, 5571105u },
  { 533, 524352u, 800u, 8389169u },
  { 537, 352320u, 544u, 5636641u },
  { 543, 356416u, 544u, 5702177u },
  { 550, 360512u, 544u, 5767713u },
  { 556, 364608u, 544u, 5833249u },
  { 562, 368704u, 544u, 5898785u },
  { 568, 372800u, 544u, 5964321u },
  { 575, 376896u, 544u, 6029857u },
  { 581, 380992u, 544u, 6095393u },
  { 587, 385088u, 544u, 6160929u },
  { 593, 389184u, 544u, 6226465u },
  { 600, 393280u, 544u, 6291777u },
  { 606, 397376u, 544u, 6357537u },
  { 612, 401472u, 544u, 6423073u },
  { 618, 405568u, 544u, 6488609u },
  { 625, 409664u, 544u, 6554145u },
  { 631, 413760u, 544u, 6619681u },
  { 637, 417856u, 544u, 6685217u },
  { 643, 421952u, 544u, 6750753u },
  { 650, 426048u, 544u, 6816289u },
  { 656, 430144u, 544u, 6881825u },
  { 662, 434240u, 544u, 6947361u },
  { 668, 438336u, 544u, 7012897u },
  { 675, 442432u, 544u, 7078433u },
  { 681, 446528u, 544u, 7143969u },
  { 687, 450624u, 544u, 7209505u },
  { 693, 454720u, 544u, 7275041u },
  { 700, 458816u, 544u, 7340577u },
  { 706, 462912u, 544u, 7406113u },
  { 712, 467008u, 544u, 7471649u },
  { 718, 471104u, 544u, 7537185u },
  { 725, 475200u, 544u, 7602721u },
  { 731, 479296u, 544u, 7668257u },
  { 737, 483392u, 544u, 7733793u },
  { 743, 487488u, 544u, 7799329u },
  { 750, 491584u, 544u, 7864865u },
  { 756, 495680u, 544u, 7930401u },
  { 762, 499776u, 544u, 7995937u },
  { 768, 503872u, 544u, 8061473u },
  { 775, 507968u, 544u, 8127009u },
  { 781, 512064u, 544u, 8192545u },
  { 787, 516160u, 544u, 8258081u },
  { 793, 520256u, 544u, 8323617u },
  { 800, 524352u, 544u, 8389153u },
  { 825, 270400u, 288u, 4325905u },
  { 850, 278592u, 288u, 4456977u },
  { 875, 286784u, 288u, 4588049u },
  { 900, 294976u, 288u, 7078193u },
  { 925, 303168u, 288u, 4850193u },
  { 950, 311360u, 288u, 4981265u },
  { 975, 319552u, 288u, 5112337u },
  { 1000, 327744u, 288u, 5243409u },
  { 1025, 335936u, 288u, 5374481u },
  { 1050, 344128u, 288u, 5505553u },
  { 1075, 352320u, 288u, 5636625u },
  { 1100, 360512u, 288u, 5767697u },
  { 1125, 368704u, 288u, 5898769u },
  { 1150, 376896u, 288u, 6029841u },
  { 1175, 385088u, 288u, 6160913u },
  { 1200, 385088u, 288u, 6291985u },
  { 1300, 385088u, 288u, 6816273u },
  { 1400, 385088u, 288u, 7340561u },
  { 1500, 385088u, 288u, 7864849u },
  { 1600, 385088u, 288u, 8389137u },
  { 1700, 385088u, 288u, 8913425u },
  { 1800, 385088u, 288u, 9437713u },
  { 1900, 385088u, 288u, 9962001u },
  { 2000, 385088u, 288u, 5243153u },
  { 2100, 393248u, 288u, 5505297u },
  { 2200, 393248u, 288u, 5767441u },
  { 2300, 393248u, 288u, 6029585u },
  { 2400, 393248u, 288u, 6291729u },
  { 2500, 409632u, 288u, 6553873u },
  { 2550, 409632u, 288u, 13369873u },
  { 2600, 426016u, 288u, 6816017u },
  { 2625, 426016u, 288u, 13763089u },
  { 2700, 442400u, 288u, 7078161u },
  { 2750, 442400u, 288u, 14418449u },
  { 2800, 458784u, 288u, 7340305u },
  { 2850, 458784u, 288u, 14942737u },
  { 2875, 458784u, 288u, 15073809u },
  { 2900, 458784u, 288u, 7602449u },
  { 3000, 458784u, 288u, 7864593u },
  { 3100, 458784u, 288u, 8126737u },
  { 3200, 458784u, 288u, 8388881u },
  { 3300, 458784u, 288u, 8651025u }
}; // idb
high_pll_out freq_high_pll_1391[33] =
{
  { 100u, 15u, 1500u },
  { 125u, 12u, 1500u },
  { 150u, 10u, 1500u },
  { 175u, 12u, 2100u },
  { 200u, 15u, 3000u },
  { 225u, 12u, 2700u },
  { 250u, 12u, 3000u },
  { 275u, 10u, 2750u },
  { 300u, 10u, 3000u },
  { 325u, 8u, 2600u },
  { 350u, 8u, 2800u },
  { 375u, 8u, 3000u },
  { 400u, 7u, 2800u },
  { 425u, 6u, 2550u },
  { 450u, 6u, 2700u },
  { 475u, 6u, 2850u },
  { 500u, 6u, 3000u },
  { 525u, 5u, 2625u },
  { 550u, 5u, 2750u },
  { 575u, 5u, 2870u },
  { 600u, 5u, 3000u },
  { 625u, 4u, 2500u },
  { 650u, 4u, 2600u },
  { 675u, 4u, 2700u },
  { 700u, 4u, 2800u },
  { 725u, 4u, 2900u },
  { 750u, 4u, 3000u },
  { 775u, 4u, 3100u },
  { 800u, 4u, 3200u },
  { 825u, 4u, 3300u },
  { 850u, 3u, 2550u },
  { 875u, 3u, 2625u },
  { 900u, 3u, 2700u }
}; // idb
unsigned int PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608u; // idb
unsigned __int8 last_job_buffer[8192] =
{
  23u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
bool blink_15352 = true; // idb
double voltage_15574 = 17.3; // idb
double voltage_15577 = 17.3; // idb
int pwm_15579 = 70; // idb
int tmp_version_16913 = -1; // idb
uint8_t power_iic_addr = 16u; // idb
uint8_t power_iic_no = 1u; // idb
uint16_t power_protocal_type = 1u; // idb
const unsigned __int8 *power_log_file = &aVarLogLog_0; // idb
int (*selective_yield)(void) = &no_yield; // idb
unsigned __int8 bit_swap_table[256] =
{
  0u,
  128u,
  64u,
  192u,
  32u,
  160u,
  96u,
  224u,
  16u,
  144u,
  80u,
  208u,
  48u,
  176u,
  112u,
  240u,
  8u,
  136u,
  72u,
  200u,
  40u,
  168u,
  104u,
  232u,
  24u,
  152u,
  88u,
  216u,
  56u,
  184u,
  120u,
  248u,
  4u,
  132u,
  68u,
  196u,
  36u,
  164u,
  100u,
  228u,
  20u,
  148u,
  84u,
  212u,
  52u,
  180u,
  116u,
  244u,
  12u,
  140u,
  76u,
  204u,
  44u,
  172u,
  108u,
  236u,
  28u,
  156u,
  92u,
  220u,
  60u,
  188u,
  124u,
  252u,
  2u,
  130u,
  66u,
  194u,
  34u,
  162u,
  98u,
  226u,
  18u,
  146u,
  82u,
  210u,
  50u,
  178u,
  114u,
  242u,
  10u,
  138u,
  74u,
  202u,
  42u,
  170u,
  106u,
  234u,
  26u,
  154u,
  90u,
  218u,
  58u,
  186u,
  122u,
  250u,
  6u,
  134u,
  70u,
  198u,
  38u,
  166u,
  102u,
  230u,
  22u,
  150u,
  86u,
  214u,
  54u,
  182u,
  118u,
  246u,
  14u,
  142u,
  78u,
  206u,
  46u,
  174u,
  110u,
  238u,
  30u,
  158u,
  94u,
  222u,
  62u,
  190u,
  126u,
  254u,
  1u,
  129u,
  65u,
  193u,
  33u,
  161u,
  97u,
  225u,
  17u,
  145u,
  81u,
  209u,
  49u,
  177u,
  113u,
  241u,
  9u,
  137u,
  73u,
  201u,
  41u,
  169u,
  105u,
  233u,
  25u,
  153u,
  89u,
  217u,
  57u,
  185u,
  121u,
  249u,
  5u,
  133u,
  69u,
  197u,
  37u,
  165u,
  101u,
  229u,
  21u,
  149u,
  85u,
  213u,
  53u,
  181u,
  117u,
  245u,
  13u,
  141u,
  77u,
  205u,
  45u,
  173u,
  109u,
  237u,
  29u,
  157u,
  93u,
  221u,
  61u,
  189u,
  125u,
  253u,
  3u,
  131u,
  67u,
  195u,
  35u,
  163u,
  99u,
  227u,
  19u,
  147u,
  83u,
  211u,
  51u,
  179u,
  115u,
  243u,
  11u,
  139u,
  75u,
  203u,
  43u,
  171u,
  107u,
  235u,
  27u,
  155u,
  91u,
  219u,
  59u,
  187u,
  123u,
  251u,
  7u,
  135u,
  71u,
  199u,
  39u,
  167u,
  103u,
  231u,
  23u,
  151u,
  87u,
  215u,
  55u,
  183u,
  119u,
  247u,
  15u,
  143u,
  79u,
  207u,
  47u,
  175u,
  111u,
  239u,
  31u,
  159u,
  95u,
  223u,
  63u,
  191u,
  127u,
  255u
}; // idb
$262D70590CF6D71EA9430194459E5D8E proxynames[7] =
{
  { &aHttp_0, 0 },
  { &aHttp0, 1 },
  { &aSocks4, 2 },
  { &aSocks5, 3 },
  { &aSocks4a, 4 },
  { &aSocks5h, 5 },
  { NULL, 0 }
}; // idb
unsigned __int8 *blank_merkle = &a00000000000000; // idb
unsigned __int8 *curly = &unk_A19C8; // idb
strategies strategies_0[] = { { &aFailover } }; // idb
benchfile_layout benchfile_data[5] =
{
  { 1, &aVersion_1 },
  { 64, &aMerkleroot },
  { 64, &aPrevhash },
  { 8, &aDifficultybits },
  { 10, &aNoncetime }
}; // idb
int opt_log_interval = 5; // idb
int max_queue = 1; // idb
int opt_scantime = -1; // idb
int opt_expiry = 120; // idb
int opt_pool_fallback = 120; // idb
unsigned int global_quota_gcd = 1u; // idb
bool opt_restart = true; // idb
bool opt_submit_stale = true; // idb
bool opt_bitmain_ab = true; // idb
unsigned __int8 *opt_api_description = &aCgminer100; // idb
int opt_api_port = 4028; // idb
unsigned __int8 *opt_api_host = &a0000; // idb
unsigned __int8 *opt_api_mcast_addr = &a2240075; // idb
unsigned __int8 *opt_api_mcast_code = &aFtw; // idb
unsigned __int8 *opt_api_mcast_des = &byte_A1BD4; // idb
int opt_api_mcast_port = 4028; // idb
unsigned __int8 best_share[8] = { 48u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // idb
double current_diff = 1.84467441e19; // idb
int opt_multi_version = 1; // idb
unsigned __int8 *getwork_req = &aMethodGetworkP; // idb
opt_table opt_config_table[78] =
{
  {
    &aVersionFile,
    OPT_HASARG,
    NULL,
    &set_version_path,
    NULL,
    { &opt_hidden },
    &aSetMinerVersio
  },
  {
    &aLogfileOpenfla,
    OPT_HASARG,
    NULL,
    &set_logfile_openflag,
    NULL,
    { &opt_hidden },
    &aSetLogFileOpen
  },
  {
    &aLogwork,
    OPT_HASARG,
    NULL,
    &set_logwork_path,
    NULL,
    { &opt_hidden },
    &aSetLogWorkFile
  },
  {
    &aLogworkAsicnum,
    OPT_HASARG,
    NULL,
    &set_logwork_asicnum,
    NULL,
    { &opt_hidden },
    &aSetLogWorkAsic
  },
  {
    &aLogworkDiff,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_logwork_diff },
    &aAllowLogWorkDi
  },
  {
    &aLogfile,
    OPT_HASARG,
    NULL,
    &set_logfile_path,
    NULL,
    { &opt_hidden },
    &aSetLogFileDefa
  },
  {
    &aApiAllow,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_api_allow },
    &aAllowApiAccess
  },
  {
    &aApiDescription,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_api_description },
    &aDescriptionPla
  },
  {
    &aApiGroups,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_api_groups },
    &aApiOneLetterGr
  },
  {
    &aApiListen,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_api_listen },
    &aEnableApiDefau
  },
  {
    &aApiMcast,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_api_mcast },
    &aEnableApiMulti
  },
  {
    &aApiMcastAddr,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_api_mcast_addr },
    &aApiMulticastLi_0
  },
  {
    &aApiMcastCode,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_api_mcast_code },
    &aCodeExpectedIn
  },
  {
    &aApiMcastDes,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_api_mcast_des },
    &aDescriptionApp
  },
  {
    &aApiMcastPort,
    OPT_HASARG,
    NULL,
    &set_int_1_to_65535,
    &opt_show_intval,
    { &opt_api_mcast_port },
    &aApiMulticastLi_1
  },
  {
    &aApiNetwork,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_api_network },
    &aAllowApiIfEnab
  },
  {
    &aApiPort,
    OPT_HASARG,
    NULL,
    &set_int_1_to_65535,
    &opt_show_intval,
    { &opt_api_port },
    &aPortNumberOfMi
  },
  {
    &aApiHost,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_api_host },
    &aSpecifyApiList
  },
  {
    &aBalance,
    OPT_NOARG,
    &set_balance,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo
  },
  {
    &aBenchfile_0,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_benchfile },
    &aRunCgminerInBe
  },
  {
    &aBenchfileDispl,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_benchfile_display },
    &aDisplayEachBen
  },
  {
    &aBenchmark_0,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_benchmark },
    &aRunCgminerInBe_0
  },
  {
    &aBitmainFanCtrl,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_bitmain_fan_ctrl },
    &aEnableBitmainM
  },
  {
    &aBitmainNobeepe,
    OPT_NOARG,
    &opt_set_invbool,
    NULL,
    NULL,
    { &opt_bitmain_ab },
    &aEnableBitmainL
  },
  {
    &aBitmainFanPwm,
    OPT_HASARG,
    NULL,
    &set_int_0_to_100,
    &opt_show_intval,
    { &opt_bitmain_fan_pwm },
    &aSetBitmainFanP
  },
  {
    &aBitmainFreq,
    OPT_HASARG,
    NULL,
    &set_int_0_to_9999,
    &opt_show_intval,
    { &opt_bitmain_soc_freq },
    &aSetFrequency
  },
  {
    &aBitmainVoltage,
    OPT_HASARG,
    NULL,
    &set_int_0_to_9999,
    &opt_show_intval,
    { &opt_bitmain_soc_voltage },
    &aSetVoltage
  },
  {
    &aFixedFreq,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_fixed_freq },
    &aSetBitmainMine
  },
  {
    &aNoPreHeat,
    OPT_NOARG,
    &opt_set_false,
    NULL,
    NULL,
    { &opt_pre_heat },
    &aSetBitmainMine_0
  },
  {
    &aBitmainInitFre,
    OPT_HASARG,
    NULL,
    &set_float_0_to_500,
    &opt_show_floatval,
    { &init_freq },
    &aSetInitFreqRan
  },
  {
    &aBitmainFreqSte,
    OPT_HASARG,
    NULL,
    &set_float_0_to_500,
    &opt_show_floatval,
    { &freq_step },
    &aIncreaseFreqSt
  },
  {
    &aBitmainUsePllL,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_use_pll_list },
    &aSetBitmainMine
  },
  {
    &aPrePatternTest,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_pattern },
    &aDoPatternTestB
  },
  {
    &aBitmainEconomi,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_bitmain_economic_mode },
    &aEnableBitmainM_0
  },
  {
    &aDebugD,
    OPT_NOARG,
    &enable_debug,
    NULL,
    NULL,
    { &opt_debug },
    &aEnableDebugOut
  },
  {
    &aDisableRejecti,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_disable_pool },
    &aAutomaticallyD
  },
  {
    &aExpiryE,
    OPT_HASARG,
    NULL,
    &set_int_0_to_9999,
    &opt_show_intval,
    { &opt_expiry },
    &aUpperBoundOnHo
  },
  {
    &aExtranonceSubs_0,
    OPT_NOARG,
    &set_extranonce_subscribe,
    NULL,
    NULL,
    { NULL },
    &aEnableExtranon_0
  },
  {
    &aFailoverOnly,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_fail_only },
    &aDonTLeakWorkTo
  },
  {
    &aFixProtocol,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_fix_protocol },
    &aDoNotRedirectT
  },
  {
    &aFallbackTime,
    OPT_HASARG,
    NULL,
    &opt_set_intval,
    &opt_show_intval,
    { &opt_pool_fallback },
    &aSetTimeInSecon
  },
  {
    &aHotplug_0,
    OPT_HASARG,
    NULL,
    &set_int_0_to_9999,
    NULL,
    { &hotplug_time },
    &opt_hidden
  },
  {
    &aLoadBalance,
    OPT_NOARG,
    &set_loadbalance,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_0
  },
  {
    &aLogL,
    OPT_HASARG,
    NULL,
    &set_int_0_to_9999,
    &opt_show_intval,
    { &opt_log_interval },
    &aIntervalInSeco
  },
  {
    &aLowmem,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_lowmem },
    &aMinimiseCachin
  },
  {
    &aMonitorM,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_stderr_cmd },
    &aUseCustomPipeC
  },
  {
    &aNetDelay,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_delaynet },
    &aImposeSmallDel
  },
  {
    &aNoPoolDisable,
    OPT_NOARG,
    &opt_set_invbool,
    NULL,
    NULL,
    { &opt_disable_pool },
    &opt_hidden
  },
  {
    &aNoSubmitStale,
    OPT_NOARG,
    &opt_set_invbool,
    NULL,
    NULL,
    { &opt_submit_stale },
    &aDonTSubmitShar
  },
  {
    &aPassP,
    OPT_HASARG,
    NULL,
    &set_pass,
    NULL,
    { &opt_set_null },
    &aPasswordForBit
  },
  {
    &aPerDeviceStats,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &want_per_device_stats },
    &aForceVerboseMo
  },
  {
    &aPools_1,
    OPT_HASARG,
    NULL,
    &opt_set_bool,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aProtocolDumpP,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_protocol },
    &aVerboseDumpOfP
  },
  {
    &aQueueQ,
    OPT_HASARG,
    NULL,
    &set_int_0_to_9999,
    &opt_show_intval,
    { &opt_queue },
    &aMaximumNumberO
  },
  {
    &aQuietQ,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_quiet },
    &aDisableLogging
  },
  {
    &aQuotaU,
    OPT_HASARG,
    NULL,
    &set_quota,
    NULL,
    { &opt_set_null },
    &aQuotaUrlCombin
  },
  {
    &aRealQuiet,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_realquiet },
    &aDisableAllOutp
  },
  {
    &aRetries,
    OPT_HASARG,
    NULL,
    &set_null,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRetryPause,
    OPT_HASARG,
    NULL,
    &set_null,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    &aRotate,
    OPT_HASARG,
    NULL,
    &set_rotate,
    NULL,
    { &opt_set_null },
    &aChangeMultipoo_1
  },
  {
    &aRoundRobin,
    OPT_NOARG,
    &set_rr,
    NULL,
    NULL,
    { &pool_strategy_0 },
    &aChangeMultipoo_2
  },
  {
    &aScanTimeS,
    OPT_HASARG,
    NULL,
    &set_int_0_to_9999,
    &opt_show_intval,
    { &opt_scantime },
    &aUpperBoundOnTi
  },
  {
    &aSchedStart,
    OPT_PROCESSARG,
    NULL,
    &set_sched_start,
    NULL,
    { &opt_set_sched_start },
    &aSetATimeOfDayI
  },
  {
    &aSchedStop,
    OPT_PROCESSARG,
    NULL,
    &set_sched_stop,
    NULL,
    { &opt_set_sched_stop },
    &aSetATimeOfDayI_0
  },
  {
    &aSharelog,
    OPT_PROCESSARG,
    NULL,
    &set_sharelog,
    NULL,
    { &opt_set_sharelog },
    &aAppendShareLog
  },
  {
    &aShares,
    OPT_HASARG,
    NULL,
    &opt_set_intval,
    NULL,
    { &opt_shares },
    &aQuitAfterMinin
  },
  {
    &aSocksProxy,
    OPT_HASARG,
    NULL,
    &opt_set_charp,
    NULL,
    { &opt_socks_proxy },
    &aSetSocks4Proxy
  },
  {
    &aSuggestDiff,
    OPT_HASARG,
    NULL,
    &opt_set_intval,
    NULL,
    { &opt_suggest_diff },
    &aSuggestMinerDi
  },
  {
    &aMultiVersion,
    OPT_HASARG,
    NULL,
    &opt_set_intval,
    NULL,
    { &opt_multi_version },
    &aMultiVersionMi
  },
  {
    &aSyslog_0,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &use_syslog },
    &aUseSystemLogFo
  },
  {
    &aTextOnlyT,
    OPT_NOARG,
    &opt_set_invbool,
    NULL,
    NULL,
    { &use_curses },
    &opt_hidden
  },
  {
    &aUrlO,
    OPT_HASARG,
    NULL,
    &set_url,
    NULL,
    { &opt_set_null },
    &aUrlForBitcoinJ
  },
  {
    &aUserU,
    OPT_HASARG,
    NULL,
    &set_user,
    NULL,
    { &opt_set_null },
    &aUsernameForBit
  },
  {
    &aUserpassO,
    OPT_HASARG,
    NULL,
    &set_userpass,
    NULL,
    { &opt_set_null },
    &aUsernamePasswo
  },
  {
    &aVerbose_0,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_log_output },
    &aLogVerboseOutp
  },
  {
    &aWidescreen,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_widescreen },
    &aUseExtraWideDi
  },
  {
    &aWorktime_0,
    OPT_NOARG,
    &opt_set_bool,
    NULL,
    NULL,
    { &opt_worktime },
    &aDisplayExtraWo
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
opt_table opt_cmdline_table[5] =
{
  {
    &aConfigC,
    OPT_HASARG,
    NULL,
    &load_config,
    NULL,
    { &opt_set_null },
    &aLoadAJsonForma
  },
  {
    &aDefaultConfig,
    OPT_HASARG,
    NULL,
    &set_default_config,
    NULL,
    { &opt_set_null },
    &aSpecifyTheFile
  },
  {
    &aHelpH,
    OPT_NOARG,
    &opt_verusage_and_exit,
    NULL,
    NULL,
    { NULL },
    &aPrintThisMessa
  },
  {
    &aVersionV,
    OPT_NOARG,
    &opt_version_and_exit,
    NULL,
    NULL,
    { &packagename },
    &aDisplayVersion
  },
  { NULL, OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
unsigned __int8 *workpadding = &a00000080000000; // idb
double total_secs = 1.0; // idb
double new_total_secs = 1.0; // idb
double last_total_secs = 1.0; // idb
unsigned int log_level = 4u; // idb
unsigned __int8 *log_file = &aVarLogLog; // idb
uint32_t sha256_h0[8] =
{
  1779033703u,
  3144134277u,
  1013904242u,
  2773480762u,
  1359893119u,
  2600822924u,
  528734635u,
  1541459225u
}; // idb
uint32_t sha256_k[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
int opt_log_level = 5; // idb
int listen_sockfd = -1; // idb
const unsigned __int8 *UNAVAILABLE = &aApiWillNotBeAv; // idb
const unsigned __int8 *MUNAVAILABLE = &aApiMulticastLi; // idb
const unsigned __int8 *BLANK = &unk_AD1A0; // idb
const unsigned __int8 *COMMA = &asc_AD1A4; // idb
const unsigned __int8 *APIVERSION = &a31; // idb
const unsigned __int8 *DEAD = &aDead; // idb
const unsigned __int8 *SICK = &aSick; // idb
const unsigned __int8 *NOSTART = &aNostart; // idb
const unsigned __int8 *INIT = &aInitialising; // idb
const unsigned __int8 *DISABLED = &aDisabled; // idb
const unsigned __int8 *ALIVE = &aAlive; // idb
const unsigned __int8 *REJECTING = &aRejecting; // idb
const unsigned __int8 *UNKNOWN = &aUnknown; // idb
const unsigned __int8 *NONE = &aNone; // idb
const unsigned __int8 *YES = &aY; // idb
const unsigned __int8 *NO = &aN; // idb
const unsigned __int8 *NULLSTR = &aNull; // idb
const unsigned __int8 *TRUESTR = &aTrue_1; // idb
const unsigned __int8 *FALSESTR = &aFalse_1; // idb
const unsigned __int8 *SHA256STR = &aSha256; // idb
const unsigned __int8 *DEVICECODE = &unk_AD1A0; // idb
const unsigned __int8 *OSINFO = &aLinux; // idb
const unsigned __int8 *JSON_COMMAND = &aCommand; // idb
const unsigned __int8 *JSON_PARAMETER = &aParameter; // idb
CODES codes[84] =
{
  { SEVERITY_SUCC, 7, PARAM_PMAX, &aDPoolS },
  { SEVERITY_ERR, 8, PARAM_NONE, &aNoPools },
  { SEVERITY_SUCC, 9, PARAM_DMAX, &aDAscS },
  { SEVERITY_ERR, 10, PARAM_NONE, &aNoAscs },
  { SEVERITY_SUCC, 11, PARAM_NONE, &aSummary_1 },
  { SEVERITY_SUCC, 16, PARAM_NONE, &aNonceNum },
  { SEVERITY_ERR, 14, PARAM_NONE, &aInvalidCommand },
  { SEVERITY_ERR, 15, PARAM_NONE, &aMissingDeviceI },
  { SEVERITY_SUCC, 59, PARAM_NONE, &aPgaCount_0 },
  { SEVERITY_SUCC, 104, PARAM_NONE, &aAscCount_0 },
  { SEVERITY_SUCC, 22, PARAM_NONE, &aCgminerVersion },
  { SEVERITY_ERR, 23, PARAM_NONE, &aInvalidJson },
  { SEVERITY_ERR, 24, PARAM_CMD, &aMissingJsonS },
  { SEVERITY_ERR, 25, PARAM_NONE, &aMissingPoolIdP },
  { SEVERITY_ERR, 26, PARAM_POOLMAX, &aInvalidPoolIdD },
  { SEVERITY_SUCC, 27, PARAM_POOL, &aSwitchingToPoo_1 },
  { SEVERITY_SUCC, 33, PARAM_NONE, &aCgminerConfig },
  { SEVERITY_ERR, 42, PARAM_NONE, &aMissingSaveFil },
  { SEVERITY_ERR, 43, PARAM_STR, &aCanTOpenOrCrea },
  { SEVERITY_SUCC, 44, PARAM_STR, &aConfigurationS },
  { SEVERITY_ERR, 45, PARAM_STR, &aAccessDeniedTo },
  { SEVERITY_SUCC, 46, PARAM_NONE, &aPrivilegedAcce },
  { SEVERITY_SUCC, 47, PARAM_POOL, &aEnablingPoolDS },
  { SEVERITY_SUCC, 73, PARAM_NONE, &aChangedPoolPri },
  { SEVERITY_ERR, 74, PARAM_PID, &aDuplicatePoolS },
  { SEVERITY_SUCC, 48, PARAM_POOL, &aDisablingPoolD },
  { SEVERITY_INFO, 49, PARAM_POOL, &aPoolDSAlreadyE },
  { SEVERITY_INFO, 50, PARAM_POOL, &aPoolDSAlreadyD },
  { SEVERITY_ERR, 51, PARAM_POOL, &aCannotDisableL },
  { SEVERITY_ERR, 52, PARAM_NONE, &aMissingAddpool },
  { SEVERITY_ERR, 53, PARAM_STR, &aInvalidAddpool },
  { SEVERITY_ERR, 54, PARAM_NONE, &aReachedMaximum },
  { SEVERITY_SUCC, 55, PARAM_POOL, &aAddedPoolDS },
  { SEVERITY_ERR, 66, PARAM_POOL, &aCannotRemoveLa },
  { SEVERITY_ERR, 67, PARAM_POOL, &aCannotRemoveAc },
  { SEVERITY_SUCC, 68, PARAM_BOTH, &aRemovedPoolDS },
  { SEVERITY_SUCC, 60, PARAM_NONE, &aNotify_1 },
  { SEVERITY_SUCC, 69, PARAM_NONE, &aDeviceDetails },
  { SEVERITY_SUCC, 70, PARAM_NONE, &aCgminerStats },
  { SEVERITY_ERR, 71, PARAM_NONE, &aMissingCheckCm },
  { SEVERITY_SUCC, 72, PARAM_NONE, &aCheckCommand },
  { SEVERITY_ERR, 75, PARAM_NONE, &aMissingParamet },
  { SEVERITY_ERR, 76, PARAM_NONE, &aInvalidParamet },
  { SEVERITY_SUCC, 77, PARAM_BOOL, &aFailoverOnlySe },
  { SEVERITY_SUCC, 78, PARAM_NONE, &aCgminerCoin },
  { SEVERITY_SUCC, 79, PARAM_NONE, &aDebugSettings },
  { SEVERITY_SUCC, 82, PARAM_SET, &aSetConfigSToD },
  { SEVERITY_ERR, 83, PARAM_STR, &aUnknownConfigS },
  { SEVERITY_ERR, 126, PARAM_STR, &aDeprecatedConf },
  { SEVERITY_ERR, 84, PARAM_BOTH, &aInvalidNumberD },
  { SEVERITY_ERR, 121, PARAM_BOTH, &aInvalidNegativ_0 },
  { SEVERITY_SUCC, 122, PARAM_SET, &aSetPoolSToQuot },
  { SEVERITY_ERR, 85, PARAM_NONE, &aMissingConfigP },
  { SEVERITY_ERR, 86, PARAM_STR, &aMissingConfigV },
  { SEVERITY_SUCC, 87, PARAM_NONE, &aUsbStatistics },
  { SEVERITY_INFO, 88, PARAM_NONE, &aNoUsbStatistic },
  { SEVERITY_ERR, 94, PARAM_NONE, &aMissingZeroPar },
  { SEVERITY_ERR, 95, PARAM_STR, &aInvalidZeroPar },
  { SEVERITY_SUCC, 96, PARAM_STR, &aZeroedSStatsWi },
  { SEVERITY_SUCC, 97, PARAM_STR, &aZeroedSStatsWi_0 },
  { SEVERITY_ERR, 99, PARAM_STR, &aInvalidValueFo },
  { SEVERITY_SUCC, 100, PARAM_INT, &aHotplugCheckSe },
  { SEVERITY_SUCC, 101, PARAM_NONE, &aHotplugDisable },
  { SEVERITY_WARN, 102, PARAM_NONE, &aHotplugIsNotAv },
  { SEVERITY_ERR, 103, PARAM_NONE, &aMissingHotplug },
  { SEVERITY_ERR, 105, PARAM_NONE, &aNoAscs },
  { SEVERITY_SUCC, 106, PARAM_ASC, &aAscD },
  { SEVERITY_ERR, 107, PARAM_ASCMAX, &aInvalidAscIdDR },
  { SEVERITY_INFO, 108, PARAM_ASC, &aAscDAlreadyEna },
  { SEVERITY_INFO, 109, PARAM_ASC, &aAscDAlreadyDis },
  { SEVERITY_INFO, 110, PARAM_ASC, &aAscDSentEnable },
  { SEVERITY_INFO, 111, PARAM_ASC, &aAscDSetDisable },
  { SEVERITY_ERR, 112, PARAM_ASC, &aAscDIsNotFlagg },
  { SEVERITY_SUCC, 113, PARAM_ASC, &aIdentifyComman },
  { SEVERITY_WARN, 114, PARAM_ASC, &aAscDDoesNotSup },
  { SEVERITY_ERR, 116, PARAM_NONE, &aMissingOptionA },
  { SEVERITY_WARN, 117, PARAM_ASC, &aAscDDoesNotSup_0 },
  { SEVERITY_INFO, 118, PARAM_BOTH, &aAscDSetHelpS },
  { SEVERITY_SUCC, 119, PARAM_BOTH, &aAscDSetOk },
  { SEVERITY_ERR, 120, PARAM_BOTH, &aAscDSetFailedS },
  { SEVERITY_SUCC, 125, PARAM_NONE, &aLcd },
  { SEVERITY_SUCC, 123, PARAM_NONE, &aLockStatsCreat },
  { SEVERITY_WARN, 124, PARAM_NONE, &aLockStatsNotEn },
  { SEVERITY_FAIL, 0, PARAM_PGA, NULL }
}; // idb
const unsigned __int8 *localaddr = &a127001; // idb
CMDS cmds[40] =
{
  { &aVersion_2, &apiversion, false, true },
  { &aConfig_1, &minerconfig, false, true },
  { &aDevs_0, &devstatus, false, true },
  { &aEdevs, &edevstatus, false, true },
  { &aPools_2, &poolstatus, false, true },
  { &aSummary_2, &summary, false, true },
  { &aNoncenum_1, &noncenum, false, true },
  { &aPgacount, &pgacount, false, true },
  { &aSwitchpool, &switchpool, true, false },
  { &aAddpool, &addpool, true, false },
  { &aPoolpriority, &poolpriority, true, false },
  { &aPoolquota, &poolquota, true, false },
  { &aEnablepool, &enablepool, true, false },
  { &aDisablepool, &disablepool, true, false },
  { &aRemovepool, &removepool, true, false },
  { &aSave, &dosave, true, false },
  { &aQuit_0, &doquit, true, false },
  { &aPrivileged, &privileged, true, false },
  { &aNotify_2, &notify, false, true },
  { &aDevdetails_1, &devdetails, false, true },
  { &aRestart_0, &dorestart, true, false },
  { &aStats_1, &minerstats, false, true },
  { &aEstats, &minerestats, false, true },
  { &aCheck_1, &checkcommand, false, false },
  { &aFailoverOnly_0, &failoveronly, true, false },
  { &aCoin_1, &minecoin, false, true },
  { &aDebug_2, &debugstate, true, false },
  { &aSetconfig, &setconfig, true, false },
  { &aUsbstats, &usbstats, false, true },
  { &aZero, &dozero, true, false },
  { &aHotplug_1, &dohotplug, true, false },
  { &aAsc_1, &ascdev, false, false },
  { &aAscenable, &ascenable, true, false },
  { &aAscdisable, &ascdisable, true, false },
  { &aAscidentify, &ascidentify, true, false },
  { &aAscset, &ascset, true, false },
  { &aAsccount, &asccount, false, true },
  { &aLcd_0, &lcddisplay, false, true },
  { &aLockstats, &lockstats, true, true },
  { NULL, NULL, false, false }
}; // idb
json_t_0 the_true_8956 = { JSON_TRUE, 4294967295u }; // idb
json_t_0 the_false_8960 = { JSON_FALSE, 4294967295u }; // idb
json_t_0 the_null_8964 = { JSON_NULL, 4294967295u }; // idb
json_malloc_t do_malloc = &malloc; // idb
json_free_t do_free = &free; // idb
_UNKNOWN _bss_start; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
char completed_10499; // weak
int test_level_12990; // idb
int fatal_error_counter; // idb
bool once_error; // idb
int8_t middle_Offset[128]; // idb
temp_info_t temp_info[16]; // idb
STATUS_CODE status_value; // idb
CALC_NONCE_INFO calc_nonce_info; // idb
bool doTestPatten; // idb
bool startCheckNetworkJob; // idb
bool opt_use_pll_list; // idb
bool opt_pattern; // idb
int last_testpatten_highest_pcb_temp; // idb
int last_testpatten_lowest_pcb_temp; // idb
bool is_reading_core_reg; // idb
int bring_up_pcb_temp; // idb
bool b_is_re_open_core; // idb
bool is_dump_asic_reg_all; // idb
unsigned int *axi_fpga_addr; // idb
unsigned int *fpga_mem_addr; // idb
unsigned int *nonce2_jobid_address; // idb
unsigned int *job_start_address_1; // idb
unsigned int *job_start_address_2; // idb
thr_info *read_temp_id; // idb
bool gBegin_get_nonce; // idb
timeval tv_send_job; // idb
timeval tv_send; // idb
pthread_mutex_t reg_mutex; // idb
pthread_mutex_t nonce_mutex; // idb
pthread_mutex_t iic_mutex; // idb
pthread_mutex_t fpga_mutex; // idb
pthread_mutex_t reopen_core; // idb
uint64_t h; // idb
uint32_t c_coinbase_padding; // idb
uint32_t c_merkles_num; // idb
uint32_t l_coinbase_padding; // idb
uint32_t l_merkles_num; // idb
bool opt_bitmain_economic_mode; // idb
int total_freq; // idb
bool opt_fixed_freq; // idb
bool status_error; // idb
float freq_from_board[16]; // idb
double chain_asic_RT[16][48]; // idb
uint64_t rate[16]; // idb
uint64_t nonce_num[16][128][60]; // idb
int nonce_times; // idb
int rate_error[16]; // idb
unsigned __int8 last_freq[16][256]; // idb
int chain_badcore_num[16][256]; // idb
int x_time[16][128]; // idb
int temp_offside[16]; // idb
bool isChainAllCoresOpened[16]; // idb
pthread_mutex_t reinit_mutex; // idb
uint64_t h_each_chain[16]; // idb
double each_chain_h_avg[16]; // idb
double geach_chain_h_all; // idb
int g_total_hashrate; // idb
int g_ideal_hashrate_fixed; // idb
int g_ideal_hashrate; // idb
int g_ideal_hashrate_max; // idb
uint64_t pool_send_nu_16892; // idb
uint64_t pool_diff_17072; // idb
uint64_t pool_diff_bit_17074; // idb
uint64_t net_diff_17073; // idb
uint64_t net_diff_bit_17075; // idb
uint32_t last_nonce3_17106; // idb
uint32_t last_workid_17107; // idb
power_info_t power_info; // idb
bool successful_connect; // idb
unsigned __int8 packagename[256]; // idb
FILE *g_logwork_file; // idb
FILE *g_logwork_files[65]; // idb
FILE *g_logwork_diffs[65]; // idb
int g_logwork_asicnum; // idb
unsigned __int8 *opt_benchfile; // idb
bool opt_benchfile_display; // idb
FILE *benchfile_in; // idb
int benchfile_line; // idb
int benchfile_work; // idb
bool opt_benchmark; // idb
bool work_filled; // idb
bool work_emptied; // idb
bool opt_display_devs; // idb
int most_devices; // idb
bool alt_status; // idb
bool switch_status; // idb
int opt_shares; // idb
bool opt_fix_protocol; // idb
unsigned __int8 *opt_version_path; // idb
unsigned __int8 *opt_logfile_path; // idb
unsigned __int8 *opt_logfile_openflag; // idb
unsigned __int8 *opt_logwork_path; // idb
unsigned __int8 *opt_logwork_asicnum; // idb
bool opt_logwork_diff; // idb
unsigned __int8 *opt_api_allow; // idb
bool no_work; // idb
unsigned __int8 *opt_set_null; // idb
int gwsched_thr_id; // idb
int watchpool_thr_id; // idb
int watchdog_thr_id; // idb
int api_thr_id; // idb
int total_control_threads; // idb
int new_devices; // idb
int new_threads; // idb
pthread_mutex_t *stgd_lock; // idb
pthread_rwlock_t blk_lock; // idb
pthread_mutex_t sshare_lock; // idb
pthread_mutex_t lp_lock; // idb
pthread_cond_t lp_cond; // idb
double g_local_mhashes_dones[12]; // idb
int g_local_mhashes_index; // idb
double g_displayed_rolling; // idb
unsigned __int8 g_miner_version[256]; // idb
unsigned __int8 g_miner_compiletime[256]; // idb
unsigned __int8 g_miner_type[256]; // idb
unsigned __int8 displayed_hash_rate[16]; // idb
unsigned __int8 displayed_working_voltage[16]; // idb
unsigned __int8 displayed_mode[16]; // idb
timeval total_tv_start; // idb
timeval total_tv_end; // idb
timeval restart_tv_start; // idb
timeval update_tv_start; // idb
int staged_rollable; // idb
unsigned int work_block; // idb
unsigned int local_work_last; // idb
int local_work_lasttime; // idb
pool *currentpool; // idb
pool_strategy pool_strategy_0; // idb
int total_urls; // idb
int total_users; // idb
int total_passes; // idb
int total_userpasses; // idb
int total_extranonce; // idb
unsigned __int8 prev_block[12]; // idb
unsigned __int8 current_block[32]; // idb
unsigned __int8 datestamp[40]; // idb
unsigned __int8 blocktime[32]; // idb
unsigned __int8 block_diff[8]; // idb
uint64_t best_diff; // idb
block *blocks; // idb
stratum_share *stratum_shares; // idb
unsigned __int8 *opt_socks_proxy; // idb
unsigned __int8 *default_config; // idb
bool config_loaded; // idb
int include_count; // idb
unsigned __int8 *opt_stderr_cmd; // idb
int forkpid; // idb
uint32_t total_work; // idb
work *staged_work; // idb
unsigned __int8 exit_buf[512]; // idb
pthread_mutex_t sharelog_lock; // idb
FILE *sharelog_file; // idb
unsigned __int8 *temp_cutoff_str; // idb
int fileconf_load; // idb
unsigned __int8 *cnfbuf; // idb
unsigned __int8 statusline[256]; // idb
int devcursor; // idb
int logstart; // idb
int logcursor; // idb
unsigned __int8 bench_hidiff_bins[16][160]; // idb
unsigned __int8 bench_lodiff_bins[16][160]; // idb
unsigned __int8 bench_target[32]; // idb
unsigned __int8 **initial_args; // idb
JE *jedata; // idb
timeval tv_hashmeter; // idb
time_t hashdisplay_t; // idb
timeval rotate_tv; // idb
bool pools_active; // idb
int cgminer_id_count; // idb
unsigned __int8 err_buf_14961[200]; // idb
_cgpu_devid_counter *devids_16954; // idb
int rotating_pool_15206; // idb
_log_ctx log_ctx; // idb
eeprom_layout_t g_eeprom_buf[16]; // idb
bool g_is_eeprom_loaded; // idb
bool opt_debug; // idb
bool opt_log_output; // idb
FILE *g_log_file; // idb
bool g_logfile_enable; // idb
unsigned __int8 g_logfile_path[256]; // idb
unsigned __int8 g_logfile_openflag[32]; // idb
bool ExitServer; // idb
int my_thr_id; // idb
bool bye; // idb
pthread_mutex_t quit_restart_lock; // idb
bool do_a_quit; // idb
bool do_a_restart; // idb
time_t when; // idb
IPACCESS *ipaccess; // idb
int ips; // idb
io_list *io_head; // idb
K_LIST *strbufs; // idb
volatile uint32_t hashtable_seed; // idb
uint32_t chain_invalid_num; // idb
int chain_hw_num[16]; // idb
device_drv bitmain_drv; // idb
uint32_t asic_invalid_num; // idb
int crc_err_nonce_num[16]; // idb
uint32_t send_work_num[16]; // idb
int g_init_freq; // idb
int err_nonce_num[16]; // idb
int valid_nonce_num[16]; // idb
int asic_nonce_num[16][128]; // idb
int extra_nonce_num[16]; // idb
uint64_t nonce_recv_num_all; // idb
unsigned __int8 g_pattern_status[16][48][672]; // idb
freq_tuning_work g_work_for_hw_check[16][128]; // idb
int invalid_nonce_num[16]; // idb
freq_tuning_project g_BHB91602_proj; // idb
device_drv modminer_drv; // idb
uint16_t domain_nonce_num[16][12][4]; // idb
int asic_core_nonce_num[16][128][1024]; // idb
device_drv bitforce_drv; // idb
int chain_ValidNonce[16]; // idb
int repeated_nonce_num[16]; // idb
freq_tuning_work *g_works[48]; // idb
uint8_t g_chain_unbalance[16]; // idb
thr_info *read_hash_rate; // idb
int g_asic_core_data[16][15]; // idb
int fd; // idb
int fd_fpga_mem; // idb
volatile nonce_buf nonce_read_out; // idb
unsigned __int8 g_asic_data_status[16][255]; // idb
volatile reg_buf reg_value_buf; // idb
int pcb_version; // idb
LOG_FILE_BACKUP init_log_bak; // idb
unsigned __int8 search_failed_info[64]; // idb
int scan_freq_average[16]; // idb
unsigned __int8 FPGA_ID_str[32]; // idb
unsigned __int8 g_asic_core_data_status[16][15]; // idb
unsigned __int8 displayed_rate[16][32]; // idb
thr_info *read_nonce_reg_id; // idb
thr_info *check_system_work_id; // idb
init_config config_parameter; // idb
int fpga_major_version; // idb
clock_delay_ctrl_t core_hash_clock_delay_control[16][128][1024]; // idb
all_parameters *dev; // idb
int g_asic_data[16][255]; // idb
int fpga_version; // idb
SCAN_FREQ_RESULT scan_result[16]; // idb
unsigned __int8 *opt_api_groups; // idb
schedtime schedstop; // idb
int64_t total_stale; // idb
time_t total_tv_start_sys; // idb
unsigned __int8 current_hash[68]; // idb
int hw_errors; // idb
double total_diff_accepted; // idb
bool opt_quiet; // idb
int64_t total_discarded; // idb
bool want_per_device_stats; // idb
double total_diff_rejected; // idb
bool opt_protocol; // idb
schedtime schedstart; // idb
int total_pools; // idb
sigaction abrthandler; // idb
unsigned int found_blocks; // idb
bool sched_paused; // idb
int opt_rotate_period; // idb
cgpu_info **devices; // idb
unsigned __int64 global_hashrate; // idb
bool hotplug_mode; // idb
bool opt_api_mcast; // idb
int opt_suggest_diff; // idb
unsigned __int8 nonce_num60_string[4096]; // idb
time_t total_tv_end_sys; // idb
bool use_curses; // idb
int swork_id; // idb
unsigned int total_ro; // idb
int zombie_devs; // idb
bool opt_worktime; // idb
time_t last_getwork; // idb
thr_info **mining_thr; // idb
pthread_rwlock_t mining_thr_lock; // idb
pool **pools; // idb
pthread_cond_t gws_cond; // idb
bool use_syslog; // idb
bool opt_delaynet; // idb
bool have_longpoll; // idb
cglock_t ch_lock; // idb
cglock_t control_lock; // idb
int enabled_pools; // idb
unsigned __int8 nonce_num30_string[4096]; // idb
unsigned __int8 *cgminer_path; // idb
int g_max_fan; // idb
int g_max_temp; // idb
int mining_threads; // idb
double total_rolling; // idb
thr_info *control_thr; // idb
bool opt_realquiet; // idb
pthread_rwlock_t netacc_lock; // idb
int total_devices; // idb
unsigned __int8 *opt_kernel_path; // idb
unsigned int total_go; // idb
bool opt_fail_only; // idb
int64_t total_accepted; // idb
thread_q *getq; // idb
int64_t total_getworks; // idb
timeval block_timeval; // idb
sigaction termhandler; // idb
bool opt_lowmem; // idb
bool opt_api_listen; // idb
double rolling5; // idb
double rolling1; // idb
double rolling15; // idb
double total_mhashes_done; // idb
bool opt_compact; // idb
unsigned __int8 nonce_num10_string[4096]; // idb
double total_diff_stale; // idb
pthread_mutex_t stats_lock; // idb
unsigned int new_blocks; // idb
bool opt_disable_pool; // idb
pthread_mutex_t console_lock; // idb
pthread_cond_t restart_cond; // idb
sigaction inthandler; // idb
bool opt_api_network; // idb
list_head scan_devices; // idb
pthread_mutex_t update_job_lock; // idb
unsigned int local_work; // idb
int64_t total_rejected; // idb
bool opt_work_update; // idb
pthread_mutex_t restart_lock; // idb
pthread_rwlock_t devices_lock; // idb
double new_total_mhashes_done; // idb
pthread_mutex_t hash_lock; // idb
int64_t total_diff1; // idb
APIGROUPS apigroups[26]; // idb
unsigned int opt_num_short_arg; // idb
unsigned int opt_num_long; // idb
unsigned int opt_num_short; // idb
opt_table *opt_table_0; // idb
const unsigned __int8 *opt_argv0; // idb
unsigned int opt_count; // idb
const unsigned __int8 opt_hidden[]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00011F5C) --------------------------------------------------------
int init_proc()
{
  return call_weak_fn();
}

//----- (00011F68) --------------------------------------------------------
void sub_11F68()
{
  JUMPOUT(0);
}
// 11F74: control flows out of bounds to 0

//----- (00012720) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(void), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    (char **)&va,
    (void (*)(void))_libc_csu_init,
    (void (*)(void))_libc_csu_fini,
    a1,
    &va);
  abort();
}
// 1272C: positive sp value 4 has been found
// 12748: variable 'v4' is possibly undefined
// 97B78: using guessed type int _libc_csu_fini();

//----- (0001275C) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 12300: using guessed type int _gmon_start__(void);

//----- (00012780) --------------------------------------------------------
void *deregister_tm_clones()
{
  return &_bss_start;
}

//----- (000127AC) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &_bss_start;
  HIDWORD(result) = 0;
  return result;
}

//----- (000127E4) --------------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // r0

  if ( !completed_10499 )
  {
    result = deregister_tm_clones();
    completed_10499 = 1;
  }
  return result;
}
// C4488: using guessed type char completed_10499;

//----- (00012810) --------------------------------------------------------
uint32_t __cdecl swab32(uint32_t v)
{
  return bswap32(v);
}

//----- (00012838) --------------------------------------------------------
void __cdecl flip32(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp-10h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (000128C0) --------------------------------------------------------
void __cdecl flip_swab(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp-10h]

  for ( i = 0; length >> 2 > i; ++i )
    *((_DWORD *)dest_p + i) = swab32(*((_DWORD *)src_p + i));
}

//----- (00012954) --------------------------------------------------------
void freq_tuning_get_proj_type()
{
  g_BHB91602_proj.proj_type = 2;
  g_BHB91602_proj.sub_proj_count = 2;
  g_BHB91602_proj.conf_list = g_proj_conf_BHB07601_48;
  g_BHB91602_proj.test_pattern = "/dev/07601_patten_48.txt";
}

//----- (000129B4) --------------------------------------------------------
bool __cdecl freq_tuning_get_max_freq(int *p_max_freq)
{
  FILE *pFile; // [sp+10h] [bp-1Ch]
  FILE *pFile_0; // [sp+14h] [bp-18h]
  int sub_proj_index; // [sp+20h] [bp-Ch]
  int max_freq_tmp; // [sp+24h] [bp-8h]

  max_freq_tmp = (unsigned int)init_freq;
  freq_tuning_get_proj_type();
  if ( g_BHB91602_proj.proj_type == 3 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Fail to get freq tuning max freq!\n",
          "freq_tuning.c",
          283,
          (const char *)_FUNCTION___12783);
      fclose(pFile);
    }
    return 0;
  }
  else
  {
    for ( sub_proj_index = 0; sub_proj_index < g_BHB91602_proj.sub_proj_count; ++sub_proj_index )
    {
      if ( !opt_bitmain_economic_mode == g_BHB91602_proj.conf_list[sub_proj_index].proj_sub_type )
      {
        max_freq_tmp = g_BHB91602_proj.conf_list[sub_proj_index].base_freq
                     + 7 * g_BHB91602_proj.conf_list[sub_proj_index].freq_step;
        break;
      }
    }
    if ( p_max_freq )
    {
      *p_max_freq = max_freq_tmp;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Max freq of tuning is %d\n",
            "freq_tuning.c",
            309,
            (const char *)_FUNCTION___12783,
            max_freq_tmp);
        fclose(pFile_0);
      }
    }
    return 1;
  }
}

//----- (00012BF8) --------------------------------------------------------
void __cdecl freq_tuning_init_freq_info(freq_tuning_info *freq_info)
{
  int i; // [sp+Ch] [bp-8h]

  memset(freq_info, 0, sizeof(freq_tuning_info));
  freq_info->asic_num_per_chain = 48;
  freq_info->asic_num_per_vol_domain = 4;
  memset(freq_info->vol_value_table, 0, sizeof(freq_info->vol_value_table));
  for ( i = 0; i <= 15; ++i )
  {
    freq_info->scan_freq[i] = freq_info->freq_table[i][0];
    freq_info->test_done[i] = 0;
    freq_info->fake_done[i] = 0;
  }
  freq_info->is_pass = 0;
  freq_info->is_unbalance_happened = 0;
}

//----- (00012D00) --------------------------------------------------------
freq_tuning_info *freq_tuning_create_info()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  freq_tuning_info *freq_info; // [sp+Ch] [bp-8h]

  freq_info = (freq_tuning_info *)cgmalloc(0x1410Cu, "freq_tuning.c", _func___12822, 393);
  if ( freq_info )
  {
    freq_tuning_init_freq_info(freq_info);
    return freq_info;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Fail to alloc memory for freq info.\n",
          "freq_tuning.c",
          397,
          (const char *)_FUNCTION___12824);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (00012DE4) --------------------------------------------------------
void __cdecl freq_tuning_domain_nonce_dump(int chain)
{
  FILE *pFile_0; // [sp+8h] [bp-1Ch]
  FILE *pFile_1; // [sp+Ch] [bp-18h]
  FILE *pFile; // [sp+10h] [bp-14h]
  int domain_total; // [sp+14h] [bp-10h]
  int core_domain; // [sp+18h] [bp-Ch]
  int domain; // [sp+1Ch] [bp-8h]

  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "chain %d domain_nonce_num:\n", chain);
    fclose(pFile);
  }
  for ( domain = 0; domain <= 11; ++domain )
  {
    domain_total = 0;
    for ( core_domain = 0; core_domain <= 3; ++core_domain )
    {
      domain_total += domain_nonce_num[chain][domain][core_domain];
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "D[%02d]:%04d ", 4 * domain + core_domain, domain_nonce_num[chain][domain][core_domain]);
        fclose(pFile_0);
      }
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, " D_BIG[%02d]:%05d\n", domain, domain_total);
      fclose(pFile_1);
    }
  }
}

//----- (00013000) --------------------------------------------------------
void __cdecl freq_tuning_parameter_dump(freq_tuning_info *freq_info)
{
  double v1; // d7
  uint64_t v2; // r4
  FILE *pFile_10; // [sp+14h] [bp-70h]
  FILE *pFile_9; // [sp+18h] [bp-6Ch]
  FILE *pFile_8; // [sp+1Ch] [bp-68h]
  FILE *pFile_7; // [sp+20h] [bp-64h]
  FILE *pFile_6; // [sp+24h] [bp-60h]
  FILE *pFile_5; // [sp+28h] [bp-5Ch]
  FILE *pFile_4; // [sp+2Ch] [bp-58h]
  FILE *pFile_3; // [sp+30h] [bp-54h]
  FILE *pFile_2; // [sp+34h] [bp-50h]
  FILE *pFile_1; // [sp+38h] [bp-4Ch]
  FILE *pFile_0; // [sp+3Ch] [bp-48h]
  FILE *pFile_18; // [sp+40h] [bp-44h]
  FILE *pFile_17; // [sp+44h] [bp-40h]
  FILE *pFile_19; // [sp+48h] [bp-3Ch]
  FILE *pFile_16; // [sp+4Ch] [bp-38h]
  FILE *pFile_20; // [sp+50h] [bp-34h]
  FILE *pFile_15; // [sp+54h] [bp-30h]
  FILE *pFile_14; // [sp+58h] [bp-2Ch]
  FILE *pFile_13; // [sp+5Ch] [bp-28h]
  FILE *pFile_12; // [sp+60h] [bp-24h]
  FILE *pFile_11; // [sp+64h] [bp-20h]
  FILE *pFile; // [sp+68h] [bp-1Ch]
  int nonce_recv; // [sp+6Ch] [bp-18h]
  int nonce_recva; // [sp+6Ch] [bp-18h]
  int asic; // [sp+70h] [bp-14h]
  int chain; // [sp+74h] [bp-10h]
  int chaina; // [sp+74h] [bp-10h]
  int chainb; // [sp+74h] [bp-10h]

  nonce_recv = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: ======== dump freq tuning result ========\n",
        "freq_tuning.c",
        450,
        (const char *)_FUNCTION___12863);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !freq_info->test_done[chain] && !freq_info->fake_done[chain] )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "chain %d\n", chain);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%-30s : %d\n", "send_work_num", send_work_num[chain]);
        fclose(pFile_1);
      }
      if ( log_level > 3 )
      {
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, "%-30s : %d\n", "valid_nonce_num", valid_nonce_num[chain]);
        fclose(pFile_2);
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
        {
          if ( send_work_num[chain] )
            v1 = (double)valid_nonce_num[chain] / (double)send_work_num[chain];
          else
            v1 = 0.0;
          fprintf(pFile_3, "%-30s : %f\n", "nonce_return_rate", v1);
        }
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(pFile_4, "%-30s : %d\n", "repeated_nonce_num", repeated_nonce_num[chain]);
        fclose(pFile_4);
      }
      if ( log_level > 3 )
      {
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(pFile_5, "%-30s : %d\n", "extra_nonce_num", extra_nonce_num[chain]);
        fclose(pFile_5);
      }
      if ( log_level > 3 )
      {
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(pFile_6, "%-30s : %d\n", "invalid_nonce_num", invalid_nonce_num[chain]);
        fclose(pFile_6);
      }
      if ( log_level > 3 )
      {
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(pFile_7, "%-30s : %d\n", "crc_err_nonce_num", crc_err_nonce_num[chain]);
        fclose(pFile_7);
      }
      if ( log_level > 3 )
      {
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(pFile_8, "%-30s : %d\n", "err_nonce_num", err_nonce_num[chain]);
        fclose(pFile_8);
      }
      if ( log_level > 3 )
      {
        pFile_9 = fopen((const char *)log_file, "a+");
        if ( pFile_9 )
          fprintf(pFile_9, "%-30s : %d\n", "chain_hw_num", chain_hw_num[chain]);
        fclose(pFile_9);
      }
      if ( log_level > 3 )
      {
        pFile_10 = fopen((const char *)log_file, "a+");
        if ( pFile_10 )
          fputc(10, pFile_10);
        fclose(pFile_10);
      }
      nonce_recv += valid_nonce_num[chain]
                  + repeated_nonce_num[chain]
                  + extra_nonce_num[chain]
                  + invalid_nonce_num[chain];
    }
  }
  nonce_recva = nonce_recv + asic_invalid_num + chain_invalid_num;
  if ( log_level > 3 )
  {
    pFile_11 = fopen((const char *)log_file, "a+");
    if ( pFile_11 )
      fprintf(pFile_11, "%-30s : %u\n", "asic_invalid_num", asic_invalid_num);
    fclose(pFile_11);
  }
  if ( log_level > 3 )
  {
    pFile_12 = fopen((const char *)log_file, "a+");
    if ( pFile_12 )
      fprintf(pFile_12, "%-30s : %u\n", "chain_invalid_num", chain_invalid_num);
    fclose(pFile_12);
  }
  if ( log_level > 3 )
  {
    pFile_13 = fopen((const char *)log_file, "a+");
    if ( pFile_13 )
      fprintf(pFile_13, "%-30s : %llu\n", "nonce_recv_num_all", nonce_recv_num_all);
    fclose(pFile_13);
  }
  if ( log_level > 3 )
  {
    pFile_14 = fopen((const char *)log_file, "a+");
    if ( pFile_14 )
    {
      if ( nonce_recva >= nonce_recv_num_all )
        v2 = nonce_recva - nonce_recv_num_all;
      else
        v2 = nonce_recv_num_all - nonce_recva;
      fprintf(pFile_14, "%-30s : %llu\n", "nonce_recv_num_diff", v2);
    }
    fclose(pFile_14);
  }
  if ( log_level > 3 )
  {
    pFile_15 = fopen((const char *)log_file, "a+");
    if ( pFile_15 )
      fputc(10, pFile_15);
    fclose(pFile_15);
  }
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina] && !freq_info->test_done[chaina] && !freq_info->fake_done[chaina] )
    {
      if ( log_level > 3 )
      {
        pFile_16 = fopen((const char *)log_file, "a+");
        if ( pFile_16 )
          fprintf(pFile_16, "chain %d asic_nonce_num:\n", chaina);
        fclose(pFile_16);
      }
      for ( asic = 0; asic <= 47; ++asic )
      {
        if ( log_level > 3 )
        {
          pFile_17 = fopen((const char *)log_file, "a+");
          if ( pFile_17 )
            fprintf(pFile_17, "IC[%02d]:%04d ", asic, asic_nonce_num[chaina][asic]);
          fclose(pFile_17);
        }
        if ( (((_BYTE)asic + 1) & 3) == 0 && log_level > 3 )
        {
          pFile_18 = fopen((const char *)log_file, "a+");
          if ( pFile_18 )
            fputc(10, pFile_18);
          fclose(pFile_18);
        }
      }
      if ( log_level > 3 )
      {
        pFile_19 = fopen((const char *)log_file, "a+");
        if ( pFile_19 )
          fputc(10, pFile_19);
        fclose(pFile_19);
      }
    }
  }
  for ( chainb = 0; chainb <= 15; ++chainb )
  {
    if ( dev->chain_exist[chainb] )
    {
      if ( !freq_info->test_done[chainb] && !freq_info->fake_done[chainb] )
      {
        freq_tuning_domain_nonce_dump(chainb);
        if ( log_level > 3 )
        {
          pFile_20 = fopen((const char *)log_file, "a+");
          if ( pFile_20 )
            fputc(10, pFile_20);
          fclose(pFile_20);
        }
      }
    }
  }
}

//----- (00013C78) --------------------------------------------------------
void freq_tuning_config_dump()
{
  FILE *pFile_13; // [sp+Ch] [bp-48h]
  FILE *pFile_12; // [sp+10h] [bp-44h]
  FILE *pFile_11; // [sp+14h] [bp-40h]
  FILE *pFile_10; // [sp+18h] [bp-3Ch]
  FILE *pFile_9; // [sp+1Ch] [bp-38h]
  FILE *pFile_8; // [sp+20h] [bp-34h]
  FILE *pFile_7; // [sp+24h] [bp-30h]
  FILE *pFile_6; // [sp+28h] [bp-2Ch]
  FILE *pFile_5; // [sp+2Ch] [bp-28h]
  FILE *pFile_4; // [sp+30h] [bp-24h]
  FILE *pFile_3; // [sp+34h] [bp-20h]
  FILE *pFile_1; // [sp+38h] [bp-1Ch]
  FILE *pFile_2; // [sp+3Ch] [bp-18h]
  FILE *pFile; // [sp+40h] [bp-14h]
  FILE *pFile_0; // [sp+44h] [bp-10h]
  freq_tuning_project_conf *conf; // [sp+48h] [bp-Ch]
  int sub_proj_index; // [sp+4Ch] [bp-8h]

  for ( sub_proj_index = 0; sub_proj_index < g_BHB91602_proj.sub_proj_count; ++sub_proj_index )
  {
    conf = &g_BHB91602_proj.conf_list[sub_proj_index];
    if ( conf->proj_type )
    {
      if ( conf->proj_type == 1 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: proj_type          : %s\n",
            "freq_tuning.c",
            530,
            (const char *)_FUNCTION___12903,
            "S15");
        fclose(pFile_0);
      }
    }
    else if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: proj_type          : %s\n",
          "freq_tuning.c",
          526,
          (const char *)_FUNCTION___12903,
          (const char *)&off_97F50);
      fclose(pFile);
    }
    if ( conf->proj_sub_type )
    {
      if ( conf->proj_sub_type == 1 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: proj_sub_type      : %s\n",
            "freq_tuning.c",
            539,
            (const char *)_FUNCTION___12903,
            "High Hashrate");
        fclose(pFile_2);
      }
    }
    else if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: proj_sub_type      : %s\n",
          "freq_tuning.c",
          535,
          (const char *)_FUNCTION___12903,
          "Economy");
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: asic_num           : %d\n",
          "freq_tuning.c",
          542,
          (const char *)_FUNCTION___12903,
          conf->asic_num);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(
          pFile_4,
          "%s:%d:%s: base_voltage       : %d\n",
          "freq_tuning.c",
          543,
          (const char *)_FUNCTION___12903,
          conf->base_voltage);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(
          pFile_5,
          "%s:%d:%s: base_freq          : %d\n",
          "freq_tuning.c",
          544,
          (const char *)_FUNCTION___12903,
          conf->base_freq);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "%s:%d:%s: freq_step          : %d\n",
          "freq_tuning.c",
          545,
          (const char *)_FUNCTION___12903,
          conf->freq_step);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(
          pFile_7,
          "%s:%d:%s: max_voltage        : %d\n",
          "freq_tuning.c",
          546,
          (const char *)_FUNCTION___12903,
          conf->max_voltage);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(
          pFile_8,
          "%s:%d:%s: Step_count         : %d\n",
          "freq_tuning.c",
          547,
          (const char *)_FUNCTION___12903,
          8);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(
          pFile_9,
          "%s:%d:%s: target_hash_rate   : %d\n",
          "freq_tuning.c",
          548,
          (const char *)_FUNCTION___12903,
          conf->target_hash_rate);
      fclose(pFile_9);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_10 = fopen((const char *)log_file, "a+");
      if ( pFile_10 )
        fprintf(
          pFile_10,
          "%s:%d:%s: max_hash_rate      : %d\n",
          "freq_tuning.c",
          549,
          (const char *)_FUNCTION___12903,
          conf->max_hash_rate);
      fclose(pFile_10);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_11 = fopen((const char *)log_file, "a+");
      if ( pFile_11 )
        fprintf(
          pFile_11,
          "%s:%d:%s: fan_pwm            : %d\n",
          "freq_tuning.c",
          550,
          (const char *)_FUNCTION___12903,
          conf->fan_pwm);
      fclose(pFile_11);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_12 = fopen((const char *)log_file, "a+");
      if ( pFile_12 )
        fprintf(
          pFile_12,
          "%s:%d:%s: serial_level_count : %d\n",
          "freq_tuning.c",
          551,
          (const char *)_FUNCTION___12903,
          conf->serial_level_count);
      fclose(pFile_12);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_13 = fopen((const char *)log_file, "a+");
      if ( pFile_13 )
        fprintf(pFile_13, "%s:%d:%s: \n", "freq_tuning.c", 552, (const char *)_FUNCTION___12903);
      fclose(pFile_13);
    }
  }
}
// 97F50: using guessed type void *off_97F50;

//----- (000145C4) --------------------------------------------------------
int __cdecl freq_tuning_get_work_for_one_core(FILE **fp, int asic, int core, int count)
{
  uint32_t v5; // r0
  unsigned __int8 str[1024]; // [sp+14h] [bp-410h] BYREF
  freq_tuning_work *new_work; // [sp+414h] [bp-10h]
  unsigned __int8 *temp; // [sp+418h] [bp-Ch]
  uint32_t subid; // [sp+41Ch] [bp-8h]

  memset(str, 0, sizeof(str));
  subid = 0;
  do
  {
    if ( !fgets((char *)str, 1023, *fp) )
      break;
    if ( subid < count )
    {
      new_work = &g_works[asic][count * core + subid];
      temp = (unsigned __int8 *)strstr((const char *)str, "nonce");
      if ( !temp )
        return subid;
      for ( temp += 5; *temp == 32; ++temp )
        ;
      s2hex((unsigned __int8 *)&new_work->nonce, temp, 8);
      v5 = htonl(new_work->nonce);
      new_work->nonce = v5;
      temp = (unsigned __int8 *)strstr((const char *)str, "midstate");
      if ( !temp )
        return subid;
      for ( temp += 8; *temp == 32; ++temp )
        ;
      s2hex(new_work->midstate, temp, 64);
      temp = (unsigned __int8 *)strstr((const char *)str, "data");
      if ( !temp )
        return subid;
      for ( temp += 4; *temp == 32; ++temp )
        ;
      s2hex(new_work->data, temp, 24);
      new_work->id = subid++;
    }
  }
  while ( subid < count );
  return subid;
}

//----- (00014840) --------------------------------------------------------
int freq_tuning_prepare_works()
{
  int work_for_one_core; // r0
  FILE *fp; // [sp+14h] [bp-20h] BYREF
  FILE *pFile; // [sp+18h] [bp-1Ch]
  FILE *pFile_0; // [sp+1Ch] [bp-18h]
  int ret; // [sp+20h] [bp-14h]
  int core; // [sp+24h] [bp-10h]
  int asic; // [sp+28h] [bp-Ch]
  int work_count_for_asic; // [sp+2Ch] [bp-8h]

  ret = 0;
  fp = fopen((const char *)g_BHB91602_proj.test_pattern, "r");
  if ( fp )
  {
    for ( asic = 0; asic <= 47; ++asic )
    {
      work_count_for_asic = 0;
      for ( core = 0; core < 672; ++core )
      {
        work_for_one_core = freq_tuning_get_work_for_one_core(&fp, asic, core, 1);
        work_count_for_asic += work_for_one_core;
      }
      if ( work_count_for_asic < 672 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: No enough work for freq tuning. ASIC %d, work %d, required work %d\n",
              "freq_tuning.c",
              627,
              (const char *)_FUNCTION___12952,
              asic,
              work_count_for_asic,
              672);
          fclose(pFile_0);
        }
        ret = -1;
        break;
      }
    }
    fclose(fp);
    return ret;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Fail to open test pattern file %s.\n",
          "freq_tuning.c",
          611,
          (const char *)_FUNCTION___12952,
          (const char *)g_BHB91602_proj.test_pattern);
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00014A6C) --------------------------------------------------------
void freq_tuning_reset_global_arg()
{
  memset(asic_nonce_num, 0, sizeof(asic_nonce_num));
  memset(asic_core_nonce_num, 0, sizeof(asic_core_nonce_num));
  memset(repeated_nonce_num, 0, sizeof(repeated_nonce_num));
  memset(valid_nonce_num, 0, sizeof(valid_nonce_num));
  memset(send_work_num, 0, sizeof(send_work_num));
  memset(g_pattern_status, 0, sizeof(g_pattern_status));
  memset(extra_nonce_num, 0, sizeof(extra_nonce_num));
  memset(crc_err_nonce_num, 0, sizeof(crc_err_nonce_num));
  memset(invalid_nonce_num, 0, sizeof(invalid_nonce_num));
  memset(err_nonce_num, 0, sizeof(err_nonce_num));
  memset(chain_hw_num, 0, sizeof(chain_hw_num));
  memset(g_work_for_hw_check, 0, sizeof(g_work_for_hw_check));
  chain_invalid_num = 0;
  asic_invalid_num = 0;
  nonce_recv_num_all = 0LL;
}

//----- (00014BB4) --------------------------------------------------------
void __cdecl freq_tuning_env_init(bool is_need_read_temp, freq_tuning_info *freq_info)
{
  float v2; // s0
  double v3; // r0
  int dhash_acc_control; // r0
  float v5; // r0
  int v6; // r0
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  set_QN_write_data_command(0x8080800F);
  sleep(2u);
  set_pwm(0x50u);
  set_Hardware_version(0x40000000u);
  dev->baud = 115200;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  check_chain();
  eeprom_load();
  dump_pcb_bom_version();
  init_pic();
  power_init();
  power_on();
  power_off_hash_board(All_Chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Enter %ds sleep to make sure power release finish.\n",
        "freq_tuning.c",
        686,
        (const char *)_FUNCTION___12968,
        30);
    fclose(pFile);
  }
  LODWORD(v3) = sleep(0x1Eu);
  if ( is_need_read_temp )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Enter 5 minute sleep to cool down hash board, waiting...\n",
          "freq_tuning.c",
          691,
          (const char *)_FUNCTION___12968);
      fclose(pFile_0);
    }
    LODWORD(v3) = sleep(0x12Cu);
  }
  set_iic_power_to_highest_voltage(v3);
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF701F | 0x8100);
  }
  cgsleep_ms(10);
  dev->corenum = 672;
  hash_board_power_on_with_reset();
  check_asic_number();
  if ( is_need_read_temp )
  {
    cgsleep_ms(10);
    software_set_address();
    cgsleep_ms(10);
    do_calibration_temperature_sensor();
    temp_get_environment_temp();
    g_env_temp = v2;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: environment temperature: %.2f\n",
          "freq_tuning.c",
          732,
          (const char *)_FUNCTION___12968,
          g_env_temp);
      fclose(pFile_1);
    }
  }
  cgsleep_ms(10);
  software_set_address();
  cgsleep_ms(10);
  set_pll(v5);
  v6 = 0x1000000 / calculate_core_number(dev->corenum);
  dev->timeout = (unsigned int)(float)((float)((float)((float)(dev->addrInterval * v6) / init_freq) * 50.0) / 100.0);
  if ( dev->timeout >= 0x20000 )
    dev->timeout = 0x1FFFF;
  cgsleep_ms(10);
  init_uart_baud();
  cgsleep_ms(10);
  set_time_out_control(0x8000C350);
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms(10);
  open_core_bm1391(1, All_Chain);
  freq_tuning_pre_test(freq_info);
}
// 14D9C: variable 'v3' is possibly undefined
// 14E30: variable 'v2' is possibly undefined
// 14EF4: variable 'v5' is possibly undefined

//----- (00015024) --------------------------------------------------------
int __cdecl freq_tuning_get_board_test_voltage_and_freq(int level, int *pVoltage, int *pFreq, int sub_proj_index)
{
  FILE *pFile_0; // [sp+28h] [bp-1Ch]
  FILE *pFile; // [sp+2Ch] [bp-18h]
  int freq_step; // [sp+30h] [bp-14h]
  int target_vol; // [sp+34h] [bp-10h]
  int base_freq; // [sp+38h] [bp-Ch]
  int ret; // [sp+3Ch] [bp-8h]

  ret = 0;
  base_freq = g_BHB91602_proj.conf_list[sub_proj_index].base_freq;
  target_vol = g_BHB91602_proj.conf_list[sub_proj_index].base_voltage;
  freq_step = g_BHB91602_proj.conf_list[sub_proj_index].freq_step;
  if ( level > 7 )
  {
    ret = -1;
  }
  else
  {
    *pVoltage = target_vol;
    *pFreq = freq_step * level + base_freq;
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: base_freq = %d, step = %d, base_voltage = %d, max_scan_level = %d\n",
        "freq_tuning.c",
        794,
        (const char *)_FUNCTION___12983,
        base_freq,
        freq_step,
        target_vol,
        8);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: level = %d, voltage = %d, freq = %d\n",
        "freq_tuning.c",
        795,
        (const char *)_FUNCTION___12983,
        level,
        *pVoltage,
        *pFreq);
    fclose(pFile_0);
  }
  return ret;
}

//----- (00015254) --------------------------------------------------------
bool __cdecl freq_tuning_get_next_test_voltage_and_freq(
        freq_tuning_info *freq_info,
        bool reset_test_level,
        int sub_proj_index)
{
  int v3; // r0
  int test_freq; // [sp+14h] [bp-10h] BYREF
  int test_voltage; // [sp+18h] [bp-Ch] BYREF
  int chain; // [sp+1Ch] [bp-8h]

  test_voltage = 0;
  test_freq = 0;
  if ( reset_test_level )
    test_level_12990 = 0;
  v3 = test_level_12990++;
  if ( freq_tuning_get_board_test_voltage_and_freq(v3, &test_voltage, &test_freq, sub_proj_index) == -1 )
    return 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      freq_info->vol_value_table[chain] = test_voltage;
      freq_info->scan_freq[chain] = test_freq;
    }
  }
  return 1;
}

//----- (00015360) --------------------------------------------------------
void __cdecl freq_tuning_set_vol_all_chain(int sub_proj_index)
{
  double v1; // d0
  double v2; // r0
  int v3; // s15
  int v4; // r3

  get_current_voltage();
  v3 = (int)((double)g_BHB91602_proj.conf_list[sub_proj_index].base_voltage - v1 * 100.0);
  v4 = v3;
  if ( v3 < 0 )
    v4 = -v3;
  if ( v4 > 1 )
  {
    HIDWORD(v2) = 44;
    set_working_voltage(v2);
    slowly_set_iic_power_to_working_voltage();
  }
}
// 153A8: variable 'v1' is possibly undefined
// 153FC: variable 'v2' is possibly undefined

//----- (00015418) --------------------------------------------------------
void __cdecl freq_tuning_set_freq_all_chain(const freq_tuning_info *freq_info)
{
  float v1; // r1
  int chain; // [sp+Ch] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      increase_freq_slowly(COERCE_FLOAT(All_Chain), v1, *(float *)&freq_info, All_Chain);
      g_init_freq = freq_info->scan_freq[chain];
      return;
    }
  }
}
// 154A8: variable 'v1' is possibly undefined

//----- (000154F8) --------------------------------------------------------
void __cdecl freq_tuning_set_time_control_by_freq(int freq)
{
  set_timeout(freq, 65);
}

//----- (00015520) --------------------------------------------------------
int __cdecl freq_tuning_get_min_freq(freq_tuning_info *freq_info)
{
  int chain; // [sp+8h] [bp-Ch]
  int min_freq; // [sp+Ch] [bp-8h]

  min_freq = 0xFFFF;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && min_freq > freq_info->scan_freq[chain] )
      min_freq = freq_info->scan_freq[chain];
  }
  return min_freq;
}

//----- (000155C8) --------------------------------------------------------
void *__cdecl freq_tuning_send_work_one_chain(void *args)
{
  int v1; // r1
  int v2; // r2
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int diff; // [sp+18h] [bp-BCh]
  timeval end; // [sp+20h] [bp-B4h] BYREF
  timeval start; // [sp+28h] [bp-ACh] BYREF
  uint32_t buf_vil[13]; // [sp+30h] [bp-A4h] BYREF
  vil_work_1387 work_vil_1387; // [sp+64h] [bp-70h] BYREF
  FILE *pFile; // [sp+98h] [bp-3Ch]
  freq_tuning_work *work_for_pattern; // [sp+9Ch] [bp-38h]
  uint32_t work_fifo_ready; // [sp+A0h] [bp-34h]
  freq_tuning_work *works_for_asic; // [sp+A4h] [bp-30h]
  FILE *pFile_1; // [sp+A8h] [bp-2Ch]
  FILE *pFile_0; // [sp+ACh] [bp-28h]
  int chain; // [sp+B0h] [bp-24h]
  send_work_parameter *param; // [sp+B4h] [bp-20h]
  int sleep_count; // [sp+B8h] [bp-1Ch]
  int j; // [sp+BCh] [bp-18h]
  uint32_t work_id; // [sp+C0h] [bp-14h]
  int pattern; // [sp+C4h] [bp-10h]
  int core; // [sp+C8h] [bp-Ch]
  int asic; // [sp+CCh] [bp-8h]

  memset(buf_vil, 0, sizeof(buf_vil));
  work_id = 0;
  sleep_count = 0;
  param = (send_work_parameter *)args;
  if ( *((_DWORD *)args + 1) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Send work for chain %d already done.\n",
          "freq_tuning.c",
          901,
          (const char *)_FUNCTION___13041,
          param->chain);
      fclose(pFile);
    }
  }
  else
  {
    cgtime(&start);
    chain = param->chain;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Frequency tuning: send work for chain %d\n",
          "freq_tuning.c",
          909,
          (const char *)_FUNCTION___13041,
          chain);
      fclose(pFile_0);
    }
    for ( asic = 0; asic <= 47; ++asic )
    {
      works_for_asic = g_works[asic];
      for ( core = 0; core < 672; ++core )
      {
        for ( pattern = 0; pattern <= 0; ++pattern )
        {
          while ( 1 )
          {
            work_fifo_ready = get_buffer_space();
            if ( (work_fifo_ready & (1 << chain)) != 0 )
              break;
            usleep(0x3E8u);
            ++sleep_count;
          }
          memset(buf_vil, 0, sizeof(buf_vil));
          work_for_pattern = &works_for_asic[core + pattern];
          memset(&work_vil_1387, 0, sizeof(work_vil_1387));
          work_vil_1387.work_type = 1;
          work_vil_1387.chain_id = ~((unsigned int)~((char)chain << 25) >> 25);
          work_vil_1387.work_count = work_id & 0x7F | (pattern << 7);
          v1 = *(_DWORD *)&work_for_pattern->data[4];
          v2 = *(_DWORD *)&work_for_pattern->data[8];
          *(_DWORD *)work_vil_1387.data = *(_DWORD *)work_for_pattern->data;
          *(_DWORD *)&work_vil_1387.data[4] = v1;
          *(_DWORD *)&work_vil_1387.data[8] = v2;
          v3 = *(_DWORD *)&work_for_pattern->midstate[4];
          v4 = *(_DWORD *)&work_for_pattern->midstate[8];
          v5 = *(_DWORD *)&work_for_pattern->midstate[12];
          *(_DWORD *)work_vil_1387.midstate = *(_DWORD *)work_for_pattern->midstate;
          *(_DWORD *)&work_vil_1387.midstate[4] = v3;
          *(_DWORD *)&work_vil_1387.midstate[8] = v4;
          *(_DWORD *)&work_vil_1387.midstate[12] = v5;
          v6 = *(_DWORD *)&work_for_pattern->midstate[20];
          v7 = *(_DWORD *)&work_for_pattern->midstate[24];
          v8 = *(_DWORD *)&work_for_pattern->midstate[28];
          *(_DWORD *)&work_vil_1387.midstate[16] = *(_DWORD *)&work_for_pattern->midstate[16];
          *(_DWORD *)&work_vil_1387.midstate[20] = v6;
          *(_DWORD *)&work_vil_1387.midstate[24] = v7;
          *(_DWORD *)&work_vil_1387.midstate[28] = v8;
          buf_vil[0] = ((unsigned __int8)~((unsigned int)~((char)chain << 25) >> 25) << 16) | 0x1000000 | (work_vil_1387.reserved1[0] << 8) | work_vil_1387.reserved1[1];
          buf_vil[1] = work_vil_1387.work_count;
          for ( j = 2; (unsigned int)j <= 4; ++j )
            buf_vil[j] = (*(&work_vil_1387.work_type + 4 * j) << 24) | (work_vil_1387.reserved1[4 * j - 1] << 16) | (work_vil_1387.reserved1[4 * j] << 8) | work_vil_1387.reserved1[4 * j + 1];
          for ( j = 5; (unsigned int)j <= 0xC; ++j )
            buf_vil[j] = (*(&work_vil_1387.work_type + 4 * j) << 24) | (work_vil_1387.reserved1[4 * j - 1] << 16) | (work_vil_1387.reserved1[4 * j] << 8) | work_vil_1387.reserved1[4 * j + 1];
          set_TW_write_command_vil(buf_vil);
          ++send_work_num[chain];
          memcpy(
            &g_work_for_hw_check[chain][work_id++],
            work_for_pattern,
            sizeof(g_work_for_hw_check[chain][work_id++]));
          if ( work_id > 0x7F )
            work_id = 0;
        }
      }
    }
    param->done = 1;
    cgtime(&end);
    diff = end.tv_sec - start.tv_sec;
    if ( end.tv_usec - start.tv_usec < 0 )
      --diff;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: Frequency tuning: send work for chain %d done, time cost %lds, sleep_count = %d\n",
          "freq_tuning.c",
          982,
          (const char *)_FUNCTION___13041,
          chain,
          diff,
          sleep_count);
      fclose(pFile_1);
    }
  }
  return 0;
}

//----- (00015C54) --------------------------------------------------------
void __cdecl freq_tuning_send_work(freq_tuning_info *freq_info)
{
  send_work_parameter param[16]; // [sp+10h] [bp-F4h] BYREF
  pthread_t thread_id[16]; // [sp+90h] [bp-74h] BYREF
  timeval diff; // [sp+D0h] [bp-34h]
  timeval end; // [sp+D8h] [bp-2Ch] BYREF
  timeval start; // [sp+E0h] [bp-24h] BYREF
  FILE *pFile_0; // [sp+E8h] [bp-1Ch]
  FILE *pFile; // [sp+ECh] [bp-18h]
  int chain_count; // [sp+F0h] [bp-14h]
  int done_count; // [sp+F4h] [bp-10h]
  int waiting; // [sp+F8h] [bp-Ch]
  int chain; // [sp+FCh] [bp-8h]

  waiting = 1;
  done_count = 0;
  chain_count = 0;
  cgtime(&start);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Frequency tuning: send work start.\n",
        "freq_tuning.c",
        996,
        (const char *)_FUNCTION___13074);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    thread_id[chain] = 0;
    if ( dev->chain_exist[chain] && !freq_info->test_done[chain] && !freq_info->fake_done[chain] )
    {
      ++chain_count;
      param[chain].chain = chain;
      param[chain].done = 0;
      pthread_create(&thread_id[chain], 0, (void *(*)(void *))freq_tuning_send_work_one_chain, &param[chain]);
      pthread_detach(thread_id[chain]);
    }
  }
  while ( waiting )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( thread_id[chain] && param[chain].done )
      {
        ++done_count;
        thread_id[chain] = 0;
      }
    }
    if ( done_count == chain_count )
      waiting = 0;
    else
      sleep(1u);
  }
  cgtime(&end);
  diff.tv_sec = end.tv_sec - start.tv_sec;
  diff.tv_usec = end.tv_usec - start.tv_usec;
  if ( end.tv_usec - start.tv_usec < 0 )
  {
    --diff.tv_sec;
    diff.tv_usec += 1000000;
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: Frequency tuning: send work done, time cost %lds\n",
        "freq_tuning.c",
        1046,
        (const char *)_FUNCTION___13074,
        diff.tv_sec);
    fclose(pFile_0);
  }
}

//----- (00015FE0) --------------------------------------------------------
void freq_tuning_get_domain_nonce_statistics()
{
  int core; // [sp+Ch] [bp-10h]
  int asic; // [sp+10h] [bp-Ch]
  int chain; // [sp+14h] [bp-8h]

  memset(domain_nonce_num, 0, sizeof(domain_nonce_num));
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( asic = 0; asic <= 47; ++asic )
      {
        for ( core = 0; core < 672; ++core )
          domain_nonce_num[chain][asic / 4][core / 84] += asic_core_nonce_num[0][(chain << 7) + asic][core];
      }
    }
  }
}

//----- (00016188) --------------------------------------------------------
bool freq_tuning_check_domain_unbalance()
{
  FILE *pFile_0; // [sp+1Ch] [bp-28h]
  unsigned int nonce_unbalance_threshold; // [sp+20h] [bp-24h]
  FILE *pFile; // [sp+28h] [bp-1Ch]
  bool is_unbalance_happened; // [sp+2Fh] [bp-15h]
  uint32_t chain_nonce_total; // [sp+30h] [bp-14h]
  int core_domain; // [sp+34h] [bp-10h]
  int core_domaina; // [sp+34h] [bp-10h]
  int domain; // [sp+38h] [bp-Ch]
  int domaina; // [sp+38h] [bp-Ch]
  int chain; // [sp+3Ch] [bp-8h]

  is_unbalance_happened = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Check domain unbalance.\n", "freq_tuning.c", 1081, (const char *)_FUNCTION___13115);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      chain_nonce_total = 0;
      for ( domain = 0; domain <= 11; ++domain )
      {
        for ( core_domain = 0; core_domain <= 3; ++core_domain )
          chain_nonce_total += domain_nonce_num[chain][domain][core_domain];
      }
      nonce_unbalance_threshold = chain_nonce_total / 0x60;
      for ( domaina = 0; domaina <= 11; ++domaina )
      {
        for ( core_domaina = 0; core_domaina <= 3; ++core_domaina )
        {
          if ( nonce_unbalance_threshold >= domain_nonce_num[chain][domaina][core_domaina] )
          {
            is_unbalance_happened = 1;
            g_chain_unbalance[chain] = 1;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile_0 = fopen((const char *)log_file, "a+");
              if ( pFile_0 )
                fprintf(
                  pFile_0,
                  "%s:%d:%s: chain[%d] domain[%d] core_domain[%d] unbalance: domain_nonce_num(%d) <= unbalance_threshold(%u)\n",
                  "freq_tuning.c",
                  1111,
                  (const char *)_FUNCTION___13115,
                  chain,
                  domaina,
                  core_domaina,
                  domain_nonce_num[chain][domaina][core_domaina],
                  nonce_unbalance_threshold);
              fclose(pFile_0);
            }
          }
        }
      }
    }
  }
  return is_unbalance_happened;
}

//----- (000164E0) --------------------------------------------------------
void __cdecl freq_tuning_wait_recv_nonce(freq_tuning_info *freq_info)
{
  unsigned int crc_count; // r0
  FILE *pFile; // [sp+14h] [bp-10h]
  int wait_count; // [sp+18h] [bp-Ch]
  int chain; // [sp+1Ch] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !freq_info->test_done[chain] && !freq_info->fake_done[chain] )
    {
      for ( wait_count = 0; wait_count <= 3 && valid_nonce_num[chain] < chain_ValidNonce[chain]; ++wait_count )
        usleep(0x186A0u);
    }
  }
  freq_tuning_get_domain_nonce_statistics();
  freq_tuning_parameter_dump(freq_info);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      crc_count = get_crc_count();
      fprintf(
        pFile,
        "%s:%d:%s: ++++ CRC ERROR = %d\n",
        "freq_tuning.c",
        1141,
        (const char *)_FUNCTION___13146,
        crc_count);
    }
    fclose(pFile);
  }
}

//----- (00016680) --------------------------------------------------------
int __cdecl freq_tuning_get_scan_level_index(freq_tuning_info *freq_info, int freq)
{
  int scan_level_index; // [sp+Ch] [bp-8h]

  for ( scan_level_index = 0; scan_level_index <= 7; ++scan_level_index )
  {
    if ( freq == freq_info->scan_level_table[scan_level_index] )
      return scan_level_index;
    if ( !freq_info->scan_level_table[scan_level_index] )
    {
      freq_info->scan_level_table[scan_level_index] = freq;
      return scan_level_index;
    }
  }
  freq_info->scan_level_table[0] = freq;
  return 0;
}

//----- (0001674C) --------------------------------------------------------
void __cdecl freq_tuning_init_chip_rate_table(freq_tuning_info *freq_info, int *recv_nonce_num_table, int chain)
{
  int scan_level_index; // [sp+10h] [bp-Ch]
  int asic; // [sp+14h] [bp-8h]

  scan_level_index = freq_tuning_get_scan_level_index(freq_info, freq_info->scan_freq[chain]);
  for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
    freq_info->chip_rate_table[0][8 * chain + scan_level_index][asic] = recv_nonce_num_table[asic]
                                                                      * freq_info->scan_freq[chain];
}

//----- (00016818) --------------------------------------------------------
void __cdecl freq_tuning_send_work_and_check_result_all_chain(freq_tuning_info *freq_info)
{
  int nonce_fifo_interrupt; // r0
  int chain; // [sp+14h] [bp-8h]
  int chaina; // [sp+14h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !freq_info->test_done[chain] && !freq_info->fake_done[chain] )
      chain_ValidNonce[chain] = 32256;
  }
  if ( !gBegin_get_nonce )
  {
    nonce_fifo_interrupt = get_nonce_fifo_interrupt();
    set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
    gBegin_get_nonce = 1;
  }
  freq_tuning_send_work(freq_info);
  freq_tuning_wait_recv_nonce(freq_info);
  gBegin_get_nonce = 0;
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina] )
    {
      if ( !freq_info->test_done[chaina] && !freq_info->fake_done[chaina] )
      {
        freq_tuning_init_chip_rate_table(freq_info, asic_nonce_num[chaina], chaina);
        if ( (int)((double)chain_ValidNonce[chaina] * 0.98) > valid_nonce_num[chaina]
          || (int)((double)chain_ValidNonce[chaina] * 0.0003) < chain_hw_num[chaina] )
        {
          freq_info->test_done[chaina] = 1;
        }
      }
    }
  }
}

//----- (00016AA0) --------------------------------------------------------
int __cdecl freq_tuning_check_hw(freq_tuning_work *work, uint32_t nonce)
{
  sha2_context ctx; // [sp+8h] [bp-134h] BYREF
  uint32_t nonce_temp; // [sp+F0h] [bp-4Ch]
  uint8_t hash2[32]; // [sp+F4h] [bp-48h] BYREF
  uint8_t hash1[32]; // [sp+114h] [bp-28h] BYREF
  uint32_t *hash2_32; // [sp+134h] [bp-8h]

  memset(hash1, 0, sizeof(hash1));
  memset(hash2, 0, sizeof(hash2));
  hash2_32 = (uint32_t *)hash1;
  nonce_temp = HIBYTE(nonce) | (nonce >> 8) & 0xFF00 | (nonce << 8) & 0xFF0000 | (nonce << 24);
  if ( !work )
    return 0;
  memcpy(ctx.state, work->midstate, sizeof(ctx.state));
  rev((unsigned __int8 *)ctx.state, 0x20u);
  ctx.total[0] = 80;
  ctx.total[1] = 0;
  memcpy(hash1, work->data, 0xCu);
  rev(hash1, 0xCu);
  flip_swab(ctx.buffer, hash1, 0xCu);
  *(_DWORD *)hash1 = nonce_temp;
  rev(hash1, 4u);
  flip_swab(&ctx.buffer[12], hash1, 4u);
  sha2_finish(&ctx, hash1);
  memset(&ctx, 0, sizeof(ctx));
  sha2(hash1, 32, hash2);
  flip32(hash1, hash2);
  return hash2_32[7] != 0;
}

//----- (00016C60) --------------------------------------------------------
void *__cdecl __noreturn freq_tuning_recv_nonce_and_register(void *arg)
{
  __int16 nonce_number_in_fifo; // r0
  nonce_format_t nonce; // [sp+Ch] [bp-40h]
  uint32_t buf[2]; // [sp+10h] [bp-3Ch] BYREF
  uint32_t target_nonce; // [sp+18h] [bp-34h]
  freq_tuning_work *work; // [sp+1Ch] [bp-30h]
  int core; // [sp+20h] [bp-2Ch]
  int asic; // [sp+24h] [bp-28h]
  int pattern; // [sp+28h] [bp-24h]
  uint32_t work_id; // [sp+2Ch] [bp-20h]
  uint32_t nonce_num; // [sp+30h] [bp-1Ch]
  freq_tuning_info *freq_info; // [sp+34h] [bp-18h]
  int chain; // [sp+38h] [bp-14h]
  uint32_t loop; // [sp+3Ch] [bp-10h]

  freq_info = (freq_tuning_info *)arg;
  while ( 1 )
  {
    do
    {
      usleep(0x3E8u);
      nonce_number_in_fifo = get_nonce_number_in_fifo();
      nonce_num = nonce_number_in_fifo & 0x1FF;
    }
    while ( (nonce_number_in_fifo & 0x1FF) == 0 );
    for ( loop = 0; loop < nonce_num; ++loop )
    {
      get_return_nonce(buf);
      if ( (buf[0] & 0x80000000) == 0 )
      {
        if ( reg_value_buf.reg_value_num <= 0x1FE && reg_value_buf.p_wr <= 0x1FE )
        {
          pthread_mutex_lock(&reg_mutex);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = buf[1];
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = HIBYTE(buf[0]) & 0x1F;
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].chip_address = BYTE2(buf[0]);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_address = BYTE1(buf[0]);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = buf[0] & 0xF;
          if ( reg_value_buf.p_wr > 0x1FD )
            reg_value_buf.p_wr = 0;
          else
            ++reg_value_buf.p_wr;
          if ( reg_value_buf.reg_value_num > 0x1FE )
            reg_value_buf.reg_value_num = 511;
          else
            ++reg_value_buf.reg_value_num;
          pthread_mutex_unlock(&reg_mutex);
        }
        else
        {
          clear_register_value_buf();
        }
      }
      else if ( gBegin_get_nonce )
      {
        if ( (buf[0] & 0x80) == 0 || (buf[0] & 0x40) != 0 || (buf[0] & 0x20) != 0 )
        {
          if ( (buf[0] & 0x40) != 0 )
            ++crc_err_nonce_num[chain];
          if ( (buf[0] & 0x20) != 0 )
            ++err_nonce_num[chain];
          if ( (buf[0] & 0x80) != 0 )
            ++invalid_nonce_num[chain];
          ++extra_nonce_num[chain];
        }
        else
        {
          ++nonce_recv_num_all;
          chain = buf[0] & 0xF;
          if ( (unsigned int)chain <= 0xF && dev->chain_exist[chain] && !freq_info->test_done[chain] )
          {
            pattern = (unsigned __int16)(HIWORD(buf[0]) & 0x7FFF) >> 7;
            work_id = BYTE2(buf[0]) & 0x7F;
            nonce.u = ($3B6C5DB24DEFE61227BB8ADDA81064A9)buf[1];
            asic = get_asic_id((nonce_format_t)buf[1]);
            core = get_core_id(nonce);
            if ( asic <= 47 )
            {
              if ( pattern <= 0 )
              {
                work = &g_works[asic][core + pattern];
                target_nonce = work->nonce;
                if ( target_nonce == nonce.v )
                {
                  if ( (((int)g_pattern_status[chain][asic][core] >> pattern) & 1) != 0 )
                  {
                    ++repeated_nonce_num[chain];
                  }
                  else
                  {
                    g_pattern_status[chain][asic][core] |= 1 << pattern;
                    ++asic_nonce_num[chain][asic];
                    ++valid_nonce_num[chain];
                    ++asic_core_nonce_num[0][(chain << 7) + asic][core];
                  }
                }
                else
                {
                  if ( freq_tuning_check_hw(&g_work_for_hw_check[chain][work_id], buf[1]) )
                    ++chain_hw_num[chain];
                  ++extra_nonce_num[chain];
                }
              }
              else
              {
                ++extra_nonce_num[chain];
              }
            }
            else
            {
              ++asic_invalid_num;
            }
          }
          else
          {
            ++chain_invalid_num;
          }
        }
      }
    }
  }
}

//----- (000173D4) --------------------------------------------------------
bool __cdecl freq_tuning_check_if_test_done(freq_tuning_info *freq_info)
{
  int chain; // [sp+Ch] [bp-10h]
  int chain_num; // [sp+10h] [bp-Ch]
  int done_num; // [sp+14h] [bp-8h]

  done_num = 0;
  chain_num = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      ++chain_num;
      if ( freq_info->test_done[chain] )
        ++done_num;
    }
  }
  return done_num == chain_num;
}

//----- (000174A0) --------------------------------------------------------
void __cdecl freq_tuning_calc_sum_of_all_freq(const freq_tuning_info *freq_info, int *sum, int chain)
{
  int scan_level; // [sp+10h] [bp-Ch]
  int asic; // [sp+14h] [bp-8h]

  for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
  {
    sum[asic] = 0;
    for ( scan_level = 0; scan_level <= 7; ++scan_level )
      sum[asic] += freq_info->chip_rate_table[0][8 * chain + scan_level][asic];
  }
}

//----- (00017588) --------------------------------------------------------
void __cdecl freq_tuning_sort_array(int *src, int *rate, unsigned int len)
{
  int index_of_max; // [sp+18h] [bp-14h]
  int max; // [sp+1Ch] [bp-10h]
  unsigned int j; // [sp+20h] [bp-Ch]
  unsigned int i; // [sp+24h] [bp-8h]
  unsigned int ia; // [sp+24h] [bp-8h]

  for ( i = 0; len > i; ++i )
    rate[i] = 0;
  for ( ia = 0; len > ia; ++ia )
  {
    max = 0x80000000;
    index_of_max = 0x80000000;
    for ( j = 0; len > j; ++j )
    {
      if ( !rate[j] && max < src[j] )
      {
        max = src[j];
        index_of_max = j;
      }
    }
    rate[index_of_max] = ia + 1;
  }
}

//----- (000176D0) --------------------------------------------------------
void __cdecl freq_tuning_set_asic_quality_per_domain(freq_tuning_info *freq_info, int chain)
{
  FILE *pFile; // [sp+Ch] [bp-10h]
  int *sum; // [sp+10h] [bp-Ch]
  int asic; // [sp+14h] [bp-8h]

  sum = (int *)malloc(4 * freq_info->asic_num_per_chain);
  if ( !sum )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "Assert fail!! %s:%d: Fail to alloc memory for asic quality.\n", "freq_tuning.c", 1480);
    fclose(pFile);
    _assert_fail("sum", "freq_tuning.c", 0x5C8u, (const char *)_PRETTY_FUNCTION___13257);
  }
  freq_tuning_calc_sum_of_all_freq(freq_info, sum, chain);
  for ( asic = 0; asic < freq_info->asic_num_per_chain; asic += freq_info->asic_num_per_vol_domain )
    freq_tuning_sort_array(
      &sum[asic],
      &freq_info->asic_quality_per_vol_domain[chain][asic],
      freq_info->asic_num_per_vol_domain);
  free(sum);
}
// 1777C: conditional instruction was optimized away because %sum.4==0

//----- (00017840) --------------------------------------------------------
int __cdecl freq_tuning_get_max_index(int *array, unsigned int len)
{
  unsigned int i; // [sp+Ch] [bp-10h]
  int max_index; // [sp+10h] [bp-Ch]
  int max; // [sp+14h] [bp-8h]

  max = *array;
  max_index = 0;
  for ( i = 0; len > i; ++i )
  {
    if ( max < array[i] )
    {
      max = array[i];
      max_index = i;
    }
  }
  return max_index;
}

//----- (000178EC) --------------------------------------------------------
void __cdecl freq_tuning_set_freq_table(freq_tuning_info *freq_info, int chain)
{
  int sum[8]; // [sp+8h] [bp-3Ch] BYREF
  FILE *pFile; // [sp+28h] [bp-1Ch]
  int *best_freq_of_asic_quality; // [sp+2Ch] [bp-18h]
  int max_index; // [sp+30h] [bp-14h]
  int asic; // [sp+34h] [bp-10h]
  int scan_level; // [sp+38h] [bp-Ch]
  int col; // [sp+3Ch] [bp-8h]

  memset(sum, 0, sizeof(sum));
  max_index = 0;
  best_freq_of_asic_quality = (int *)malloc(4 * freq_info->asic_num_per_vol_domain);
  if ( !best_freq_of_asic_quality )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "Assert fail!! %s:%d: Fail to alloc memory for best freq table.\n", "freq_tuning.c", 1518);
    fclose(pFile);
    if ( !best_freq_of_asic_quality )
      _assert_fail("best_freq_of_asic_quality", "freq_tuning.c", 0x5EEu, (const char *)_PRETTY_FUNCTION___13283);
  }
  for ( col = 0; col < freq_info->asic_num_per_vol_domain; ++col )
  {
    memset(sum, 0, sizeof(sum));
    for ( scan_level = 0; scan_level <= 7; ++scan_level )
    {
      for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
      {
        if ( freq_info->asic_quality_per_vol_domain[chain][asic] == col + 1 )
          sum[scan_level] += freq_info->chip_rate_table[0][8 * chain + scan_level][asic];
      }
    }
    max_index = freq_tuning_get_max_index(sum, 8u);
    best_freq_of_asic_quality[col] = freq_info->scan_level_table[max_index];
  }
  for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
    freq_info->freq_table[chain][asic] = best_freq_of_asic_quality[freq_info->asic_quality_per_vol_domain[chain][asic]
                                                                 - 1];
  free(best_freq_of_asic_quality);
}

//----- (00017BC0) --------------------------------------------------------
void __cdecl freq_tuning_print_chip_rate_table(freq_tuning_info *freq_info)
{
  FILE *pFile_2; // [sp+10h] [bp-34h]
  FILE *pFile_7; // [sp+14h] [bp-30h]
  FILE *pFile_5; // [sp+18h] [bp-2Ch]
  FILE *pFile_6; // [sp+1Ch] [bp-28h]
  FILE *pFile_4; // [sp+20h] [bp-24h]
  FILE *pFile_3; // [sp+24h] [bp-20h]
  FILE *pFile_1; // [sp+28h] [bp-1Ch]
  FILE *pFile_0; // [sp+2Ch] [bp-18h]
  FILE *pFile; // [sp+30h] [bp-14h]
  int scan_level; // [sp+34h] [bp-10h]
  int asic; // [sp+38h] [bp-Ch]
  int asica; // [sp+38h] [bp-Ch]
  int chain; // [sp+3Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: print_chip_rate_table...\n", "freq_tuning.c", 1550, (const char *)_FUNCTION___13303);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "chain[%d]:\n", chain);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fwrite("   ", 1u, 3u, pFile_1);
        fclose(pFile_1);
      }
      for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
      {
        if ( log_level > 3 )
        {
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(pFile_2, " Asic%02d", asic + 1);
          fclose(pFile_2);
        }
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fputc(10, pFile_3);
        fclose(pFile_3);
      }
      for ( scan_level = 0; scan_level <= 7 && freq_info->scan_level_table[scan_level]; ++scan_level )
      {
        if ( log_level > 3 )
        {
          pFile_4 = fopen((const char *)log_file, "a+");
          if ( pFile_4 )
            fprintf(pFile_4, "%03d", freq_info->scan_level_table[scan_level]);
          fclose(pFile_4);
        }
        for ( asica = 0; asica < freq_info->asic_num_per_chain; ++asica )
        {
          if ( log_level > 3 )
          {
            pFile_5 = fopen((const char *)log_file, "a+");
            if ( pFile_5 )
              fprintf(pFile_5, " %7d", freq_info->chip_rate_table[0][8 * chain + scan_level][asica]);
            fclose(pFile_5);
          }
        }
        if ( log_level > 3 )
        {
          pFile_6 = fopen((const char *)log_file, "a+");
          if ( pFile_6 )
            fputc(10, pFile_6);
          fclose(pFile_6);
        }
      }
      if ( log_level > 3 )
      {
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fputc(10, pFile_7);
        fclose(pFile_7);
      }
    }
  }
}

//----- (0001805C) --------------------------------------------------------
void __cdecl freq_tuning_print_freq_table(freq_tuning_info *freq_info)
{
  FILE *pFile_2; // [sp+10h] [bp-24h]
  FILE *pFile_3; // [sp+14h] [bp-20h]
  FILE *pFile_1; // [sp+18h] [bp-1Ch]
  FILE *pFile_4; // [sp+1Ch] [bp-18h]
  FILE *pFile_0; // [sp+20h] [bp-14h]
  FILE *pFile; // [sp+24h] [bp-10h]
  int asic; // [sp+28h] [bp-Ch]
  int chain; // [sp+2Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: print_freq_table...\n", "freq_tuning.c", 1583, (const char *)_FUNCTION___13329);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "chain[%d]:\n", chain);
        fclose(pFile_0);
      }
      for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
      {
        if ( log_level > 3 )
        {
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "Freq%02d=%03d  ", asic, freq_info->freq_table[chain][asic]);
          fclose(pFile_1);
        }
        if ( (asic + 1) % (3 * freq_info->asic_num_per_vol_domain) )
        {
          if ( !((asic + 1) % freq_info->asic_num_per_vol_domain) && log_level > 3 )
          {
            pFile_3 = fopen((const char *)log_file, "a+");
            if ( pFile_3 )
              fwrite("|  ", 1u, 3u, pFile_3);
            fclose(pFile_3);
          }
        }
        else if ( log_level > 3 )
        {
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fputc(10, pFile_2);
          fclose(pFile_2);
        }
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fputc(10, pFile_4);
        fclose(pFile_4);
      }
    }
  }
}

//----- (000183B0) --------------------------------------------------------
void __cdecl freq_tuning_increase_final_freq_slowly(freq_tuning_info *freq_info, int init_freq, int freq_step)
{
  char *v3; // r1
  uint32_t v4; // r2
  uint32_t diff_freq[48]; // [sp+1Ch] [bp-E0h] BYREF
  uint32_t total; // [sp+DCh] [bp-20h] BYREF
  uint32_t max; // [sp+E0h] [bp-1Ch] BYREF
  uint32_t min; // [sp+E4h] [bp-18h] BYREF
  FILE *pFile_0; // [sp+E8h] [bp-14h]
  FILE *pFile; // [sp+ECh] [bp-10h]
  int asic; // [sp+F0h] [bp-Ch]
  int chain; // [sp+F4h] [bp-8h]
  char v15; // [sp+F8h] [bp-4h] BYREF

  min = 0;
  max = 0;
  total = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Increase ideal frequency slowly for chain %d.\n",
            "freq_tuning.c",
            1625,
            (const char *)_FUNCTION___13357,
            chain);
        fclose(pFile);
      }
      min = 0xFFFFFF;
      max = 0;
      total = 0;
      get_statistics_of_asic_freq((uint32_t *)freq_info->freq_table[chain], &min, &max, &total);
      for ( asic = 0; asic <= 47; ++asic )
      {
        v4 = freq_info->freq_table[chain][asic] - min;
        v3 = &v15;
        diff_freq[asic] = v4;
      }
      increase_freq_slowly(COERCE_FLOAT((unsigned __int8)chain), *(float *)&v3, *(float *)&v4, chain);
      if ( min != max )
      {
        increase_asic_diff_freq_slowly_one_chain(diff_freq, min, freq_step, chain);
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: \n\nIncrease frequency to max %dM\n",
              "freq_tuning.c",
              1648,
              (const char *)_FUNCTION___13357,
              max);
          fclose(pFile_0);
        }
      }
    }
  }
}
// 18574: variable 'v3' is possibly undefined
// 18574: variable 'v4' is possibly undefined

//----- (00018658) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl freq_tuning_hash_board_init(freq_tuning_info *freq_info)
{
  float v1; // r0
  freq_tuning_info *freq_infoa; // [sp+4h] [bp-10h]
  int chain; // [sp+Ch] [bp-8h]

  freq_infoa = freq_info;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] && !freq_infoa->test_done[chain] )
    {
      set_reset_hashboard(chain, 1);
      sleep(3u);
      set_reset_hashboard(chain, 0);
      freq_info = (freq_tuning_info *)sleep(3u);
    }
  }
  set_iic_power_to_highest_voltage(*(double *)&freq_info);
  set_baud(115200, 1);
  cgsleep_ms(10);
  init_uart_baud();
  cgsleep_ms(10);
  software_set_address();
  cgsleep_ms(10);
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms(10);
  set_pll(v1);
  set_timeout((int)init_freq, 90);
  open_core_bm1391(1, All_Chain);
}
// 18658: variables would overlap: r0.4 and r0.8

//----- (000187A0) --------------------------------------------------------
void __fastcall freq_tuning_single_pre_test_prepare(double a1)
{
  float v1; // r0
  int chain; // [sp+4h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      set_reset_hashboard(chain, 1);
      sleep(3u);
      set_reset_hashboard(chain, 0);
      LODWORD(a1) = sleep(3u);
    }
  }
  set_iic_power_to_highest_voltage(a1);
  set_baud(115200, 1);
  cgsleep_ms(10);
  balance_domain_voltage();
  init_uart_baud();
  cgsleep_ms(10);
  software_set_address();
  cgsleep_ms(10);
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms(10);
  set_pll(v1);
  set_timeout((int)init_freq, 90);
  open_core_bm1391(1, All_Chain);
}
// 18820: variable 'a1' is possibly undefined
// 18884: variable 'v1' is possibly undefined

//----- (000188C8) --------------------------------------------------------
bool __cdecl freq_tuning_single_pre_test(freq_tuning_info *freq_info)
{
  float v1; // r1
  float v2; // r2
  FILE *pFile; // [sp+10h] [bp-14h]
  FILE *pFile_0; // [sp+14h] [bp-10h]
  freq_tuning_project_conf *p_conf; // [sp+18h] [bp-Ch]
  bool is_pass; // [sp+1Fh] [bp-5h]

  p_conf = g_BHB91602_proj.conf_list;
  is_pass = 0;
  freq_tuning_init_freq_info(freq_info);
  freq_tuning_reset_global_arg();
  freq_tuning_set_vol_all_chain(0);
  increase_freq_slowly(COERCE_FLOAT(All_Chain), v1, v2, All_Chain);
  freq_tuning_set_time_control_by_freq(p_conf->base_freq);
  freq_tuning_send_work_and_check_result_all_chain(freq_info);
  if ( !freq_tuning_check_domain_unbalance() )
  {
    is_pass = 1;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: Pre-test: already balance.\n", "freq_tuning.c", 1768, (const char *)_FUNCTION___13386);
      fclose(pFile);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: Pre-test: unbalance happened.\n",
        "freq_tuning.c",
        1772,
        (const char *)_FUNCTION___13386);
    fclose(pFile_0);
  }
  return is_pass;
}
// 18944: variable 'v1' is possibly undefined
// 18944: variable 'v2' is possibly undefined

//----- (00018AA8) --------------------------------------------------------
void __cdecl freq_tuning_pre_test(freq_tuning_info *freq_info)
{
  double v1; // r0
  FILE *pFile_2; // [sp+18h] [bp-1Ch]
  FILE *pFile_1; // [sp+1Ch] [bp-18h]
  FILE *pFile_0; // [sp+20h] [bp-14h]
  FILE *pFile; // [sp+24h] [bp-10h]
  int trya; // [sp+2Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Pre-test: start.\n", "freq_tuning.c", 1806, (const char *)_FUNCTION___13401);
    fclose(pFile);
  }
  for ( trya = 0; trya < 3; ++trya )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: Pre-test: times %d\n", "freq_tuning.c", 1810, (const char *)_FUNCTION___13401, trya);
      fclose(pFile_0);
    }
    LODWORD(v1) = freq_tuning_single_pre_test(freq_info);
    if ( LODWORD(v1) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: Pre-test: set to init freq %fM.\n",
            "freq_tuning.c",
            1813,
            (const char *)_FUNCTION___13401,
            init_freq);
        LODWORD(v1) = fclose(pFile_1);
      }
      set_pll(*(float *)&v1);
      break;
    }
    freq_tuning_single_pre_test_prepare(v1);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(pFile_2, "%s:%d:%s: Pre-test: done.\n", "freq_tuning.c", 1823, (const char *)_FUNCTION___13401);
    fclose(pFile_2);
  }
}
// 18CAC: variable 'v1' is possibly undefined

//----- (00018D60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl freq_tuning_pre_open_core(freq_tuning_info *freq_info)
{
  int i; // [sp+10h] [bp-Ch]
  int chain; // [sp+14h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      set_reset_hashboard(chain, 1);
      sleep(3u);
      set_reset_hashboard(chain, 0);
      freq_info = (freq_tuning_info *)sleep(3u);
    }
  }
  set_iic_power_to_highest_voltage(*(double *)&freq_info);
  for ( i = 0; i < 2; ++i )
    balance_domain_voltage();
}
// 18D60: variables would overlap: r0.4 and r0.8

//----- (00018E28) --------------------------------------------------------
void __cdecl freq_tuning_get_ideal_hash_rate(freq_tuning_info *freq_info, int sub_proj_index)
{
  int nonce_fifo_interrupt; // r0
  FILE *pFile; // [sp+18h] [bp-2Ch]
  FILE *pFile_0; // [sp+1Ch] [bp-28h]
  int total_hash_rate; // [sp+24h] [bp-20h]
  double hash_rate; // [sp+28h] [bp-1Ch]
  int min_freq; // [sp+34h] [bp-10h]
  int asic; // [sp+38h] [bp-Ch]
  int asica; // [sp+38h] [bp-Ch]
  int chain; // [sp+3Ch] [bp-8h]
  int chaina; // [sp+3Ch] [bp-8h]
  int chainb; // [sp+3Ch] [bp-8h]

  min_freq = 0xFFFF;
  total_hash_rate = 0;
  freq_tuning_reset_global_arg();
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      freq_info->test_done[chain] = 0;
      chain_ValidNonce[chain] = 32256;
    }
  }
  freq_tuning_pre_open_core(freq_info);
  freq_tuning_hash_board_init(freq_info);
  freq_tuning_set_vol_all_chain(sub_proj_index);
  freq_tuning_increase_final_freq_slowly(freq_info, (int)init_freq, (int)freq_step);
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina] )
    {
      for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
      {
        if ( min_freq > freq_info->freq_table[chaina][asic] )
          min_freq = freq_info->freq_table[chaina][asic];
      }
    }
  }
  freq_tuning_set_time_control_by_freq(min_freq);
  if ( !gBegin_get_nonce )
  {
    nonce_fifo_interrupt = get_nonce_fifo_interrupt();
    set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
    gBegin_get_nonce = 1;
  }
  freq_tuning_send_work(freq_info);
  freq_tuning_wait_recv_nonce(freq_info);
  gBegin_get_nonce = 0;
  for ( chainb = 0; chainb <= 15; ++chainb )
  {
    if ( dev->chain_exist[chainb] )
    {
      hash_rate = 0.0;
      for ( asica = 0; asica < freq_info->asic_num_per_chain; ++asica )
        hash_rate = hash_rate + (double)(asic_nonce_num[chainb][asica] * freq_info->freq_table[chainb][asica] / 1000);
      freq_info->ideal_hash_rate[chainb] = (int)hash_rate;
      total_hash_rate += (int)hash_rate;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: CH[%d] ideal_hash_rate = %d\n",
            "freq_tuning.c",
            1964,
            (const char *)_FUNCTION___13458,
            chainb,
            freq_info->ideal_hash_rate[chainb]);
        fclose(pFile);
      }
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: Ideal total hash rate = %d\n",
        "freq_tuning.c",
        1967,
        (const char *)_FUNCTION___13458,
        total_hash_rate);
    fclose(pFile_0);
  }
}

//----- (000192A4) --------------------------------------------------------
int __cdecl freq_tuning_get_hash_rate_MH(freq_tuning_info *freq_info)
{
  int hash_rate; // [sp+Ch] [bp-10h]
  int asic; // [sp+10h] [bp-Ch]
  int chain; // [sp+14h] [bp-8h]

  hash_rate = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
        hash_rate += 672 * freq_info->freq_table[chain][asic];
    }
  }
  return hash_rate;
}

//----- (00019378) --------------------------------------------------------
void __cdecl freq_tuning_adjust_result_for_low_temperature(freq_tuning_info *freq_info, int sub_proj_index)
{
  FILE *pFile; // [sp+20h] [bp-14h]
  int freq_diff; // [sp+24h] [bp-10h]
  int asic; // [sp+28h] [bp-Ch]
  int chain; // [sp+2Ch] [bp-8h]

  freq_diff = 5;
  if ( g_env_temp < 30.0 )
  {
    if ( g_env_temp < 26.6 || g_env_temp >= 30.0 )
    {
      if ( g_env_temp < 23.3 || g_env_temp >= 26.6 )
      {
        if ( g_env_temp < 20.0 || g_env_temp >= 23.3 )
        {
          if ( g_env_temp < 20.0 )
            freq_diff = 5;
        }
        else
        {
          freq_diff = 10;
        }
      }
      else
      {
        freq_diff = 15;
      }
    }
    else
    {
      freq_diff = 20;
    }
  }
  else
  {
    freq_diff = 25;
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: environment_temp = %.2f, decrease_freq = %d\n",
        "freq_tuning.c",
        2048,
        (const char *)_FUNCTION___13502,
        g_env_temp,
        freq_diff);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
        freq_info->freq_table[chain][asic] -= freq_diff;
    }
  }
}

//----- (00019638) --------------------------------------------------------
void __cdecl freq_tuning_adjust_result_according_to_distance_to_air_in(freq_tuning_info *freq_info, int chain)
{
  int logical_column_by_chip_no; // r0
  int v3; // r3
  int column_air_in; // [sp+18h] [bp-Ch]
  int asic; // [sp+1Ch] [bp-8h]

  column_air_in = get_logical_column_by_chip_no(11);
  for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
  {
    logical_column_by_chip_no = get_logical_column_by_chip_no(asic);
    v3 = logical_column_by_chip_no - column_air_in;
    if ( logical_column_by_chip_no - column_air_in < 0 )
      v3 = column_air_in - logical_column_by_chip_no;
    freq_info->freq_table[chain][asic] -= 10 * (v3 / 2);
  }
}

//----- (0001971C) --------------------------------------------------------
void __cdecl freq_tuning_adjust_result_for_poor_heat_dissipation(freq_tuning_info *freq_info, int sub_proj_index)
{
  FILE *pFile_0; // [sp+1Ch] [bp-18h]
  FILE *pFile; // [sp+20h] [bp-14h]
  int asic; // [sp+2Ch] [bp-8h]

  if ( g_BHB91602_proj.proj_type == 1
    && g_BHB91602_proj.conf_list[sub_proj_index].proj_sub_type == 1
    && dev->chain_exist[2] )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Adjust S15 chain %d frequency <=%dM at high hash rate due to its poor heat dissipation.\n",
          "freq_tuning.c",
          2107,
          (const char *)_FUNCTION___13530,
          2,
          380);
      fclose(pFile);
    }
    for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
    {
      if ( freq_info->freq_table[2][asic] > 380 )
        freq_info->freq_table[2][asic] = 380;
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Adjust S15 chain 3 frequency [0M 0M 10M 10M 20M 20M] according to its distance to air in.\n",
          "freq_tuning.c",
          2116,
          (const char *)_FUNCTION___13530);
      fclose(pFile_0);
    }
    freq_tuning_adjust_result_according_to_distance_to_air_in(freq_info, 2);
  }
}

//----- (00019954) --------------------------------------------------------
int __cdecl freq_tuning_adjust_result_according_to_hash_rate(
        freq_tuning_info *freq_info,
        int hash_rate_target_MH,
        bool is_rounding_TH)
{
  FILE *pFile_11; // [sp+20h] [bp-74h]
  FILE *pFile_10; // [sp+24h] [bp-70h]
  FILE *pFile_9; // [sp+28h] [bp-6Ch]
  FILE *pFile_8; // [sp+2Ch] [bp-68h]
  FILE *pFile_7; // [sp+30h] [bp-64h]
  FILE *pFile_6; // [sp+34h] [bp-60h]
  FILE *pFile_5; // [sp+38h] [bp-5Ch]
  FILE *pFile_4; // [sp+3Ch] [bp-58h]
  FILE *pFile_3; // [sp+40h] [bp-54h]
  int freq_diff_steps; // [sp+44h] [bp-50h]
  int hash_rate_steps; // [sp+48h] [bp-4Ch]
  int hash_rate_step_MH; // [sp+4Ch] [bp-48h]
  int freq_store_step; // [sp+50h] [bp-44h]
  FILE *pFile; // [sp+58h] [bp-3Ch]
  FILE *pFile_2; // [sp+5Ch] [bp-38h]
  FILE *pFile_1; // [sp+60h] [bp-34h]
  FILE *pFile_0; // [sp+64h] [bp-30h]
  int hash_rate_stable_MH; // [sp+68h] [bp-2Ch]
  int hash_rate_target_sale_MH; // [sp+6Ch] [bp-28h]
  int hash_rate_curr_MH; // [sp+70h] [bp-24h]
  int freq_diff_steps_extra; // [sp+7Ch] [bp-18h]
  int freq_diff; // [sp+80h] [bp-14h]
  int hash_rate_threshold_MH; // [sp+84h] [bp-10h]
  int asic; // [sp+88h] [bp-Ch]
  int chain; // [sp+8Ch] [bp-8h]

  freq_diff = 0;
  hash_rate_curr_MH = freq_tuning_get_hash_rate_MH(freq_info);
  if ( hash_rate_curr_MH > hash_rate_target_MH )
  {
    hash_rate_threshold_MH = hash_rate_target_MH;
LABEL_25:
    freq_store_step = eeprom_get_freq_store_step();
    hash_rate_step_MH = freq_info->asic_num_per_chain * 672 * freq_store_step;
    hash_rate_steps = (hash_rate_curr_MH - hash_rate_threshold_MH + hash_rate_step_MH - 1) / hash_rate_step_MH;
    freq_diff_steps = hash_rate_steps / dev->chain_num;
    freq_diff_steps_extra = hash_rate_steps % dev->chain_num;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: hash_rate_threshold_MH   = %dMH\n",
          "freq_tuning.c",
          2177,
          (const char *)_FUNCTION___13556,
          hash_rate_threshold_MH);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(
          pFile_4,
          "%s:%d:%s: hash_rate_curr           = %dMH\n",
          "freq_tuning.c",
          2178,
          (const char *)_FUNCTION___13556,
          hash_rate_curr_MH);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(
          pFile_5,
          "%s:%d:%s: hash_rate_diff           = %dMH\n",
          "freq_tuning.c",
          2179,
          (const char *)_FUNCTION___13556,
          hash_rate_curr_MH - hash_rate_threshold_MH);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "%s:%d:%s: hash_rate_step_MH        = %dMH\n",
          "freq_tuning.c",
          2180,
          (const char *)_FUNCTION___13556,
          hash_rate_step_MH);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(
          pFile_7,
          "%s:%d:%s: freq_store_step          = %dM\n",
          "freq_tuning.c",
          2181,
          (const char *)_FUNCTION___13556,
          freq_store_step);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(
          pFile_8,
          "%s:%d:%s: hash_rate_steps          = %d\n",
          "freq_tuning.c",
          2182,
          (const char *)_FUNCTION___13556,
          hash_rate_steps);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(
          pFile_9,
          "%s:%d:%s: freq_diff_steps          = %d\n",
          "freq_tuning.c",
          2183,
          (const char *)_FUNCTION___13556,
          freq_diff_steps);
      fclose(pFile_9);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_10 = fopen((const char *)log_file, "a+");
      if ( pFile_10 )
        fprintf(
          pFile_10,
          "%s:%d:%s: freq_diff_steps_extra    = %d\n",
          "freq_tuning.c",
          2184,
          (const char *)_FUNCTION___13556,
          freq_diff_steps_extra);
      fclose(pFile_10);
    }
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        freq_diff = freq_store_step * freq_diff_steps;
        if ( freq_diff_steps_extra )
        {
          freq_diff += freq_store_step;
          --freq_diff_steps_extra;
        }
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_11 = fopen((const char *)log_file, "a+");
          if ( pFile_11 )
            fprintf(
              pFile_11,
              "%s:%d:%s: Adjust frequency %dM for chain %d.\n",
              "freq_tuning.c",
              2200,
              (const char *)_FUNCTION___13556,
              freq_diff,
              chain);
          fclose(pFile_11);
        }
        for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
          freq_info->freq_table[chain][asic] -= freq_diff;
      }
    }
    return freq_diff;
  }
  if ( !is_rounding_TH )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Hash rate(%dMH) <= target(%dMH), no need adjust\n",
          "freq_tuning.c",
          2147,
          (const char *)_FUNCTION___13556,
          hash_rate_curr_MH,
          hash_rate_target_MH);
      fclose(pFile);
    }
    return 0;
  }
  else
  {
    hash_rate_target_sale_MH = hash_rate_target_MH
                             / (int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377]
                             * (_DWORD)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377];
    hash_rate_stable_MH = (_DWORD)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377]
                        * (hash_rate_curr_MH
                         / (int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377])
                        + 450000;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: hash_rate_stable_MH      = %d\n",
          "freq_tuning.c",
          2154,
          (const char *)_FUNCTION___13556,
          hash_rate_stable_MH);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: hash_rate_target_sale_MH = %d\n",
          "freq_tuning.c",
          2155,
          (const char *)_FUNCTION___13556,
          hash_rate_target_sale_MH);
      fclose(pFile_1);
    }
    if ( hash_rate_curr_MH < hash_rate_target_sale_MH && hash_rate_curr_MH > hash_rate_stable_MH )
    {
      hash_rate_threshold_MH = (_DWORD)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377]
                             * (hash_rate_curr_MH
                              / (int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377])
                             + 450000;
      goto LABEL_25;
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: Hash rate(%dMH), no need adjust\n",
          "freq_tuning.c",
          2163,
          (const char *)_FUNCTION___13556,
          hash_rate_curr_MH);
      fclose(pFile_2);
    }
    return 0;
  }
}

//----- (0001A364) --------------------------------------------------------
void __cdecl freq_tuning_adjust_result_for_high_temperature(freq_tuning_info *freq_info, int sub_proj_index)
{
  FILE *pFile; // [sp+1Ch] [bp-20h]
  FILE *pFile_0; // [sp+20h] [bp-1Ch]
  int freq_threshold; // [sp+2Ch] [bp-10h]
  int asic; // [sp+30h] [bp-Ch]
  int chain; // [sp+34h] [bp-8h]

  if ( g_BHB91602_proj.proj_type == 1 && g_BHB91602_proj.conf_list[sub_proj_index].proj_sub_type == 1 )
  {
    for ( chain = 0; ; ++chain )
    {
      if ( chain > 15 )
        return;
      if ( dev->chain_exist[chain] )
      {
        if ( chain && chain != 3 )
        {
          if ( chain != 1 )
            continue;
          freq_threshold = 390;
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "%s:%d:%s: Adjust chain %d frequency <= %dM at high hash rate for S15 due to high temperature.\n",
                "freq_tuning.c",
                2263,
                (const char *)_FUNCTION___13595,
                1,
                390);
            fclose(pFile_0);
          }
        }
        else
        {
          freq_threshold = 400;
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile = fopen((const char *)log_file, "a+");
            if ( pFile )
              fprintf(
                pFile,
                "%s:%d:%s: Adjust chain %d frequency <= %dM at high hash rate for S15 due to high temperature.\n",
                "freq_tuning.c",
                2258,
                (const char *)_FUNCTION___13595,
                chain,
                400);
            fclose(pFile);
          }
        }
        for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
        {
          if ( freq_threshold < freq_info->freq_table[chain][asic] )
            freq_info->freq_table[chain][asic] = freq_threshold;
        }
      }
    }
  }
}

//----- (0001A604) --------------------------------------------------------
void __cdecl freq_tuning_adjust_result_for_J_TH(freq_tuning_info *freq_info, int sub_proj_index)
{
  FILE *pFile; // [sp+14h] [bp-10h]
  int freq_diff; // [sp+18h] [bp-Ch]

  if ( g_BHB91602_proj.proj_type == 1 && !g_BHB91602_proj.conf_list[sub_proj_index].proj_sub_type )
  {
    freq_diff = freq_tuning_adjust_result_according_to_hash_rate(
                  freq_info,
                  dev->chain_num * 174720 * freq_info->asic_num_per_chain,
                  0);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Adjust frequency %dM+ at economic mode for S15 due to J/TH.\n",
          "freq_tuning.c",
          2295,
          (const char *)_FUNCTION___13610,
          freq_diff);
      fclose(pFile);
    }
  }
}

//----- (0001A738) --------------------------------------------------------
void __cdecl freq_tuning_adjust_result_for_hash_rate_threshold_S15_H(freq_tuning_info *freq_info, int sub_proj_index)
{
  int freq_diff_extra_S15_H[16]; // [sp+18h] [bp-ACh] BYREF
  FILE *pFile_9; // [sp+58h] [bp-6Ch]
  int freq_diff; // [sp+5Ch] [bp-68h]
  FILE *pFile_8; // [sp+60h] [bp-64h]
  FILE *pFile_7; // [sp+64h] [bp-60h]
  FILE *pFile_6; // [sp+68h] [bp-5Ch]
  FILE *pFile_5; // [sp+6Ch] [bp-58h]
  FILE *pFile_4; // [sp+70h] [bp-54h]
  FILE *pFile_3; // [sp+74h] [bp-50h]
  FILE *pFile_2; // [sp+78h] [bp-4Ch]
  int freq_diff_steps_extra; // [sp+7Ch] [bp-48h]
  int freq_diff_steps; // [sp+80h] [bp-44h]
  int hash_rate_steps; // [sp+84h] [bp-40h]
  int hash_rate_step_MH; // [sp+88h] [bp-3Ch]
  int freq_store_step; // [sp+8Ch] [bp-38h]
  FILE *pFile_1; // [sp+90h] [bp-34h]
  FILE *pFile_0; // [sp+94h] [bp-30h]
  FILE *pFile; // [sp+98h] [bp-2Ch]
  int hash_rate_stable_MH; // [sp+9Ch] [bp-28h]
  int hash_rate_target_sale_MH; // [sp+A0h] [bp-24h]
  int hash_rate_curr_MH; // [sp+A4h] [bp-20h]
  int hash_rate_max_MH; // [sp+A8h] [bp-1Ch]
  int GH; // [sp+ACh] [bp-18h]
  int TH; // [sp+B0h] [bp-14h]
  int hash_rate_threshold_MH; // [sp+B4h] [bp-10h]
  int asic; // [sp+B8h] [bp-Ch]
  int chain; // [sp+BCh] [bp-8h]

  TH = (int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377];
  GH = 1000;
  hash_rate_max_MH = 1000 * g_BHB91602_proj.conf_list[sub_proj_index].max_hash_rate;
  hash_rate_curr_MH = freq_tuning_get_hash_rate_MH(freq_info);
  if ( hash_rate_curr_MH > hash_rate_max_MH )
  {
    hash_rate_threshold_MH = hash_rate_max_MH;
    goto LABEL_18;
  }
  hash_rate_target_sale_MH = hash_rate_max_MH / TH * TH;
  hash_rate_stable_MH = TH * (hash_rate_curr_MH / TH) + 450 * GH;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: hash_rate_stable_MH      = %d\n",
        "freq_tuning.c",
        2333,
        (const char *)_FUNCTION___13632,
        hash_rate_stable_MH);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: hash_rate_target_sale_MH = %d\n",
        "freq_tuning.c",
        2334,
        (const char *)_FUNCTION___13632,
        hash_rate_target_sale_MH);
    fclose(pFile_0);
  }
  if ( hash_rate_curr_MH < hash_rate_target_sale_MH && hash_rate_curr_MH > hash_rate_stable_MH )
  {
    hash_rate_threshold_MH = hash_rate_stable_MH;
LABEL_18:
    freq_store_step = eeprom_get_freq_store_step();
    hash_rate_step_MH = freq_info->asic_num_per_chain * 672 * freq_store_step;
    hash_rate_steps = (hash_rate_curr_MH - hash_rate_threshold_MH + hash_rate_step_MH - 1) / hash_rate_step_MH;
    freq_diff_steps = hash_rate_steps / dev->chain_num;
    freq_diff_steps_extra = hash_rate_steps % dev->chain_num;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: hash_rate_curr_MH        = %d\n",
          "freq_tuning.c",
          2353,
          (const char *)_FUNCTION___13632,
          hash_rate_curr_MH);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: hash_rate_threshold_MH   = %d\n",
          "freq_tuning.c",
          2354,
          (const char *)_FUNCTION___13632,
          hash_rate_threshold_MH);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(
          pFile_4,
          "%s:%d:%s: freq_store_step          = %d\n",
          "freq_tuning.c",
          2355,
          (const char *)_FUNCTION___13632,
          freq_store_step);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(
          pFile_5,
          "%s:%d:%s: hash_rate_step_MH        = %d\n",
          "freq_tuning.c",
          2356,
          (const char *)_FUNCTION___13632,
          hash_rate_step_MH);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "%s:%d:%s: hash_rate_steps          = %d\n",
          "freq_tuning.c",
          2357,
          (const char *)_FUNCTION___13632,
          hash_rate_steps);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(
          pFile_7,
          "%s:%d:%s: freq_diff_steps          = %d\n",
          "freq_tuning.c",
          2358,
          (const char *)_FUNCTION___13632,
          freq_diff_steps);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(
          pFile_8,
          "%s:%d:%s: freq_diff_steps_extra    = %d\n",
          "freq_tuning.c",
          2359,
          (const char *)_FUNCTION___13632,
          freq_diff_steps_extra);
      fclose(pFile_8);
    }
    memset(freq_diff_extra_S15_H, 0, sizeof(freq_diff_extra_S15_H));
    if ( freq_diff_steps_extra != 2 )
    {
      if ( freq_diff_steps_extra != 3 )
      {
        if ( freq_diff_steps_extra != 1 )
        {
LABEL_53:
          for ( chain = 0; chain <= 15; ++chain )
          {
            if ( dev->chain_exist[chain] )
            {
              freq_diff = (freq_diff_extra_S15_H[chain] + freq_diff_steps) * freq_store_step;
              if ( log_level > 3 )
              {
                print_crt_time_to_file(log_file, 3u);
                pFile_9 = fopen((const char *)log_file, "a+");
                if ( pFile_9 )
                  fprintf(
                    pFile_9,
                    "%s:%d:%s: Adjust frequency %dM for chain %d due to hash rate excceed target too much.\n",
                    "freq_tuning.c",
                    2384,
                    (const char *)_FUNCTION___13632,
                    freq_diff,
                    chain);
                fclose(pFile_9);
              }
              for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
                freq_info->freq_table[chain][asic] -= freq_diff;
            }
          }
          return;
        }
LABEL_52:
        freq_diff_extra_S15_H[2] = 1;
        goto LABEL_53;
      }
      freq_diff_extra_S15_H[0] = 1;
    }
    freq_diff_extra_S15_H[1] = 1;
    goto LABEL_52;
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: Hash rate = %dMH, no need adjust\n",
        "freq_tuning.c",
        2342,
        (const char *)_FUNCTION___13632,
        hash_rate_curr_MH);
    fclose(pFile_1);
  }
}

//----- (0001B054) --------------------------------------------------------
void __cdecl freq_tuning_adjust_result_for_hash_rate_threshold(freq_tuning_info *freq_info, int sub_proj_index)
{
  FILE *pFile; // [sp+14h] [bp-10h]
  int freq_diff; // [sp+18h] [bp-Ch]
  bool is_rounding_TH; // [sp+1Fh] [bp-5h]

  is_rounding_TH = 0;
  if ( g_BHB91602_proj.proj_type == 1 && g_BHB91602_proj.conf_list[sub_proj_index].proj_sub_type == 1 )
  {
    freq_tuning_adjust_result_for_hash_rate_threshold_S15_H(freq_info, sub_proj_index);
  }
  else
  {
    if ( g_BHB91602_proj.conf_list[sub_proj_index].proj_sub_type == 1 )
      is_rounding_TH = 1;
    freq_diff = freq_tuning_adjust_result_according_to_hash_rate(
                  freq_info,
                  1000 * g_BHB91602_proj.conf_list[sub_proj_index].max_hash_rate,
                  is_rounding_TH);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Adjust frequency %dM+ due to hash rate excceed target too much.\n",
          "freq_tuning.c",
          2413,
          (const char *)_FUNCTION___13662,
          freq_diff);
      fclose(pFile);
    }
  }
}

//----- (0001B1C4) --------------------------------------------------------
void __cdecl freq_tuning_save_result(freq_tuning_info *freq_info, int sub_proj_index)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  FILE *pFile_1; // [sp+10h] [bp-1Ch]
  FILE *pFile_0; // [sp+14h] [bp-18h]
  FILE *pFile; // [sp+18h] [bp-14h]
  int proj_sub_type; // [sp+1Ch] [bp-10h]
  int work_mode; // [sp+20h] [bp-Ch]
  uint8_t chain; // [sp+27h] [bp-5h]

  proj_sub_type = g_BHB91602_proj.conf_list[sub_proj_index].proj_sub_type;
  for ( chain = 0; chain <= 0xFu; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      while ( 1 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Save freq to eeprom for chain %d...\n",
              "freq_tuning.c",
              2432,
              (const char *)_FUNCTION___13672,
              chain);
          fclose(pFile);
        }
        if ( proj_sub_type )
        {
          if ( proj_sub_type == 1 )
            work_mode = 1;
          v2 = eeprom_set_freq(chain, work_mode, freq_info->freq_table[chain], 0x30u);
        }
        else
        {
          work_mode = 0;
          v2 = eeprom_set_freq(chain, 0, freq_info->freq_table[chain], 0x30u);
        }
        if ( v2 )
          break;
        sleep(1u);
      }
      while ( 1 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: Save voltage to eeprom for chain %d...\n",
              "freq_tuning.c",
              2453,
              (const char *)_FUNCTION___13672,
              chain);
          fclose(pFile_0);
        }
        if ( proj_sub_type )
        {
          if ( proj_sub_type == 1 )
            work_mode = 1;
          v3 = eeprom_set_voltage(chain, work_mode, freq_info->vol_value_table[chain]);
        }
        else
        {
          work_mode = 0;
          v3 = eeprom_set_voltage(chain, 0, freq_info->vol_value_table[chain]);
        }
        if ( v3 )
          break;
        sleep(1u);
      }
      while ( 1 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: Save hash rate to eeprom for chain %d...\n",
              "freq_tuning.c",
              2474,
              (const char *)_FUNCTION___13672,
              chain);
          fclose(pFile_1);
        }
        if ( proj_sub_type )
        {
          if ( proj_sub_type == 1 )
            work_mode = 1;
          v4 = eeprom_set_hash_rate(chain, work_mode, freq_info->ideal_hash_rate[chain]);
        }
        else
        {
          work_mode = 0;
          v4 = eeprom_set_hash_rate(chain, 0, freq_info->ideal_hash_rate[chain]);
        }
        if ( v4 )
          break;
        sleep(1u);
      }
    }
  }
  eeprom_dump();
}
// 1B304: variable 'work_mode' is possibly undefined

//----- (0001B550) --------------------------------------------------------
void __cdecl freq_tuning_mark_unbalance_chain(freq_tuning_info *freq_info)
{
  FILE *pFile_1; // [sp+1Ch] [bp-20h]
  FILE *pFile_0; // [sp+20h] [bp-1Ch]
  FILE *pFile; // [sp+24h] [bp-18h]
  int sub_proj_index; // [sp+28h] [bp-14h]
  int freq; // [sp+2Ch] [bp-10h]
  int asic; // [sp+30h] [bp-Ch]
  int chain; // [sp+34h] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Mark unbalance freq.\n", "freq_tuning.c", 2503, (const char *)_FUNCTION___13692);
    fclose(pFile);
  }
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: g_chain_unbalance[%d] = %d\n",
            "freq_tuning.c",
            2512,
            (const char *)_FUNCTION___13692,
            chain,
            g_chain_unbalance[chain]);
        fclose(pFile_0);
      }
      if ( g_chain_unbalance[chain] )
        freq = 100;
      else
        freq = 200;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: chain[%d]: freq = %d\n",
            "freq_tuning.c",
            2523,
            (const char *)_FUNCTION___13692,
            chain,
            freq);
        fclose(pFile_1);
      }
      for ( asic = 0; asic < freq_info->asic_num_per_chain; ++asic )
        freq_info->freq_table[chain][asic] = freq;
      freq_info->vol_value_table[chain] = g_BHB91602_proj.conf_list->base_voltage;
      freq_info->ideal_hash_rate[chain] = freq_info->asic_num_per_chain * 672 * freq / 1000;
    }
  }
  for ( sub_proj_index = 0; sub_proj_index < g_BHB91602_proj.sub_proj_count; ++sub_proj_index )
    freq_tuning_save_result(freq_info, sub_proj_index);
}

//----- (0001B8A0) --------------------------------------------------------
int freq_tuning_already_done()
{
  FILE *fp; // [sp+4h] [bp-8h]

  fp = fopen("/config/scanfreqdone", "r");
  if ( !fp )
    return 0;
  fclose(fp);
  return 1;
}

//----- (0001B8F0) --------------------------------------------------------
void freq_tuning_done_mark()
{
  system("touch /config/scanfreqdone");
}

//----- (0001B90C) --------------------------------------------------------
void __cdecl freq_tuning_set_fake_done_for_other_chain(freq_tuning_info *freq_info, int chain)
{
  int chain_other; // [sp+Ch] [bp-8h]

  for ( chain_other = 0; chain_other <= 15; ++chain_other )
  {
    if ( dev->chain_exist[chain_other] && chain_other != chain && !freq_info->test_done[chain_other] )
      freq_info->fake_done[chain_other] = 1;
  }
}

//----- (0001B9C8) --------------------------------------------------------
void __cdecl freq_tuning_clear_fake_done(freq_tuning_info *freq_info)
{
  int chain; // [sp+Ch] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      freq_info->fake_done[chain] = 0;
  }
}

//----- (0001BA48) --------------------------------------------------------
void __cdecl freq_tuning_pattern_test_serial(
        freq_tuning_info *freq_info,
        int chain,
        int level_start,
        int level_cnt,
        int sub_proj_index)
{
  int v5; // r1
  int freq; // [sp+1Ch] [bp-20h] BYREF
  int voltage; // [sp+20h] [bp-1Ch] BYREF
  FILE *pFile_0; // [sp+24h] [bp-18h]
  FILE *pFile; // [sp+28h] [bp-14h]
  int level_end; // [sp+2Ch] [bp-10h]
  int init_freq; // [sp+30h] [bp-Ch]
  int curr_scan_level; // [sp+34h] [bp-8h]

  curr_scan_level = level_start;
  level_end = level_start + level_cnt;
  init_freq = g_init_freq;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: serial pattern test start: chain[%d]\n",
        "freq_tuning.c",
        2591,
        (const char *)_FUNCTION___13738,
        chain);
    fclose(pFile);
  }
  freq_tuning_set_fake_done_for_other_chain(freq_info, chain);
  do
  {
    if ( curr_scan_level >= level_end )
      break;
    freq_tuning_reset_global_arg();
    if ( freq_tuning_get_board_test_voltage_and_freq(curr_scan_level, &voltage, &freq, sub_proj_index) == -1 )
      break;
    freq_info->vol_value_table[chain] = voltage;
    v5 = freq;
    freq_info->scan_freq[chain] = freq;
    increase_freq_slowly(COERCE_FLOAT((unsigned __int8)chain), *(float *)&v5, *(float *)&freq_info, chain);
    init_freq = freq_info->scan_freq[chain];
    freq_tuning_set_time_control_by_freq(freq_info->scan_freq[chain]);
    freq_tuning_send_work_and_check_result_all_chain(freq_info);
    ++curr_scan_level;
  }
  while ( !freq_info->test_done[chain] );
  change_high_pll_test(chain, 0.0, (unsigned __int8)chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: Down to low freq %dM to keep total power under threshold.\n",
        "freq_tuning.c",
        2624,
        (const char *)_FUNCTION___13738,
        g_init_freq);
    fclose(pFile_0);
  }
  freq_tuning_clear_fake_done(freq_info);
}

//----- (0001BD30) --------------------------------------------------------
int __cdecl freq_tuning_get_hash_rate_GH(freq_tuning_info *freq_info)
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  int hash_rate; // [sp+14h] [bp-8h]

  hash_rate = freq_tuning_get_hash_rate_MH(freq_info) / 1000;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: hash rate = %d (GH)\n",
        "freq_tuning.c",
        2636,
        (const char *)_FUNCTION___13748,
        hash_rate);
    fclose(pFile);
  }
  return hash_rate;
}

//----- (0001BE0C) --------------------------------------------------------
void __cdecl freq_tuning_set_pass_or_not(freq_tuning_info *freq_info, int sub_proj_index)
{
  freq_info->is_pass = freq_tuning_get_hash_rate_GH(freq_info) >= g_BHB91602_proj.conf_list[sub_proj_index].target_hash_rate
                    || g_BHB91602_proj.conf_list[sub_proj_index].base_voltage >= g_BHB91602_proj.conf_list[sub_proj_index].max_voltage;
}

//----- (0001BEC4) --------------------------------------------------------
void __cdecl freq_tuning_pattern_test(freq_tuning_info *freq_info, int sub_proj_index)
{
  int min_freq; // r0
  FILE *pFile_0; // [sp+14h] [bp-20h]
  FILE *pFile; // [sp+18h] [bp-1Ch]
  bool all_done; // [sp+1Fh] [bp-15h]
  int serial_level_count; // [sp+20h] [bp-14h]
  int chain; // [sp+24h] [bp-10h]
  int chaina; // [sp+24h] [bp-10h]
  int scan_level; // [sp+28h] [bp-Ch]
  bool reset_test_level; // [sp+2Fh] [bp-5h]

  reset_test_level = 1;
  scan_level = 0;
  serial_level_count = g_BHB91602_proj.conf_list[sub_proj_index].serial_level_count;
  all_done = 0;
  if ( serial_level_count > 8 )
  {
    serial_level_count = 0;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Note: serial_level_count > MAX_SCAN_LEVEL.\n",
          "freq_tuning.c",
          2671,
          (const char *)_FUNCTION___13763);
      fclose(pFile);
    }
  }
  freq_tuning_set_vol_all_chain(sub_proj_index);
  while ( scan_level < 8 - serial_level_count )
  {
    freq_tuning_reset_global_arg();
    if ( !freq_tuning_get_next_test_voltage_and_freq(freq_info, reset_test_level, sub_proj_index) )
      break;
    reset_test_level = 0;
    freq_tuning_set_freq_all_chain(freq_info);
    min_freq = freq_tuning_get_min_freq(freq_info);
    freq_tuning_set_time_control_by_freq(min_freq);
    freq_tuning_send_work_and_check_result_all_chain(freq_info);
    if ( !sub_proj_index
      && !scan_level
      && g_BHB91602_proj.conf_list->base_voltage < g_BHB91602_proj.conf_list->max_voltage
      && freq_tuning_check_domain_unbalance() )
    {
      freq_info->is_unbalance_happened = 1;
      return;
    }
    ++scan_level;
    if ( freq_tuning_check_if_test_done(freq_info) )
    {
      all_done = 1;
      break;
    }
  }
  if ( !all_done && serial_level_count )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] && !freq_info->test_done[chain] )
        freq_tuning_pattern_test_serial(freq_info, chain, scan_level, serial_level_count, sub_proj_index);
    }
  }
  for ( chaina = 0; chaina <= 15; ++chaina )
  {
    if ( dev->chain_exist[chaina] )
    {
      freq_tuning_set_asic_quality_per_domain(freq_info, chaina);
      freq_tuning_set_freq_table(freq_info, chaina);
    }
  }
  freq_tuning_print_chip_rate_table(freq_info);
  freq_tuning_print_freq_table(freq_info);
  freq_tuning_adjust_result_for_low_temperature(freq_info, sub_proj_index);
  freq_tuning_adjust_result_for_high_temperature(freq_info, sub_proj_index);
  freq_tuning_adjust_result_for_J_TH(freq_info, sub_proj_index);
  freq_tuning_adjust_result_for_poor_heat_dissipation(freq_info, sub_proj_index);
  freq_tuning_adjust_result_for_hash_rate_threshold(freq_info, sub_proj_index);
  freq_tuning_set_pass_or_not(freq_info, sub_proj_index);
  if ( !freq_info->is_pass )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Not pass. High frequency may make chip unstable, try to balance domain.\n",
          "freq_tuning.c",
          2750,
          (const char *)_FUNCTION___13763);
      fclose(pFile_0);
    }
    freq_tuning_pre_open_core(freq_info);
  }
  else
  {
    freq_tuning_get_ideal_hash_rate(freq_info, sub_proj_index);
    freq_tuning_save_result(freq_info, sub_proj_index);
  }
}

//----- (0001C314) --------------------------------------------------------
void freq_tuning_test_based_voltage_domain()
{
  pthread_t nonce_receive_id; // [sp+Ch] [bp-20h] BYREF
  FILE *pFile; // [sp+10h] [bp-1Ch]
  FILE *pFile_0; // [sp+14h] [bp-18h]
  FILE *pFile_1; // [sp+18h] [bp-14h]
  freq_tuning_info *freq_info; // [sp+1Ch] [bp-10h]
  bool reset_after_unbalance; // [sp+22h] [bp-Ah]
  bool is_need_read_temp; // [sp+23h] [bp-9h]
  int sub_proj_index; // [sp+24h] [bp-8h]

  is_need_read_temp = 1;
  reset_after_unbalance = 0;
  freq_info = freq_tuning_create_info();
  if ( freq_info )
  {
    pthread_create(&nonce_receive_id, 0, (void *(*)(void *))freq_tuning_recv_nonce_and_register, freq_info);
    pthread_detach(nonce_receive_id);
    freq_tuning_config_dump();
    memset(g_chain_unbalance, 0, sizeof(g_chain_unbalance));
    reset_after_unbalance = 0;
INIT:
    freq_tuning_env_init(is_need_read_temp, freq_info);
    is_need_read_temp = 0;
    freq_tuning_init_freq_info(freq_info);
    for ( sub_proj_index = 0; sub_proj_index < g_BHB91602_proj.sub_proj_count; ++sub_proj_index )
    {
      g_init_freq = (int)init_freq;
      set_pwm(g_BHB91602_proj.conf_list[sub_proj_index].fan_pwm);
      freq_tuning_pattern_test(freq_info, sub_proj_index);
      if ( freq_info->is_unbalance_happened )
      {
        if ( !reset_after_unbalance )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile = fopen((const char *)log_file, "a+");
            if ( pFile )
              fprintf(
                pFile,
                "%s:%d:%s: [Note] first unbalance happened, will enter re-init!!!\n",
                "freq_tuning.c",
                2805,
                (const char *)_FUNCTION___13783);
            fclose(pFile);
          }
          reset_after_unbalance = 1;
          freq_tuning_init_freq_info(freq_info);
          goto INIT;
        }
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: [Note] second unbalance happened, save unbalance result and exit freq tuning!!!\n",
              "freq_tuning.c",
              2812,
              (const char *)_FUNCTION___13783);
          fclose(pFile_0);
        }
        freq_tuning_mark_unbalance_chain(freq_info);
        break;
      }
      if ( !freq_info->is_pass )
      {
        g_BHB91602_proj.conf_list[sub_proj_index].base_voltage += 20;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: Frequency tuning: not pass, will try again, voltage change to %d.\n",
              "freq_tuning.c",
              2823,
              (const char *)_FUNCTION___13783,
              g_BHB91602_proj.conf_list[sub_proj_index].base_voltage);
          fclose(pFile_1);
        }
        --sub_proj_index;
      }
      if ( sub_proj_index != g_BHB91602_proj.sub_proj_count - 1 )
      {
        freq_tuning_init_freq_info(freq_info);
        freq_tuning_hash_board_init(freq_info);
      }
    }
    eeprom_flush();
    freq_tuning_done_mark();
    free(freq_info);
    freq_info = 0;
    pthread_cancel(nonce_receive_id);
  }
}

//----- (0001C70C) --------------------------------------------------------
void freq_tuning_free_works_buffer()
{
  int asic; // [sp+4h] [bp-8h]

  for ( asic = 0; asic <= 47; ++asic )
  {
    if ( g_works[asic] )
    {
      free(g_works[asic]);
      g_works[asic] = 0;
    }
  }
}

//----- (0001C794) --------------------------------------------------------
bool freq_tuning_alloc_works_buffer()
{
  FILE *pFile; // [sp+Ch] [bp-10h]
  bool ret; // [sp+13h] [bp-9h]
  int asic; // [sp+14h] [bp-8h]

  ret = 1;
  memset(g_works, 0, sizeof(g_works));
  for ( asic = 0; asic <= 47; ++asic )
  {
    g_works[asic] = (freq_tuning_work *)cgmalloc(0x8880u, "freq_tuning.c", _func___13802, 2879);
    if ( !g_works[asic] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Fail to allocate buffer for works!\n",
            "freq_tuning.c",
            2882,
            (const char *)_FUNCTION___13804);
        fclose(pFile);
      }
      ret = 0;
      break;
    }
  }
  if ( !ret )
    freq_tuning_free_works_buffer();
  return ret;
}

//----- (0001C8E4) --------------------------------------------------------
void do_freq_tuning()
{
  int diff; // [sp+14h] [bp-30h]
  timeval end; // [sp+1Ch] [bp-28h] BYREF
  timeval start; // [sp+24h] [bp-20h] BYREF
  FILE *pFile_0; // [sp+2Ch] [bp-18h]
  FILE *pFile_1; // [sp+30h] [bp-14h]
  FILE *pFile_3; // [sp+34h] [bp-10h]
  FILE *pFile_2; // [sp+38h] [bp-Ch]
  FILE *pFile; // [sp+3Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Frequency tuning: start!\n", "freq_tuning.c", 2901, (const char *)_FUNCTION___13815);
    fclose(pFile);
  }
  freq_tuning_get_proj_type();
  if ( g_BHB91602_proj.proj_type == 3 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Unknown project type, chain asic num is %d\n",
          "freq_tuning.c",
          2906,
          (const char *)_FUNCTION___13815,
          48);
      fclose(pFile_0);
    }
  }
  else if ( freq_tuning_already_done() )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: Frequency tuning is alreay done.\n",
          "freq_tuning.c",
          2912,
          (const char *)_FUNCTION___13815);
      fclose(pFile_1);
    }
  }
  else
  {
    cgtime(&start);
    freq_scan_status = 0;
    if ( freq_tuning_alloc_works_buffer() )
    {
      if ( !freq_tuning_prepare_works() )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: Frequency tuning nonce rate theshold is %.2f\n",
              "freq_tuning.c",
              2929,
              (const char *)_FUNCTION___13815,
              0.98);
          fclose(pFile_2);
        }
        freq_tuning_test_based_voltage_domain();
      }
      freq_tuning_free_works_buffer();
      freq_scan_status = 1;
      cgtime(&end);
      diff = end.tv_sec - start.tv_sec;
      if ( end.tv_usec - start.tv_usec < 0 )
        --diff;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: \n\n***Frequency tuning: done! time cost %ld minutes***\n\n",
            "freq_tuning.c",
            2943,
            (const char *)_FUNCTION___13815,
            diff / 60);
        fclose(pFile_3);
      }
    }
  }
}

//----- (0001CCD8) --------------------------------------------------------
unsigned int __cdecl check_asic_reg_with_addr(
        unsigned int reg,
        unsigned __int8 chip_addr,
        unsigned int chain,
        int check_num)
{
  FILE *pFile_0; // [sp+20h] [bp-1Ch]
  FILE *pFile; // [sp+24h] [bp-18h]
  unsigned int reg_buf; // [sp+28h] [bp-14h]
  unsigned int reg_value_num; // [sp+2Ch] [bp-10h]
  int not_reg_data_time; // [sp+30h] [bp-Ch]
  unsigned int i; // [sp+34h] [bp-8h]

  not_reg_data_time = 0;
  LOBYTE(i) = chain;
  while ( 1 )
  {
    clear_register_value_buf();
    read_asic_register(i, 0, chip_addr, reg);
    cgsleep_ms(80);
LABEL_28:
    if ( not_reg_data_time > 4 )
    {
      clear_register_value_buf();
      return 0;
    }
    pthread_mutex_lock(&reg_mutex);
    reg_value_num = reg_value_buf.reg_value_num;
    pthread_mutex_unlock(&reg_mutex);
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: reg_value_num %d\n",
          "temperature.c",
          96,
          (const char *)_FUNCTION___11116,
          reg_value_num);
      fclose(pFile);
    }
    if ( reg_value_num <= 0x1FE && reg_value_buf.p_rd <= 0x1FE && reg_value_num )
      break;
    ++not_reg_data_time;
  }
  pthread_mutex_lock(&reg_mutex);
  for ( i = 0; ; ++i )
  {
    if ( reg_value_num <= i )
    {
      pthread_mutex_unlock(&reg_mutex);
      goto LABEL_28;
    }
    reg_buf = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
    if ( chain != reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number )
    {
      ++reg_value_buf.p_rd;
      --reg_value_buf.reg_value_num;
      if ( reg_value_buf.p_rd > 0x1FE )
        reg_value_buf.p_rd = 0;
      continue;
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chip %x reg %x reg_buff %x\n",
          "temperature.c",
          124,
          (const char *)_FUNCTION___11116,
          chip_addr,
          reg,
          reg_buf);
      fclose(pFile_0);
    }
    ++reg_value_buf.p_rd;
    --reg_value_buf.reg_value_num;
    if ( reg_value_buf.p_rd > 0x1FE )
      reg_value_buf.p_rd = 0;
    if ( reg == 28 )
      break;
  }
  pthread_mutex_unlock(&reg_mutex);
  clear_register_value_buf();
  if ( (reg_buf & 0xC0000000) != 0 )
    return 0;
  else
    return reg_buf;
}
// 1CE38: conditional instruction was optimized away because %not_reg_data_time.4<5
// 1CE54: conditional instruction was optimized away because %not_reg_data_time.4<5

//----- (0001D0D4) --------------------------------------------------------
unsigned int __cdecl wait_iic_ok(unsigned int chip_addr, unsigned int chain, bool update)
{
  unsigned __int8 chip_addra; // [sp+Ch] [bp-10h]
  unsigned int ret; // [sp+10h] [bp-Ch]
  int fail_time; // [sp+14h] [bp-8h]

  chip_addra = chip_addr;
  for ( fail_time = 0; fail_time <= 1; ++fail_time )
  {
    ret = check_asic_reg_with_addr(0x1Cu, chip_addra, chain, 1);
    if ( ret )
      return ret;
    cgsleep_ms(1);
  }
  return 0;
}

//----- (0001D164) --------------------------------------------------------
uint8_t __cdecl check_reg_temp(uint8_t reg, uint8_t data, uint8_t write, uint8_t chip_addr, int chain)
{
  __int16 ret; // [sp+10h] [bp-Ch]
  int fail_time; // [sp+14h] [bp-8h]

  fail_time = 0;
  if ( write )
  {
    do
    {
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(0x98u, reg, data, write, chip_addr, chain);
      wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(0x98u, reg, 0, 0, chip_addr, chain);
      ret = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      ++fail_time;
    }
    while ( HIBYTE(ret) != reg && (unsigned __int8)ret != data && fail_time <= 1 );
  }
  else
  {
    do
    {
      wait_iic_ok(chip_addr, chain, 0);
      read_temp(0x98u, reg, data, 0, chip_addr, chain);
      cgsleep_ms(1);
      ret = wait_iic_ok(chip_addr, chain, 1);
      cgsleep_ms(1);
      ++fail_time;
    }
    while ( HIBYTE(ret) != reg && fail_time <= 1 );
  }
  if ( fail_time == 2 )
    return 0;
  else
    return ret;
}

//----- (0001D368) --------------------------------------------------------
int16_t __cdecl get_local(int16_t local)
{
  return local - 64;
}

//----- (0001D3A0) --------------------------------------------------------
void __cdecl get_temp_info_from_default_by_chain(uint32_t chain)
{
  FILE *pFile_1; // [sp+8h] [bp-24h]
  FILE *pFile_4; // [sp+Ch] [bp-20h]
  FILE *pFile_5; // [sp+10h] [bp-1Ch]
  FILE *pFile_3; // [sp+14h] [bp-18h]
  FILE *pFile_2; // [sp+18h] [bp-14h]
  FILE *pFile_0; // [sp+1Ch] [bp-10h]
  FILE *pFile; // [sp+20h] [bp-Ch]
  int i; // [sp+24h] [bp-8h]
  int ia; // [sp+24h] [bp-8h]

  temp_info[chain].type = TMP451;
  temp_info[chain].num = 4;
  temp_info[chain].pos[0] = 12;
  temp_info[chain].pos[1] = 9;
  temp_info[chain].pos[2] = 37;
  temp_info[chain].pos[3] = 40;
  temp_info[chain].offset[0] = 0;
  temp_info[chain].offset[1] = 0;
  temp_info[chain].offset[2] = 0;
  temp_info[chain].offset[3] = 0;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "sensor type = %d,sensor num = %d\n", temp_info[chain].type, temp_info[chain].num);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fwrite("sensor pos:", 1u, 0xBu, pFile_0);
    fclose(pFile_0);
  }
  for ( i = 0; i <= 7; ++i )
  {
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, " %d ", temp_info[chain].pos[i]);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fwrite("sensor offset:", 1u, 0xEu, pFile_3);
    fclose(pFile_3);
  }
  for ( ia = 0; ia <= 7; ++ia )
  {
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, " %d ", temp_info[chain].offset[ia]);
      fclose(pFile_4);
    }
  }
  if ( log_level > 3 )
  {
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fputc(10, pFile_5);
    fclose(pFile_5);
  }
}

//----- (0001D8E8) --------------------------------------------------------
void __cdecl update_middle_offset(int chain, int temp_id)
{
  check_reg_temp(0x11u, 1u, 1u, dev->TempChipAddr[chain][temp_id], chain);
}

//----- (0001D950) --------------------------------------------------------
int32_t __cdecl calibration_sensor_offset(int32_t chain)
{
  FILE *pFile_1; // [sp+24h] [bp-18h]
  FILE *pFile_0; // [sp+28h] [bp-14h]
  FILE *pFile; // [sp+2Ch] [bp-10h]
  unsigned int i; // [sp+34h] [bp-8h]

  get_temp_info_from_default_by_chain(chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: chain[%d] temp chip I2C addr=0x%02x\n",
        "temperature.c",
        307,
        (const char *)_FUNCTION___11190,
        chain,
        152);
    fclose(pFile);
  }
  dev->chain_asic_temp_num[chain] = temp_info[chain].num;
  for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
  {
    dev->TempChipAddr[chain][i] = 5 * (temp_info[chain].pos[i] - 1);
    middle_Offset[8 * chain + i] = temp_info[chain].offset[i];
    set_misc_control(chain, 0, dev->TempChipAddr[chain][i], 1);
    check_asic_reg_with_addr(0x18u, dev->TempChipAddr[chain][i], chain, 1);
    dev->TempChipType[chain][i] = check_reg_temp(0xFEu, 0, 0, dev->TempChipAddr[chain][i], chain);
    if ( dev->TempChipType[chain][i] != 26 && dev->TempChipType[chain][i] != 85 && dev->TempChipType[chain][i] != 65 )
    {
      dev->chain_asic_temp_num[chain] = 0;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: wrong temp chip type!!!\n", "temperature.c", 332, (const char *)_FUNCTION___11190);
        fclose(pFile_0);
      }
      return 0;
    }
    check_reg_temp(9u, 4u, 1u, dev->TempChipAddr[chain][i], chain);
    update_middle_offset(chain, i);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: Chain[%d] chip[%d] use PIC middle temp offset=%d, typeID=%02x\n",
          "temperature.c",
          345,
          (const char *)_FUNCTION___11190,
          chain,
          dev->TempChipAddr[chain][i] / 5u,
          middle_Offset[8 * chain + i],
          dev->TempChipType[chain][i]);
      fclose(pFile_1);
    }
  }
  return 0;
}

//----- (0001DF68) --------------------------------------------------------
void do_calibration_temperature_sensor()
{
  int chain; // [sp+4h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] == 1 && dev->chain_asic_num[chain] == 48 )
    {
      calibration_sensor_offset(chain);
      cgsleep_ms(10);
    }
  }
}

//----- (0001DFFC) --------------------------------------------------------
void __cdecl set_pwm(unsigned __int8 pwm_percent)
{
  int temp_pwm_percent; // [sp+Ch] [bp-8h]

  temp_pwm_percent = pwm_percent;
  if ( pwm_percent <= 0x13u )
    temp_pwm_percent = 20;
  if ( temp_pwm_percent > 100 )
    LOWORD(temp_pwm_percent) = 100;
  dev->pwm_value = ((unsigned __int16)((__int16)(50 * temp_pwm_percent) / 100) << 16) | (unsigned __int16)((__int16)(50 * (100 - temp_pwm_percent)) / 100);
  dev->pwm_percent = temp_pwm_percent;
  set_fan_control(dev->pwm_value);
}

//----- (0001E10C) --------------------------------------------------------
int __cdecl get_target_airout_pcb_temp(int airin_pcb_temp)
{
  float v2; // s15
  int target_airout_pcb_temp; // [sp+Ch] [bp-10h]
  int i; // [sp+10h] [bp-Ch]
  const target_temp_args_t *ptarget_temp_arg; // [sp+14h] [bp-8h]

  if ( !is_T15() )
    return 68;
  if ( opt_bitmain_economic_mode )
    ptarget_temp_arg = target_temp_arg[0];
  else
    ptarget_temp_arg = target_temp_arg[1];
  if ( airin_pcb_temp <= ptarget_temp_arg->target_airin_pcb_temp )
    return ptarget_temp_arg->target_airout_pcb_temp;
  target_airout_pcb_temp = 68;
  for ( i = 0; i <= 2; ++i )
  {
    if ( airin_pcb_temp > ptarget_temp_arg[i].target_airin_pcb_temp
      && airin_pcb_temp <= ptarget_temp_arg[i + 1].target_airin_pcb_temp )
    {
      v2 = (double)(ptarget_temp_arg[i + 1].target_airout_pcb_temp - ptarget_temp_arg[i].target_airout_pcb_temp)
         / (double)(ptarget_temp_arg[i + 1].target_airin_pcb_temp - ptarget_temp_arg[i].target_airin_pcb_temp);
      return (int)(float)((float)((float)(airin_pcb_temp - ptarget_temp_arg[i].target_airin_pcb_temp) * v2)
                        + (float)ptarget_temp_arg[i].target_airout_pcb_temp);
    }
  }
  return target_airout_pcb_temp;
}

//----- (0001E2E8) --------------------------------------------------------
int set_pwm_by_pid_method()
{
  FILE *pFile_0; // [sp+2Ch] [bp-28h]
  FILE *pFile; // [sp+30h] [bp-24h]
  float delta_pwm; // [sp+34h] [bp-20h]
  int target_airout_pcb_temp; // [sp+40h] [bp-14h]
  int airout_pcb_temp; // [sp+44h] [bp-10h]
  int airin_pcb_temp; // [sp+48h] [bp-Ch]
  int pwm_percent; // [sp+4Ch] [bp-8h]

  pwm_percent = dev->fan_pwm;
  airin_pcb_temp = dev->temp_low1[0];
  airout_pcb_temp = dev->temp_top1[0];
  if ( airout_pcb_temp <= 67 )
  {
    target_airout_pcb_temp = get_target_airout_pcb_temp(airin_pcb_temp);
    delta_pwm = (float)((float)(airout_pcb_temp - target_airout_pcb_temp) * 1.0)
              - (float)((float)(last_airout_pcb_temp_11224 - target_airout_pcb_temp) * 0.5);
    if ( (int)delta_pwm < -1 || (int)delta_pwm > 1 )
    {
      pwm_percent = (int)((double)pwm_percent + delta_pwm + 0.5);
      if ( pwm_percent <= 19 )
        pwm_percent = 20;
      if ( pwm_percent > 100 )
        pwm_percent = 100;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_0 = fopen((const char *)temp_log, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: PWM change from %d to %d:  airin_pcb_temp=%d, airout_pcb_temp=%d, last_airout_pcb_temp=%d, target_"
            "airout_pcb_temp=%d, delta_pwm=%0.1f\n",
            "temperature.c",
            468,
            (const char *)_FUNCTION___11233,
            dev->fan_pwm,
            pwm_percent,
            airin_pcb_temp,
            airout_pcb_temp,
            last_airout_pcb_temp_11224,
            target_airout_pcb_temp,
            delta_pwm);
        fclose(pFile_0);
      }
      set_pwm(pwm_percent);
    }
    else if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile = fopen((const char *)temp_log, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: PWM keep %d:  airin_pcb_temp=%d, airout_pcb_temp=%d, last_airout_pcb_temp=%d, target_airout_pcb_temp"
          "=%d, delta_pwm=%0.1f\n",
          "temperature.c",
          456,
          (const char *)_FUNCTION___11233,
          pwm_percent,
          airin_pcb_temp,
          airout_pcb_temp,
          last_airout_pcb_temp_11224,
          target_airout_pcb_temp,
          delta_pwm);
      fclose(pFile);
    }
    dev->fan_pwm = pwm_percent;
    last_airout_pcb_temp_11224 = airout_pcb_temp;
    return pwm_percent;
  }
  else
  {
    set_pwm(0x64u);
    return 100;
  }
}

//----- (0001E64C) --------------------------------------------------------
int __cdecl set_pwm_by_airin_temp(int air_in_lowest_temp)
{
  float v1; // s15
  float v2; // s15
  FILE *pFile; // [sp+18h] [bp-1Ch]
  int i; // [sp+24h] [bp-10h]
  const fan_speed_temp_args_t *pfan_speed_temp_arg; // [sp+28h] [bp-Ch]
  int pwm_percent; // [sp+2Ch] [bp-8h]

  pwm_percent = dev->fan_pwm;
  if ( opt_bitmain_economic_mode )
  {
    if ( is_S15() )
    {
      pfan_speed_temp_arg = fan_speed_temp_arg[0];
    }
    else if ( is_T15() )
    {
      pfan_speed_temp_arg = fan_speed_temp_arg[1];
    }
  }
  else if ( is_S15() )
  {
    pfan_speed_temp_arg = fan_speed_temp_arg[2];
  }
  else if ( is_T15() )
  {
    pfan_speed_temp_arg = fan_speed_temp_arg[3];
  }
  if ( air_in_lowest_temp > pfan_speed_temp_arg->temp )
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( pfan_speed_temp_arg[i + 1].temp == 100 )
      {
        v1 = (double)(pfan_speed_temp_arg[i].fan_speed - pfan_speed_temp_arg[i - 1].fan_speed)
           / (double)(pfan_speed_temp_arg[i].temp - pfan_speed_temp_arg[i - 1].temp);
        pwm_percent = (int)(float)((float)((float)(air_in_lowest_temp - pfan_speed_temp_arg[i].temp) * v1)
                                 + (float)pfan_speed_temp_arg[i].fan_speed);
        break;
      }
      if ( air_in_lowest_temp > pfan_speed_temp_arg[i].temp && air_in_lowest_temp <= pfan_speed_temp_arg[i + 1].temp )
      {
        v2 = (double)(pfan_speed_temp_arg[i + 1].fan_speed - pfan_speed_temp_arg[i].fan_speed)
           / (double)(pfan_speed_temp_arg[i + 1].temp - pfan_speed_temp_arg[i].temp);
        pwm_percent = (int)(float)((float)((float)(air_in_lowest_temp - pfan_speed_temp_arg[i].temp) * v2)
                                 + (float)pfan_speed_temp_arg[i].fan_speed);
        break;
      }
    }
  }
  else
  {
    pwm_percent = pfan_speed_temp_arg->fan_speed;
  }
  if ( pwm_percent <= 19 )
    pwm_percent = 20;
  if ( pwm_percent > 100 )
    pwm_percent = 100;
  dev->fan_pwm = pwm_percent;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(temp_log, 3u);
    pFile = fopen((const char *)temp_log, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: air_in_lowest_temp=%d, set fan speed=%d\n",
        "temperature.c",
        539,
        (const char *)_FUNCTION___11247,
        air_in_lowest_temp,
        pwm_percent);
    fclose(pFile);
  }
  set_pwm(pwm_percent);
  return pwm_percent;
}
// 1E704: variable 'pfan_speed_temp_arg' is possibly undefined

//----- (0001EA64) --------------------------------------------------------
bool is_hashboard_dead()
{
  return fatal_error_counter == 57005;
}

//----- (0001EA9C) --------------------------------------------------------
void temp_get_local_and_remote_temp()
{
  all_parameters *v0; // r4
  all_parameters *v1; // r4
  FILE *pFile; // [sp+18h] [bp-34h]
  FILE *pFile_3; // [sp+1Ch] [bp-30h]
  FILE *pFile_4; // [sp+20h] [bp-2Ch]
  FILE *pFile_1; // [sp+24h] [bp-28h]
  FILE *pFile_2; // [sp+28h] [bp-24h]
  FILE *pFile_0; // [sp+2Ch] [bp-20h]
  FILE *pFile_5; // [sp+30h] [bp-1Ch]
  uint8_t remote_temp; // [sp+36h] [bp-16h]
  uint8_t local_temp; // [sp+37h] [bp-15h]
  int temp_asic; // [sp+38h] [bp-14h]
  int chain; // [sp+3Ch] [bp-10h]

  if ( is_hashboard_dead() )
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(temp_log, 1u);
      pFile = fopen((const char *)temp_log, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: no need to read temp from dead board, reason: %d\n",
          "temperature.c",
          608,
          (const char *)_FUNCTION___11287,
          status_value);
      fclose(pFile);
    }
  }
  else
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        for ( temp_asic = 0; temp_asic < dev->chain_asic_temp_num[chain]; ++temp_asic )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(temp_log, 3u);
            pFile_0 = fopen((const char *)temp_log, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "%s:%d:%s: Chain[%d] Chip[%d] TempTypeID=%02x middle_offset=%d\n",
                "temperature.c",
                623,
                (const char *)_FUNCTION___11287,
                chain,
                dev->TempChipAddr[chain][temp_asic] / 5u,
                dev->TempChipType[chain][temp_asic],
                middle_Offset[8 * chain + temp_asic]);
            fclose(pFile_0);
          }
          local_temp = check_reg_temp(0, 0, 0, dev->TempChipAddr[chain][temp_asic], chain);
          if ( local_temp )
          {
            v0 = dev;
            v0->chain_asic_temp[chain][temp_asic][0] = get_local(local_temp);
            dev->chain_asic_temp_status[chain][temp_asic] = 1;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(temp_log, 3u);
              pFile_1 = fopen((const char *)temp_log, "a+");
              if ( pFile_1 )
                fprintf(
                  pFile_1,
                  "%s:%d:%s: Chain[%d] Chip[%d] local_temp=%d\n",
                  "temperature.c",
                  633,
                  (const char *)_FUNCTION___11287,
                  chain,
                  dev->TempChipAddr[chain][temp_asic] / 5u,
                  dev->chain_asic_temp[chain][temp_asic][0]);
              fclose(pFile_1);
            }
          }
          else
          {
            dev->chain_asic_temp_status[chain][temp_asic] = 0;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(temp_log, 3u);
              pFile_2 = fopen((const char *)temp_log, "a+");
              if ( pFile_2 )
                fprintf(
                  pFile_2,
                  "%s:%d:%s: read failed, old value: Chain[%d] Chip[%d] local_temp=%d\n",
                  "temperature.c",
                  640,
                  (const char *)_FUNCTION___11287,
                  chain,
                  dev->TempChipAddr[chain][temp_asic] / 5u,
                  dev->chain_asic_temp[chain][temp_asic][0]);
              fclose(pFile_2);
            }
          }
          remote_temp = check_reg_temp(1u, 0, 0, dev->TempChipAddr[chain][temp_asic], chain);
          if ( remote_temp )
          {
            v1 = dev;
            v1->chain_asic_temp[chain][temp_asic][1] = get_local(remote_temp);
            dev->chain_asic_temp_status[chain][temp_asic] = 1;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(temp_log, 3u);
              pFile_3 = fopen((const char *)temp_log, "a+");
              if ( pFile_3 )
                fprintf(
                  pFile_3,
                  "%s:%d:%s: Chain[%d] Chip[%d] middle_temp=%d\n",
                  "temperature.c",
                  651,
                  (const char *)_FUNCTION___11287,
                  chain,
                  dev->TempChipAddr[chain][temp_asic] / 5u,
                  dev->chain_asic_temp[chain][temp_asic][1]);
              fclose(pFile_3);
            }
          }
          else
          {
            dev->chain_asic_temp_status[chain][temp_asic] = 0;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(temp_log, 3u);
              pFile_4 = fopen((const char *)temp_log, "a+");
              if ( pFile_4 )
                fprintf(
                  pFile_4,
                  "%s:%d:%s: read failed, old value: Chain[%d] Chip[%d] middle_temp=%d\n",
                  "temperature.c",
                  658,
                  (const char *)_FUNCTION___11287,
                  chain,
                  dev->TempChipAddr[chain][temp_asic] / 5u,
                  dev->chain_asic_temp[chain][temp_asic][1]);
              fclose(pFile_4);
            }
          }
        }
        if ( log_level > 3 )
        {
          print_crt_time_to_file(temp_log, 3u);
          pFile_5 = fopen((const char *)temp_log, "a+");
          if ( pFile_5 )
            fprintf(
              pFile_5,
              "%s:%d:%s: Done read temp on Chain[%d]\n",
              "temperature.c",
              662,
              (const char *)_FUNCTION___11287,
              chain);
          fclose(pFile_5);
        }
      }
    }
  }
}

//----- (0001F41C) --------------------------------------------------------
int temp_is_air_out_too_high()
{
  FILE *pFile; // [sp+Ch] [bp-10h]
  int temp_asic; // [sp+10h] [bp-Ch]
  int chain; // [sp+14h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( temp_asic = 0; temp_asic < dev->chain_asic_temp_num[chain]; ++temp_asic )
      {
        if ( ((unsigned __int8)(dev->TempChipAddr[chain][temp_asic] - 40) <= 4u
           || (unsigned __int8)(dev->TempChipAddr[chain][temp_asic] + 61) <= 4u)
          && dev->chain_asic_temp_status[chain][temp_asic] == 1
          && dev->chain_asic_temp[chain][temp_asic][0] > 68 )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(temp_log, 3u);
            pFile = fopen((const char *)temp_log, "a+");
            if ( pFile )
              fprintf(
                pFile,
                "%s:%d:%s: **high_priority error, temp=%d.\n",
                "temperature.c",
                681,
                (const char *)_FUNCTION___11307,
                dev->chain_asic_temp[chain][temp_asic][0]);
            fclose(pFile);
          }
          return 1;
        }
      }
    }
  }
  return 0;
}

//----- (0001F66C) --------------------------------------------------------
void temp_get_statistics()
{
  FILE *pFile; // [sp+10h] [bp-24h]
  FILE *pFile_0; // [sp+14h] [bp-20h]
  int tmp_pos; // [sp+18h] [bp-1Ch]
  int m; // [sp+1Ch] [bp-18h]
  int temp_asic; // [sp+20h] [bp-14h]
  int chain; // [sp+24h] [bp-10h]

  if ( is_hashboard_dead() )
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(temp_log, 1u);
      pFile = fopen((const char *)temp_log, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: no need to get statistics as hashboard is  dead for reason: %d\n",
          "temperature.c",
          699,
          (const char *)_FUNCTION___11321,
          status_value);
      fclose(pFile);
    }
  }
  else
  {
    dev->temp_air_out_avg = 0;
    dev->temp_air_out_sum = 0;
    dev->temp_bad_count = 0;
    dev->temp_air_out_good_count = 0;
    dev->temp_air_in_bad_count = 0;
    dev->temp_top1[0] = 0;
    dev->temp_top1[1] = 0;
    dev->temp_top1[2] = 0;
    dev->temp_low1[0] = 1000;
    dev->temp_low1[1] = 1000;
    dev->temp_low1[2] = 1000;
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        dev->chain_asic_maxtemp[chain][0] = 0;
        dev->chain_asic_maxtemp[chain][1] = 0;
        dev->chain_asic_maxtemp[chain][2] = 0;
        dev->chain_asic_mintemp[chain][0] = 1000;
        dev->chain_asic_mintemp[chain][1] = 1000;
        dev->chain_asic_mintemp[chain][2] = 1000;
        for ( temp_asic = 0; temp_asic < dev->chain_asic_temp_num[chain]; ++temp_asic )
        {
          if ( dev->chain_asic_temp_status[chain][temp_asic] == 1 )
          {
            if ( (unsigned __int8)(dev->TempChipAddr[chain][temp_asic] - 40) <= 4u
              || (unsigned __int8)(dev->TempChipAddr[chain][temp_asic] + 61) <= 4u )
            {
              ++dev->temp_air_out_good_count;
              dev->temp_air_out_sum += dev->chain_asic_temp[chain][temp_asic][0];
              if ( log_level > 3 )
              {
                print_crt_time_to_file(temp_log, 3u);
                pFile_0 = fopen((const char *)temp_log, "a+");
                if ( pFile_0 )
                  fprintf(
                    pFile_0,
                    "%s:%d:%s: ****temp_sum:%d, temp cnt: %d.\n",
                    "temperature.c",
                    742,
                    (const char *)_FUNCTION___11321,
                    dev->temp_air_out_sum,
                    dev->temp_air_out_good_count);
                fclose(pFile_0);
              }
            }
            for ( m = 0; m <= 2; ++m )
            {
              if ( dev->chain_asic_maxtemp[chain][m] < dev->chain_asic_temp[chain][temp_asic][m] )
                dev->chain_asic_maxtemp[chain][m] = dev->chain_asic_temp[chain][temp_asic][m];
              if ( dev->chain_asic_mintemp[chain][m] > dev->chain_asic_temp[chain][temp_asic][m] )
                dev->chain_asic_mintemp[chain][m] = dev->chain_asic_temp[chain][temp_asic][m];
            }
          }
          else
          {
            ++dev->temp_bad_count;
            if ( (unsigned __int8)(dev->TempChipAddr[chain][temp_asic] - 55) <= 4u
              || (unsigned __int8)(dev->TempChipAddr[chain][temp_asic] + 76) <= 4u )
            {
              ++dev->temp_air_in_bad_count;
            }
          }
        }
        for ( tmp_pos = 0; tmp_pos <= 2; ++tmp_pos )
        {
          if ( dev->temp_top1[tmp_pos] < dev->chain_asic_maxtemp[chain][tmp_pos] )
            dev->temp_top1[tmp_pos] = dev->chain_asic_maxtemp[chain][tmp_pos];
          if ( dev->temp_low1[tmp_pos] > dev->chain_asic_mintemp[chain][tmp_pos] )
            dev->temp_low1[tmp_pos] = dev->chain_asic_mintemp[chain][tmp_pos];
        }
      }
    }
    if ( dev->temp_air_out_good_count )
      dev->temp_air_out_avg = dev->temp_air_out_sum / dev->temp_air_out_good_count;
  }
}

//----- (00020048) --------------------------------------------------------
bool is_full_speed_fan()
{
  return dev->temp_air_in_bad_count > 1 || temp_is_air_out_too_high();
}

//----- (00020098) --------------------------------------------------------
void set_pwm_by_temp()
{
  FILE *pFile; // [sp+Ch] [bp-18h]
  FILE *pFile_3; // [sp+10h] [bp-14h]
  FILE *pFile_0; // [sp+14h] [bp-10h]
  FILE *pFile_2; // [sp+18h] [bp-Ch]
  FILE *pFile_1; // [sp+1Ch] [bp-8h]

  if ( is_hashboard_dead() )
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(temp_log, 1u);
      pFile = fopen((const char *)temp_log, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: error: no need to set_pwm_by_temp for reason: %d\n",
          "temperature.c",
          809,
          (const char *)_FUNCTION___11341,
          status_value);
      fclose(pFile);
    }
  }
  else
  {
    if ( is_full_speed_fan() )
    {
      set_pwm(0x64u);
      dev->fan_pwm = 100;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_0 = fopen((const char *)temp_log, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s:  Air out temprature is too high, set fixed full fan speed\n",
            "temperature.c",
            818,
            (const char *)_FUNCTION___11341);
        fclose(pFile_0);
      }
    }
    else if ( (*((_BYTE *)&config_parameter + 4) & 2) != 0 && config_parameter.fan_pwm_percent <= 0x64u )
    {
      set_pwm(config_parameter.fan_pwm_percent);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_1 = fopen((const char *)temp_log, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: fan_etf: Set fixed fan speed=%d\n",
            "temperature.c",
            825,
            (const char *)_FUNCTION___11341,
            config_parameter.fan_pwm_percent);
        fclose(pFile_1);
      }
    }
    else if ( is_S15() )
    {
      set_pwm_by_airin_temp(dev->temp_low1[0]);
    }
    else if ( is_T15() )
    {
      set_pwm_by_pid_method();
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: Miner type is ERROR! PWM running in full speed! \n",
            "temperature.c",
            835,
            (const char *)_FUNCTION___11341);
        fclose(pFile_2);
      }
      set_pwm(0x64u);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_3 = fopen((const char *)temp_log, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%s:%d:%s: FAN PWM: %d\n", "temperature.c", 841, (const char *)_FUNCTION___11341, dev->fan_pwm);
      fclose(pFile_3);
    }
  }
}

//----- (00020474) --------------------------------------------------------
void __noreturn read_temp_func()
{
  unsigned int crc_count; // r0
  FILE *pFile_3; // [sp+14h] [bp-20h]
  FILE *pFile_2; // [sp+18h] [bp-1Ch]
  FILE *pFile_1; // [sp+1Ch] [bp-18h]
  FILE *pFile_0; // [sp+20h] [bp-14h]
  FILE *pFile; // [sp+24h] [bp-10h]
  uint32_t counter; // [sp+28h] [bp-Ch]
  bool is_bringup_temp_collected; // [sp+2Fh] [bp-5h]

  fatal_error_counter = 0;
  is_bringup_temp_collected = 0;
  counter = 0;
  if ( (*((_BYTE *)&config_parameter + 4) & 2) == 0 )
    dev->fan_pwm = 70;
  while ( 1 )
  {
    if ( !(++counter % 0xA) )
    {
      copy_log_to_latest(temp_log);
      clear_log(temp_log);
    }
    pthread_mutex_lock(&reopen_core);
    temp_get_local_and_remote_temp();
    temp_get_statistics();
    last_testpatten_lowest_pcb_temp = dev->temp_low1[0];
    last_testpatten_highest_pcb_temp = dev->temp_top1[0];
    if ( !is_bringup_temp_collected )
    {
      if ( last_testpatten_lowest_pcb_temp )
      {
        bring_up_pcb_temp = last_testpatten_lowest_pcb_temp;
        is_bringup_temp_collected = 1;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: bring_up_pcb_temp = %d\n",
              "temperature.c",
              876,
              (const char *)_FUNCTION___11351,
              bring_up_pcb_temp);
          fclose(pFile);
        }
      }
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_0 = fopen((const char *)temp_log, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: lowest temp = %d, highest temp = %d \n",
          "temperature.c",
          879,
          (const char *)_FUNCTION___11351,
          last_testpatten_lowest_pcb_temp,
          last_testpatten_highest_pcb_temp);
      fclose(pFile_0);
    }
    check_fan();
    set_pwm_by_temp();
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_1 = fopen((const char *)temp_log, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: fan map is 0x%08x, num = %d\n",
          "temperature.c",
          886,
          (const char *)_FUNCTION___11351,
          dev->fan_exist_map,
          dev->fan_num);
      fclose(pFile_1);
    }
    check_error_protect();
    pthread_mutex_unlock(&reopen_core);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_2 = fopen((const char *)temp_log, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%s:%d:%s: read_temp_func Done!\n", "temperature.c", 892, (const char *)_FUNCTION___11351);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile_3 = fopen((const char *)temp_log, "a+");
      if ( pFile_3 )
      {
        crc_count = get_crc_count();
        fprintf(
          pFile_3,
          "%s:%d:%s: CRC error counter=%d\n",
          "temperature.c",
          894,
          (const char *)_FUNCTION___11351,
          crc_count);
      }
      fclose(pFile_3);
    }
    sleep(0xAu);
  }
}

//----- (00020908) --------------------------------------------------------
void update_error_status()
{
  int diff; // [sp+10h] [bp-24h]
  FILE *pFile_3; // [sp+18h] [bp-1Ch]
  FILE *pFile_4; // [sp+1Ch] [bp-18h]
  FILE *pFile_2; // [sp+20h] [bp-14h]
  FILE *pFile_1; // [sp+24h] [bp-10h]
  FILE *pFile_0; // [sp+28h] [bp-Ch]
  FILE *pFile; // [sp+2Ch] [bp-8h]

  if ( startCheckNetworkJob )
  {
    cgtime(&tv_send);
    diff = tv_send.tv_sec - tv_send_job.tv_sec;
    if ( tv_send.tv_usec - tv_send_job.tv_usec < 0 )
      --diff;
    if ( diff > 120 )
    {
      status_value = ERROR_NETCONN_LOST;
      if ( log_level > 1 )
      {
        print_crt_time_to_file(log_file, 1u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Fatal Error: network connection lost!\n",
            "temperature.c",
            913,
            (const char *)_FUNCTION___11361);
        fclose(pFile);
      }
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(temp_log, 3u);
    pFile_0 = fopen((const char *)temp_log, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: dev->temp_top1[TEMP_POS_LOCAL] = %d\n",
        "temperature.c",
        922,
        (const char *)_FUNCTION___11361,
        dev->temp_top1[0]);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(temp_log, 3u);
    pFile_1 = fopen((const char *)temp_log, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: dev->temp_top1[TEMP_POS_MIDDLE] = %d\n",
        "temperature.c",
        923,
        (const char *)_FUNCTION___11361,
        dev->temp_top1[1]);
    fclose(pFile_1);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(temp_log, 3u);
    pFile_2 = fopen((const char *)temp_log, "a+");
    if ( pFile_2 )
      fprintf(
        pFile_2,
        "%s:%d:%s: flast_testpatten_highest_pcb_temp = %d\n",
        "temperature.c",
        924,
        (const char *)_FUNCTION___11361,
        last_testpatten_highest_pcb_temp);
    fclose(pFile_2);
  }
  if ( dev->temp_top1[0] <= 80 && dev->temp_top1[1] <= 100 )
  {
    if ( dev->fan_num <= 1u )
    {
      if ( log_level > 1 )
      {
        print_crt_time_to_file(log_file, 1u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: Fatal Error: Fan lost!cnt: %d.\n",
            "temperature.c",
            934,
            (const char *)_FUNCTION___11361,
            dev->fan_num);
        fclose(pFile_4);
      }
      status_value = ERROR_FAN_LOST;
    }
  }
  else
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: Fatal Error: temp too high! pcb_temp = %d, chip_temp = %d\n",
          "temperature.c",
          929,
          (const char *)_FUNCTION___11361,
          dev->temp_top1[0],
          dev->temp_top1[1]);
      fclose(pFile_3);
    }
    status_value = ERROR_OVER_MAXTEMP;
  }
}

//----- (00020E00) --------------------------------------------------------
void check_error_protect()
{
  FILE *pFile; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile_2; // [sp+1Ch] [bp-8h]

  if ( is_hashboard_dead() )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(temp_log, 3u);
      pFile = fopen((const char *)temp_log, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: ***already dead: %d\n",
          "temperature.c",
          943,
          (const char *)_FUNCTION___11370,
          status_value);
      fclose(pFile);
    }
  }
  else
  {
    update_error_status();
    switch ( status_value )
    {
      case STATUS_INIT:
      case STATUS_OK:
        fatal_error_counter = 0;
        if ( !once_error )
          status_error = 0;
        break;
      case ERROR_NETCONN_LOST:
        ++fatal_error_counter;
        if ( log_level > 1 )
        {
          print_crt_time_to_file(log_file, 1u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: fatal_error_counter increase as: %d, error status: %d\n",
              "temperature.c",
              954,
              (const char *)_FUNCTION___11370,
              fatal_error_counter,
              status_value);
          fclose(pFile_0);
        }
        if ( fatal_error_counter > 59 )
        {
          killall_hashboard();
          print_crt_time_to_file(log_file, 1u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "Assert fail!! %s:%d: assert_log: network connection lost!\n", "temperature.c", 958);
          fclose(pFile_1);
          _assert_fail("0", "temperature.c", 0x3BEu, (const char *)_PRETTY_FUNCTION___11375);
        }
        if ( !once_error )
          status_error = 0;
        break;
      case ERROR_OVER_MAXTEMP:
      case ERROR_FAN_LOST:
        ++fatal_error_counter;
        if ( log_level > 1 )
        {
          print_crt_time_to_file(log_file, 1u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: fatal_error_counter increase as: %d, error status: %d\n",
              "temperature.c",
              974,
              (const char *)_FUNCTION___11370,
              fatal_error_counter,
              status_value);
          fclose(pFile_2);
        }
        if ( fatal_error_counter <= 0 )
        {
          if ( !once_error )
            status_error = 0;
        }
        else
        {
          killall_hashboard();
        }
        break;
      default:
        return;
    }
  }
}
// 20ED0: control flows out of bounds to 20ED4

//----- (000211F4) --------------------------------------------------------
void killall_hashboard()
{
  int dhash_acc_control; // r0
  FILE *pFile_1; // [sp+8h] [bp-14h]
  FILE *pFile_0; // [sp+Ch] [bp-10h]
  FILE *pFile; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  status_error = 1;
  once_error = 1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && !is_hashboard_dead() )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile = fopen((const char *)temp_log, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: ****power off hashboard-->*Fatal error reached the threshold: %d\n",
            "temperature.c",
            1015,
            (const char *)_FUNCTION___11387,
            status_value);
        fclose(pFile);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_0 = fopen((const char *)temp_log, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: ****bad_tmp_cnt: %d\n",
            "temperature.c",
            1016,
            (const char *)_FUNCTION___11387,
            dev->temp_bad_count);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(temp_log, 3u);
        pFile_1 = fopen((const char *)temp_log, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: ****Good temp: %d\n",
            "temperature.c",
            1017,
            (const char *)_FUNCTION___11387,
            dev->temp_air_out_good_count);
        fclose(pFile_1);
      }
      hashboard_power_off(i);
    }
  }
  fatal_error_counter = 57005;
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
}

//----- (00021494) --------------------------------------------------------
STATUS_CODE get_error_type()
{
  return status_value;
}

//----- (000214B8) --------------------------------------------------------
bool is_in_error()
{
  return fatal_error_counter > 0 && (unsigned int)status_value > STATUS_OK;
}

//----- (0002150C) --------------------------------------------------------
void __cdecl set_status(STATUS_CODE err)
{
  status_value = err;
}

//----- (0002153C) --------------------------------------------------------
int __cdecl temp_get_local_temp(float *p_temp)
{
  FILE *pFile; // [sp+1Ch] [bp-30h]
  int local_temp; // [sp+20h] [bp-2Ch]
  uint8_t reg_temp; // [sp+25h] [bp-27h]
  int ret; // [sp+28h] [bp-24h]
  float sum; // [sp+2Ch] [bp-20h]
  float suma; // [sp+2Ch] [bp-20h]
  int good_air_in; // [sp+30h] [bp-1Ch]
  int good_air_ina; // [sp+30h] [bp-1Ch]
  int bad_air_in; // [sp+34h] [bp-18h]
  int min; // [sp+38h] [bp-14h]
  int max; // [sp+3Ch] [bp-10h]
  int i; // [sp+40h] [bp-Ch]
  int chain; // [sp+44h] [bp-8h]

  max = -1000;
  min = 1000;
  bad_air_in = 0;
  good_air_in = 0;
  sum = 0.0;
  ret = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      for ( i = 0; i < dev->chain_asic_temp_num[chain]; ++i )
      {
        if ( (unsigned __int8)(dev->TempChipAddr[chain][i] - 55) <= 4u
          || (unsigned __int8)(dev->TempChipAddr[chain][i] + 76) <= 4u )
        {
          reg_temp = check_reg_temp(0, 0, 0, dev->TempChipAddr[chain][i], chain);
          if ( reg_temp )
          {
            local_temp = get_local(reg_temp);
            if ( log_level > 4 )
            {
              print_crt_time_to_file(log_file, 4u);
              pFile = fopen((const char *)log_file, "a+");
              if ( pFile )
                fprintf(
                  pFile,
                  "%s:%d:%s: sensor[%d] = %d, reg_temp = %d\n",
                  "temperature.c",
                  1073,
                  (const char *)_FUNCTION___11418,
                  dev->TempChipAddr[chain][i] / 5u,
                  local_temp,
                  reg_temp);
              fclose(pFile);
            }
            ++good_air_in;
            sum = sum + (float)local_temp;
            if ( local_temp < min )
              min = local_temp;
            if ( local_temp > max )
              max = local_temp;
          }
          else
          {
            ++bad_air_in;
          }
        }
      }
    }
  }
  suma = (float)(sum - (float)max) - (float)min;
  good_air_ina = good_air_in - 2;
  if ( !good_air_ina || bad_air_in > good_air_ina )
    return -1;
  *p_temp = suma / (float)good_air_ina;
  return ret;
}

//----- (000218F8) --------------------------------------------------------
void temp_get_environment_temp()
{
  float local_temp; // [sp+Ch] [bp-20h] BYREF
  FILE *pFile; // [sp+10h] [bp-1Ch]
  int try_count; // [sp+14h] [bp-18h]
  float sum; // [sp+1Ch] [bp-10h]
  int good_temp_count; // [sp+20h] [bp-Ch]
  int i; // [sp+24h] [bp-8h]

  try_count = 5;
  good_temp_count = 0;
  sum = 0.0;
  for ( i = 0; i < try_count; ++i )
  {
    if ( temp_get_local_temp(&local_temp) )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Get too many bad air in tempture.\n",
            "temperature.c",
            1127,
            (const char *)_FUNCTION___11435);
        fclose(pFile);
      }
    }
    else
    {
      sum = sum + local_temp;
      ++good_temp_count;
    }
  }
}

//----- (00021A4C) --------------------------------------------------------
unsigned int __cdecl _bswap_32(unsigned int __bsx)
{
  return bswap32(__bsx);
}

//----- (00021A74) --------------------------------------------------------
__uint64_t __cdecl _uint64_identity(__uint64_t __x)
{
  return __x;
}

//----- (00021A9C) --------------------------------------------------------
uint32_t __cdecl swab32_0(uint32_t v)
{
  return bswap32(v);
}

//----- (00021AC4) --------------------------------------------------------
void __cdecl flip32_0(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp-10h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32_0(*((_DWORD *)src_p + i));
}

//----- (00021B4C) --------------------------------------------------------
void __cdecl mutex_lock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00021BE8) --------------------------------------------------------
void __cdecl mutex_unlock_noyield(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00021C84) --------------------------------------------------------
void __cdecl mutex_unlock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield(lock, file, func, line);
  selective_yield();
}

//----- (00021CD0) --------------------------------------------------------
void __cdecl wr_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00021D6C) --------------------------------------------------------
void __cdecl rd_lock(pthread_rwlock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00021E08) --------------------------------------------------------
void __cdecl rw_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00021EA4) --------------------------------------------------------
void __cdecl wr_unlock_noyield(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock(lock, file, func, line);
}

//----- (00021EE0) --------------------------------------------------------
void __cdecl rd_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock(lock, file, func, line);
  selective_yield();
}

//----- (00021F2C) --------------------------------------------------------
void __cdecl mutex_init(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00021FCC) --------------------------------------------------------
void __cdecl rwlock_init(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0002206C) --------------------------------------------------------
void __cdecl cglock_init(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init(&lock->mutex, file, func, line);
  rwlock_init(&lock->rwlock, file, func, line);
}

//----- (000220C0) --------------------------------------------------------
void __cdecl cg_rlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock(&lock->mutex, file, func, line);
  rd_lock(&lock->rwlock, file, func, line);
  mutex_unlock_noyield(&lock->mutex, file, func, line);
}

//----- (00022128) --------------------------------------------------------
void __cdecl cg_wlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock(&lock->mutex, file, func, line);
  wr_lock(&lock->rwlock, file, func, line);
}

//----- (0002217C) --------------------------------------------------------
void __cdecl cg_runlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock(&lock->rwlock, file, func, line);
}

//----- (000221BC) --------------------------------------------------------
void __cdecl cg_wunlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield(&lock->rwlock, file, func, line);
  mutex_unlock(&lock->mutex, file, func, line);
}

//----- (00022210) --------------------------------------------------------
void __cdecl flip_swab_0(void *dest_p, const void *src_p, unsigned int length)
{
  unsigned int i; // [sp+1Ch] [bp-10h]

  for ( i = 0; length >> 2 > i; ++i )
    *((_DWORD *)dest_p + i) = swab32_0(*((_DWORD *)src_p + i));
}

//----- (000222A4) --------------------------------------------------------
int __cdecl get_index_from_pll_B1391(int pll)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-808h] BYREF
  int i; // [sp+80Ch] [bp-8h]

  for ( i = 0; (unsigned int)i <= 0xB2 && pll != freq_pll_1391[i].freq; ++i )
    ;
  if ( i != 179 )
    return i;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "freq index set error,return default pll index");
    applog(3, tmp42, 0);
  }
  return get_index_from_pll_B1391(200);
}

//----- (000223B8) --------------------------------------------------------
void __cdecl get_plldata_from_index(int index, uint8_t *vil_pll)
{
  size_t v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-824h] BYREF
  unsigned __int8 plldivider1[32]; // [sp+808h] [bp-24h] BYREF

  memset(plldivider1, 0, sizeof(plldivider1));
  if ( (unsigned int)index > 0xB2 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "freq set error");
      applog(3, tmp42, 0);
    }
    exit(0);
  }
  sprintf((char *)plldivider1, "%08x", freq_pll_1391[index].vilpll);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "vil pll data:%s", (const char *)plldivider1);
    applog(5, tmp42, 0);
  }
  v2 = strlen((const char *)plldivider1);
  if ( !hex2bin(vil_pll, plldivider1, v2 >> 1) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "hex2bin failed in %s", (const char *)_FUNCTION___14555);
      applog(4, tmp42, 0);
    }
    exit(-1);
  }
}

//----- (000225D8) --------------------------------------------------------
int __cdecl get_pllparam_divider(float freq, uint32_t *pll_param, uint8_t *divider, float *pll_freq)
{
  float v4; // s0
  unsigned int v5; // r3
  unsigned __int8 tmp42[2048]; // [sp+38h] [bp-854h] BYREF
  float real_freq; // [sp+838h] [bp-54h]
  uint32_t postdiv_i_0; // [sp+83Ch] [bp-50h]
  float postdiv_f_0; // [sp+840h] [bp-4Ch]
  uint32_t postdiv_i; // [sp+844h] [bp-48h]
  float postdiv_f; // [sp+848h] [bp-44h]
  float decimals; // [sp+84Ch] [bp-40h]
  uint32_t pll_out_div_i; // [sp+850h] [bp-3Ch]
  float pll_out_div_f; // [sp+854h] [bp-38h]
  uint8_t fbdiv; // [sp+85Ah] [bp-32h]
  uint8_t refdiv; // [sp+85Bh] [bp-31h]
  float min_vco; // [sp+85Ch] [bp-30h]
  float max_vco; // [sp+860h] [bp-2Ch]
  bool need_recal; // [sp+867h] [bp-25h]
  float decimals_last; // [sp+868h] [bp-24h]
  uint8_t postdiv; // [sp+86Eh] [bp-1Eh]
  uint8_t pll_div; // [sp+86Fh] [bp-1Dh]
  uint8_t postdiv2; // [sp+870h] [bp-1Ch]
  uint8_t postdiv1; // [sp+871h] [bp-1Bh]
  uint8_t refdiv_choice; // [sp+872h] [bp-1Ah]
  uint8_t fbdiv_choice; // [sp+873h] [bp-19h]
  float pll_vco_step; // [sp+874h] [bp-18h]
  float pll_vco_choice; // [sp+878h] [bp-14h]
  float pll_vco; // [sp+87Ch] [bp-10h]

  postdiv1 = 1;
  postdiv2 = 1;
  pll_div = 1;
  decimals_last = 25.0;
  max_vco = 3200.0;
  min_vco = 2000.0;
  need_recal = 0;
  pll_vco = 3200.0;
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        if ( pll_vco >= 3125.0 )
          pll_vco_step = 25.0;
        else
          pll_vco_step = 12.5;
        if ( need_recal )
        {
          pll_vco = pll_vco_choice - pll_vco_step;
          need_recal = 0;
          decimals_last = 25.0;
        }
        refdiv = (unsigned int)(float)(25.0 / pll_vco_step);
        fbdiv = (unsigned int)(float)((float)((float)refdiv * pll_vco) / 25.0);
        pll_out_div_f = pll_vco / v4;
        pll_out_div_i = (unsigned int)(float)(pll_vco / v4);
        decimals = (float)(pll_vco / v4) - (float)pll_out_div_i;
        if ( decimals < decimals_last )
        {
          postdiv = pll_out_div_i;
          pll_vco_choice = pll_vco;
          fbdiv_choice = fbdiv;
          refdiv_choice = refdiv;
          decimals_last = decimals;
        }
        pll_vco = pll_vco - pll_vco_step;
      }
      while ( pll_vco >= min_vco );
      if ( postdiv <= 0x10u )
      {
        pll_div = postdiv;
        postdiv2 = 1;
        postdiv1 = 1;
LABEL_57:
        real_freq = (float)((float)(25.0 / (float)refdiv_choice) * (float)fbdiv_choice)
                  / (float)(pll_div * postdiv2 * postdiv1);
        if ( divider )
          *(float *)divider = (float)((float)(25.0 / (float)refdiv_choice) * (float)fbdiv_choice)
                            / (float)(postdiv2 * postdiv1);
        *(_DWORD *)LODWORD(freq) = (fbdiv_choice << 16) | (refdiv_choice << 8) | (16 * postdiv1) | postdiv2;
        *(_BYTE *)pll_param = pll_div;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Want freq %f  real freq %f", v4, real_freq);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "pll_vco %f, fbdiv %#x refdiv %#x postdiv1 %#x postdiv2 %#x, pll_divider %d ,{pll_value %#x}",
            pll_vco_choice,
            fbdiv_choice,
            refdiv_choice,
            postdiv1,
            postdiv2,
            *(unsigned __int8 *)pll_param,
            *(_DWORD *)LODWORD(freq));
          applog(7, tmp42, 0);
        }
        return 0;
      }
      pll_div = 16;
      while ( 1 )
      {
        v5 = pll_div--;
        if ( v5 <= 2 )
          break;
        postdiv_f = (float)postdiv / (float)pll_div;
        postdiv_i = (unsigned int)postdiv_f;
        decimals = postdiv_f - (float)(unsigned int)postdiv_f;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "pll_div decimals %f postdiv_f %f", decimals, postdiv_f);
          applog(7, tmp42, 0);
        }
        if ( decimals < 0.0001 )
        {
          postdiv /= pll_div;
          break;
        }
      }
      if ( pll_div != 2 || (postdiv & 1) == 0 )
        break;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "need recal 1");
        applog(7, tmp42, 0);
      }
      if ( pll_vco_choice <= min_vco )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "!!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll");
          applog(3, tmp42, 0);
        }
        *(_DWORD *)LODWORD(freq) = 7864593;
        *(_BYTE *)pll_param = 15;
        return -1;
      }
      pll_vco = pll_vco_choice;
      need_recal = 1;
    }
    if ( postdiv <= 7u )
    {
      postdiv1 = postdiv;
      postdiv2 = 1;
      goto LABEL_57;
    }
    postdiv1 = 7;
    postdiv2 = 1;
    while ( postdiv1-- )
    {
      postdiv_f_0 = (float)postdiv / (float)postdiv1;
      postdiv_i_0 = (unsigned int)postdiv_f_0;
      decimals = postdiv_f_0 - (float)(unsigned int)postdiv_f_0;
      if ( decimals < 0.0001 )
      {
        postdiv2 = (unsigned int)postdiv_f_0;
        break;
      }
    }
    if ( postdiv1 >= (unsigned int)postdiv2 && postdiv2 <= 7u )
      break;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "need recal 2");
      applog(7, tmp42, 0);
    }
    if ( pll_vco_choice <= min_vco )
      break;
    pll_vco = pll_vco_choice;
    need_recal = 1;
  }
  if ( postdiv == postdiv2 * postdiv1 )
    goto LABEL_57;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "Don't find postdiv1 %d * postdiv2 %d = postdiv %d", postdiv1, postdiv2, postdiv);
    applog(3, tmp42, 0);
  }
  *(_DWORD *)LODWORD(freq) = 7864593;
  *(_BYTE *)pll_param = 15;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "!!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll");
    applog(3, tmp42, 0);
  }
  return -1;
}
// 22728: variable 'v4' is possibly undefined

//----- (0002304C) --------------------------------------------------------
bool is_fixed_freq_mode()
{
  return opt_fixed_freq;
}

//----- (00023070) --------------------------------------------------------
uint16_t __cdecl CRC16(const uint8_t *p_data, uint16_t w_len)
{
  const uint8_t *v2; // r3
  uint16_t wIndex; // [sp+Ch] [bp-8h]
  uint8_t chCRCLo; // [sp+Eh] [bp-6h]
  uint8_t chCRCHi; // [sp+Fh] [bp-5h]

  chCRCHi = -1;
  chCRCLo = -1;
  while ( w_len-- )
  {
    v2 = p_data++;
    wIndex = (unsigned __int8)(chCRCLo ^ *v2);
    chCRCLo = chCRCHi ^ chCRCHTalbe[chCRCLo ^ *v2];
    chCRCHi = chCRCLTalbe[wIndex];
  }
  return (chCRCHi << 8) | chCRCLo;
}

//----- (00023138) --------------------------------------------------------
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  unsigned __int8 crcout[5]; // [sp+Ch] [bp-18h]
  int crcin; // [sp+14h] [bp-10h]
  char crcin_4; // [sp+18h] [bp-Ch]
  bool din; // [sp+1Bh] [bp-9h]
  unsigned __int8 crc; // [sp+1Ch] [bp-8h]
  unsigned __int8 k; // [sp+1Dh] [bp-7h]
  unsigned __int8 j; // [sp+1Eh] [bp-6h]
  unsigned __int8 i; // [sp+1Fh] [bp-5h]

  crcin = 16843009;
  crcin_4 = 1;
  j = 0x80;
  k = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    din = (j & *ptr) != 0;
    crcout[0] = din ^ crcin_4;
    crcout[1] = crcin;
    crcout[2] = din ^ crcin_4 ^ BYTE1(crcin);
    *(_WORD *)&crcout[3] = HIWORD(crcin);
    j >>= 1;
    if ( ++k == 8 )
    {
      j = 0x80;
      k = 0;
      ++ptr;
    }
    crcin = *(_DWORD *)crcout;
    crcin_4 = crcout[4];
  }
  crc = 0;
  if ( crcin_4 )
    crc = 16;
  if ( HIBYTE(crcin) )
    crc |= 8u;
  if ( BYTE2(crcin) )
    crc |= 4u;
  if ( BYTE1(crcin) )
    crc |= 2u;
  if ( (_BYTE)crcin )
    crc |= 1u;
  return crc;
}

//----- (00023338) --------------------------------------------------------
uint32_t __cdecl get_core_id(nonce_format_t nonce)
{
  return (2 * ((HIWORD(nonce.v) >> 6) & 0x1FF)) | (HIBYTE(nonce.v) >> 7);
}

//----- (00023378) --------------------------------------------------------
uint32_t __cdecl get_asic_id(nonce_format_t nonce)
{
  int addrInterval; // r3

  if ( dev->addrInterval )
    addrInterval = dev->addrInterval;
  else
    addrInterval = 4;
  return (unsigned __int8)(nonce.v >> 14) / addrInterval;
}

//----- (000233F0) --------------------------------------------------------
void __noreturn get_hash_rate()
{
  int index[16]; // [sp+0h] [bp-58Ch] BYREF
  double each_chain_h[16][10]; // [sp+40h] [bp-54Ch] BYREF
  timeval diff; // [sp+540h] [bp-4Ch]
  timeval new_h; // [sp+548h] [bp-44h] BYREF
  timeval old_h; // [sp+550h] [bp-3Ch] BYREF
  unsigned __int8 *hash_log; // [sp+558h] [bp-34h]
  uint32_t counter; // [sp+55Ch] [bp-30h]
  double each_chain_h_all; // [sp+560h] [bp-2Ch]
  uint32_t i; // [sp+568h] [bp-24h]
  uint32_t which_chain; // [sp+56Ch] [bp-20h]

  which_chain = 0;
  i = 0;
  memset(each_chain_h, 0, sizeof(each_chain_h));
  each_chain_h_all = 0.0;
  memset(index, 0, sizeof(index));
  cgtime(&old_h);
  cgtime(&new_h);
  counter = 0;
  hash_log = "/var/log/hash_rate";
  while ( 1 )
  {
    ++counter;
    cgtime(&new_h);
    diff.tv_sec = new_h.tv_sec - old_h.tv_sec;
    diff.tv_usec = new_h.tv_usec - old_h.tv_usec;
    if ( new_h.tv_usec - old_h.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    each_chain_h_all = 0.0;
    for ( which_chain = 0; which_chain <= 0xF; ++which_chain )
    {
      if ( dev->chain_exist[which_chain] )
      {
        each_chain_h[which_chain][index[which_chain]] = (double)(0xFFFFFFFEFFFFFFFFLL * h_each_chain[which_chain]);
        h_each_chain[which_chain] = 0LL;
        each_chain_h[which_chain][index[which_chain]] = each_chain_h[which_chain][index[which_chain]]
                                                      / ((double)diff.tv_sec + (double)(diff.tv_usec + 1) / 1000000.0);
        each_chain_h_avg[which_chain] = 0.0;
        for ( i = 0; i <= 9; ++i )
          each_chain_h_avg[which_chain] = each_chain_h_avg[which_chain] + each_chain_h[which_chain][i];
        sprintf((char *)displayed_rate[which_chain], "%.2f", each_chain_h_avg[which_chain] / 1000000000.0 / 10.0);
        each_chain_h_all = each_chain_h_all + each_chain_h_avg[which_chain] / 1000000000.0 / 10.0;
        if ( ++index[which_chain] > 9 )
          index[which_chain] = 0;
      }
    }
    sprintf((char *)displayed_hash_rate, "%.2f", each_chain_h_all);
    geach_chain_h_all = each_chain_h_all;
    copy_time(&old_h, &new_h);
    sleep(5u);
  }
}

//----- (00023890) --------------------------------------------------------
int bitmain_axi_init()
{
  FILE *pFile; // [sp+10h] [bp-3Ch]
  FILE *pFile_0; // [sp+14h] [bp-38h]
  FILE *pFile_4; // [sp+18h] [bp-34h]
  FILE *pFile_5; // [sp+1Ch] [bp-30h]
  FILE *pFile_9; // [sp+20h] [bp-2Ch]
  FILE *pFile_10; // [sp+24h] [bp-28h]
  FILE *pFile_8; // [sp+28h] [bp-24h]
  FILE *pFile_7; // [sp+2Ch] [bp-20h]
  FILE *pFile_6; // [sp+30h] [bp-1Ch]
  FILE *pFile_3; // [sp+34h] [bp-18h]
  FILE *pFile_2; // [sp+38h] [bp-14h]
  unsigned int data; // [sp+3Ch] [bp-10h]
  FILE *pFile_1; // [sp+40h] [bp-Ch]

  fd = open("/dev/axi_fpga_dev", 2);
  if ( fd < 0 )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: /dev/axi_fpga_dev open failed. fd = %d\n",
          "driver-btm-soc.c",
          1239,
          (const char *)_FUNCTION___14793,
          fd);
      fclose(pFile);
    }
LABEL_6:
    perror("open");
    return -1;
  }
  axi_fpga_addr = (unsigned int *)mmap(0, 0x160u, 3, 1, fd, 0);
  if ( axi_fpga_addr )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: mmap axi_fpga_addr = %p\n",
          "driver-btm-soc.c",
          1250,
          (const char *)_FUNCTION___14793,
          axi_fpga_addr);
      fclose(pFile_1);
    }
    data = *axi_fpga_addr;
    if ( (unsigned __int16)*axi_fpga_addr != 50433 && log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(
          pFile_2,
          "%s:%d:%s: data = 0x%x, and it's not equal to HARDWARE_VERSION_VALUE : 0x%x\n",
          "driver-btm-soc.c",
          1256,
          (const char *)_FUNCTION___14793,
          data,
          50433);
      fclose(pFile_2);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(
          pFile_3,
          "%s:%d:%s: axi_fpga_addr data = 0x%x\n",
          "driver-btm-soc.c",
          1259,
          (const char *)_FUNCTION___14793,
          data);
      fclose(pFile_3);
    }
    fd_fpga_mem = open("/dev/fpga_mem", 2);
    if ( fd_fpga_mem < 0 )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: /dev/fpga_mem open failed. fd_fpga_mem = %d\n",
            "driver-btm-soc.c",
            1264,
            (const char *)_FUNCTION___14793,
            fd_fpga_mem);
        fclose(pFile_4);
      }
      goto LABEL_6;
    }
    fpga_mem_addr = (unsigned int *)mmap(0, 0x1000000u, 3, 1, fd_fpga_mem, 0);
    if ( fpga_mem_addr )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(
            pFile_6,
            "%s:%d:%s: mmap fpga_mem_addr = %p\n",
            "driver-btm-soc.c",
            1275,
            (const char *)_FUNCTION___14793,
            fpga_mem_addr);
        fclose(pFile_6);
      }
      nonce2_jobid_address = fpga_mem_addr;
      job_start_address_1 = fpga_mem_addr + 0x80000;
      job_start_address_2 = fpga_mem_addr + 540672;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(
            pFile_7,
            "%s:%d:%s: job_start_address_1 = %p\n",
            "driver-btm-soc.c",
            1281,
            (const char *)_FUNCTION___14793,
            job_start_address_1);
        fclose(pFile_7);
      }
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(
            pFile_8,
            "%s:%d:%s: job_start_address_2 = %p\n",
            "driver-btm-soc.c",
            1282,
            (const char *)_FUNCTION___14793,
            job_start_address_2);
        fclose(pFile_8);
      }
      set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
      dev = (all_parameters *)calloc(0x5518u, 1u);
      if ( dev )
      {
        dev->current_job_start_address = job_start_address_1;
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_10 = fopen((const char *)log_file, "a+");
          if ( pFile_10 )
            fprintf(
              pFile_10,
              "%s:%d:%s: kmalloc for dev success.\n",
              "driver-btm-soc.c",
              1296,
              (const char *)_FUNCTION___14793);
          fclose(pFile_10);
        }
        return 0;
      }
      else
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_9 = fopen((const char *)log_file, "a+");
          if ( pFile_9 )
            fprintf(
              pFile_9,
              "%s:%d:%s: kmalloc for dev failed.\n",
              "driver-btm-soc.c",
              1290,
              (const char *)_FUNCTION___14793);
          fclose(pFile_9);
        }
        return -1;
      }
    }
    else
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: mmap fpga_mem_addr failed. fpga_mem_addr = %p\n",
            "driver-btm-soc.c",
            1272,
            (const char *)_FUNCTION___14793,
            fpga_mem_addr);
        fclose(pFile_5);
      }
      return -1;
    }
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: mmap axi_fpga_addr failed. axi_fpga_addr = %p\n",
          "driver-btm-soc.c",
          1247,
          (const char *)_FUNCTION___14793,
          axi_fpga_addr);
      fclose(pFile_0);
    }
    return -1;
  }
}

//----- (000241E8) --------------------------------------------------------
void check_chain()
{
  FILE *pFile_0; // [sp+Ch] [bp-18h]
  FILE *pFile_1; // [sp+10h] [bp-14h]
  FILE *pFile; // [sp+14h] [bp-10h]
  int ret; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  dev->chain_num = 0;
  ret = get_hash_on_plug();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: get_hash_on_plug is 0x%x\n",
        "driver-btm-soc.c",
        1354,
        (const char *)_FUNCTION___14823,
        ret);
    fclose(pFile);
  }
  if ( ret >= 0 )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( ((ret >> i) & 1) != 0 )
      {
        dev->chain_exist[i] = 1;
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: !! chain[%d]is exist\n",
              "driver-btm-soc.c",
              1366,
              (const char *)_FUNCTION___14823,
              i);
          fclose(pFile_1);
        }
        ++dev->chain_num;
      }
      else
      {
        dev->chain_exist[i] = 0;
      }
    }
  }
  else if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: get_hash_on_plug functions error\n",
        "driver-btm-soc.c",
        1357,
        (const char *)_FUNCTION___14823);
    fclose(pFile_0);
  }
}

//----- (0002447C) --------------------------------------------------------
int check_fan()
{
  unsigned int fan_speed; // [sp+10h] [bp-14h] BYREF
  unsigned __int8 fan_id; // [sp+17h] [bp-Dh] BYREF
  FILE *pFile; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  fan_id = 0;
  dev->fan_speed_top1 = 0;
  dev->fan_speed_low1 = 0;
  for ( i = 0; ; ++i )
  {
    if ( i > 7 )
      return 1;
    if ( get_fan_speed(&fan_id, &fan_speed) != -1 )
    {
      dev->fan_speed_value[fan_id] = 120 * fan_speed;
      if ( !fan_speed || dev->fan_exist[fan_id] )
      {
        if ( !fan_speed && dev->fan_exist[fan_id] == 1 )
        {
          dev->fan_exist[fan_id] = 0;
          --dev->fan_num;
          dev->fan_exist_map &= ~(1 << fan_id);
        }
      }
      else
      {
        dev->fan_exist[fan_id] = 1;
        ++dev->fan_num;
        dev->fan_exist_map |= 1 << fan_id;
      }
      if ( dev->fan_speed_top1 < dev->fan_speed_value[fan_id] )
        dev->fan_speed_top1 = dev->fan_speed_value[fan_id];
      if ( dev->fan_speed_low1 > dev->fan_speed_value[fan_id] && dev->fan_speed_value[fan_id] || !dev->fan_speed_low1 )
        dev->fan_speed_low1 = dev->fan_speed_value[fan_id];
      if ( dev->fan_speed_value[fan_id] <= 0x1F4 && dev->fan_exist[fan_id] == 1 )
        break;
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: check FAN Speed Error: fan[%d] speed=%d\n",
        "driver-btm-soc.c",
        1410,
        (const char *)_FUNCTION___14835,
        fan_id,
        dev->fan_speed_value[fan_id]);
    fclose(pFile);
  }
  return 0;
}

//----- (000248EC) --------------------------------------------------------
int __cdecl get_index_from_high_pll(int freq)
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  unsigned int i; // [sp+14h] [bp-8h]

  for ( i = 0;
        i <= 0x20
     && freq_high_pll_1391[i].freq != freq
     && (freq_high_pll_1391[i].freq <= freq || freq_high_pll_1391[i - 1].freq >= freq);
        ++i )
  {
    ;
  }
  if ( i != 33 )
    return i;
  if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: high freq index set error,return default pll index\n",
        "driver-btm-soc.c",
        1633,
        (const char *)_FUNCTION___14903);
    fclose(pFile);
  }
  return get_index_from_high_pll(200);
}

//----- (00024A78) --------------------------------------------------------
int get_eeprom_total_hash_rate()
{
  uint32_t hashrate_tmp; // [sp+Ch] [bp-18h] BYREF
  FILE *pFile; // [sp+10h] [bp-14h]
  int work_mode; // [sp+14h] [bp-10h]
  int total_rate; // [sp+18h] [bp-Ch]
  int chain; // [sp+1Ch] [bp-8h]

  total_rate = 0;
  hashrate_tmp = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      work_mode = !opt_bitmain_economic_mode;
      eeprom_get_hash_rate(chain, work_mode, &hashrate_tmp);
      total_rate += hashrate_tmp;
      usleep(0x186A0u);
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: total rate = %d\n",
        "driver-btm-soc.c",
        1678,
        (const char *)_FUNCTION___14922,
        total_rate);
    fclose(pFile);
  }
  return total_rate;
}

//----- (00024BD8) --------------------------------------------------------
int get_fixed_total_hash_rate()
{
  int total_rate; // [sp+0h] [bp-Ch]

  total_rate = get_eeprom_total_hash_rate();
  if ( opt_bitmain_economic_mode )
    return 500 * (total_rate / 500);
  else
    return 1000 * (total_rate / 1000);
}

//----- (00024C74) --------------------------------------------------------
int get_total_rate()
{
  int total_rate; // [sp+0h] [bp-Ch]
  int chain; // [sp+4h] [bp-8h]

  total_rate = 0;
  if ( freq_mode == 2 )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
        total_rate = (int)(float)((float)total_rate + (float)((float)(freq_from_board[chain] * 48.0) * 672.0));
    }
    return total_rate / 1000;
  }
  else
  {
    if ( !g_total_hashrate )
      g_total_hashrate = get_fixed_total_hash_rate();
    return g_total_hashrate;
  }
}

//----- (00024D94) --------------------------------------------------------
int get_ideal_hash_rate_fixed()
{
  if ( !g_ideal_hashrate_fixed )
    g_ideal_hashrate_fixed = get_total_rate();
  return g_ideal_hashrate_fixed;
}

//----- (00024DD8) --------------------------------------------------------
int get_ideal_hash_rate()
{
  int total_rate; // [sp+0h] [bp-Ch]
  int chain; // [sp+4h] [bp-8h]

  total_rate = 0;
  if ( freq_mode == 2 )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
        total_rate = (int)(float)((float)total_rate + (float)((float)(freq_from_board[chain] * 48.0) * 672.0));
    }
    return total_rate / 1000;
  }
  else
  {
    if ( !g_ideal_hashrate )
      g_ideal_hashrate = get_eeprom_total_hash_rate();
    return g_ideal_hashrate;
  }
}

//----- (00024EF8) --------------------------------------------------------
uint32_t do_get_ideal_max_hash_rate()
{
  uint32_t freq_one_chain[48]; // [sp+0h] [bp-D4h] BYREF
  int work_mode; // [sp+C0h] [bp-14h]
  int i; // [sp+C4h] [bp-10h]
  int chain; // [sp+C8h] [bp-Ch]
  uint32_t total_rate; // [sp+CCh] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      work_mode = !opt_bitmain_economic_mode;
      eeprom_get_freq(chain, work_mode, freq_one_chain, 48);
      for ( i = 0; i <= 47; ++i )
        total_rate += 672 * freq_one_chain[i];
    }
  }
  return total_rate / 0x3E8;
}

//----- (00024FF8) --------------------------------------------------------
int get_ideal_hash_rate_max()
{
  int total_rate; // [sp+0h] [bp-Ch]
  int chain; // [sp+4h] [bp-8h]

  total_rate = 0;
  if ( freq_mode == 2 )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
        total_rate = (int)(float)((float)total_rate + (float)((float)(freq_from_board[chain] * 48.0) * 672.0));
    }
    return total_rate / 1000;
  }
  else
  {
    if ( !g_ideal_hashrate_max )
      g_ideal_hashrate_max = do_get_ideal_max_hash_rate();
    return g_ideal_hashrate_max;
  }
}

//----- (00025110) --------------------------------------------------------
int __cdecl convirt_total_rate(int totalRate)
{
  return totalRate;
}

//----- (00025134) --------------------------------------------------------
void clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  reg_value_buf.p_wr = 0;
  reg_value_buf.p_rd = 0;
  reg_value_buf.reg_value_num = 0;
  pthread_mutex_unlock(&reg_mutex);
}

//----- (00025190) --------------------------------------------------------
void __cdecl suffix_string_soc(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits, bool display)
{
  double v5; // r0
  double v6; // r0
  double v7; // d7
  unsigned __int8 suffix[2]; // [sp+28h] [bp-48h] BYREF
  int ndigits; // [sp+2Ch] [bp-44h]
  uint64_t giga; // [sp+30h] [bp-40h]
  uint64_t mega; // [sp+38h] [bp-38h]
  uint64_t kilo; // [sp+40h] [bp-30h]
  double dkilo; // [sp+48h] [bp-28h]
  double dval; // [sp+50h] [bp-20h]
  bool decimal; // [sp+5Fh] [bp-11h]

  dkilo = 1000.0;
  kilo = 1000LL;
  mega = (unsigned int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377];
  giga = 1000000000LL;
  *(_WORD *)suffix = 0;
  decimal = 1;
  if ( val < 0x3B9ACA00 )
  {
    if ( val < mega )
    {
      v5 = (double)val;
      if ( val >= kilo )
      {
        dval = (double)val / dkilo;
        strcpy((char *)suffix, "K");
      }
      else
      {
        dval = (double)val;
        decimal = 0;
      }
    }
    else
    {
      v5 = (double)(val / kilo);
      dval = v5 / dkilo;
      strcpy((char *)suffix, "M");
    }
  }
  else
  {
    v5 = (double)(val / mega);
    dval = v5 / dkilo;
    strcpy((char *)suffix, "G");
  }
  if ( sigdigits )
  {
    if ( dval <= 0.0 )
    {
      v7 = 0.0;
    }
    else
    {
      v6 = log10(v5);
      floor(v6);
      v7 = dval;
    }
    ndigits = (int)((double)(sigdigits - 1) - v7);
    if ( display )
      snprintf((char *)buf, bufsiz, "%*.*f%s", sigdigits + 1, ndigits, dval, (const char *)suffix);
    else
      snprintf((char *)buf, bufsiz, "%*.*f", sigdigits + 1, ndigits, dval);
  }
  else if ( decimal )
  {
    snprintf((char *)buf, bufsiz, "%.3g%s", dval, (const char *)suffix);
  }
  else
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)dval, (const char *)suffix);
  }
}

//----- (00025440) --------------------------------------------------------
bool __cdecl check_single_asic_reg(unsigned int reg)
{
  unsigned __int8 rega; // [sp+14h] [bp-30h]
  unsigned __int8 reg_buf[7]; // [sp+18h] [bp-2Ch] BYREF
  FILE *pFile; // [sp+20h] [bp-24h]
  unsigned __int8 crc_value; // [sp+26h] [bp-1Eh]
  unsigned __int8 reg_address; // [sp+27h] [bp-1Dh]
  int reg_value; // [sp+28h] [bp-1Ch]
  unsigned int reg_value_num; // [sp+2Ch] [bp-18h]
  int reg_processed_counter; // [sp+30h] [bp-14h]
  int not_reg_data_time; // [sp+34h] [bp-10h]
  int j; // [sp+38h] [bp-Ch]
  int i; // [sp+3Ch] [bp-8h]

  rega = reg;
  not_reg_data_time = 0;
  reg_value_num = 0;
  memset(reg_buf, 0, sizeof(reg_buf));
  reg_value = 0;
  reg_address = 0;
  reg_processed_counter = 0;
  crc_value = 0;
rerun_all:
  clear_register_value_buf();
  for ( i = 0; i <= 15; ++i )
  {
    reg_processed_counter = 0;
    if ( dev->chain_exist[i] == 1 )
    {
      read_asic_register(i, 0, 0, rega);
      while ( not_reg_data_time <= 2 )
      {
        cgsleep_ms(300);
        pthread_mutex_lock(&reg_mutex);
        reg_value_num = reg_value_buf.reg_value_num;
        if ( (reg_value_buf.reg_value_num > 0x1FE || reg_value_buf.p_rd > 0x1FE) && not_reg_data_time <= 2 )
        {
          ++not_reg_data_time;
          pthread_mutex_unlock(&reg_mutex);
          goto rerun_all;
        }
        if ( not_reg_data_time == 3 )
        {
          pthread_mutex_unlock(&reg_mutex);
          return 1;
        }
        if ( reg_value_num )
        {
          reg_processed_counter += reg_value_num;
          if ( reg_processed_counter > 600 )
          {
            pthread_mutex_unlock(&reg_mutex);
            return 0;
          }
          not_reg_data_time = 0;
          for ( j = 0; reg_value_num > j; ++j )
          {
            if ( i == reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number )
            {
              reg_buf[3] = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
              reg_buf[2] = BYTE1(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
              reg_buf[1] = BYTE2(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
              reg_buf[0] = HIBYTE(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
              reg_buf[4] = reg_value_buf.reg_buffer[reg_value_buf.p_rd].chip_address;
              reg_buf[5] = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_address;
              reg_buf[6] = 0;
              crc_value = CRC5(reg_buf, 0x33u);
              if ( crc_value == reg_value_buf.reg_buffer[reg_value_buf.p_rd].crc )
              {
                reg_address = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_address;
                reg_value = *(&reg_value_buf.p_rd + 2 * ++reg_value_buf.p_rd);
                --reg_value_buf.reg_value_num;
                if ( reg_value_buf.p_rd > 0x1FE )
                  reg_value_buf.p_rd = 0;
                g_asic_data[i][reg_address] = reg_value;
                g_asic_data_status[i][reg_address] = 1;
              }
              else
              {
                if ( log_level > 4 )
                {
                  print_crt_time_to_file(log_file, 4u);
                  pFile = fopen((const char *)log_file, "a+");
                  if ( pFile )
                    fprintf(
                      pFile,
                      "%s:%d:%s: crc is 0x%x, but it should be 0x%x\n",
                      "driver-btm-soc.c",
                      2767,
                      (const char *)_FUNCTION___15236,
                      crc_value,
                      reg_value_buf.reg_buffer[reg_value_buf.p_rd].crc);
                  fclose(pFile);
                }
                ++reg_value_buf.p_rd;
                --reg_value_buf.reg_value_num;
                if ( reg_value_buf.p_rd == 511 )
                  reg_value_buf.p_rd = 0;
              }
            }
            else
            {
              ++reg_value_buf.p_rd;
              --reg_value_buf.reg_value_num;
              if ( reg_value_buf.p_rd > 0x1FE )
                reg_value_buf.p_rd = 0;
            }
          }
        }
        else
        {
          cgsleep_ms(100);
          ++not_reg_data_time;
        }
        pthread_mutex_unlock(&reg_mutex);
      }
      not_reg_data_time = 0;
      clear_register_value_buf();
    }
  }
  return 1;
}

//----- (00025A84) --------------------------------------------------------
bool __cdecl check_asic_reg_oneChain(int chainIndex, unsigned int reg, bool core_response)
{
  double v3; // d0
  int v5; // r0
  int v6; // r6
  unsigned __int8 displayed_rate_asic[32]; // [sp+2Ch] [bp-A8h] BYREF
  unsigned __int8 rate_buf[10]; // [sp+4Ch] [bp-88h] BYREF
  unsigned __int8 reg_buf[7]; // [sp+58h] [bp-7Ch] BYREF
  FILE *pFile_8; // [sp+60h] [bp-74h]
  FILE *pFile; // [sp+64h] [bp-70h]
  FILE *pFile_7; // [sp+68h] [bp-6Ch]
  FILE *pFile_0; // [sp+6Ch] [bp-68h]
  FILE *pFile_6; // [sp+70h] [bp-64h]
  FILE *pFile_5; // [sp+74h] [bp-60h]
  uint64_t temp_hash_rate; // [sp+78h] [bp-5Ch]
  FILE *pFile_2; // [sp+80h] [bp-54h]
  FILE *pFile_4; // [sp+84h] [bp-50h]
  FILE *pFile_3; // [sp+88h] [bp-4Ch]
  FILE *pFile_1; // [sp+8Ch] [bp-48h]
  unsigned int reg_value; // [sp+90h] [bp-44h]
  int i; // [sp+94h] [bp-40h]
  unsigned int reg_value_num; // [sp+98h] [bp-3Ch]
  int ii; // [sp+9Ch] [bp-38h]
  unsigned __int8 reg_address; // [sp+A3h] [bp-31h]
  int reg_processed_counter; // [sp+A4h] [bp-30h]
  uint64_t tmp_rate; // [sp+A8h] [bp-2Ch]
  int read_num; // [sp+B4h] [bp-20h]
  int not_reg_data_time; // [sp+B8h] [bp-1Ch]
  int j; // [sp+BCh] [bp-18h]

  not_reg_data_time = 0;
  reg_value_num = 0;
  memset(reg_buf, 0, sizeof(reg_buf));
  read_num = 0;
  tmp_rate = 0LL;
  reg_processed_counter = 0;
  reg_address = -1;
rerun_all:
  if ( !core_response )
    clear_register_value_buf();
  tmp_rate = 0LL;
  i = chainIndex;
  reg_processed_counter = 0;
  read_num = 0;
  if ( dev->chain_exist[chainIndex] == 1 )
  {
    tmp_rate = 0LL;
    if ( !core_response )
      read_asic_register(i, 1u, 0, reg);
    if ( !reg )
      dev->chain_asic_num[i] = 0;
    while ( not_reg_data_time <= 2 )
    {
      cgsleep_ms(300);
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf.reg_value_num;
      if ( (reg_value_buf.reg_value_num > 0x1FE || reg_value_buf.p_rd > 0x1FE) && not_reg_data_time <= 2 )
      {
        ++not_reg_data_time;
        pthread_mutex_unlock(&reg_mutex);
        goto rerun_all;
      }
      if ( not_reg_data_time == 3 )
      {
        pthread_mutex_unlock(&reg_mutex);
        return 1;
      }
      if ( reg_value_num )
      {
        reg_processed_counter += reg_value_num;
        if ( reg_processed_counter > 600 )
        {
          pthread_mutex_unlock(&reg_mutex);
          return 0;
        }
        not_reg_data_time = 0;
        for ( j = 0; reg_value_num > j; ++j )
        {
          if ( i == reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number )
          {
            reg_buf[3] = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
            reg_buf[2] = BYTE1(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_buf[1] = BYTE2(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_buf[0] = HIBYTE(reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value);
            reg_address = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_address;
            reg_value = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
            if ( CRC5(reg_buf, 0x33u) == reg_value_buf.reg_buffer[reg_value_buf.p_rd].crc )
            {
              ++reg_value_buf.p_rd;
              --reg_value_buf.reg_value_num;
              if ( reg_value_buf.p_rd > 0x1FE )
                reg_value_buf.p_rd = 0;
              switch ( reg_address )
              {
                case 0u:
                  if ( HIWORD(reg_value) == 5015 )
                    ++dev->chain_asic_num[i];
                  if ( log_level > 4 )
                  {
                    print_crt_time_to_file(log_file, 4u);
                    pFile_0 = fopen((const char *)log_file, "a+");
                    if ( pFile_0 )
                      fprintf(
                        pFile_0,
                        "%s:%d:%s: chain[%02d] num[%d]: the asic CHIP_ADDRESS is 0x%08x\n",
                        "driver-btm-soc.c",
                        2932,
                        (const char *)_FUNCTION___15270,
                        i,
                        j,
                        reg_value);
                    fclose(pFile_0);
                  }
                  break;
                case 4u:
                  temp_hash_rate = 0LL;
                  if ( ++read_num <= 48 )
                  {
                    for ( ii = 0; ii <= 3; ++ii )
                      sprintf((char *)&rate_buf[2 * ii], "%02x", reg_buf[ii]);
                    temp_hash_rate = (__int64)strtol((const char *)rate_buf, 0, 16) << 24;
                    tmp_rate += temp_hash_rate;
                    suffix_string_soc(temp_hash_rate, displayed_rate_asic, 0x20u, 6, 0);
                    if ( log_level > 3 )
                    {
                      print_crt_time_to_file(log_file, 3u);
                      pFile_5 = fopen((const char *)log_file, "a+");
                      if ( pFile_5 )
                        fprintf(
                          pFile_5,
                          "%s:%d:%s: Asic[%02d]=%s ",
                          "driver-btm-soc.c",
                          2971,
                          (const char *)_FUNCTION___15270,
                          read_num,
                          (const char *)displayed_rate_asic);
                      fclose(pFile_5);
                    }
                    v6 = read_num - 1;
                    atof((const char *)displayed_rate_asic);
                    chain_asic_RT[i][v6] = v3;
                    if ( ((read_num & 7) == 0 || read_num == 48) && log_level > 3 )
                    {
                      print_crt_time_to_file(log_file, 3u);
                      pFile_6 = fopen((const char *)log_file, "a+");
                      if ( pFile_6 )
                        fprintf(pFile_6, "%s:%d:%s: \n", "driver-btm-soc.c", 2977, (const char *)_FUNCTION___15270);
                      fclose(pFile_6);
                    }
                  }
                  break;
                case 8u:
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_2 = fopen((const char *)log_file, "a+");
                    if ( pFile_2 )
                      fprintf(
                        pFile_2,
                        "%s:%d:%s: chain[%d]: the asic freq is 0x%x\n",
                        "driver-btm-soc.c",
                        2938,
                        (const char *)_FUNCTION___15270,
                        i,
                        reg_value);
                    fclose(pFile_2);
                  }
                  break;
                case 0x10u:
                  ++read_num;
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_4 = fopen((const char *)log_file, "a+");
                    if ( pFile_4 )
                      fprintf(
                        pFile_4,
                        "%s:%d:%s: chain[%02d] chip[%02d]: the asic HASH_COUNTING_NUMBER is 0x%08x\n",
                        "driver-btm-soc.c",
                        2946,
                        (const char *)_FUNCTION___15270,
                        i,
                        read_num,
                        reg_value);
                    fclose(pFile_4);
                  }
                  break;
                case 0x14u:
                  ++read_num;
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_3 = fopen((const char *)log_file, "a+");
                    if ( pFile_3 )
                      fprintf(
                        pFile_3,
                        "%s:%d:%s: chain[%02d] chip[%02d]: the asic TICKET_MASK is 0x%08x\n",
                        "driver-btm-soc.c",
                        2942,
                        (const char *)_FUNCTION___15270,
                        i,
                        read_num,
                        reg_value);
                    fclose(pFile_3);
                  }
                  break;
                case 0x18u:
                  if ( log_level > 4 )
                  {
                    print_crt_time_to_file(log_file, 4u);
                    pFile_1 = fopen((const char *)log_file, "a+");
                    if ( pFile_1 )
                      fprintf(
                        pFile_1,
                        "%s:%d:%s: chain[%02d] chip[%02d]: the misc is 0x%08x\n",
                        "driver-btm-soc.c",
                        2935,
                        (const char *)_FUNCTION___15270,
                        i,
                        read_num,
                        reg_value);
                    fclose(pFile_1);
                  }
                  break;
                default:
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_7 = fopen((const char *)log_file, "a+");
                    if ( pFile_7 )
                      fprintf(
                        pFile_7,
                        "%s:%d:%s: chain[%02d] num[%d]: the register  %02x value is 0x%08x\n",
                        "driver-btm-soc.c",
                        2982,
                        (const char *)_FUNCTION___15270,
                        i,
                        j,
                        reg_address,
                        reg_value);
                    fclose(pFile_7);
                  }
                  break;
              }
            }
            else
            {
              if ( log_level > 4 )
              {
                print_crt_time_to_file(log_file, 4u);
                pFile = fopen((const char *)log_file, "a+");
                if ( pFile )
                {
                  v5 = CRC5(reg_buf, 0x23u);
                  fprintf(
                    pFile,
                    "%s:%d:%s: crc is 0x%x, but it should be 0x%x\n",
                    "driver-btm-soc.c",
                    2908,
                    (const char *)_FUNCTION___15270,
                    v5,
                    reg_value_buf.reg_buffer[reg_value_buf.p_rd].crc);
                }
                fclose(pFile);
              }
              ++reg_value_buf.p_rd;
              --reg_value_buf.reg_value_num;
              if ( reg_value_buf.p_rd > 0x1FE )
                reg_value_buf.p_rd = 0;
            }
          }
          else
          {
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
          }
        }
        if ( !reg_address && dev->chain_asic_num[i] == 48 )
        {
          pthread_mutex_unlock(&reg_mutex);
          break;
        }
      }
      else
      {
        cgsleep_ms(100);
        ++not_reg_data_time;
      }
      pthread_mutex_unlock(&reg_mutex);
    }
    not_reg_data_time = 0;
    if ( !reg_address && dev->chain_asic_num[i] > (unsigned int)dev->max_asic_num_in_one_chain )
      dev->max_asic_num_in_one_chain = dev->chain_asic_num[i];
    if ( read_num == dev->chain_asic_num[i] )
    {
      rate[i] = tmp_rate;
      suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
      rate_error[i] = 0;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(
            pFile_8,
            "%s:%d:%s: chain %d hashrate is %s\n",
            "driver-btm-soc.c",
            3023,
            (const char *)_FUNCTION___15270,
            i,
            (const char *)displayed_rate[i]);
        fclose(pFile_8);
      }
    }
    if ( (!read_num || status_error) && (++rate_error[i] > 3 || status_error) )
    {
      rate[i] = 0LL;
      suffix_string_soc(rate[i], displayed_rate[i], 0x20u, 6, 0);
    }
    clear_register_value_buf();
  }
  return 1;
}
// 26024: control flows out of bounds to 26028
// 265EC: variable 'v3' is possibly undefined

//----- (00026AD4) --------------------------------------------------------
int __cdecl calculate_core_number(unsigned int actual_core_number)
{
  unsigned int core_number; // [sp+Ch] [bp-8h]

  core_number = 1;
  if ( !actual_core_number )
    return 0;
  while ( actual_core_number > core_number )
    core_number *= 2;
  return core_number;
}

//----- (00026B30) --------------------------------------------------------
void __cdecl set_addr_one_chain(const uint8_t chain)
{
  FILE *pFile; // [sp+1Ch] [bp-10h]
  unsigned __int8 chip_addr; // [sp+23h] [bp-9h]
  int j; // [sp+24h] [bp-8h]

  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: ----- %d,-- interval %d\n",
        "driver-btm-soc.c",
        3097,
        (const char *)_FUNCTION___15325,
        chain,
        dev->addrInterval);
    fclose(pFile);
  }
  if ( dev->chain_exist[chain] == 1 && dev->chain_asic_num[chain] )
  {
    chip_addr = 0;
    chain_inactive(chain);
    cgsleep_ms(30);
    chain_inactive(chain);
    cgsleep_ms(30);
    chain_inactive(chain);
    cgsleep_ms(30);
    for ( j = 0; j < 256 / dev->addrInterval; ++j )
    {
      set_address(chain, 0, chip_addr);
      cgsleep_ms(2);
      chip_addr += dev->addrInterval;
      cgsleep_ms(50);
    }
  }
}

//----- (00026D1C) --------------------------------------------------------
void software_set_address()
{
  uint8_t i; // [sp+7h] [bp-5h]

  dev->addrInterval = 5;
  for ( i = 0; i <= 0xFu; ++i )
    set_addr_one_chain(i);
}

//----- (00026D7C) --------------------------------------------------------
void __cdecl set_baud(int baud, int no_use)
{
  int chain; // [sp+Ch] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
    set_baud_one_chain(baud, 0, chain);
  cgsleep_us(50000LL);
  set_baud_fpga(baud);
  dev->baud = baud;
}

//----- (00026E04) --------------------------------------------------------
void init_uart_baud()
{
  set_baud((int)&asic_core_nonce_num[2][101][208], 1);
}

//----- (00026E24) --------------------------------------------------------
void init_led()
{
  unsigned __int8 cmd[100]; // [sp+4h] [bp-68h] BYREF

  memset(cmd, 0, sizeof(cmd));
  sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
  system((const char *)cmd);
  sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
  system((const char *)cmd);
}

//----- (00026EA0) --------------------------------------------------------
void set_led()
{
  STATUS_CODE error_type; // r0
  unsigned __int8 cmd[100]; // [sp+0h] [bp-6Ch] BYREF
  STATUS_CODE stopcode; // [sp+64h] [bp-8h]

  memset(cmd, 0, sizeof(cmd));
  blink_15352 = !blink_15352;
  error_type = get_error_type();
  stopcode = error_type;
  if ( error_type == STATUS_OK )
  {
    sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/gpio/gpio941/value");
    system((const char *)cmd);
    sprintf((char *)cmd, "echo %d > %s", blink_15352, "/sys/class/gpio/gpio942/value");
    system((const char *)cmd);
  }
  else if ( error_type )
  {
    if ( (unsigned int)error_type <= ERROR_UNKOWN_STATUS )
    {
      sprintf((char *)cmd, "echo %d > %s", 0, "/sys/class/gpio/gpio942/value");
      system((const char *)cmd);
      sprintf((char *)cmd, "echo %d > %s", blink_15352, "/sys/class/gpio/gpio941/value");
      system((const char *)cmd);
    }
  }
}

//----- (00026FF0) --------------------------------------------------------
void *__cdecl __noreturn heart_beat_func_one_chain(void *arg)
{
  pthread_t v1; // r0
  FILE *pFile; // [sp+10h] [bp-Ch]

  v1 = pthread_self();
  pthread_detach(v1);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: for chain %d\n", "driver-btm-soc.c", 3208, (const char *)_FUNCTION___15367, arg);
    fclose(pFile);
  }
  while ( 1 )
  {
    pic_set_heart_beat((uint8_t)arg);
    sleep(0xAu);
  }
}

//----- (000270C4) --------------------------------------------------------
void *__cdecl pic_heart_beat_func(void *arg)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i]
      && pthread_create(&dev->heart_beat_id[i], 0, (void *(*)(void *))heart_beat_func_one_chain, (void *)i) )
    {
      perror("create pthread failed in pic_heart_beat_func");
    }
  }
  return 0;
}

//----- (0002717C) --------------------------------------------------------
int __cdecl get_asic_nonce_num(int chain, int asic, int timeslice)
{
  int nonce; // [sp+14h] [bp-10h]
  int index; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  nonce = 0;
  for ( i = 1; i <= timeslice; ++i )
  {
    if ( nonce_times % 60 - i < 0 )
      index = nonce_times % 60 - i + 60;
    else
      index = nonce_times % 60 - i;
    nonce += LODWORD(nonce_num[chain][asic][index]);
  }
  return nonce;
}

//----- (00027324) --------------------------------------------------------
void __cdecl get_lastn_nonce_num(unsigned __int8 *dest, int n)
{
  int asic_nonce_num; // r0
  int v3; // r0
  size_t v4; // r4
  size_t v5; // r0
  unsigned __int8 xtime[2048]; // [sp+10h] [bp-854h] BYREF
  unsigned __int8 tmp[20]; // [sp+810h] [bp-54h] BYREF
  FILE *pFile_4; // [sp+824h] [bp-40h]
  FILE *pFile_3; // [sp+828h] [bp-3Ch]
  FILE *pFile_6; // [sp+82Ch] [bp-38h]
  FILE *pFile_5; // [sp+830h] [bp-34h]
  FILE *pFile_2; // [sp+834h] [bp-30h]
  FILE *pFile_1; // [sp+838h] [bp-2Ch]
  FILE *pFile_0; // [sp+83Ch] [bp-28h]
  FILE *pFile; // [sp+840h] [bp-24h]
  int len; // [sp+844h] [bp-20h]
  FILE *pFile_7; // [sp+848h] [bp-1Ch]
  FILE *pFile_8; // [sp+84Ch] [bp-18h]
  int j; // [sp+850h] [bp-14h]
  int i; // [sp+854h] [bp-10h]

  j = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      *(_DWORD *)xtime = 123;
      memset(&xtime[4], 0, 0x7FCu);
      memset(tmp, 0, sizeof(tmp));
      len = snprintf((char *)tmp, 0x14u, "Chain%d:{", i + 1);
      if ( (unsigned int)len > 0x14 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3292, (const char *)_FUNCTION___15398);
        fclose(pFile);
      }
      len = 2047 - strlen((const char *)xtime);
      if ( (unsigned int)len <= 0x13 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3297, (const char *)_FUNCTION___15398);
        fclose(pFile_0);
      }
      strncat((char *)xtime, (const char *)tmp, len);
      asic_nonce_num = get_asic_nonce_num(i, 0, n);
      len = snprintf((char *)tmp, 0x14u, "N%d=%d", 0, asic_nonce_num);
      if ( (unsigned int)len > 0x14 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3303, (const char *)_FUNCTION___15398);
        fclose(pFile_1);
      }
      len = 2047 - strlen((const char *)xtime);
      if ( (unsigned int)len <= 0x13 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3308, (const char *)_FUNCTION___15398);
        fclose(pFile_2);
      }
      strncat((char *)xtime, (const char *)tmp, len);
      for ( j = 1; j < dev->max_asic_num_in_one_chain; ++j )
      {
        v3 = get_asic_nonce_num(i, j, n);
        len = snprintf((char *)tmp, 0x14u, ",N%d=%d", j, v3);
        if ( (unsigned int)len > 0x14 && log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(pFile_3, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3317, (const char *)_FUNCTION___15398);
          fclose(pFile_3);
        }
        len = 2047 - strlen((const char *)xtime);
        if ( (unsigned int)len <= 0x13 && log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_4 = fopen((const char *)log_file, "a+");
          if ( pFile_4 )
            fprintf(pFile_4, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3322, (const char *)_FUNCTION___15398);
          fclose(pFile_4);
        }
        strncat((char *)xtime, (const char *)tmp, len);
      }
      len = 2047 - strlen((const char *)xtime);
      if ( len <= 1 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(pFile_5, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3329, (const char *)_FUNCTION___15398);
        fclose(pFile_5);
      }
      strncat((char *)xtime, "},", len);
      v4 = -strlen((const char *)dest);
      len = v4 - strlen((const char *)xtime) + 4095;
      if ( len <= 0 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(pFile_6, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3335, (const char *)_FUNCTION___15398);
        fclose(pFile_6);
      }
      strncat((char *)dest, (const char *)xtime, len);
    }
  }
  if ( strlen((const char *)dest) < 0x1000 )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
      {
        v5 = strlen((const char *)dest);
        fprintf(pFile_8, "%s:%d:%s: len=%u\n", "driver-btm-soc.c", 3346, (const char *)_FUNCTION___15398, v5);
      }
      fclose(pFile_8);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_7 = fopen((const char *)log_file, "a+");
    if ( pFile_7 )
      fprintf(pFile_7, "%s:%d:%s: string too long\n", "driver-btm-soc.c", 3342, (const char *)_FUNCTION___15398);
    fclose(pFile_7);
  }
  dest[strlen((const char *)dest) - 1] = 0;
}

//----- (00027BF4) --------------------------------------------------------
uint32_t __cdecl get_domain_nounce_number(uint32_t chain, uint32_t domain)
{
  int j; // [sp+1Ch] [bp-10h]
  int i; // [sp+20h] [bp-Ch]
  uint32_t nounc_num; // [sp+24h] [bp-8h]

  nounc_num = 0;
  for ( i = domain & 0xFFFFFFFC; i < (int)((domain & 0xFFFFFFFC) + 4); ++i )
  {
    for ( j = 168 * (domain & 3); j < (int)(168 * (domain & 3) + 168); ++j )
      nounc_num += calc_nonce_info.chain_asic_core_nonce_num[chain][i][j];
  }
  return nounc_num;
}

//----- (00027CF8) --------------------------------------------------------
void dump_nonce_info_all_domain()
{
  FILE *pFile_2; // [sp+0h] [bp-2Ch]
  FILE *pFile_1; // [sp+4h] [bp-28h]
  FILE *pFile_3; // [sp+8h] [bp-24h]
  FILE *pFile_0; // [sp+Ch] [bp-20h]
  FILE *pFile; // [sp+10h] [bp-1Ch]
  uint32_t nonce_num; // [sp+18h] [bp-14h]
  uint32_t total_big_domain_nonce_num; // [sp+1Ch] [bp-10h]
  int domain_id; // [sp+20h] [bp-Ch]
  int chain_id; // [sp+24h] [bp-8h]

  if ( log_level > 3 )
  {
    pFile = fopen("/var/log/hash_rate", "a+");
    if ( pFile )
      fwrite("\n dump domain nonce number...\n", 1u, 0x1Eu, pFile);
    fclose(pFile);
  }
  for ( chain_id = 0; chain_id <= 15; ++chain_id )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "Chain[%d]:\n", chain_id);
        fclose(pFile_0);
      }
      total_big_domain_nonce_num = 0;
      for ( domain_id = 0; domain_id <= 47; ++domain_id )
      {
        nonce_num = get_domain_nounce_number(chain_id, domain_id);
        if ( log_level > 3 )
        {
          pFile_1 = fopen("/var/log/hash_rate", "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "D[%02d]:%-10d ", domain_id, nonce_num);
          fclose(pFile_1);
        }
        total_big_domain_nonce_num += nonce_num;
        if ( (((_BYTE)domain_id + 1) & 3) == 0 )
        {
          if ( log_level > 3 )
          {
            pFile_2 = fopen("/var/log/hash_rate", "a+");
            if ( pFile_2 )
              fprintf(pFile_2, "D_BIG[%02d]:%-10d\n", domain_id / 4, total_big_domain_nonce_num);
            fclose(pFile_2);
          }
          total_big_domain_nonce_num = 0;
        }
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_3 )
          fputc(10, pFile_3);
        fclose(pFile_3);
      }
    }
  }
}

//----- (00027FA4) --------------------------------------------------------
int is_domain_unbalance()
{
  uint32_t domain_nounce_number; // r0
  unsigned __int64 v1; // r0
  FILE *pFile; // [sp+CCh] [bp-40h]
  uint64_t nonce_unbalance_threshold; // [sp+D0h] [bp-3Ch]
  uint64_t domain_nonce_avg; // [sp+D8h] [bp-34h]
  FILE *pFile_0; // [sp+E4h] [bp-28h]
  uint32_t core_domain_number; // [sp+E8h] [bp-24h]
  uint32_t domain_nonce_check_threshold; // [sp+ECh] [bp-20h]
  uint64_t chain_nonce_total; // [sp+F0h] [bp-1Ch]
  uint32_t core_domain; // [sp+F8h] [bp-14h]
  uint32_t chain; // [sp+FCh] [bp-10h]
  _DWORD v13[3]; // [sp+100h] [bp-Ch] BYREF

  domain_nonce_check_threshold = 5000;
  core_domain_number = 48;
  for ( chain = 0; chain <= 0xF; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      chain_nonce_total = 0LL;
      for ( core_domain = 0; core_domain < core_domain_number; ++core_domain )
      {
        domain_nounce_number = get_domain_nounce_number(chain, core_domain);
        v13[core_domain - 61] = domain_nounce_number;
        chain_nonce_total += (unsigned int)v13[core_domain - 61];
      }
      v1 = chain_nonce_total / core_domain_number;
      domain_nonce_avg = v1;
      nonce_unbalance_threshold = v1 >> 1;
      if ( v1 >= domain_nonce_check_threshold )
      {
        for ( core_domain = 0; core_domain < core_domain_number; ++core_domain )
        {
          if ( nonce_unbalance_threshold > (unsigned int)v13[core_domain - 61] )
          {
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile = fopen((const char *)log_file, "a+");
              if ( pFile )
                fprintf(
                  pFile,
                  "%s:%d:%s: Domain unbalance happened!\n",
                  "driver-btm-soc.c",
                  3459,
                  (const char *)_FUNCTION___15469);
              fclose(pFile);
            }
            return 1;
          }
        }
      }
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: No Domain unbalance happened.\n",
        "driver-btm-soc.c",
        3465,
        (const char *)_FUNCTION___15469);
    fclose(pFile_0);
  }
  return 0;
}

//----- (00028260) --------------------------------------------------------
void dump_nonce_info_all_asic()
{
  FILE *pFile_2; // [sp+0h] [bp-34h]
  FILE *pFile_1; // [sp+4h] [bp-30h]
  FILE *pFile_4; // [sp+8h] [bp-2Ch]
  FILE *pFile_3; // [sp+Ch] [bp-28h]
  FILE *pFile_0; // [sp+10h] [bp-24h]
  FILE *pFile; // [sp+14h] [bp-20h]
  uint32_t total_nonce_num; // [sp+1Ch] [bp-18h]
  uint32_t nounc_num; // [sp+20h] [bp-14h]
  int core_id; // [sp+24h] [bp-10h]
  int chip_id; // [sp+28h] [bp-Ch]
  int chain_id; // [sp+2Ch] [bp-8h]

  if ( log_level > 3 )
  {
    pFile = fopen("/var/log/hash_rate", "a+");
    if ( pFile )
      fwrite("\n dump asic nonce number...\n", 1u, 0x1Cu, pFile);
    fclose(pFile);
  }
  for ( chain_id = 0; chain_id <= 15; ++chain_id )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "Chain[%d]:\n", chain_id);
        fclose(pFile_0);
      }
      total_nonce_num = 0;
      for ( chip_id = 0; chip_id <= 47; ++chip_id )
      {
        nounc_num = 0;
        for ( core_id = 0; core_id < 672; ++core_id )
          nounc_num += calc_nonce_info.chain_asic_core_nonce_num[chain_id][chip_id][core_id];
        if ( log_level > 3 )
        {
          pFile_1 = fopen("/var/log/hash_rate", "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "ic[%02d]=%-10d", chip_id, nounc_num);
          fclose(pFile_1);
        }
        total_nonce_num += nounc_num;
        if ( (((_BYTE)chip_id + 1) & 3) == 0 && log_level > 3 )
        {
          pFile_2 = fopen("/var/log/hash_rate", "a+");
          if ( pFile_2 )
            fputc(10, pFile_2);
          fclose(pFile_2);
        }
      }
      if ( log_level > 3 )
      {
        pFile_3 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_3 )
          fprintf(pFile_3, "Chain[%d] total nonce number = %d\n", chain_id, total_nonce_num);
        fclose(pFile_3);
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen("/var/log/hash_rate", "a+");
        if ( pFile_4 )
          fputc(10, pFile_4);
        fclose(pFile_4);
      }
    }
  }
}

//----- (00028594) --------------------------------------------------------
void __cdecl dump_nonce_info_one_asic(uint32_t chain, uint32_t asic_id)
{
  FILE *pFile_1; // [sp+8h] [bp-1Ch]
  FILE *pFile_0; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile; // [sp+14h] [bp-10h]
  int core_id; // [sp+1Ch] [bp-8h]

  if ( log_level > 3 )
  {
    pFile = fopen("/var/log/hash_rate", "a+");
    if ( pFile )
      fprintf(pFile, "\n asic nonce number for chain[%d] asic[%d]...\n", chain, asic_id);
    fclose(pFile);
  }
  for ( core_id = 0; core_id < 672; ++core_id )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen("/var/log/hash_rate", "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "core[%03d]=%-8d", core_id, calc_nonce_info.chain_asic_core_nonce_num[chain][asic_id][core_id]);
      fclose(pFile_0);
    }
    if ( !((core_id + 1) % 10) && log_level > 3 )
    {
      pFile_1 = fopen("/var/log/hash_rate", "a+");
      if ( pFile_1 )
        fputc(10, pFile_1);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen("/var/log/hash_rate", "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
}

//----- (00028790) --------------------------------------------------------
void dump_nonce_info_all_core()
{
  int j; // [sp+0h] [bp-Ch]
  int i; // [sp+4h] [bp-8h]

  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      for ( j = 0; j <= 47; ++j )
        dump_nonce_info_one_asic(i, j);
    }
  }
}

//----- (0002882C) --------------------------------------------------------
void __cdecl save_test_ID(int testID)
{
  unsigned __int8 testnumStr[32]; // [sp+Ch] [bp-28h] BYREF
  FILE *fd; // [sp+2Ch] [bp-8h]

  fd = fopen("/tmp/testID", "wb");
  if ( fd )
  {
    memset(testnumStr, 0, sizeof(testnumStr));
    sprintf((char *)testnumStr, "%d", testID);
    fwrite(testnumStr, 1u, 0x20u, fd);
    fclose(fd);
  }
}

//----- (000288B4) --------------------------------------------------------
int read_test_ID()
{
  int testid; // [sp+Ch] [bp-30h] BYREF
  unsigned __int8 testnumStr[32]; // [sp+10h] [bp-2Ch] BYREF
  FILE *pFile; // [sp+30h] [bp-Ch]
  FILE *fd; // [sp+34h] [bp-8h]

  fd = fopen("/tmp/testID", "rb");
  if ( !fd )
    return 0;
  memset(testnumStr, 0, sizeof(testnumStr));
  fread(testnumStr, 1u, 0x20u, fd);
  fclose(fd);
  if ( testnumStr[0] != 48 || testnumStr[1] != 120 )
    return atoi((const char *)testnumStr);
  sscanf((const char *)testnumStr, "%x", &testid);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: receive test id :0x%x!\n",
        "driver-btm-soc.c",
        3606,
        (const char *)_FUNCTION___15555,
        testid);
    fclose(pFile);
  }
  return testid;
}

//----- (00028A00) --------------------------------------------------------
void __cdecl dump_asic_reg(uint32_t value)
{
  FILE *pFile; // [sp+1Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: dump asic reg!\n", "driver-btm-soc.c", 3634, (const char *)_FUNCTION___15562);
    fclose(pFile);
  }
  do_dump_asic_reg(BYTE2(value), BYTE1(value));
}

//----- (00028AD0) --------------------------------------------------------
void __cdecl dump_core_reg(uint32_t value)
{
  FILE *pFile; // [sp+1Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: dump core reg!\n", "driver-btm-soc.c", 3648, (const char *)_FUNCTION___15570);
    fclose(pFile);
  }
  do_dump_core_reg(BYTE2(value), BYTE1(value), (unsigned __int8)value);
}

//----- (00028BB0) --------------------------------------------------------
void process_TEST()
{
  double v0; // r0
  int v1; // r0
  unsigned __int8 log_level_str[32]; // [sp+14h] [bp-40h] BYREF
  FILE *pFile; // [sp+34h] [bp-20h]
  FILE *pFile_0; // [sp+38h] [bp-1Ch]
  FILE *pFile_1; // [sp+3Ch] [bp-18h]
  FILE *pFile_3; // [sp+40h] [bp-14h]
  FILE *fd; // [sp+44h] [bp-10h]
  FILE *pFile_2; // [sp+48h] [bp-Ch]
  int testID; // [sp+4Ch] [bp-8h]

  testID = read_test_ID();
  if ( testID )
  {
    save_test_ID(0);
    switch ( testID )
    {
      case 11:
        dump_nonce_info_all_core();
        break;
      case 12:
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: current voltage = %f\n",
              "driver-btm-soc.c",
              3677,
              (const char *)_FUNCTION___15576,
              voltage_15574);
          LODWORD(v0) = fclose(pFile);
        }
        set_working_voltage(v0);
        slowly_set_iic_power_to_working_voltage();
        voltage_15574 = voltage_15574 - 0.1;
        break;
      case 13:
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: current voltage = %f\n",
              "driver-btm-soc.c",
              3687,
              (const char *)_FUNCTION___15576,
              voltage_15577);
          LODWORD(v0) = fclose(pFile_0);
        }
        set_working_voltage(v0);
        slowly_set_iic_power_to_working_voltage();
        voltage_15577 = voltage_15577 + 0.1;
        break;
      case 14:
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(
              pFile_1,
              "%s:%d:%s: current pwm = %d\n",
              "driver-btm-soc.c",
              3697,
              (const char *)_FUNCTION___15576,
              pwm_15579);
          fclose(pFile_1);
        }
        set_pwm(pwm_15579);
        pwm_15579 -= 3;
        break;
      default:
        if ( testID != 15 && testID != 16 )
        {
          if ( testID == 17 )
          {
            if ( log_level > 1 )
            {
              print_crt_time_to_file(log_file, 1u);
              pFile_2 = fopen((const char *)log_file, "a+");
              if ( pFile_2 )
                fprintf(
                  pFile_2,
                  "%s:%d:%s: try to set log level...\n",
                  "driver-btm-soc.c",
                  3712,
                  (const char *)_FUNCTION___15576);
              fclose(pFile_2);
            }
            fd = fopen("/etc/config/log_level", "rb");
            if ( fd )
            {
              memset(log_level_str, 0, sizeof(log_level_str));
              fread(log_level_str, 1u, 0x20u, fd);
              fclose(fd);
              v1 = atoi((const char *)log_level_str);
              set_log_level(v1);
              if ( log_level > 1 )
              {
                print_crt_time_to_file(log_file, 1u);
                pFile_3 = fopen((const char *)log_file, "a+");
                if ( pFile_3 )
                  fprintf(
                    pFile_3,
                    "%s:%d:%s: log level set to %d\n",
                    "driver-btm-soc.c",
                    3724,
                    (const char *)_FUNCTION___15576,
                    log_level);
                fclose(pFile_3);
              }
            }
          }
          else if ( testID != 18 && testID != 19 )
          {
            if ( testID == 20 )
            {
              dump_all_asic_reg();
            }
            else if ( (testID & 0xFF000000) == -1509949440 )
            {
              dump_asic_reg(testID);
            }
            else if ( (testID & 0xFF000000) == -1526726656 )
            {
              dump_core_reg(testID);
            }
          }
        }
        break;
    }
  }
}
// 28CA0: variable 'v0' is possibly undefined

//----- (000290BC) --------------------------------------------------------
void disable_pic_circuit()
{
  int chain; // [sp+4h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      pic_voltage_clamp_disable(chain);
  }
}

//----- (00029128) --------------------------------------------------------
void __noreturn check_system_work()
{
  double v0; // d0
  uint64_t *v1; // r3
  int diff; // [sp+18h] [bp-9Ch]
  timeval tv_reboot_start; // [sp+20h] [bp-94h] BYREF
  timeval tv_reboot; // [sp+28h] [bp-8Ch] BYREF
  timeval tv_end; // [sp+30h] [bp-84h] BYREF
  timeval tv_start; // [sp+38h] [bp-7Ch] BYREF
  FILE *pFile_1; // [sp+40h] [bp-74h]
  FILE *pFile_2; // [sp+44h] [bp-70h]
  FILE *pFile_0; // [sp+48h] [bp-6Ch]
  FILE *pFile; // [sp+4Ch] [bp-68h]
  double latest_avg_rate; // [sp+50h] [bp-64h]
  int six_hour; // [sp+5Ch] [bp-58h]
  double total_secs; // [sp+60h] [bp-54h]
  double total_mhashes; // [sp+68h] [bp-4Ch]
  unsigned __int8 *hash_log; // [sp+74h] [bp-40h]
  int offset; // [sp+78h] [bp-3Ch]
  bool get_stable_hashs_flag; // [sp+7Fh] [bp-35h]
  double last_total_secs; // [sp+80h] [bp-34h]
  double last_total_mhashes; // [sp+88h] [bp-2Ch]
  uint32_t counter; // [sp+90h] [bp-24h]
  int run_counter; // [sp+94h] [bp-20h]
  int avg_num; // [sp+98h] [bp-1Ch]
  int asic_num; // [sp+9Ch] [bp-18h]
  int j; // [sp+A0h] [bp-14h]
  int i; // [sp+A4h] [bp-10h]

  i = 0;
  j = 0;
  cgtime(&tv_end);
  cgtime(&tv_reboot);
  copy_time(&tv_start, &tv_end);
  copy_time(&tv_reboot_start, &tv_reboot);
  hash_log = "/var/log/hash_rate";
  asic_num = 0;
  avg_num = 0;
  run_counter = 0;
  counter = 0;
  get_total_hashs();
  last_total_mhashes = v0;
  get_total_secs();
  last_total_secs = v0;
  get_total_hashs();
  total_mhashes = v0;
  get_total_secs();
  total_secs = v0 + 1.0;
  get_stable_hashs_flag = 1;
  six_hour = 21600;
  while ( 1 )
  {
    while ( doTestPatten )
      cgsleep_ms(100);
    set_led();
    ++counter;
    cgtime(&tv_end);
    cgtime(&tv_reboot);
    diff = tv_end.tv_sec - tv_start.tv_sec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
      --diff;
    if ( counter == 30 )
      disable_pic_circuit();
    if ( !(counter % 0x3C) )
    {
      if ( !(counter % 0x258) )
      {
        copy_log_to_latest(hash_log);
        clear_log(hash_log);
      }
      print_crt_time_to_file("/var/log/hash_rate", 3u);
      dump_nonce_info_all_domain();
      dump_nonce_info_all_asic();
    }
    if ( get_stable_hashs_flag && !(counter % 0x78) )
    {
      get_stable_hashs_flag = 0;
      get_total_hashs();
      last_total_mhashes = v0;
      get_total_secs();
      last_total_secs = v0;
    }
    if ( !(counter % 0x708) )
    {
      get_total_hashs();
      total_mhashes = v0;
      get_total_secs();
      total_secs = v0;
      latest_avg_rate = (total_mhashes - last_total_mhashes) / 1000.0 / (v0 - last_total_secs);
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: The avg rate is  %0.0f in 30 mins, PCB temperature between %d ~ %d \n",
            "driver-btm-soc.c",
            3904,
            (const char *)_FUNCTION___15623,
            latest_avg_rate,
            last_testpatten_lowest_pcb_temp,
            last_testpatten_highest_pcb_temp);
        fclose(pFile);
      }
      last_total_mhashes = total_mhashes;
      last_total_secs = total_secs;
      if ( !status_error
        && !(counter % six_hour)
        && latest_avg_rate < (double)get_ideal_hash_rate_fixed() * 0.95
        && is_domain_unbalance()
        && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Six hour hash rate check: unbalance domain happened.\n",
            "driver-btm-soc.c",
            3917,
            (const char *)_FUNCTION___15623);
        fclose(pFile_0);
      }
    }
    if ( !(counter % 0xA) )
      process_TEST();
    if ( diff > 60 || is_in_error() && diff > 30 )
    {
      ++run_counter;
      asic_num = 0;
      avg_num = 0;
      for ( i = 0; i <= 15; ++i )
      {
        if ( dev->chain_exist[i] )
        {
          asic_num += dev->chain_asic_num[i];
          for ( j = 0; j < dev->chain_asic_num[i]; ++j )
          {
            nonce_num[i][j][nonce_times % 60] = dev->chain_asic_nonce[i][j];
            avg_num += LODWORD(dev->chain_asic_nonce[i][j]);
            if ( log_level > 4 )
            {
              print_crt_time_to_file(log_file, 4u);
              pFile_1 = fopen((const char *)log_file, "a+");
              if ( pFile_1 )
                fprintf(
                  pFile_1,
                  "%s:%d:%s: chain %d asic %d asic_nonce_num %lld\n",
                  "driver-btm-soc.c",
                  4024,
                  (const char *)_FUNCTION___15623,
                  i,
                  j,
                  dev->chain_asic_nonce[i][j]);
              fclose(pFile_1);
            }
          }
        }
      }
      ++nonce_times;
      memset(nonce_num10_string, 0, sizeof(nonce_num10_string));
      memset(nonce_num30_string, 0, sizeof(nonce_num30_string));
      memset(nonce_num60_string, 0, sizeof(nonce_num60_string));
      get_lastn_nonce_num(nonce_num10_string, 10);
      get_lastn_nonce_num(nonce_num30_string, 30);
      get_lastn_nonce_num(nonce_num60_string, 60);
      if ( asic_num )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: avg_num %d asic_num %d\n",
              "driver-btm-soc.c",
              4038,
              (const char *)_FUNCTION___15623,
              avg_num,
              asic_num);
          fclose(pFile_2);
        }
        avg_num = 10;
      }
      else
      {
        avg_num = 1;
      }
      for ( i = 0; i <= 15; ++i )
      {
        if ( dev->chain_exist[i] )
        {
          offset = 0;
          for ( j = 0; j < dev->chain_asic_num[i]; ++j )
          {
            if ( (j & 7) == 0 )
              dev->chain_asic_status_string[i][j + offset++] = 32;
            if ( get_asic_nonce_num(i, j, 1) <= 1 )
            {
              dev->chain_asic_status_string[i][j + offset] = 111;
              if ( !status_error )
                ++x_time[i][j];
            }
            else
            {
              dev->chain_asic_status_string[i][j + offset] = 111;
            }
            v1 = &dev->chain_asic_nonce[i][j];
            *(_DWORD *)v1 = 0;
            *((_DWORD *)v1 + 1) = 0;
          }
          dev->chain_asic_status_string[i][j + offset] = 0;
        }
      }
      if ( run_counter > 60 )
        run_counter = 0;
      copy_time(&tv_start, &tv_end);
    }
    cgsleep_ms(1000);
  }
}
// 291B4: variable 'v0' is possibly undefined

//----- (00029C94) --------------------------------------------------------
void __cdecl pre_open_core_one_chain(uint32_t num, const uint8_t chain)
{
  unsigned int buf_vil_tw[13]; // [sp+18h] [bp-4Ch] BYREF
  FILE *pFile; // [sp+4Ch] [bp-18h]
  FILE *pFile_0; // [sp+50h] [bp-14h]
  FILE *pFile_1; // [sp+54h] [bp-10h]
  uint32_t work_fifo_ready; // [sp+58h] [bp-Ch]
  uint32_t loop; // [sp+5Ch] [bp-8h]

  work_fifo_ready = 0;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  if ( dev->chain_exist[chain] == 1 )
  {
    for ( loop = 0; loop < num; ++loop )
    {
      enable_core_clock_BM1391(loop, 1u, chain);
      enable_core_clock_BM1391(loop + 84, 1u, chain);
      enable_core_clock_BM1391(loop + 168, 1u, chain);
      enable_core_clock_BM1391(loop + 252, 1u, chain);
      buf_vil_tw[0] = (chain << 16) | 0x1000080;
      while ( 1 )
      {
        work_fifo_ready = get_buffer_space();
        if ( (work_fifo_ready & (1 << chain)) != 0 )
          break;
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: chain%d work fifo not ready: 0x%x\n",
              "driver-btm-soc.c",
              4125,
              (const char *)_FUNCTION___15650,
              chain,
              work_fifo_ready);
          fclose(pFile);
        }
        usleep(0x3E8u);
      }
      set_TW_write_command_vil(buf_vil_tw);
      usleep(0x4E20u);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: for chain %d\n", "driver-btm-soc.c", 4134, (const char *)_FUNCTION___15650, chain);
      fclose(pFile_0);
    }
  }
  else if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: filed on chain %d,do not exist!!\n",
        "driver-btm-soc.c",
        4138,
        (const char *)_FUNCTION___15650,
        chain);
    fclose(pFile_1);
  }
}

//----- (00029F98) --------------------------------------------------------
void __cdecl open_core_BM1391_pre_open(int chain, unsigned int num, unsigned __int8 set)
{
  int dhash_acc_control; // r0
  int v4; // r0
  FILE *pFile; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  if ( set )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF701F | 0x8100);
    set_hash_counting_number(0);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: pre open core = %d\n", "driver-btm-soc.c", 4153, (const char *)_FUNCTION___15664, num);
    fclose(pFile);
  }
  if ( chain == All_Chain )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] == 1 )
        pre_open_core_one_chain(num, i);
    }
  }
  else
  {
    pre_open_core_one_chain(num, chain);
  }
  if ( set )
  {
    v4 = get_dhash_acc_control();
    set_dhash_acc_control(v4 | 0x8000 | ((_WORD)opt_multi_version << 8) & 0xF00);
  }
}

//----- (0002A144) --------------------------------------------------------
void __cdecl set_clock_delay_control(const uint8_t chain)
{
  core_cmd core; // [sp+14h] [bp-20h] BYREF
  FILE *pFile_0; // [sp+24h] [bp-10h]
  FILE *pFile; // [sp+28h] [bp-Ch]
  uint8_t i; // [sp+2Fh] [bp-5h]

  i = 0;
  *(_DWORD *)&core.chain = 16842752;
  *((_BYTE *)&core.reg_data + 4) = 0;
  core.core_id = 0;
  *(_DWORD *)&core.cmd_type = 256;
  core.reg_data = 52;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set CLOCK_DELAY_CTRL to 0x%02x\n",
        "driver-btm-soc.c",
        4275,
        (const char *)_FUNCTION___15699,
        core.reg_data);
    fclose(pFile);
  }
  if ( chain != All_Chain )
    i = chain;
  while ( i <= 0xFu )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      if ( dev->chain_asic_num[i] )
      {
        core.chain = i;
        set_core_cmd_BM1391(&core);
        if ( chain != All_Chain )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "%s:%d:%s: singe chain mode\n",
                "driver-btm-soc.c",
                4290,
                (const char *)_FUNCTION___15699);
            fclose(pFile_0);
          }
          return;
        }
      }
    }
    ++i;
  }
}

//----- (0002A3BC) --------------------------------------------------------
void __cdecl open_core_bm1391(bool set, uint8_t chain_mode)
{
  int dhash_acc_control; // r0
  int v3; // r0
  unsigned int buf_vil_tw[13]; // [sp+1Ch] [bp-58h] BYREF
  FILE *pFile_1; // [sp+50h] [bp-24h]
  FILE *pFile_0; // [sp+54h] [bp-20h]
  FILE *pFile; // [sp+58h] [bp-1Ch]
  unsigned int core_index; // [sp+5Ch] [bp-18h]
  unsigned int work_fifo_ready; // [sp+60h] [bp-14h]
  int slot; // [sp+64h] [bp-10h]
  int core_id; // [sp+68h] [bp-Ch]
  unsigned int i; // [sp+6Ch] [bp-8h]

  i = 0;
  work_fifo_ready = 0;
  memset(buf_vil_tw, 0, sizeof(buf_vil_tw));
  core_id = 0;
  slot = 0;
  core_index = 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Start Open Core!!\n", "driver-btm-soc.c", 4323, (const char *)_FUNCTION___15722);
    fclose(pFile);
  }
  if ( opt_multi_version )
  {
    if ( set )
    {
      dhash_acc_control = get_dhash_acc_control();
      set_dhash_acc_control(dhash_acc_control & 0xFFFF7FDF | 0x8000 | ((_WORD)opt_multi_version << 8) & 0xF00);
      set_hash_counting_number(0);
    }
    for ( core_id = 0; core_id <= 83; ++core_id )
    {
      for ( i = 0; i <= 0xF; ++i )
      {
        if ( (chain_mode == All_Chain || i == chain_mode) && dev->chain_exist[i] == 1 && dev->chain_asic_num[i] == 48 )
        {
          buf_vil_tw[0] = (i << 16) | 0x1000080;
          for ( slot = 0; slot <= 3; ++slot )
          {
            core_index = 84 * slot + core_id;
            enable_core_clock_BM1391(core_index, 1u, i);
          }
          cgsleep_ms(5);
          while ( 1 )
          {
            work_fifo_ready = get_buffer_space();
            if ( (work_fifo_ready & (1 << i)) != 0 )
              break;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile_0 = fopen((const char *)log_file, "a+");
              if ( pFile_0 )
                fprintf(
                  pFile_0,
                  "%s:%d:%s: chain%d work fifo not ready: 0x%x\n",
                  "driver-btm-soc.c",
                  4371,
                  (const char *)_FUNCTION___15722,
                  i,
                  work_fifo_ready);
              fclose(pFile_0);
            }
            usleep(0x3E8u);
          }
          set_TW_write_command_vil(buf_vil_tw);
          cgsleep_ms(10);
        }
      }
    }
    if ( set )
    {
      v3 = get_dhash_acc_control();
      set_dhash_acc_control(v3 | 0x8000 | ((_WORD)opt_multi_version << 8) & 0xF00);
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: End Open Core!!\n", "driver-btm-soc.c", 4393, (const char *)_FUNCTION___15722);
    fclose(pFile_1);
  }
}

//----- (0002A7E0) --------------------------------------------------------
void __cdecl nonce_calc(int chain, unsigned int buf)
{
  FILE *pFile_0; // [sp+20h] [bp-14h]
  FILE *pFile; // [sp+24h] [bp-10h]
  unsigned int whose_nonce; // [sp+28h] [bp-Ch]
  unsigned int which_core_nonce; // [sp+2Ch] [bp-8h]

  which_core_nonce = get_core_id((nonce_format_t)buf);
  whose_nonce = get_asic_id((nonce_format_t)buf);
  if ( chain <= 15 && whose_nonce <= 0x2F && which_core_nonce < 0x2A0 && buf )
  {
    ++calc_nonce_info.chain_asic_core_nonce_num[chain][whose_nonce][which_core_nonce];
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: buf [%x] is error!\n", "driver-btm-soc.c", 4500, (const char *)_FUNCTION___15776, buf);
      fclose(pFile);
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: chain = %d,chip = %d,core = %d\n",
          "driver-btm-soc.c",
          4501,
          (const char *)_FUNCTION___15776,
          chain,
          whose_nonce,
          which_core_nonce);
      fclose(pFile_0);
    }
  }
}

//----- (0002AA04) --------------------------------------------------------
void __noreturn get_nonce_and_register()
{
  int nonce_fifo_interrupt; // r0
  __int16 nonce_number_in_fifo; // r0
  __int64 v2; // r2
  unsigned int buf[2]; // [sp+8h] [bp-4Ch] BYREF
  FILE *pFile_0; // [sp+10h] [bp-44h]
  FILE *pFile_1; // [sp+14h] [bp-40h]
  FILE *pFile_2; // [sp+18h] [bp-3Ch]
  FILE *pFile; // [sp+1Ch] [bp-38h]
  uint64_t n2l; // [sp+20h] [bp-34h]
  uint64_t n2h; // [sp+28h] [bp-2Ch]
  unsigned int read_loop; // [sp+30h] [bp-24h]
  unsigned int nonce_number; // [sp+34h] [bp-20h]
  unsigned int *data_addr; // [sp+38h] [bp-1Ch]
  unsigned int work_id; // [sp+3Ch] [bp-18h]
  unsigned int m; // [sp+40h] [bp-14h]
  unsigned int j; // [sp+44h] [bp-10h]

  work_id = 0;
  data_addr = 0;
  j = 0;
  m = 0;
  nonce_number = 0;
  read_loop = 0;
  buf[0] = 0;
  buf[1] = 0;
  n2h = 0LL;
  n2l = 0LL;
  nonce_fifo_interrupt = get_nonce_fifo_interrupt();
  set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        cgsleep_ms(1);
        if ( !doTestPatten )
          break;
        cgsleep_ms(100);
      }
      read_loop = 0;
      nonce_number_in_fifo = get_nonce_number_in_fifo();
      nonce_number = nonce_number_in_fifo & 0x1FF;
    }
    while ( (nonce_number_in_fifo & 0x1FF) == 0 );
    read_loop = nonce_number;
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: read_loop = %d\n",
          "driver-btm-soc.c",
          4701,
          (const char *)_FUNCTION___15814,
          read_loop);
      fclose(pFile);
    }
    for ( j = 0; j < read_loop; ++j )
    {
      get_return_nonce(buf);
      if ( (buf[0] & 0x80000000) == 0 )
      {
        if ( reg_value_buf.reg_value_num > 0x1FE )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_2 = fopen((const char *)log_file, "a+");
            if ( pFile_2 )
              fprintf(
                pFile_2,
                "%s:%d:%s: reg_value_buf buffer is full!\n",
                "driver-btm-soc.c",
                4805,
                (const char *)_FUNCTION___15814);
            fclose(pFile_2);
          }
        }
        else if ( (buf[0] & 0x40) != 0 )
        {
          if ( log_level > 4 )
          {
            print_crt_time_to_file(log_file, 4u);
            pFile_0 = fopen((const char *)log_file, "a+");
            if ( pFile_0 )
              fprintf(
                pFile_0,
                "%s:%d:%s: !!! reg crc error\n",
                "driver-btm-soc.c",
                4778,
                (const char *)_FUNCTION___15814);
            fclose(pFile_0);
          }
        }
        else
        {
          pthread_mutex_lock(&reg_mutex);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_value = buf[1];
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].crc = HIBYTE(buf[0]) & 0x1F;
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].chip_address = BYTE2(buf[0]);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_address = BYTE1(buf[0]);
          reg_value_buf.reg_buffer[reg_value_buf.p_wr].chain_number = buf[0] & 0xF;
          if ( ((buf[0] >> 29) & 3) != 0 && log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: !!! REG_TYPE = 1\n",
                "driver-btm-soc.c",
                4789,
                (const char *)_FUNCTION___15814);
            fclose(pFile_1);
          }
          if ( is_reading_core_reg
            || !is_reading_core_reg && reg_value_buf.reg_buffer[reg_value_buf.p_wr].reg_address != 64 )
          {
            ++reg_value_buf.p_wr;
            ++reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_wr > 0x1FE )
              reg_value_buf.p_wr = 0;
          }
          pthread_mutex_unlock(&reg_mutex);
        }
      }
      else if ( gBegin_get_nonce && (buf[0] & 0x80) != 0 )
      {
        pthread_mutex_lock(&nonce_mutex);
        work_id = HIWORD(buf[0]) & 0x7FFF;
        data_addr = &nonce2_jobid_address[16 * work_id];
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].work_id = work_id;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].nonce3 = buf[1];
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].chain_num = buf[0] & 0xF;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].job_id = *data_addr;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].header_version = data_addr[1];
        n2h = data_addr[3];
        n2l = data_addr[2];
        HIDWORD(v2) = n2h;
        LODWORD(v2) = 0;
        nonce_read_out.nonce_buffer[nonce_read_out.p_wr].nonce2 = v2 | n2l;
        for ( m = 0; m <= 0x1F; ++m )
          nonce_read_out.nonce_buffer[nonce_read_out.p_wr].midstate[m] = *((_BYTE *)data_addr + m + 32);
        if ( nonce_read_out.p_wr > 0x1FD )
          nonce_read_out.p_wr = 0;
        else
          ++nonce_read_out.p_wr;
        if ( nonce_read_out.nonce_num > 0x1FE )
          nonce_read_out.nonce_num = 511;
        else
          ++nonce_read_out.nonce_num;
        nonce_calc(
          nonce_read_out.nonce_buffer[nonce_read_out.p_wr].chain_num,
          nonce_read_out.nonce_buffer[nonce_read_out.p_wr].nonce3);
        pthread_mutex_unlock(&nonce_mutex);
      }
    }
  }
}

//----- (0002B2DC) --------------------------------------------------------
void __cdecl change_high_pll_test(uint8_t chain, float freq, int index)
{
  uint8_t divider; // [sp+27h] [bp-25h] BYREF
  float pll_freq; // [sp+28h] [bp-24h] BYREF
  uint32_t vil_pll_t; // [sp+2Ch] [bp-20h] BYREF
  uint8_t vil_pll[4]; // [sp+30h] [bp-1Ch] BYREF
  FILE *pFile; // [sp+34h] [bp-18h]
  uint32_t pll_index; // [sp+38h] [bp-14h]
  uint32_t pll; // [sp+3Ch] [bp-10h]

  divider = freq_high_pll_1391[LODWORD(freq)].divider;
  pll = freq_high_pll_1391[LODWORD(freq)].pll_out;
  pll_index = 0;
  if ( opt_use_pll_list )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: set freq %d, pll_out %d\n",
          "driver-btm-soc.c",
          4892,
          (const char *)_FUNCTION___15860,
          freq_high_pll_1391[LODWORD(freq)].freq,
          pll);
      fclose(pFile);
    }
    pll_index = get_index_from_pll_B1391(pll);
    get_plldata_from_index(pll_index, vil_pll);
  }
  else
  {
    get_pllparam_divider(COERCE_FLOAT(&vil_pll_t), (uint32_t *)&divider, (uint8_t *)&pll_freq, (float *)&vil_pll_t);
    *(_DWORD *)vil_pll = _bswap_32(vil_pll_t);
  }
  vil_pll[0] |= 0x40u;
  set_config_BM1391_t(chain, 0, 1u, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1391_t(chain, 0, 1u, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_config_BM1391_t(chain, 0, 1u, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1391_t(chain, 0, 1u, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
}

//----- (0002B574) --------------------------------------------------------
void __cdecl change_high_pll_by_aisc(uint32_t chain, uint32_t asic, float freq, int index)
{
  unsigned __int8 chaina; // [sp+1Ch] [bp-30h]
  uint8_t divider; // [sp+23h] [bp-29h] BYREF
  float pll_freq; // [sp+24h] [bp-28h] BYREF
  uint32_t vil_pll_t; // [sp+28h] [bp-24h] BYREF
  uint8_t vil_pll[4]; // [sp+2Ch] [bp-20h] BYREF
  FILE *pFile; // [sp+30h] [bp-1Ch]
  uint32_t chip_addr; // [sp+34h] [bp-18h]
  uint32_t pll_index; // [sp+38h] [bp-14h]
  uint32_t pll; // [sp+3Ch] [bp-10h]

  chaina = chain;
  divider = freq_high_pll_1391[LODWORD(freq)].divider;
  pll = freq_high_pll_1391[LODWORD(freq)].pll_out;
  pll_index = 0;
  chip_addr = 5 * asic;
  if ( opt_use_pll_list )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: set freq %d, pll_out %d\n",
          "driver-btm-soc.c",
          4930,
          (const char *)_FUNCTION___15875,
          freq_high_pll_1391[LODWORD(freq)].freq,
          pll);
      fclose(pFile);
    }
    pll_index = get_index_from_pll_B1391(pll);
    get_plldata_from_index(pll_index, vil_pll);
  }
  else
  {
    get_pllparam_divider(COERCE_FLOAT(&vil_pll_t), (uint32_t *)&divider, (uint8_t *)&pll_freq, (float *)&vil_pll_t);
    *(_DWORD *)vil_pll = _bswap_32(vil_pll_t);
  }
  vil_pll[0] |= 0x40u;
  set_config_BM1391_t(chaina, chip_addr, 0, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1391_t(chaina, chip_addr, 0, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
  set_config_BM1391_t(chaina, chip_addr, 0, 0x70u, (divider - 1) | 0xF0F0F00);
  set_config_BM1391_t(chaina, chip_addr, 0, 8u, _byteswap_ulong(*(unsigned int *)vil_pll));
}

//----- (0002B848) --------------------------------------------------------
void __cdecl set_pll(float pll_value)
{
  float v1; // s0
  int v2; // r2
  int local_pll_index; // [sp+8h] [bp-Ch]
  uint8_t chain; // [sp+Fh] [bp-5h]

  local_pll_index = 0;
  if ( opt_use_pll_list )
    local_pll_index = get_index_from_high_pll((int)v1);
  for ( chain = 0; chain <= 0xFu; ++chain )
  {
    v2 = chain + 2;
    if ( *((_DWORD *)&dev->current_job_start_address + v2) )
      change_high_pll_test(chain, *(float *)&local_pll_index, v2);
  }
}
// 2B87C: variable 'v1' is possibly undefined

//----- (0002B8F4) --------------------------------------------------------
void __cdecl increase_freq_slowly(float init_freq, float final_freq, float freq_step, uint8_t chain)
{
  float v4; // s0
  float v5; // s1
  float v6; // s2
  uint8_t chaina; // [sp+13h] [bp-21h]
  FILE *pFile; // [sp+20h] [bp-14h]
  float freq_tmp; // [sp+24h] [bp-10h]
  int steps; // [sp+28h] [bp-Ch]
  int i; // [sp+2Ch] [bp-8h]

  chaina = LOBYTE(init_freq);
  steps = (int)(float)((float)(v5 - v4) / v6);
  if ( v5 > (float)((float)((float)steps * v6) + v4) )
    ++steps;
  for ( i = 0; i < steps; ++i )
  {
    freq_tmp = v4 + (float)((float)(i + 1) * v6);
    if ( freq_tmp > v5 )
      freq_tmp = v5;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: \n\nIncrease frequency to %.2fM\n",
          "driver-btm-soc.c",
          5037,
          (const char *)_FUNCTION___15912,
          freq_tmp);
      init_freq = COERCE_FLOAT(fclose(pFile));
    }
    if ( chaina == All_Chain )
      set_pll(init_freq);
    else
      change_high_pll_test(chaina, 0.0, chaina);
    init_freq = COERCE_FLOAT(sleep(1u));
  }
}
// 2B91C: variable 'v5' is possibly undefined
// 2B91C: variable 'v4' is possibly undefined
// 2B924: variable 'v6' is possibly undefined

//----- (0002BAB4) --------------------------------------------------------
unsigned __int8 __cdecl c2hex(unsigned __int8 value)
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  unsigned __int8 ret; // [sp+17h] [bp-5h]

  ret = -1;
  if ( value > 0x2Fu && value <= 0x39u )
    return value & 0xF;
  switch ( value )
  {
    case 'a':
    case 'A':
      return 10;
    case 'b':
    case 'B':
      return 11;
    case 'c':
    case 'C':
      return 12;
    case 'd':
    case 'D':
      return 13;
    case 'e':
    case 'E':
      return 14;
    case 'f':
    case 'F':
      return 15;
  }
  if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: input value error: %c\n",
        "driver-btm-soc.c",
        5123,
        (const char *)_FUNCTION___15946,
        value);
    fclose(pFile);
  }
  return ret;
}

//----- (0002BC70) --------------------------------------------------------
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  unsigned __int8 higha; // [sp+7h] [bp-Dh]

  higha = c2hex(high);
  return c2hex(low) ^ (16 * higha);
}

//----- (0002BCEC) --------------------------------------------------------
int __cdecl s2hex(unsigned __int8 *dst, const unsigned __int8 *src, int inlen)
{
  FILE *pFile; // [sp+24h] [bp-20h]
  int p; // [sp+2Ch] [bp-18h]
  int len; // [sp+30h] [bp-14h]
  int i; // [sp+34h] [bp-10h]

  if ( src && inlen > 0 && dst )
  {
    len = inlen / 2;
    p = inlen & 1;
    for ( i = 0; i < len; ++i )
      dst[i] = twoc2hex(src[2 * i], src[2 * i + 1]);
    if ( p )
      dst[i] = twoc2hex(src[2 * i], 0);
    return len + p;
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: s2hex para error dst(%p), src(%p), inlen(%d)\n",
          "driver-btm-soc.c",
          5144,
          (const char *)_FUNCTION___15963,
          dst,
          src,
          inlen);
      fclose(pFile);
    }
    return -1;
  }
}
// 2BE08: conditional instruction was optimized away because %inlen.4>=1

//----- (0002BEFC) --------------------------------------------------------
void __cdecl init_pic_one_chain(const int chain)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  if ( dev->chain_exist[chain] == 1 && !pic_init(chain) )
  {
    if ( log_level > 1 )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Chain[%d] PIC init failed!\n",
          "driver-btm-soc.c",
          5349,
          (const char *)_FUNCTION___16047,
          chain);
      fclose(pFile);
    }
    stop_mining("PIC init failed!\n");
  }
}

//----- (0002BFF0) --------------------------------------------------------
int init_pic()
{
  uint8_t i; // [sp+7h] [bp-5h]

  for ( i = 0; i <= 0xFu; ++i )
    init_pic_one_chain(i);
  pic_heart_beat_func(0);
  return 0;
}

//----- (0002C044) --------------------------------------------------------
void __cdecl set_timeout(int final_freq, int percent)
{
  FILE *pFile; // [sp+1Ch] [bp-8h]

  dev->timeout = percent * (dev->addrInterval * (0x1000000 / calculate_core_number(dev->corenum)) / final_freq) / 100;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: freq %d final timeout=%d\n",
        "driver-btm-soc.c",
        5974,
        (const char *)_FUNCTION___16309,
        final_freq,
        dev->timeout);
    fclose(pFile);
  }
  if ( opt_multi_version )
    set_time_out_control((opt_multi_version * dev->timeout) & 0x1FFFF | 0x80000000);
  else
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
}

//----- (0002C200) --------------------------------------------------------
void __fastcall set_target_freq(int a1, float a2, float a3)
{
  FILE *pFile; // [sp+1Ch] [bp-10h]
  float max_freq; // [sp+20h] [bp-Ch]
  uint8_t i; // [sp+27h] [bp-5h]
  uint8_t ia; // [sp+27h] [bp-5h]

  max_freq = 0.0;
  if ( opt_pattern )
  {
    for ( i = 0; i <= 0xFu; ++i )
    {
      if ( dev->chain_exist[i] )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: set freq %f on chain %d\n",
              "driver-btm-soc.c",
              6039,
              (const char *)_FUNCTION___16339,
              freq_from_board[i],
              i);
          fclose(pFile);
        }
        if ( max_freq <= freq_from_board[i] )
          max_freq = freq_from_board[i];
        increase_freq_slowly(COERCE_FLOAT(i), a2, COERCE_FLOAT(4 * i), i);
      }
    }
  }
  else
  {
    increase_freq_slowly(COERCE_FLOAT(All_Chain), a2, a3, All_Chain);
    for ( ia = 0; ia <= 0xFu; ++ia )
    {
      if ( dev->chain_exist[ia] )
        freq_from_board[ia] = (float)dev->frequency;
    }
  }
}
// 2C38C: variable 'a2' is possibly undefined

//----- (0002C4E0) --------------------------------------------------------
int __cdecl get_physical_chip_no(int logical_row, int logical_col)
{
  if ( logical_row > 11 )
    return 0;
  if ( (logical_row & 1) != 0 )
    return 4 * (logical_row + 1) - 1 - logical_col;
  return 4 * logical_row + logical_col;
}

//----- (0002C554) --------------------------------------------------------
int __cdecl get_logical_column_by_chip_no(int chip)
{
  int logical_row; // [sp+Ch] [bp-8h]

  logical_row = chip / 4;
  if ( chip / 4 > 11 )
    return 0;
  if ( (logical_row & 1) != 0 )
    return 4 * (logical_row + 1) - 1 - chip;
  return chip % 4;
}

//----- (0002C5E0) --------------------------------------------------------
void __cdecl get_statistics_of_asic_freq(uint32_t *asic_freq, uint32_t *min, uint32_t *max, uint32_t *total)
{
  uint32_t _total; // [sp+10h] [bp-14h]
  uint32_t _max; // [sp+14h] [bp-10h]
  uint32_t _min; // [sp+18h] [bp-Ch]
  int asic; // [sp+1Ch] [bp-8h]

  _min = 0xFFFFFF;
  _max = 0;
  _total = 0;
  for ( asic = 0; asic <= 47; ++asic )
  {
    if ( _max < asic_freq[asic] )
      _max = asic_freq[asic];
    if ( _min > asic_freq[asic] )
      _min = asic_freq[asic];
    _total += asic_freq[asic];
  }
  *min = _min;
  *max = _max;
  *total = _total;
}

//----- (0002C6FC) --------------------------------------------------------
void __cdecl increase_asic_diff_freq_slowly_one_chain(
        uint32_t *asic_diff_freq,
        uint32_t start_freq,
        int freq_step,
        int chain)
{
  uint32_t this_diff; // [sp+10h] [bp-24h]
  int domain_col; // [sp+14h] [bp-20h]
  int domain; // [sp+18h] [bp-1Ch]
  uint32_t step; // [sp+1Ch] [bp-18h]
  unsigned int steps; // [sp+20h] [bp-14h]
  uint32_t max; // [sp+28h] [bp-Ch]
  int asic; // [sp+2Ch] [bp-8h]
  uint32_t asica; // [sp+2Ch] [bp-8h]

  max = 0;
  for ( asic = 0; asic <= 47; ++asic )
  {
    if ( max < asic_diff_freq[asic] )
      max = asic_diff_freq[asic];
  }
  steps = max / freq_step;
  if ( max > max / freq_step * freq_step )
    ++steps;
  for ( step = 0; step < steps; ++step )
  {
    this_diff = freq_step * (step + 1);
    for ( domain_col = 0; domain_col <= 3; ++domain_col )
    {
      for ( domain = 0; domain <= 11; ++domain )
      {
        asica = get_physical_chip_no(domain, domain_col);
        if ( this_diff <= asic_diff_freq[asica] || this_diff - asic_diff_freq[asica] < freq_step )
          change_high_pll_by_aisc(chain, asica, 0.0, chain);
      }
      usleep(0x186A0u);
    }
  }
}

//----- (0002C92C) --------------------------------------------------------
uint16_t __cdecl increase_freq_by_eeprom_slowly(int init_freq, int freq_step)
{
  char *v2; // r1
  uint32_t v3; // r2
  uint32_t diff_freq[48]; // [sp+1Ch] [bp-E0h] BYREF
  uint32_t total; // [sp+DCh] [bp-20h] BYREF
  uint32_t max; // [sp+E0h] [bp-1Ch] BYREF
  uint32_t min; // [sp+E4h] [bp-18h] BYREF
  FILE *pFile; // [sp+E8h] [bp-14h]
  int asic; // [sp+ECh] [bp-10h]
  int chain; // [sp+F0h] [bp-Ch]
  uint32_t total_all; // [sp+F4h] [bp-8h]
  char v14; // [sp+F8h] [bp-4h] BYREF

  min = 0;
  max = 0;
  total = 0;
  total_all = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      min = 0xFFFFFF;
      max = 0;
      total = 0;
      get_statistics_of_asic_freq(scan_result[chain].freq_eeprom, &min, &max, &total);
      for ( asic = 0; asic <= 47; ++asic )
      {
        v3 = scan_result[chain].freq_eeprom[asic] - min;
        v2 = &v14;
        diff_freq[asic] = v3;
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Increase eeprom frequency slowly for chain %d. to %u\n",
            "driver-btm-soc.c",
            6283,
            (const char *)_FUNCTION___16448,
            chain,
            min);
        fclose(pFile);
      }
      increase_freq_slowly(COERCE_FLOAT((unsigned __int8)chain), *(float *)&v2, *(float *)&v3, chain);
      if ( min != max )
        increase_asic_diff_freq_slowly_one_chain(diff_freq, min, freq_step, chain);
      scan_freq_average[chain] = total / 0x30;
      total_all += total;
    }
  }
  total_freq = total_all;
  return max;
}
// 2CB20: variable 'v2' is possibly undefined
// 2CB20: variable 'v3' is possibly undefined

//----- (0002CBC4) --------------------------------------------------------
unsigned int __cdecl check_asic_reg_without_read(
        unsigned int reg,
        unsigned __int8 mode,
        unsigned __int8 chip_addr,
        unsigned int chain,
        int check_num)
{
  FILE *pFile_2; // [sp+28h] [bp-44h]
  FILE *pFile_1; // [sp+2Ch] [bp-40h]
  FILE *pFile_0; // [sp+30h] [bp-3Ch]
  int core_id; // [sp+34h] [bp-38h]
  FILE *pFile; // [sp+38h] [bp-34h]
  unsigned int reg_value_num; // [sp+3Ch] [bp-30h]
  FILE *pFile_3; // [sp+40h] [bp-2Ch]
  FILE *pFile_4; // [sp+44h] [bp-28h]
  unsigned __int8 chip_address; // [sp+4Bh] [bp-21h]
  unsigned int reg_buf; // [sp+4Ch] [bp-20h]
  int cc; // [sp+50h] [bp-1Ch]
  unsigned int no_reg_time; // [sp+54h] [bp-18h]
  int last_get_num; // [sp+58h] [bp-14h]
  int get_num; // [sp+5Ch] [bp-10h]
  int not_reg_data_time; // [sp+60h] [bp-Ch]
  unsigned int i; // [sp+64h] [bp-8h]

  not_reg_data_time = 0;
  get_num = 0;
  last_get_num = 0;
  no_reg_time = 0;
  cc = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      cgsleep_ms(80);
LABEL_41:
      if ( not_reg_data_time > 4 )
        break;
      pthread_mutex_lock(&reg_mutex);
      reg_value_num = reg_value_buf.reg_value_num;
      pthread_mutex_unlock(&reg_mutex);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: reg_value_num %d\n",
            "driver-btm-soc.c",
            6324,
            (const char *)_FUNCTION___16470,
            reg_value_num);
        fclose(pFile);
      }
      if ( reg_value_num <= 0x1FE && reg_value_buf.p_rd <= 0x1FE && reg_value_num )
      {
        get_num += reg_value_num;
        pthread_mutex_lock(&reg_mutex);
        for ( i = 0; ; ++i )
        {
          if ( reg_value_num <= i )
          {
            pthread_mutex_unlock(&reg_mutex);
            goto LABEL_41;
          }
          reg_buf = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
          chip_address = reg_value_buf.reg_buffer[reg_value_buf.p_rd].chip_address;
          if ( chain == reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number )
          {
            if ( reg == 64 )
            {
              if ( is_dump_asic_reg_all )
              {
                g_asic_core_data[chain][0] = (unsigned __int8)reg_buf;
                g_asic_core_data_status[chain][0] = 1;
              }
              else
              {
                core_id = HIWORD(reg_buf) & 0xFF00;
                core_hash_clock_delay_control[chain][chip_address / 5u][core_id].v = reg_buf;
                if ( cc <= 9 )
                {
                  ++cc;
                  if ( log_level > 3 )
                  {
                    print_crt_time_to_file(log_file, 3u);
                    pFile_0 = fopen((const char *)log_file, "a+");
                    if ( pFile_0 )
                      fprintf(
                        pFile_0,
                        "%s:%d:%s: chip %d CORE[%03d] 0x%08x %02x\n",
                        "driver-btm-soc.c",
                        6371,
                        (const char *)_FUNCTION___16470,
                        chip_address / 5u,
                        core_id,
                        reg_buf,
                        core_hash_clock_delay_control[chain][chip_address / 5u][core_id].v);
                    fclose(pFile_0);
                  }
                }
                if ( (unsigned __int8)reg_buf != 128 && log_level > 3 )
                {
                  print_crt_time_to_file(log_file, 3u);
                  pFile_1 = fopen((const char *)log_file, "a+");
                  if ( pFile_1 )
                    fprintf(
                      pFile_1,
                      "%s:%d:%s: chain[%02d] chip[%02d] core[%d] clock delay control is 0x%08x\n",
                      "driver-btm-soc.c",
                      6377,
                      (const char *)_FUNCTION___16470,
                      reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number,
                      chip_address / 5u,
                      core_id,
                      core_hash_clock_delay_control[chain][chip_address / 5u][core_id].v);
                  fclose(pFile_1);
                }
              }
            }
            if ( log_level > 4 )
            {
              print_crt_time_to_file(log_file, 4u);
              pFile_2 = fopen((const char *)log_file, "a+");
              if ( pFile_2 )
                fprintf(
                  pFile_2,
                  "%s:%d:%s: chip %x reg %x reg_buff %x\n",
                  "driver-btm-soc.c",
                  6381,
                  (const char *)_FUNCTION___16470,
                  chip_address,
                  reg,
                  reg_buf);
              fclose(pFile_2);
            }
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
            if ( reg == 28 )
            {
              pthread_mutex_unlock(&reg_mutex);
              clear_register_value_buf();
              if ( (reg_buf & 0xC0000000) != 0 )
                return 0;
              else
                return reg_buf;
            }
          }
          else
          {
            ++reg_value_buf.p_rd;
            --reg_value_buf.reg_value_num;
            if ( reg_value_buf.p_rd > 0x1FE )
              reg_value_buf.p_rd = 0;
          }
        }
      }
      ++not_reg_data_time;
    }
    if ( get_num >= check_num )
    {
      clear_register_value_buf();
      return 0;
    }
    if ( get_num == last_get_num )
      ++no_reg_time;
    if ( no_reg_time > 5 )
      break;
    last_get_num = get_num;
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(
          pFile_4,
          "%s:%d:%s: last_get =%d, get=%d\n",
          "driver-btm-soc.c",
          6426,
          (const char *)_FUNCTION___16470,
          get_num,
          get_num);
      fclose(pFile_4);
    }
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s: no reg time %d, return\n",
        "driver-btm-soc.c",
        6422,
        (const char *)_FUNCTION___16470,
        no_reg_time);
    fclose(pFile_3);
  }
  return 0;
}
// 2CD20: conditional instruction was optimized away because %not_reg_data_time.4<5
// 2CD3C: conditional instruction was optimized away because %not_reg_data_time.4<5

//----- (0002D48C) --------------------------------------------------------
void read_clock_delay_control_single_core()
{
  core_cmd core; // [sp+Ch] [bp-18h] BYREF
  int i; // [sp+1Ch] [bp-8h]

  *(_DWORD *)&core.chain = 0;
  core.core_id = 0;
  *(_QWORD *)&core.cmd_type = 4278190080LL;
  is_reading_core_reg = 1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && dev->chain_asic_num[i] )
    {
      clear_register_value_buf();
      core.core_id = 0;
      core.chain = i;
      set_core_cmd_BM1391(&core);
      check_asic_reg_without_read(0x40u, 0, 0, i, 1);
    }
  }
  is_reading_core_reg = 0;
}

//----- (0002D5DC) --------------------------------------------------------
const unsigned __int8 *__cdecl get_asic_reg_string(unsigned __int8 reg)
{
  const char *v1; // r3

  switch ( reg )
  {
    case 0u:
      v1 = "CHIP_ADDRESS";
      break;
    case 4u:
      v1 = "HASH_RATE";
      break;
    case 8u:
      v1 = "PLL_PARAMETER";
      break;
    case 0xCu:
      v1 = "CHIP_NONCE_OFFSET";
      break;
    case 0x10u:
      v1 = "HASH_COUNTING_NUMBER";
      break;
    case 0x14u:
      v1 = "TICKET_MASK";
      break;
    case 0x18u:
      v1 = "MISC_CONTROL";
      break;
    case 0x1Cu:
      v1 = "GENERAL_I2C_COMMAND";
      break;
    case 0x20u:
      v1 = "ORDERED_CLOCK_ENABLE";
      break;
    case 0x38u:
      v1 = "TICKET_MASK_2";
      break;
    case 0x3Cu:
      v1 = "CORE_COMMAND";
      break;
    case 0x40u:
      v1 = "CORE_RESPONSE";
      break;
    case 0x44u:
      v1 = "EXTERNAL_TEMPERATURE_SENSOR_READ";
      break;
    case 0x48u:
      v1 = "ERROR_FLAG";
      break;
    case 0x4Cu:
      v1 = "NONCE_ERROR_COUNTER";
      break;
    case 0x50u:
      v1 = "NONCE_OVERFLOW_COUNTER";
      break;
    case 0x54u:
      v1 = "ANALOG_MUX_CONTROL";
      break;
    case 0x58u:
      v1 = "IO_DRIVE_STRENGTH_CONFIGURATION";
      break;
    case 0x5Cu:
      v1 = "TIME_OUT_CONTROL_REG";
      break;
    case 0x60u:
      v1 = "PLL1_PARAMETER";
      break;
    case 0x64u:
      v1 = "PLL2_PARAMETER";
      break;
    case 0x68u:
      v1 = "PLL3_PARAMETER";
      break;
    case 0x6Cu:
      v1 = "ORDERED_CLOCK_MONITOR";
      break;
    case 0x70u:
      v1 = "PLL0_DIVIDER";
      break;
    case 0x74u:
      v1 = "PLL1_DIVIDER";
      break;
    case 0x78u:
      v1 = "PLL2_DIVIDER";
      break;
    case 0x7Cu:
      v1 = "PLL3_DIVIDER";
      break;
    case 0x80u:
      v1 = "CLOCK_ORDER_0";
      break;
    case 0x84u:
      v1 = "CLOCK_ORDER_1";
      break;
    case 0x8Cu:
      v1 = "CLOCK_ORDER_STATUS";
      break;
    default:
      v1 = "UNKOWN REGISTER";
      break;
  }
  return (const unsigned __int8 *)v1;
}
// 2D5FC: control flows out of bounds to 2D600

//----- (0002D9B4) --------------------------------------------------------
const unsigned __int8 *__cdecl get_asic_core_reg_string(unsigned __int8 reg)
{
  const char *v1; // r3

  switch ( reg )
  {
    case 0u:
      v1 = "CLOCK_DELAY_CTRL";
      break;
    case 1u:
      v1 = "PRO_MONI_CTRL";
      break;
    case 2u:
      v1 = "PRO_MONI_DATA";
      break;
    case 3u:
      v1 = "CORE_ERROR";
      break;
    case 4u:
      v1 = "CLOCK_EN_CTRL";
      break;
    case 5u:
      v1 = "HASH_CLOCK_CTRL";
      break;
    case 6u:
      v1 = "HASH_CLOCK_CNT";
      break;
    case 7u:
      v1 = "SWEEP_CNTRL";
      break;
    default:
      v1 = "UNKNOWN CORE REGISTER";
      break;
  }
  return (const unsigned __int8 *)v1;
}
// 2D9D4: control flows out of bounds to 2D9D8

//----- (0002DA70) --------------------------------------------------------
void dump_all_asic_reg()
{
  int v0; // r5
  int v1; // r7
  int v2; // r6
  const char *v3; // r4
  const unsigned __int8 *asic_reg_string; // r0
  int v5; // r5
  int v6; // r6
  const char *v7; // r4
  const unsigned __int8 *asic_core_reg_string; // r0
  unsigned __int8 asic_regs[26]; // [sp+1Ch] [bp-50h]
  FILE *pFile_0; // [sp+38h] [bp-34h]
  FILE *pFile_1; // [sp+3Ch] [bp-30h]
  FILE *pFile_4; // [sp+40h] [bp-2Ch]
  FILE *pFile_5; // [sp+44h] [bp-28h]
  FILE *pFile_3; // [sp+48h] [bp-24h]
  FILE *pFile_2; // [sp+4Ch] [bp-20h]
  FILE *pFile; // [sp+50h] [bp-1Ch]
  unsigned __int8 chain; // [sp+56h] [bp-16h]
  unsigned __int8 reg; // [sp+57h] [bp-15h]

  *(_DWORD *)asic_regs = 201851904;
  *(_DWORD *)&asic_regs[4] = 538448912;
  *(_DWORD *)&asic_regs[8] = 1279804472;
  *(_DWORD *)&asic_regs[12] = 1549292624;
  *(_DWORD *)&asic_regs[16] = 1885889632;
  *(_DWORD *)&asic_regs[20] = -2139326348;
  *(_WORD *)&asic_regs[24] = -29564;
  memset(g_asic_data, 0, sizeof(g_asic_data));
  memset(g_asic_data_status, 0, sizeof(g_asic_data_status));
  memset(g_asic_core_data, 0, sizeof(g_asic_core_data));
  memset(g_asic_core_data_status, 0, sizeof(g_asic_core_data_status));
  pthread_mutex_lock(&reopen_core);
  is_dump_asic_reg_all = 1;
  for ( reg = 0; reg <= 0x19u; ++reg )
    check_single_asic_reg(asic_regs[reg]);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: ASIC REGISTER:\n", "driver-btm-soc.c", 6722, (const char *)_FUNCTION___16607);
    fclose(pFile);
  }
  for ( reg = 0; reg <= 0x19u; ++reg )
  {
    for ( chain = 0; chain <= 0xFu; ++chain )
    {
      if ( dev->chain_exist[chain] && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          v0 = chain;
          v1 = asic_regs[reg];
          v2 = g_asic_data[chain][v1];
          if ( g_asic_data_status[chain][v1] )
            v3 = "Found";
          else
            v3 = "Not Found";
          asic_reg_string = get_asic_reg_string(asic_regs[reg]);
          fprintf(
            pFile_0,
            "%s:%d:%s: Chain[%d], REG[0x%2X] = 0x%08X, %s, %s\n",
            "driver-btm-soc.c",
            6734,
            (const char *)_FUNCTION___16607,
            v0,
            v1,
            v2,
            v3,
            (const char *)asic_reg_string);
        }
        fclose(pFile_0);
      }
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%s:%d:%s: \n", "driver-btm-soc.c", 6737, (const char *)_FUNCTION___16607);
      fclose(pFile_1);
    }
  }
  read_clock_delay_control_single_core();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fprintf(pFile_2, "%s:%d:%s: \n", "driver-btm-soc.c", 6744, (const char *)_FUNCTION___16607);
    fclose(pFile_2);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(pFile_3, "%s:%d:%s: ASIC CORE REGISTER:\n", "driver-btm-soc.c", 6745, (const char *)_FUNCTION___16607);
    fclose(pFile_3);
  }
  for ( chain = 0; chain <= 0xFu; ++chain )
  {
    if ( dev->chain_exist[chain] && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
      {
        v5 = chain;
        v6 = g_asic_core_data[chain][0];
        if ( g_asic_core_data_status[chain][0] )
          v7 = "Found";
        else
          v7 = "Not Found";
        asic_core_reg_string = get_asic_core_reg_string(0);
        fprintf(
          pFile_4,
          "%s:%d:%s: Chain[%d], CORE_REG[0x%2X] = 0x%08X, %s, %s\n",
          "driver-btm-soc.c",
          6756,
          (const char *)_FUNCTION___16607,
          v5,
          0,
          v6,
          v7,
          (const char *)asic_core_reg_string);
      }
      fclose(pFile_4);
    }
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fprintf(pFile_5, "%s:%d:%s: \n", "driver-btm-soc.c", 6759, (const char *)_FUNCTION___16607);
    fclose(pFile_5);
  }
  is_dump_asic_reg_all = 0;
  pthread_mutex_unlock(&reopen_core);
}

//----- (0002E130) --------------------------------------------------------
void __cdecl power_off_hash_board(int chain)
{
  int i; // [sp+Ch] [bp-8h]

  if ( chain == All_Chain )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( dev->chain_exist[i] )
        hashboard_power_off(i);
    }
  }
  else
  {
    hashboard_power_off(chain);
  }
  sleep(3u);
}

//----- (0002E1E0) --------------------------------------------------------
void balance_domain_voltage()
{
  FILE *pFile_0; // [sp+10h] [bp-14h]
  FILE *pFile; // [sp+14h] [bp-10h]
  int chain; // [sp+18h] [bp-Ch]
  int open_core_count; // [sp+1Ch] [bp-8h]

  open_core_count = 21;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: To balance voltage domain, open all core and reset hash board after find asic num.\n",
        "driver-btm-soc.c",
        6861,
        (const char *)_FUNCTION___16654);
    fclose(pFile);
  }
  while ( open_core_count <= 84 )
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: Open core %d for chain %d\n",
              "driver-btm-soc.c",
              6872,
              (const char *)_FUNCTION___16654,
              open_core_count,
              chain);
          fclose(pFile_0);
        }
        open_core_BM1391_pre_open(chain, open_core_count, 1u);
        set_reset_hashboard(chain, 1);
        sleep(3u);
        set_reset_hashboard(chain, 0);
        sleep(3u);
      }
    }
    open_core_count *= 2;
  }
}

//----- (0002E3C4) --------------------------------------------------------
void init_freq_mode()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  freq_mode = 2;
  opt_fixed_freq = 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: This is fix-freq version\n", "driver-btm-soc.c", 6900, (const char *)_FUNCTION___16667);
    fclose(pFile);
  }
}

//----- (0002E484) --------------------------------------------------------
void init_phy_mem_nonce2_jobid_address()
{
  sysinfo si; // [sp+Ch] [bp-50h] BYREF
  FILE *pFile; // [sp+4Ch] [bp-10h]
  FILE *pFile_0; // [sp+50h] [bp-Ch]
  FILE *pFile_1; // [sp+54h] [bp-8h]

  sysinfo_0(&si);
  if ( si.totalram <= 0x3B9ACA00 )
  {
    if ( si.totalram <= 0x1DCD6500 )
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 251658240;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: Detect 256MB control board of XILINX\n",
            "driver-btm-soc.c",
            6927,
            (const char *)_FUNCTION___16673);
        fclose(pFile_1);
      }
    }
    else
    {
      PHY_MEM_NONCE2_JOBID_ADDRESS = 520093696;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Detect 512MB control board of XILINX\n",
            "driver-btm-soc.c",
            6921,
            (const char *)_FUNCTION___16673);
        fclose(pFile_0);
      }
    }
  }
  else
  {
    PHY_MEM_NONCE2_JOBID_ADDRESS = 1056964608;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Detect 1GB control board of XILINX\n",
          "driver-btm-soc.c",
          6915,
          (const char *)_FUNCTION___16673);
      fclose(pFile);
    }
  }
}

//----- (0002E6A0) --------------------------------------------------------
int __cdecl init_global_config_parameter(init_config config)
{
  FILE *pFile; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  uint16_t crc; // [sp+1Eh] [bp-6h]

  config_parameter = config;
  if ( config.token_type == 81 )
  {
    crc = CRC16(&config_parameter.token_type, 0x1Eu);
    if ( crc == config_parameter.crc )
    {
      return 0;
    }
    else
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
            "driver-btm-soc.c",
            6946,
            (const char *)_FUNCTION___16681,
            config_parameter.crc,
            crc);
        fclose(pFile_0);
      }
      return -2;
    }
  }
  else
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: config_parameter.token_type != 0x%x, it is 0x%x\n",
          "driver-btm-soc.c",
          6939,
          (const char *)_FUNCTION___16681,
          81,
          config_parameter.token_type);
      fclose(pFile);
    }
    return -1;
  }
}

//----- (0002E890) --------------------------------------------------------
void check_fan_multi()
{
  FILE *pFile_0; // [sp+8h] [bp-14h]
  FILE *pFile; // [sp+10h] [bp-Ch]
  int testCounter; // [sp+14h] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: check fan for 20 times...\n", "driver-btm-soc.c", 6958, (const char *)_FUNCTION___16689);
    fclose(pFile);
  }
  for ( testCounter = 0; ; ++testCounter )
  {
    if ( !(unsigned __int8)check_fan() )
      goto LABEL_12;
    if ( dev->fan_num > 1u )
      break;
    if ( log_level > 1 )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: Error!!! Fan lost!\n", "driver-btm-soc.c", 6969, (const char *)_FUNCTION___16689);
      fclose(pFile_0);
    }
LABEL_12:
    if ( testCounter == 19 )
      stop_scan(FAN_NUM_ERR_0, 0);
    sleep(1u);
  }
}

//----- (0002EA30) --------------------------------------------------------
void init_dev_frequency()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  if ( is_fixed_freq_mode() && (*((_BYTE *)&config_parameter + 4) & 8) != 0 )
  {
    dev->frequency = config_parameter.frequency;
    sprintf((char *)dev->frequency_t, "%u", dev->frequency);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: fixd frequency is %d\n",
          "driver-btm-soc.c",
          6993,
          (const char *)_FUNCTION___16697,
          dev->frequency);
      fclose(pFile);
    }
  }
  else
  {
    dev->frequency = 275;
  }
}

//----- (0002EBC4) --------------------------------------------------------
int start_read_nonce_reg_thread()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  read_nonce_reg_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_nonce_reg_id, 0, (void *(*)(void *))get_nonce_and_register, read_nonce_reg_id) )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: create thread for get nonce and register from FPGA failed\n",
          "driver-btm-soc.c",
          7007,
          (const char *)_FUNCTION___16702);
      fclose(pFile);
    }
    return -5;
  }
  else
  {
    pthread_detach(read_nonce_reg_id->pth);
    return 0;
  }
}

//----- (0002ECDC) --------------------------------------------------------
void init_miner_version()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int hardware_version; // [sp+Ch] [bp-8h]

  hardware_version = get_hardware_version();
  pcb_version = HIWORD(hardware_version) & 0x7FFF;
  fpga_version = (unsigned __int8)hardware_version;
  fpga_major_version = BYTE1(hardware_version);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: FPGA Version = 0x%04X\n",
        "driver-btm-soc.c",
        7027,
        (const char *)_FUNCTION___16708,
        (unsigned __int16)hardware_version);
    fclose(pFile);
  }
  sprintf((char *)g_miner_version, "%d.%d.%d.%d", ((fpga_major_version - 176) << 8) + fpga_version, pcb_version, 1, 3);
}

//----- (0002EE2C) --------------------------------------------------------
void dump_pcb_bom_version()
{
  int pcb_version; // r0
  int bom_version; // r0
  FILE *pFile_0; // [sp+14h] [bp-10h]
  FILE *pFile; // [sp+18h] [bp-Ch]
  int chain; // [sp+1Ch] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
        {
          pcb_version = eeprom_get_pcb_version(chain);
          fprintf(
            pFile,
            "%s:%d:%s: Chain [%d] PCB Version: 0x%04x\n",
            "driver-btm-soc.c",
            7043,
            (const char *)_FUNCTION___16715,
            chain,
            pcb_version);
        }
        fclose(pFile);
      }
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          bom_version = eeprom_get_bom_version(chain);
          fprintf(
            pFile_0,
            "%s:%d:%s: Chain [%d] BOM Version: 0x%04x\n",
            "driver-btm-soc.c",
            7044,
            (const char *)_FUNCTION___16715,
            chain,
            bom_version);
        }
        fclose(pFile_0);
      }
    }
  }
}

//----- (0002EFD0) --------------------------------------------------------
void calculate_timeout()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  if ( (*((_BYTE *)&config_parameter + 4) & 4) != 0 )
  {
    if ( config_parameter.timeout_data_integer || config_parameter.timeout_data_fractions )
    {
      dev->timeout = 1000 * config_parameter.timeout_data_integer + config_parameter.timeout_data_fractions;
    }
    else
    {
      dev->timeout = 90 * (dev->addrInterval * (0x1000000 / calculate_core_number(dev->corenum)) / dev->frequency) / 100;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: dev->timeout = %d\n",
            "driver-btm-soc.c",
            7062,
            (const char *)_FUNCTION___16724,
            dev->timeout);
        fclose(pFile);
      }
    }
    if ( dev->timeout >= 0x20000 )
      dev->timeout = 0x1FFFF;
  }
}

//----- (0002F1E4) --------------------------------------------------------
void set_timeout_control()
{
  set_time_out_control((10 * dev->timeout) & 0x1FFFE | 0x80000000);
}

//----- (0002F284) --------------------------------------------------------
void __fastcall set_freq_and_get_max_freq(int a1, float a2, float a3)
{
  if ( freq_mode == 2 )
    set_target_freq(a1, a2, a3);
  else
    increase_freq_by_eeprom_slowly((int)init_freq, (int)freq_step);
}

//----- (0002F300) --------------------------------------------------------
void init_asic_status_and_nonce_count()
{
  uint64_t *v0; // r3
  int offset; // [sp+4h] [bp-10h]
  int y; // [sp+8h] [bp-Ch]
  int x; // [sp+Ch] [bp-8h]

  for ( x = 0; x <= 15; ++x )
  {
    if ( dev->chain_exist[x] )
    {
      offset = 0;
      for ( y = 0; y < dev->chain_asic_num[x]; ++y )
      {
        if ( (y & 7) == 0 )
          dev->chain_asic_status_string[x][y + offset++] = 32;
        dev->chain_asic_status_string[x][y + offset] = 111;
        v0 = &dev->chain_asic_nonce[x][y];
        *(_DWORD *)v0 = 0;
        *((_DWORD *)v0 + 1) = 0;
      }
      dev->chain_asic_status_string[x][y + offset] = 0;
    }
  }
}

//----- (0002F4E4) --------------------------------------------------------
int start_read_temp_thread()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  read_temp_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_temp_id, 0, (void *(*)(void *))read_temp_func, read_temp_id) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: create thread for read temp\n",
          "driver-btm-soc.c",
          7135,
          (const char *)_FUNCTION___16748);
      fclose(pFile);
    }
    return -7;
  }
  else
  {
    pthread_detach(read_temp_id->pth);
    return 0;
  }
}

//----- (0002F5FC) --------------------------------------------------------
int start_read_hash_rate_thread()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  read_hash_rate = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_hash_rate, 0, (void *(*)(void *))get_hash_rate, read_hash_rate) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: create thread for get hashrate from asic failed\n",
          "driver-btm-soc.c",
          7149,
          (const char *)_FUNCTION___16753);
      fclose(pFile);
    }
    return -6;
  }
  else
  {
    pthread_detach(read_hash_rate->pth);
    return 0;
  }
}

//----- (0002F714) --------------------------------------------------------
int start_check_system_work_thread()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  check_system_work_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(check_system_work_id, 0, (void *(*)(void *))check_system_work, check_system_work_id) )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: create thread for check system\n",
          "driver-btm-soc.c",
          7163,
          (const char *)_FUNCTION___16758);
      fclose(pFile);
    }
    return -6;
  }
  else
  {
    pthread_detach(check_system_work_id->pth);
    return 0;
  }
}

//----- (0002F830) --------------------------------------------------------
void set_working_voltage_by_eeprom()
{
  double v0; // d0
  double v1; // r0
  int voltage; // [sp+10h] [bp-24h] BYREF
  FILE *pFile; // [sp+14h] [bp-20h]
  FILE *pFile_0; // [sp+18h] [bp-1Ch]
  int avg; // [sp+1Ch] [bp-18h]
  int work_mode; // [sp+20h] [bp-14h]
  int chain_num; // [sp+24h] [bp-10h]
  int sum; // [sp+28h] [bp-Ch]
  int chain; // [sp+2Ch] [bp-8h]

  sum = 0;
  avg = -1;
  chain_num = 0;
  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      work_mode = !opt_bitmain_economic_mode;
      eeprom_get_voltage(chain, work_mode, &voltage);
      sum += voltage;
      ++chain_num;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: eeprom voltage[%d] = %d\n",
            "driver-btm-soc.c",
            7198,
            (const char *)_FUNCTION___16769,
            chain,
            voltage);
        fclose(pFile);
      }
    }
  }
  if ( chain_num )
  {
    avg = sum / chain_num;
    if ( sum == chain_num * (sum / chain_num) )
    {
      LODWORD(v1) = sum / chain_num;
      set_working_voltage(v1);
    }
    else if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
      {
        get_working_voltage();
        fprintf(
          pFile_0,
          "%s:%d:%s: Voltage are different. Will use default setting(voltage = %f).\n",
          "driver-btm-soc.c",
          7211,
          (const char *)_FUNCTION___16769,
          v0);
      }
      fclose(pFile_0);
    }
  }
}
// 2F9D8: variable 'v1' is possibly undefined
// 2FA68: variable 'v0' is possibly undefined

//----- (0002FA88) --------------------------------------------------------
void init_working_voltage()
{
  double v0; // r0
  FILE *pFile; // [sp+14h] [bp-8h]

  LODWORD(v0) = is_fixed_freq_mode();
  if ( LODWORD(v0) && (*((_BYTE *)&config_parameter + 4) & 0x10) != 0 )
  {
    set_working_voltage(v0);
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: set fixed voltage to %f\n",
          "driver-btm-soc.c",
          7221,
          (const char *)_FUNCTION___16778,
          (double)config_parameter.voltage / 100.0);
      fclose(pFile);
    }
  }
  else
  {
    set_working_voltage_by_eeprom();
  }
}
// 2FAE0: variable 'v0' is possibly undefined

//----- (0002FBA8) --------------------------------------------------------
void show_sn()
{
  int v0; // r3
  unsigned __int8 buf[100]; // [sp+8h] [bp-7Ch] BYREF
  FILE *pFile; // [sp+6Ch] [bp-18h]
  FILE *pFile_0; // [sp+70h] [bp-14h]
  FILE *pFile_1; // [sp+74h] [bp-10h]
  int len; // [sp+78h] [bp-Ch]
  FILE *fp; // [sp+7Ch] [bp-8h]

  fp = fopen("/nvdata/sn", "r");
  if ( fp )
  {
    fseek(fp, 0, 2);
    len = ftell(fp);
    fseek(fp, 0, 0);
    v0 = len;
    if ( len >= 100 )
      v0 = 100;
    len = v0;
    if ( fread(buf, v0, 1u, fp) )
    {
      if ( buf[len - 1] == 10 )
        buf[len - 1] = 0;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: %s\n",
            "driver-btm-soc.c",
            7252,
            (const char *)_FUNCTION___16786,
            (const char *)buf);
        fclose(pFile_0);
      }
    }
    else if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%s:%d:%s: read /nvdata/sn wrong\n", "driver-btm-soc.c", 7256, (const char *)_FUNCTION___16786);
      fclose(pFile_1);
    }
    fclose(fp);
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: no SN got, please write SN to /nvdata/sn\n",
        "driver-btm-soc.c",
        7237,
        (const char *)_FUNCTION___16786);
    fclose(pFile);
  }
}

//----- (0002FE2C) --------------------------------------------------------
void show_mode()
{
  memset(displayed_mode, 0, sizeof(displayed_mode));
  if ( opt_bitmain_economic_mode )
    displayed_mode[0] = 76;
  else
    displayed_mode[0] = 72;
}

//----- (0002FE88) --------------------------------------------------------
void get_freq_from_eeprom()
{
  int max_freq; // [sp+10h] [bp-1Ch] BYREF
  FILE *pFile; // [sp+14h] [bp-18h]
  uint32_t *buf; // [sp+18h] [bp-14h]
  bool is_eeprom_read_success; // [sp+1Fh] [bp-Dh]
  int work_mode; // [sp+20h] [bp-Ch]
  bool is_freq_valid; // [sp+25h] [bp-7h]
  uint8_t asic; // [sp+26h] [bp-6h]
  uint8_t chain; // [sp+27h] [bp-5h]

  is_eeprom_read_success = 0;
  if ( !freq_tuning_get_max_freq(&max_freq) )
  {
    power_off_hash_board(All_Chain);
    stop_mining("Get max freq failed!\n");
  }
  for ( chain = 0; chain <= 0xFu; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      buf = scan_result[chain].freq_eeprom;
      memset(buf, 0, 0x1B0u);
      work_mode = !opt_bitmain_economic_mode;
      is_eeprom_read_success = eeprom_get_freq(chain, work_mode, buf, 48) == 0;
      if ( is_eeprom_read_success )
      {
        is_freq_valid = 1;
        for ( asic = 0; asic <= 0x2Fu; ++asic )
        {
          if ( buf[asic] > max_freq )
          {
            is_freq_valid = 0;
            if ( log_level > 3 )
            {
              print_crt_time_to_file(log_file, 3u);
              pFile = fopen((const char *)log_file, "a+");
              if ( pFile )
                fprintf(
                  pFile,
                  "%s:%d:%s: Freq(%d) > Max_freq(%d), invalid!\n",
                  "driver-btm-soc.c",
                  7322,
                  (const char *)_FUNCTION___16804,
                  buf[asic],
                  max_freq);
              fclose(pFile);
            }
            break;
          }
        }
      }
      if ( !is_eeprom_read_success || !is_freq_valid )
      {
        power_off_hash_board(All_Chain);
        stop_mining("Get frequency from eeprom failed!\n");
      }
    }
  }
}

//----- (00030114) --------------------------------------------------------
void hash_board_power_on_with_reset()
{
  int chain; // [sp+4h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      set_reset_hashboard(chain, 1);
      sleep(3u);
      hashboard_power_on(chain);
      sleep(2u);
      set_reset_hashboard(chain, 0);
      sleep(3u);
    }
  }
}

//----- (000301B8) --------------------------------------------------------
void check_asic_number()
{
  FILE *pFile; // [sp+10h] [bp-14h]
  FILE *pFile_0; // [sp+14h] [bp-10h]
  int i; // [sp+18h] [bp-Ch]
  int chain; // [sp+1Ch] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      check_asic_reg_oneChain(chain, 0, 0);
      if ( dev->chain_asic_num[chain] == 48 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: Chain[%d]: find %d asic.\n",
              "driver-btm-soc.c",
              7397,
              (const char *)_FUNCTION___16826,
              chain,
              dev->chain_asic_num[chain]);
          fclose(pFile_0);
        }
      }
      else
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Chain %d only find %d asic, will power off hash board %d\n",
              "driver-btm-soc.c",
              7373,
              (const char *)_FUNCTION___16826,
              chain,
              dev->chain_asic_num[chain],
              chain);
          fclose(pFile);
        }
        hashboard_power_off(chain);
        if ( !freq_mode )
        {
          for ( i = 0; i <= 15; ++i )
          {
            if ( dev->chain_exist[i] )
            {
              if ( dev->chain_asic_num[i] == 48 )
                hashboard_power_off(i);
            }
          }
          stop_mining("Cannot find all asic.\n");
        }
        dev->chain_exist[chain] = 0;
        --dev->chain_num;
      }
    }
  }
}

//----- (000304BC) --------------------------------------------------------
void set_order_clock()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int chain; // [sp+Ch] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d]: set order clock, stragegy 3\n",
            "driver-btm-soc.c",
            7451,
            (const char *)_FUNCTION___16840,
            chain);
        fclose(pFile);
      }
      set_config_BM1391_t(chain, 0, 1u, 0x80u, 0);
      set_config_BM1391_t(chain, 0, 1u, 0x84u, 0);
      usleep(0x186A0u);
      set_config_BM1391_t(chain, 0, 1u, 0x20u, 1u);
    }
  }
}

//----- (0003061C) --------------------------------------------------------
int __cdecl bitmain_soc_init(init_config config)
{
  const char *v1; // r3
  double v3; // r0
  int dhash_acc_control; // r0
  float v5; // s0
  float v6; // r0
  int v7; // r0
  float v8; // r1
  float v9; // r2
  FILE *pFile_8; // [sp+14h] [bp-38h]
  FILE *pFile_7; // [sp+1Ch] [bp-30h]
  FILE *pFile_6; // [sp+20h] [bp-2Ch]
  FILE *pFile_5; // [sp+24h] [bp-28h]
  FILE *pFile_4; // [sp+28h] [bp-24h]
  FILE *pFile_3; // [sp+2Ch] [bp-20h]
  FILE *pFile_2; // [sp+30h] [bp-1Ch]
  FILE *pFile_1; // [sp+34h] [bp-18h]
  FILE *pFile_0; // [sp+38h] [bp-14h]
  FILE *pFile; // [sp+3Ch] [bp-10h]
  unsigned __int8 ret; // [sp+47h] [bp-5h]
  unsigned __int8 reta; // [sp+47h] [bp-5h]
  unsigned __int8 retb; // [sp+47h] [bp-5h]
  unsigned __int8 retc; // [sp+47h] [bp-5h]
  unsigned __int8 retd; // [sp+47h] [bp-5h]

  opt_multi_version = 1;
  opt_bitmain_ab = 1;
  set_privite_log_file("/tmp/initlog", &init_log_bak);
  log_init();
  init_freq_mode();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s\n",
        "driver-btm-soc.c",
        7474,
        (const char *)_FUNCTION___16851,
        (const char *)g_miner_type_const);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: opt_multi_version=%d\n",
        "driver-btm-soc.c",
        7475,
        (const char *)_FUNCTION___16851,
        opt_multi_version);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(
        pFile_1,
        "%s:%d:%s: opt_bitmain_ab=%d\n",
        "driver-btm-soc.c",
        7476,
        (const char *)_FUNCTION___16851,
        opt_bitmain_ab);
    fclose(pFile_1);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
    {
      if ( opt_bitmain_economic_mode )
        v1 = "true";
      else
        v1 = "false";
      fprintf(
        pFile_2,
        "%s:%d:%s: opt_bitmain_economic_mode=%s\n",
        "driver-btm-soc.c",
        7477,
        (const char *)_FUNCTION___16851,
        v1);
    }
    fclose(pFile_2);
  }
  show_sn();
  show_mode();
  init_phy_mem_nonce2_jobid_address();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s: Miner compile time: %s type: %s\n",
        "driver-btm-soc.c",
        7484,
        (const char *)_FUNCTION___16851,
        (const char *)g_miner_compiletime,
        (const char *)g_miner_type);
    fclose(pFile_3);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(
        pFile_4,
        "%s:%d:%s: last commit version: a72fb33 commit time: 2019-01-21 21:17:43 build: 2019-01-22 11:21:49\n",
        "driver-btm-soc.c",
        7486,
        (const char *)_FUNCTION___16851);
    fclose(pFile_4);
  }
  ret = init_global_config_parameter(config);
  if ( ret )
    return ret;
  init_led();
  bitmain_axi_init();
  check_fan_multi();
  init_dev_frequency();
  start_http_thread();
  if ( !freq_mode )
    do_freq_tuning();
  reta = start_read_nonce_reg_thread();
  if ( reta )
    return reta;
  if ( (*((_BYTE *)&config_parameter + 4) & 1) != 0 )
    reset_fpga_and_hash_board();
  set_pwm(0x64u);
  set_Hardware_version(0x40000000u);
  read_fpga_id(FPGA_ID_str);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fprintf(
        pFile_5,
        "%s:%d:%s: miner ID : %s\n",
        "driver-btm-soc.c",
        7532,
        (const char *)_FUNCTION___16851,
        (const char *)FPGA_ID_str);
    fclose(pFile_5);
  }
  init_miner_version();
  dev->baud = 26;
  set_nonce2_and_job_id_store_address(PHY_MEM_NONCE2_JOBID_ADDRESS);
  set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
  check_chain();
  eeprom_load();
  dump_pcb_bom_version();
  init_pic();
  power_init();
  power_on();
  power_off_hash_board(All_Chain);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_6 = fopen((const char *)log_file, "a+");
    if ( pFile_6 )
      fprintf(
        pFile_6,
        "%s:%d:%s: Enter %ds sleep to make sure power release finish.\n",
        "driver-btm-soc.c",
        7556,
        (const char *)_FUNCTION___16851,
        30);
    fclose(pFile_6);
  }
  sleep(0x1Eu);
  init_working_voltage();
  set_iic_power_to_highest_voltage(v3);
  if ( !is_fixed_freq_mode() )
    eeprom_dump();
  if ( opt_multi_version )
  {
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFF701F | 0x8100);
  }
  cgsleep_ms(10);
  dev->corenum = 672;
  hash_board_power_on_with_reset();
  check_asic_number();
  set_order_clock();
  cgsleep_ms(10);
  software_set_address();
  cgsleep_ms(10);
  v5 = init_freq;
  set_pll(v6);
  calculate_timeout();
  cgsleep_ms(10);
  init_uart_baud();
  cgsleep_ms(10);
  set_clock_delay_control(All_Chain);
  cgsleep_ms(5);
  do_calibration_temperature_sensor();
  set_timeout_control();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_7 = fopen((const char *)log_file, "a+");
    if ( pFile_7 )
      fprintf(pFile_7, "%s:%d:%s: set TICKET_MASK\n", "driver-btm-soc.c", 7615, (const char *)_FUNCTION___16851);
    fclose(pFile_7);
  }
  set_asic_ticket_mask(ticket_mask);
  cgsleep_ms(10);
  if ( freq_mode != 2 )
  {
    get_freq_from_eeprom();
    if ( !g_total_hashrate )
      g_total_hashrate = get_fixed_total_hash_rate();
  }
  v7 = slowly_set_iic_power_to_working_voltage();
  set_freq_and_get_max_freq(v7, v8, v9);
  set_timeout((int)v5, 90);
  init_asic_status_and_nonce_count();
  retb = start_read_temp_thread();
  if ( retb )
    return retb;
  cgtime(&tv_send_job);
  cgtime(&tv_send);
  startCheckNetworkJob = 1;
  retc = start_read_hash_rate_thread();
  if ( retc )
    return retc;
  retd = start_check_system_work_thread();
  if ( retd )
    return retd;
  cgsleep_ms(500);
  set_start_time_point();
  get_average_voltage();
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fprintf(pFile_8, "%s:%d:%s: Init done!\n", "driver-btm-soc.c", 7684, (const char *)_FUNCTION___16851);
    fclose(pFile_8);
  }
  restore_syslog_file(&init_log_bak);
  return 0;
}
// 30C94: variable 'v3' is possibly undefined
// 30D38: variable 'v6' is possibly undefined
// 30E60: variable 'v8' is possibly undefined
// 30E60: variable 'v9' is possibly undefined

//----- (00030FC4) --------------------------------------------------------
bool is_re_open_core_now()
{
  return b_is_re_open_core;
}

//----- (00030FE8) --------------------------------------------------------
int __cdecl parse_job_to_soc(unsigned __int8 **buf, pool *pool, uint32_t id)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-87Ch] BYREF
  part_of_job part_job; // [sp+810h] [bp-7Ch] BYREF
  uint64_t nonce2; // [sp+868h] [bp-24h] BYREF
  uint16_t crc; // [sp+872h] [bp-1Ah]
  unsigned __int8 *tmp_buf; // [sp+874h] [bp-18h]
  uint32_t buf_len; // [sp+878h] [bp-14h]
  int i; // [sp+87Ch] [bp-10h]

  crc = 0;
  buf_len = 0;
  nonce2 = 0LL;
  part_job.token_type = 82;
  part_job.version = 0;
  part_job.pool_nu = pool_send_nu_16892;
  *((_BYTE *)&part_job + 9) = *((_BYTE *)&part_job + 9) & 0xFE | pool->swork.clean | 2;
  part_job.asic_diff = 15;
  part_job.job_id = id;
  part_job.support_ab = pool->support_ab;
  part_job.version_num = pool->version_num;
  hex2bin((unsigned __int8 *)&part_job.bbversion, pool->bbversion, 4u);
  hex2bin(part_job.prev_hash, pool->prev_hash, 0x20u);
  hex2bin((unsigned __int8 *)&part_job.nbit, pool->nbit, 4u);
  hex2bin((unsigned __int8 *)&part_job.ntime, pool->ntime, 4u);
  part_job.coinbase_len = pool->coinbase_len;
  part_job.nonce2_offset = pool->nonce2_offset;
  part_job.nonce2_bytes_num = pool->n2size;
  nonce2 = _uint64_identity(pool->nonce2);
  memcpy(&part_job.nonce2_start_value, &pool->coinbase[pool->nonce2_offset], sizeof(part_job.nonce2_start_value));
  memcpy(&part_job.nonce2_start_value, &nonce2, pool->n2size);
  part_job.merkles_num = pool->merkles;
  buf_len = pool->coinbase_len + 32 * pool->merkles + 90;
  tmp_buf = (unsigned __int8 *)malloc(buf_len);
  if ( !tmp_buf )
  {
    strcpy((char *)tmp42, "Failed to malloc tmp_buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  part_job.length = buf_len - 8;
  memset(tmp_buf, 0, buf_len);
  memcpy(tmp_buf, &part_job, 0x58u);
  memcpy(tmp_buf + 88, pool->coinbase, pool->coinbase_len);
  for ( i = 0; i < pool->merkles; ++i )
    memcpy(&tmp_buf[32 * i + 88 + pool->coinbase_len], pool->swork.merkle_bin[i], 0x20u);
  crc = CRC16(tmp_buf, buf_len - 2);
  *(_WORD *)&tmp_buf[buf_len - 2] = crc;
  ++pool_send_nu_16892;
  *buf = (unsigned __int8 *)malloc(buf_len);
  if ( !tmp_buf )
  {
    strcpy((char *)tmp42, "Failed to malloc buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  memcpy(*buf, tmp_buf, buf_len);
  memcpy(last_job_buffer, tmp_buf, buf_len);
  free(tmp_buf);
  return buf_len;
}

//----- (00031404) --------------------------------------------------------
int __cdecl send_job(unsigned __int8 *buf, pool *pool)
{
  int dhash_acc_control; // r0
  int nonce_fifo_interrupt; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  unsigned int buf2[32]; // [sp+20h] [bp-ECh] BYREF
  FILE *pFile_0; // [sp+A0h] [bp-6Ch]
  FILE *pFile_2; // [sp+A4h] [bp-68h]
  FILE *pFile_5; // [sp+A8h] [bp-64h]
  FILE *pFile_9; // [sp+ACh] [bp-60h]
  FILE *pFile_12; // [sp+B0h] [bp-5Ch]
  FILE *pFile_14; // [sp+B4h] [bp-58h]
  FILE *pFile_13; // [sp+B8h] [bp-54h]
  FILE *pFile_11; // [sp+BCh] [bp-50h]
  FILE *pFile_10; // [sp+C0h] [bp-4Ch]
  FILE *pFile_7; // [sp+C4h] [bp-48h]
  FILE *pFile_8; // [sp+C8h] [bp-44h]
  FILE *pFile_6; // [sp+CCh] [bp-40h]
  FILE *pFile_4; // [sp+D0h] [bp-3Ch]
  FILE *pFile_3; // [sp+D4h] [bp-38h]
  FILE *pFile_1; // [sp+D8h] [bp-34h]
  FILE *pFile; // [sp+DCh] [bp-30h]
  part_of_job *part_job; // [sp+E0h] [bp-2Ch]
  unsigned __int8 *coinbase_padding; // [sp+E4h] [bp-28h]
  unsigned __int8 *temp_buf; // [sp+E8h] [bp-24h]
  unsigned __int16 job_length; // [sp+EEh] [bp-1Eh]
  unsigned int j; // [sp+F0h] [bp-1Ch]
  unsigned int len; // [sp+F4h] [bp-18h]
  int times; // [sp+F8h] [bp-14h]
  unsigned __int8 *merkles_bin; // [sp+FCh] [bp-10h]
  unsigned int coinbase_padding_len; // [sp+100h] [bp-Ch]
  unsigned int i; // [sp+104h] [bp-8h]

  len = 0;
  i = 0;
  j = 0;
  coinbase_padding_len = 0;
  job_length = 0;
  temp_buf = 0;
  coinbase_padding = 0;
  merkles_bin = 0;
  memset(buf2, 0, sizeof(buf2));
  times = 0;
  part_job = 0;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: doTestPatten value %d\n",
        "driver-btm-soc.c",
        8007,
        (const char *)_FUNCTION___16916,
        doTestPatten);
    fclose(pFile);
  }
  if ( doTestPatten )
    return 0;
  if ( *buf != 82 )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: SEND_JOB_TYPE is wrong : 0x%x\n",
          "driver-btm-soc.c",
          8013,
          (const char *)_FUNCTION___16916,
          *buf);
      fclose(pFile_0);
    }
    return -1;
  }
  len = *((_DWORD *)buf + 1);
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: len = 0x%x\n", "driver-btm-soc.c", 8018, (const char *)_FUNCTION___16916, len);
    fclose(pFile_1);
  }
  temp_buf = (unsigned __int8 *)malloc(len + 8);
  if ( !temp_buf )
  {
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%s:%d:%s: malloc buffer failed.\n", "driver-btm-soc.c", 8023, (const char *)_FUNCTION___16916);
      fclose(pFile_2);
    }
    return -2;
  }
  memset(temp_buf, 0, len + 8);
  memcpy(temp_buf, buf, len + 8);
  part_job = (part_of_job *)temp_buf;
  if ( dev->current_job_start_address == job_start_address_1 )
  {
    dev->current_job_start_address = job_start_address_2;
    goto LABEL_32;
  }
  if ( dev->current_job_start_address == job_start_address_2 )
  {
    dev->current_job_start_address = job_start_address_1;
LABEL_32:
    if ( part_job->support_ab )
      opt_multi_version = part_job->version_num;
    else
      opt_multi_version = 1;
    if ( tmp_version_16913 != opt_multi_version )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: Version num %d\n",
            "driver-btm-soc.c",
            8054,
            (const char *)_FUNCTION___16916,
            opt_multi_version);
        fclose(pFile_4);
      }
      tmp_version_16913 = opt_multi_version;
    }
    if ( (part_job->coinbase_len & 0x3Fu) <= 0x37 )
      coinbase_padding_len = ((part_job->coinbase_len >> 6) + 1) << 6;
    else
      coinbase_padding_len = ((part_job->coinbase_len >> 6) + 2) << 6;
    coinbase_padding = (unsigned __int8 *)malloc(coinbase_padding_len);
    if ( !coinbase_padding )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_5 = fopen((const char *)log_file, "a+");
        if ( pFile_5 )
          fprintf(
            pFile_5,
            "%s:%d:%s: malloc coinbase_padding failed.\n",
            "driver-btm-soc.c",
            8070,
            (const char *)_FUNCTION___16916);
        fclose(pFile_5);
      }
      return -4;
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(
          pFile_6,
          "%s:%d:%s: coinbase_padding = 0x%x\n",
          "driver-btm-soc.c",
          8075,
          (const char *)_FUNCTION___16916,
          coinbase_padding);
      fclose(pFile_6);
    }
    if ( part_job->merkles_num )
    {
      merkles_bin = (unsigned __int8 *)malloc(32 * part_job->merkles_num);
      if ( !merkles_bin )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_7 = fopen((const char *)log_file, "a+");
          if ( pFile_7 )
            fprintf(
              pFile_7,
              "%s:%d:%s: malloc merkles_bin failed.\n",
              "driver-btm-soc.c",
              8083,
              (const char *)_FUNCTION___16916);
          fclose(pFile_7);
        }
        return -5;
      }
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(
            pFile_8,
            "%s:%d:%s: merkles_bin = 0x%x\n",
            "driver-btm-soc.c",
            8088,
            (const char *)_FUNCTION___16916,
            merkles_bin);
        fclose(pFile_8);
      }
    }
    memset(coinbase_padding, 0, coinbase_padding_len);
    memcpy(coinbase_padding, buf + 88, part_job->coinbase_len);
    coinbase_padding[part_job->coinbase_len] = 0x80;
    *(_DWORD *)&coinbase_padding[(coinbase_padding_len - 4) & 0xFFFFFFFC] = ((8 * (unsigned int)part_job->coinbase_len) >> 24) | ((8 * (unsigned int)part_job->coinbase_len) >> 8) & 0xFF00 | (part_job->coinbase_len << 11) & 0xFF0000 | (part_job->coinbase_len << 27);
    *(_DWORD *)&coinbase_padding[(coinbase_padding_len - 8) & 0xFFFFFFFC] = 0;
    l_coinbase_padding = c_coinbase_padding;
    c_coinbase_padding = coinbase_padding_len;
    for ( i = 0; i < coinbase_padding_len; ++i )
      *((_BYTE *)dev->current_job_start_address + i) = coinbase_padding[i];
    for ( i = 0; i < coinbase_padding_len; ++i )
    {
      if ( *((unsigned __int8 *)dev->current_job_start_address + i) != coinbase_padding[i] && log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_9 = fopen((const char *)log_file, "a+");
        if ( pFile_9 )
          fprintf(
            pFile_9,
            "%s:%d:%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x\n",
            "driver-btm-soc.c",
            8112,
            (const char *)_FUNCTION___16916,
            i,
            *((unsigned __int8 *)dev->current_job_start_address + i),
            i,
            coinbase_padding[i]);
        fclose(pFile_9);
      }
    }
    l_merkles_num = c_merkles_num;
    c_merkles_num = part_job->merkles_num;
    if ( part_job->merkles_num )
    {
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_10 = fopen((const char *)log_file, "a+");
        if ( pFile_10 )
          fprintf(
            pFile_10,
            "%s:%d:%s: copy merkle bin into memory ...\n",
            "driver-btm-soc.c",
            8119,
            (const char *)_FUNCTION___16916);
        fclose(pFile_10);
      }
      memset(merkles_bin, 0, 32 * part_job->merkles_num);
      memcpy(merkles_bin, &buf[part_job->coinbase_len + 88], 32 * part_job->merkles_num);
      for ( i = 0; i < 32 * (unsigned int)part_job->merkles_num; ++i )
        *((_BYTE *)dev->current_job_start_address + coinbase_padding_len + i) = merkles_bin[i];
      for ( i = 0; i < 32 * (unsigned int)part_job->merkles_num; ++i )
      {
        if ( *((unsigned __int8 *)dev->current_job_start_address + coinbase_padding_len + i) != merkles_bin[i]
          && log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_11 = fopen((const char *)log_file, "a+");
          if ( pFile_11 )
            fprintf(
              pFile_11,
              "%s:%d:%s: merkles_in_ddr[%d] = 0x%x, but *(merkles_bin + %d) =0x%x\n",
              "driver-btm-soc.c",
              8133,
              (const char *)_FUNCTION___16916,
              i,
              *((unsigned __int8 *)dev->current_job_start_address + coinbase_padding_len + i),
              i,
              merkles_bin[i]);
          fclose(pFile_11);
        }
      }
    }
    dhash_acc_control = get_dhash_acc_control();
    set_dhash_acc_control(dhash_acc_control & 0xFFFFFF3F | 0x80);
    cgsleep_ms(1);
    while ( (get_dhash_acc_control() & 0x40) != 0 )
    {
      cgsleep_ms(1);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_12 = fopen((const char *)log_file, "a+");
        if ( pFile_12 )
          fprintf(
            pFile_12,
            "%s:%d:%s: run bit is 1 after set it to 0\n",
            "driver-btm-soc.c",
            8143,
            (const char *)_FUNCTION___16916);
        fclose(pFile_12);
      }
      ++times;
    }
    cgsleep_ms(1);
    if ( dev->current_job_start_address == job_start_address_1 )
    {
      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 0x200000);
    }
    else if ( dev->current_job_start_address == job_start_address_2 )
    {
      set_job_start_address(PHY_MEM_NONCE2_JOBID_ADDRESS + 2162688);
    }
    if ( (*((_BYTE *)part_job + 9) & 2) != 0 )
    {
      set_ticket_mask(part_job->asic_diff);
      dev->diff = part_job->asic_diff;
    }
    set_job_id(part_job->job_id);
    set_block_header_version(part_job->bbversion);
    get_block_header_version();
    if ( opt_multi_version == 2 )
    {
      set_block_header_version_1(part_job->bbversion | 0x4000);
    }
    else if ( opt_multi_version == 4 )
    {
      set_block_header_version_1(part_job->bbversion | 0x4000);
      set_block_header_version_2(part_job->bbversion | 0x8000);
      set_block_header_version_3(part_job->bbversion | 0xC000);
    }
    else if ( opt_multi_version != 1 && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_13 = fopen((const char *)log_file, "a+");
      if ( pFile_13 )
        fprintf(
          pFile_13,
          "%s:%d:%s: Note: Unknown opt_multi_version %d\n",
          "driver-btm-soc.c",
          8186,
          (const char *)_FUNCTION___16916,
          opt_multi_version);
      fclose(pFile_13);
    }
    memset(buf2, 0, sizeof(buf2));
    for ( i = 0; i <= 7; ++i )
      buf2[i] = (part_job->prev_hash[4 * i + 3] << 24) | (part_job->prev_hash[4 * i + 2] << 16) | (part_job->prev_hash[4 * i + 1] << 8) | part_job->prev_hash[4 * i];
    set_pre_header_hash(buf2);
    set_time_stamp(part_job->ntime);
    set_target_bits(part_job->nbit);
    j = (part_job->nonce2_offset << 16) | ((unsigned __int8)part_job->nonce2_bytes_num << 8) | (unsigned __int8)(coinbase_padding_len >> 6);
    set_coinbase_length_and_nonce2_length(j);
    buf2[0] = 0;
    buf2[1] = 0;
    *(_QWORD *)buf2 = part_job->nonce2_start_value;
    set_work_nonce2(buf2);
    set_merkle_bin_number(part_job->merkles_num);
    job_length = 32 * part_job->merkles_num + coinbase_padding_len;
    set_job_length(job_length);
    cgsleep_ms(1);
    if ( !gBegin_get_nonce )
    {
      nonce_fifo_interrupt = get_nonce_fifo_interrupt();
      set_nonce_fifo_interrupt(nonce_fifo_interrupt | 0x10000);
      v5 = get_dhash_acc_control();
      set_dhash_acc_control(v5 | 0x80);
      gBegin_get_nonce = 1;
      re_calculate_AVG();
    }
    set_time_out_control(dev->timeout & 0x1FFFF | 0x80000000);
    if ( (*((_BYTE *)part_job + 9) & 1) != 0 )
    {
      if ( pool->support_ab )
      {
LABEL_121:
        v6 = get_dhash_acc_control();
        set_dhash_acc_control(v6 & 0xFFFFF0BF | ((_WORD)opt_multi_version << 8) & 0xF00 | 0x8060);
LABEL_125:
        free(temp_buf);
        free(coinbase_padding);
        if ( merkles_bin )
          free(merkles_bin);
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_14 = fopen((const char *)log_file, "a+");
          if ( pFile_14 )
            fprintf(pFile_14, "%s:%d:%s: --- end\n", "driver-btm-soc.c", 8260, (const char *)_FUNCTION___16916);
          fclose(pFile_14);
        }
        set_status(STATUS_OK);
        cgtime(&tv_send_job);
        cgsleep_ms(1);
        return 0;
      }
    }
    else if ( pool->support_ab )
    {
      goto LABEL_121;
    }
    v7 = get_dhash_acc_control();
    set_dhash_acc_control(v7 & 0xFFFF709F | 0x8160);
    goto LABEL_125;
  }
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fprintf(
        pFile_3,
        "%s:%d:%s: dev->current_job_start_address = %p, but job_start_address_1 = %p, job_start_address_2 = %p\n",
        "driver-btm-soc.c",
        8044,
        (const char *)_FUNCTION___16916,
        dev->current_job_start_address,
        job_start_address_1,
        job_start_address_2);
    fclose(pFile_3);
  }
  return -3;
}

//----- (000328F0) --------------------------------------------------------
void __cdecl copy_pool_stratum(pool *pool_stratum, pool *pool)
{
  uint16_t v2; // r0
  unsigned __int8 **v3; // r4
  unsigned __int16 crc; // [sp+16h] [bp-1Eh]
  uint16_t job_id_len; // [sp+18h] [bp-1Ch]
  unsigned int coinbase_len; // [sp+1Ch] [bp-18h]
  int merkles; // [sp+20h] [bp-14h]
  int i; // [sp+24h] [bp-10h]
  int ia; // [sp+24h] [bp-10h]

  merkles = pool->merkles;
  coinbase_len = pool->coinbase_len;
  if ( pool->swork.job_id )
  {
    if ( !pool_stratum->swork.job_id
      || (v2 = strlen((const char *)pool->swork.job_id),
          crc = CRC16(pool->swork.job_id, v2),
          job_id_len = strlen((const char *)pool_stratum->swork.job_id),
          crc != CRC16(pool_stratum->swork.job_id, job_id_len)) )
    {
      cg_wlock(&pool_stratum->data_lock, "driver-btm-soc.c", _func___16961, 8299);
      free(pool_stratum->swork.job_id);
      free(pool_stratum->nonce1);
      free(pool_stratum->coinbase);
      pool_stratum->coinbase = (unsigned __int8 *)cgcalloc(coinbase_len, 1u, "driver-btm-soc.c", _func___16961, 8304);
      memcpy(pool_stratum->coinbase, pool->coinbase, coinbase_len);
      for ( i = 0; i < pool_stratum->merkles; ++i )
        free(pool_stratum->swork.merkle_bin[i]);
      if ( merkles )
      {
        pool_stratum->swork.merkle_bin = (unsigned __int8 **)cgrealloc(
                                                               pool_stratum->swork.merkle_bin,
                                                               4 * merkles + 1,
                                                               "driver-btm-soc.c",
                                                               _func___16961,
                                                               8312);
        for ( ia = 0; ia < merkles; ++ia )
        {
          v3 = &pool_stratum->swork.merkle_bin[ia];
          *v3 = (unsigned __int8 *)cgmalloc(0x20u, "driver-btm-soc.c", _func___16961, 8315);
          memcpy(pool_stratum->swork.merkle_bin[ia], pool->swork.merkle_bin[ia], 0x20u);
        }
      }
      pool_stratum->pool_no = pool->pool_no;
      pool_stratum->sdiff = pool->sdiff;
      pool_stratum->coinbase_len = pool->coinbase_len;
      pool_stratum->nonce2_offset = pool->nonce2_offset;
      pool_stratum->n2size = pool->n2size;
      pool_stratum->merkles = pool->merkles;
      pool_stratum->swork.job_id = (unsigned __int8 *)strdup((const char *)pool->swork.job_id);
      pool_stratum->nonce1 = (unsigned __int8 *)strdup((const char *)pool->nonce1);
      memcpy(pool_stratum->ntime, pool->ntime, sizeof(pool_stratum->ntime));
      memcpy(pool_stratum->header_bin, pool->header_bin, sizeof(pool_stratum->header_bin));
      cg_wunlock(&pool_stratum->data_lock, "driver-btm-soc.c", _func___16961, 8331);
    }
  }
}

//----- (00032CB4) --------------------------------------------------------
bool __cdecl bitmain_soc_prepare(thr_info *thr)
{
  init_config soc_config; // [sp+18h] [bp-2Ch] BYREF
  bitmain_soc_info *info; // [sp+38h] [bp-Ch]
  cgpu_info *bitmain_soc; // [sp+3Ch] [bp-8h]

  bitmain_soc = thr->cgpu;
  info = (bitmain_soc_info *)bitmain_soc->device_data;
  info->thr = thr;
  mutex_init(&info->lock, "driver-btm-soc.c", _func___16973, 8340);
  cglock_init(&info->update_lock, "driver-btm-soc.c", _func___16973, 8341);
  cglock_init(&info->pool0.data_lock, "driver-btm-soc.c", _func___16973, 8342);
  cglock_init(&info->pool1.data_lock, "driver-btm-soc.c", _func___16973, 8343);
  cglock_init(&info->pool2.data_lock, "driver-btm-soc.c", _func___16973, 8344);
  memset(&soc_config, 0, sizeof(soc_config));
  soc_config.token_type = 81;
  soc_config.length = 26;
  *((_BYTE *)&soc_config + 4) |= 1u;
  *((_BYTE *)&soc_config + 4) |= 2u;
  *((_BYTE *)&soc_config + 4) |= 4u;
  *((_BYTE *)&soc_config + 4) |= 8u;
  *((_BYTE *)&soc_config + 4) |= 0x10u;
  *((_BYTE *)&soc_config + 4) |= 0x20u;
  *((_BYTE *)&soc_config + 4) |= 0x40u;
  *((_BYTE *)&soc_config + 4) |= 0x80u;
  *((_BYTE *)&soc_config + 5) |= 1u;
  *((_BYTE *)&soc_config + 5) |= 2u;
  *((_BYTE *)&soc_config + 5) |= 4u;
  soc_config.chain_num = 9;
  soc_config.asic_num = 54;
  soc_config.fan_pwm_percent = 100;
  soc_config.temperature = 80;
  soc_config.frequency = opt_bitmain_soc_freq;
  soc_config.voltage = opt_bitmain_soc_voltage;
  soc_config.chain_check_time_integer = 10;
  soc_config.chain_check_time_fractions = 10;
  soc_config.chip_address = 4;
  soc_config.chain_min_freq = 400;
  soc_config.chain_max_freq = 600;
  soc_config.crc = CRC16(&soc_config.token_type, 0x1Eu);
  bitmain_soc_init(soc_config);
  return 1;
}

//----- (00032EE8) --------------------------------------------------------
void __cdecl bitmain_soc_reinit_device(cgpu_info *bitmain)
{
  if ( !status_error )
    exit(0);
}

//----- (00032F28) --------------------------------------------------------
void __cdecl bitmain_soc_detect(bool hotplug)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-810h] BYREF
  bitmain_soc_info *a; // [sp+80Ch] [bp-10h]
  device_drv *drv; // [sp+810h] [bp-Ch]
  cgpu_info *cgpu; // [sp+814h] [bp-8h]

  cgpu = (cgpu_info *)calloc(1u, 0x188u);
  drv = &bitmain_soc_drv;
  if ( !cgpu )
    _assert_fail("cgpu", "driver-btm-soc.c", 0x20D8u, (const char *)_PRETTY_FUNCTION___16984);
  cgpu->drv = drv;
  cgpu->deven = DEV_ENABLED;
  cgpu->threads = 1;
  cgpu->device_data = calloc(0x1898u, 1u);
  if ( !cgpu->device_data )
  {
    strcpy((char *)tmp42, "Failed to calloc cgpu_info data");
    applog(3, tmp42, 1);
    quit(1);
  }
  a = (bitmain_soc_info *)cgpu->device_data;
  a->pool0_given_id = 0;
  a->pool1_given_id = 1;
  a->pool2_given_id = 2;
  if ( !add_cgpu(cgpu) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-soc.c", 0x20E4u, (const char *)_PRETTY_FUNCTION___16984);
}

//----- (000330B4) --------------------------------------------------------
uint64_t __cdecl hashtest_submit(
        thr_info *thr,
        work *work,
        uint32_t nonce,
        uint8_t *midstate,
        pool *pool,
        uint64_t nonce2,
        uint32_t chain_id)
{
  sha2_context ctx; // [sp+5Ch] [bp-188h] BYREF
  nonce_format_t nonce_tmp; // [sp+144h] [bp-A0h]
  unsigned __int8 hash2[32]; // [sp+148h] [bp-9Ch] BYREF
  unsigned __int8 hash1[32]; // [sp+168h] [bp-7Ch] BYREF
  FILE *pFile_3; // [sp+188h] [bp-5Ch]
  FILE *pFile_2; // [sp+18Ch] [bp-58h]
  FILE *pFile_1; // [sp+190h] [bp-54h]
  FILE *pFile_4; // [sp+194h] [bp-50h]
  unsigned __int8 which_core_nonce; // [sp+19Ah] [bp-4Ah]
  unsigned __int8 which_asic_nonce; // [sp+19Bh] [bp-49h]
  uint32_t *hash2_32; // [sp+19Ch] [bp-48h]
  FILE *pFile_0; // [sp+1A0h] [bp-44h]
  FILE *pFile; // [sp+1A4h] [bp-40h]
  uint64_t tmp_net_diff; // [sp+1A8h] [bp-3Ch]
  uint64_t tmp_pool_diff; // [sp+1B0h] [bp-34h]
  uint64_t hashes; // [sp+1B8h] [bp-2Ch]
  int i; // [sp+1C4h] [bp-20h]

  hashes = 0LL;
  nonce_tmp.v = nonce;
  if ( (unsigned __int64)work->sdiff != pool_diff_17072 )
  {
    pool_diff_17072 = (unsigned __int64)work->sdiff;
    pool_diff_bit_17074 = 0LL;
    tmp_pool_diff = pool_diff_17072;
    while ( tmp_pool_diff )
    {
      tmp_pool_diff >>= 1;
      ++pool_diff_bit_17074;
    }
    --pool_diff_bit_17074;
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: pool_diff:%lld work_diff:%f pool_diff_bit:%lld ...\n",
          "driver-btm-soc.c",
          8630,
          (const char *)_FUNCTION___17082,
          pool_diff_17072,
          work->sdiff,
          pool_diff_bit_17074);
      fclose(pFile);
    }
  }
  if ( (unsigned __int64)current_diff != net_diff_17073 )
  {
    net_diff_17073 = (unsigned __int64)current_diff;
    net_diff_bit_17075 = 0LL;
    tmp_net_diff = (unsigned __int64)current_diff;
    while ( tmp_net_diff )
    {
      tmp_net_diff >>= 1;
      ++net_diff_bit_17075;
    }
    --net_diff_bit_17075;
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: net_diff:%lld current_diff:%f net_diff_bit %lld ...\n",
          "driver-btm-soc.c",
          8644,
          (const char *)_FUNCTION___17082,
          net_diff_17073,
          current_diff,
          net_diff_bit_17075);
      fclose(pFile_0);
    }
  }
  hash2_32 = (uint32_t *)hash1;
  memcpy(ctx.state, work->midstate, sizeof(ctx.state));
  ctx.total[0] = 80;
  ctx.total[1] = 0;
  memcpy(hash1, &work->data[64], 0xCu);
  flip_swab_0(ctx.buffer, hash1, 0xCu);
  *(_DWORD *)hash1 = nonce;
  flip_swab_0(&ctx.buffer[12], hash1, 4u);
  sha2_finish(&ctx, hash1);
  memset(&ctx, 0, sizeof(ctx));
  sha2(hash1, 32, hash2);
  flip32_0(hash1, hash2);
  if ( hash2_32[7] )
  {
    if ( dev->chain_exist[chain_id] == 1 )
    {
      inc_hw_errors(thr);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: chain[%d] nonce fail\n",
            "driver-btm-soc.c",
            8678,
            (const char *)_FUNCTION___17082,
            chain_id);
        fclose(pFile_1);
      }
      ++dev->chain_hw[chain_id];
      which_asic_nonce = get_asic_id(nonce_tmp);
      which_core_nonce = get_core_id(nonce_tmp);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: HW: chain[%d] asic[%d] core[%d]\n",
            "driver-btm-soc.c",
            8685,
            (const char *)_FUNCTION___17082,
            chain_id,
            which_asic_nonce,
            which_core_nonce);
        fclose(pFile_2);
      }
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%s:%d:%s: HASH2_32[7] != 0\n", "driver-btm-soc.c", 8689, (const char *)_FUNCTION___17082);
      fclose(pFile_3);
    }
    return 0LL;
  }
  else
  {
    for ( i = 0; i <= 6 && !_bswap_32(hash2_32[6 - i]); ++i )
      ;
    if ( i >= pool_diff_bit_17074 >> 5 )
    {
      which_asic_nonce = get_asic_id(nonce_tmp);
      which_core_nonce = get_core_id(nonce_tmp);
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(
            pFile_4,
            "%s:%d:%s: chain %d which_asic_nonce %d which_core_nonce %d\n",
            "driver-btm-soc.c",
            8709,
            (const char *)_FUNCTION___17082,
            chain_id,
            which_asic_nonce,
            which_core_nonce);
        fclose(pFile_4);
      }
      ++dev->chain_asic_nonce[chain_id][which_asic_nonce];
      if ( _bswap_32(hash2_32[-(unsigned int)((__int64)pool_diff_bit_17074 >> 5) + 6]) >= 0xFFFFFFFF >> (pool_diff_bit_17074 & 0x1F) )
      {
        if ( _bswap_32(hash2_32[6]) <= 0xFFFFFE )
        {
          hashes += 256LL;
          h_each_chain[chain_id] += 256LL;
        }
      }
      else
      {
        hashes += 256LL;
        if ( current_diff != 0.0 )
        {
          for ( i = 0; i < net_diff_bit_17075 >> 5 && !_bswap_32(hash2_32[6 - i]); ++i )
            ;
          if ( i == net_diff_bit_17075 >> 5 )
            _bswap_32(hash2_32[-(unsigned int)((__int64)net_diff_bit_17075 >> 5) + 6]);
        }
        submit_nonce(thr, work, nonce);
      }
    }
    return hashes;
  }
}

//----- (00033B64) --------------------------------------------------------
void *__cdecl bitmain_scanhash(void *arg)
{
  int v1; // r3
  uint32_t v2; // r3
  uint8_t midstate[32]; // [sp+38h] [bp-9Ch] BYREF
  work *work; // [sp+58h] [bp-7Ch] BYREF
  FILE *pFile_4; // [sp+5Ch] [bp-78h]
  pool *c_pool; // [sp+60h] [bp-74h]
  FILE *pFile_3; // [sp+64h] [bp-70h]
  FILE *pFile_2; // [sp+68h] [bp-6Ch]
  FILE *pFile_1; // [sp+6Ch] [bp-68h]
  FILE *pFile_0; // [sp+70h] [bp-64h]
  pool *pool_stratum2; // [sp+74h] [bp-60h]
  pool *pool_stratum1; // [sp+78h] [bp-5Ch]
  pool *pool_stratum0; // [sp+7Ch] [bp-58h]
  FILE *pFile; // [sp+80h] [bp-54h]
  uint32_t version; // [sp+84h] [bp-50h]
  uint32_t work_id; // [sp+88h] [bp-4Ch]
  uint32_t chain_id; // [sp+8Ch] [bp-48h]
  uint64_t nonce2; // [sp+90h] [bp-44h]
  uint32_t job_id; // [sp+98h] [bp-3Ch]
  uint32_t nonce3; // [sp+9Ch] [bp-38h]
  FILE *pFile_5; // [sp+A0h] [bp-34h]
  bitmain_soc_info *info; // [sp+A4h] [bp-30h]
  cgpu_info *bitmain_soc; // [sp+A8h] [bp-2Ch]
  thr_info *thr; // [sp+ACh] [bp-28h]
  pool *pool; // [sp+B0h] [bp-24h]
  int i; // [sp+B4h] [bp-20h]

  thr = (thr_info *)arg;
  bitmain_soc = (cgpu_info *)*((_DWORD *)arg + 9);
  info = (bitmain_soc_info *)bitmain_soc->device_data;
  h = 0LL;
  pthread_mutex_lock(&nonce_mutex);
  cg_rlock(&info->update_lock, "driver-btm-soc.c", _func___17108, 8750);
  while ( nonce_read_out.nonce_num )
  {
    nonce3 = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce3;
    job_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].job_id;
    nonce2 = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].nonce2;
    chain_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].chain_num;
    work_id = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].work_id;
    version = HIBYTE(nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version) | (nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version >> 8) & 0xFF00 | (nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version << 8) & 0xFF0000 | (nonce_read_out.nonce_buffer[nonce_read_out.p_rd].header_version << 24);
    memset(midstate, 0, sizeof(midstate));
    for ( i = 0; i <= 31; ++i )
    {
      v1 = i & 3;
      if ( i <= 0 )
        v1 = -(-i & 3);
      midstate[4 * (7 - i / 4) + v1] = nonce_read_out.nonce_buffer[nonce_read_out.p_rd].midstate[i];
    }
    if ( log_level > 4 )
    {
      print_crt_time_to_file(log_file, 4u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chain_id:%d   job_id:0x%x   work_id:0x%x   nonce2:0x%llx   nonce3:0x%x   version:0x%x\n",
          "driver-btm-soc.c",
          8765,
          (const char *)_FUNCTION___17121,
          chain_id,
          job_id,
          work_id,
          nonce2,
          nonce3,
          version);
      fclose(pFile);
    }
    pool_stratum0 = &info->pool0;
    pool_stratum1 = &info->pool1;
    pool_stratum2 = &info->pool2;
    if ( nonce_read_out.p_rd > 0x1FD )
      nonce_read_out.p_rd = 0;
    else
      ++nonce_read_out.p_rd;
    --nonce_read_out.nonce_num;
    if ( nonce3 == last_nonce3_17106 && work_id == last_workid_17107 )
    {
      if ( dev->chain_exist[chain_id] == 1 )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: recv same nonce ...\n",
              "driver-btm-soc.c",
              8793,
              (const char *)_FUNCTION___17121);
          fclose(pFile_0);
        }
LABEL_51:
        inc_hw_errors(thr);
        ++dev->chain_hw[chain_id];
      }
    }
    else
    {
      last_nonce3_17106 = nonce3;
      last_workid_17107 = work_id;
      if ( log_level > 4 )
      {
        print_crt_time_to_file(log_file, 4u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: Chain ID J%d ...\n",
            "driver-btm-soc.c",
            8800,
            (const char *)_FUNCTION___17121,
            chain_id + 1);
        fclose(pFile_1);
      }
      if ( job_id >= given_id - 2 || job_id <= given_id )
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(
              pFile_3,
              "%s:%d:%s: given_id:%d job_id:%d switch:%d  ...\n",
              "driver-btm-soc.c",
              8812,
              (const char *)_FUNCTION___17121,
              given_id,
              job_id,
              given_id - job_id);
          fclose(pFile_3);
        }
        v2 = given_id - job_id;
        if ( given_id - job_id == 1 )
        {
          pool = pool_stratum1;
          goto LABEL_52;
        }
        if ( !v2 )
        {
          pool = pool_stratum0;
          goto LABEL_52;
        }
        if ( v2 == 2 )
        {
          pool = pool_stratum2;
LABEL_52:
          c_pool = pools[pool->pool_no];
          get_work_by_nonce2(thr, &work, pool, c_pool, nonce2, version);
          h += hashtest_submit(thr, work, nonce3, midstate, pool, nonce2, chain_id);
          free_work(&work, "driver-btm-soc.c", _func___17108, 8837);
        }
        else
        {
          if ( log_level > 4 )
          {
            print_crt_time_to_file(log_file, 4u);
            pFile_4 = fopen((const char *)log_file, "a+");
            if ( pFile_4 )
              fprintf(
                pFile_4,
                "%s:%d:%s: job_id non't found given=%d, job=%d...\n",
                "driver-btm-soc.c",
                8826,
                (const char *)_FUNCTION___17121,
                given_id,
                job_id);
            fclose(pFile_4);
          }
          if ( dev->chain_exist[chain_id] == 1 )
            goto LABEL_51;
        }
      }
      else
      {
        if ( log_level > 4 )
        {
          print_crt_time_to_file(log_file, 4u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(pFile_2, "%s:%d:%s: job_id error ...\n", "driver-btm-soc.c", 8803, (const char *)_FUNCTION___17121);
          fclose(pFile_2);
        }
        if ( dev->chain_exist[chain_id] == 1 )
          goto LABEL_51;
      }
    }
  }
  cg_runlock(&info->update_lock, "driver-btm-soc.c", _func___17108, 8839);
  pthread_mutex_unlock(&nonce_mutex);
  cgsleep_ms(1);
  if ( h && log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fprintf(
        pFile_5,
        "%s:%d:%s: hashes %llu ...\n",
        "driver-btm-soc.c",
        8844,
        (const char *)_FUNCTION___17121,
        0xFFFFFFFEFFFFFFFFLL * h);
    fclose(pFile_5);
  }
  h *= 0xFFFFFFFEFFFFFFFFLL;
  return 0;
}

//----- (00034730) --------------------------------------------------------
int64_t __cdecl bitmain_soc_scanhash(thr_info *thr)
{
  h = 0LL;
  bitmain_scanhash(thr);
  return h;
}

//----- (00034778) --------------------------------------------------------
void __cdecl bitmain_soc_update(cgpu_info *bitmain_soc)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-818h] BYREF
  unsigned __int8 *buf; // [sp+80Ch] [bp-18h] BYREF
  work *work; // [sp+810h] [bp-14h] BYREF
  pool *pool; // [sp+814h] [bp-10h]
  thr_info *thr; // [sp+818h] [bp-Ch]
  bitmain_soc_info *info; // [sp+81Ch] [bp-8h]

  info = (bitmain_soc_info *)bitmain_soc->device_data;
  thr = *bitmain_soc->thr;
  buf = 0;
  mutex_lock(&info->lock, "driver-btm-soc.c", _func___17153, 8866);
  thr->work_update = 0;
  thr->work_restart = 0;
  work = get_work(thr, thr->id);
  discard_work(&work, "driver-btm-soc.c", _func___17153, 8871);
  pool = current_pool();
  if ( !pool->has_stratum )
  {
    strcpy((char *)tmp42, "Bitmain S9 has to use stratum pools");
    applog(3, tmp42, 1);
    quit(1);
  }
  cg_wlock(&info->update_lock, "driver-btm-soc.c", _func___17153, 8878);
  cg_rlock(&pool->data_lock, "driver-btm-soc.c", _func___17153, 8879);
  info->pool_no = pool->pool_no;
  copy_pool_stratum(&info->pool2, &info->pool1);
  info->pool2_given_id = info->pool1_given_id;
  copy_pool_stratum(&info->pool1, &info->pool0);
  info->pool1_given_id = info->pool0_given_id;
  copy_pool_stratum(&info->pool0, pool);
  info->pool0_given_id = ++given_id;
  parse_job_to_soc(&buf, pool, info->pool0_given_id);
  if ( !status_error )
  {
    pthread_mutex_lock(&reinit_mutex);
    send_job(buf, pool);
    pthread_mutex_unlock(&reinit_mutex);
  }
  cg_runlock(&pool->data_lock, "driver-btm-soc.c", _func___17153, 8898);
  cg_wunlock(&info->update_lock, "driver-btm-soc.c", _func___17153, 8899);
  free(buf);
  mutex_unlock(&info->lock, "driver-btm-soc.c", _func___17153, 8901);
}

//----- (00034A70) --------------------------------------------------------
void __cdecl get_bitmain_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *bitmain_soc)
{
  ;
}

//----- (00034A98) --------------------------------------------------------
void __cdecl restore_syslog_file(LOG_FILE_BACKUP *backlog)
{
  use_syslog = backlog->use_syslog;
  g_logfile_enable = backlog->logfile_enable;
  g_log_file = 0;
  strcpy((char *)g_logfile_path, (const char *)backlog->logfile_path);
  strcpy((char *)g_logfile_openflag, (const char *)backlog->logfile_openflag);
}

//----- (00034B20) --------------------------------------------------------
void __cdecl backup_syslog_file(LOG_FILE_BACKUP *backlog)
{
  backlog->use_syslog = use_syslog;
  backlog->logfile_enable = g_logfile_enable;
  strcpy((char *)backlog->logfile_path, (const char *)g_logfile_path);
  strcpy((char *)backlog->logfile_openflag, (const char *)g_logfile_openflag);
}

//----- (00034B98) --------------------------------------------------------
void __cdecl set_privite_log_file(unsigned __int8 *logfile_name, LOG_FILE_BACKUP *backlog)
{
  backup_syslog_file(backlog);
  if ( g_log_file )
  {
    fclose(g_log_file);
    g_log_file = 0;
  }
  use_syslog = 0;
  g_logfile_enable = 1;
  strcpy((char *)g_logfile_path, (const char *)logfile_name);
  strcpy((char *)g_logfile_openflag, "w");
}

//----- (00034C40) --------------------------------------------------------
void __cdecl get_miner_info(unsigned __int8 *infoStr)
{
  double v1; // d0
  int chain_num; // [sp+14h] [bp-10h]
  int retlen; // [sp+18h] [bp-Ch]
  int retlena; // [sp+18h] [bp-Ch]
  int retlenb; // [sp+18h] [bp-Ch]
  int retlenc; // [sp+18h] [bp-Ch]
  int retlend; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  retlen = 0;
  get_working_voltage();
  chain_num = 0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] )
    {
      retlena = retlen + sprintf((char *)&infoStr[retlen], "chain%d_voltage=%d;", i + 1, (int)(v1 * 100.0));
      retlenb = retlena + sprintf((char *)&infoStr[retlena], "chain%d_voladded=%d;", i + 1, 0);
      retlenc = retlenb + sprintf((char *)&infoStr[retlenb], "chain%d_basefreq=%d;", i + 1, 275);
      retlen = retlenc + sprintf((char *)&infoStr[retlenc], "chain%d_badcore=%d;", i + 1, 0);
      ++chain_num;
    }
  }
  retlend = retlen + sprintf((char *)&infoStr[retlen], "chainnum=%d;", chain_num);
  sprintf((char *)&infoStr[retlend], "version=%s;", (const char *)g_miner_compiletime);
}
// 34C68: variable 'v1' is possibly undefined

//----- (00034E18) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
api_data *__cdecl bitmain_api_stats(cgpu_info *cgpu)
{
  double v1; // d0
  api_data *v2; // r0
  int v3; // r0
  int v4; // r0
  double v5; // d7
  _BYTE param_name[2048]; // [sp+Ch] [bp-9D4h] OVERLAPPED BYREF
  unsigned __int8 tmp_2[20]; // [sp+80Ch] [bp-1D4h] BYREF
  unsigned __int8 chain_opencore[20]; // [sp+820h] [bp-1C0h] BYREF
  unsigned __int8 tmp_1[20]; // [sp+834h] [bp-1ACh] BYREF
  unsigned __int8 chain_offside[20]; // [sp+848h] [bp-198h] BYREF
  unsigned __int8 tmp_0[20]; // [sp+85Ch] [bp-184h] BYREF
  unsigned __int8 chain_xtime[16]; // [sp+870h] [bp-170h] BYREF
  unsigned __int8 chain_rate[16]; // [sp+880h] [bp-160h] BYREF
  unsigned __int8 chain_hw[16]; // [sp+890h] [bp-150h] BYREF
  unsigned __int8 chain_asic_name[12]; // [sp+8A0h] [bp-140h] BYREF
  unsigned __int8 chain_name[12]; // [sp+8ACh] [bp-134h] BYREF
  double dev_sum_freq_2; // [sp+8B8h] [bp-128h] BYREF
  double total_rate; // [sp+8C0h] [bp-120h] BYREF
  uint16_t asic_num_total; // [sp+8CEh] [bp-112h] BYREF
  double dev_sum_freq_1; // [sp+8D0h] [bp-110h] BYREF
  double dev_sum_freq_0; // [sp+8D8h] [bp-108h] BYREF
  double dev_sum_freq; // [sp+8E0h] [bp-100h] BYREF
  unsigned __int8 freq_sum[12]; // [sp+8ECh] [bp-F4h] BYREF
  unsigned __int8 temp_chip_name[12]; // [sp+8F8h] [bp-E8h] BYREF
  unsigned __int8 no_value_0[2]; // [sp+904h] [bp-DCh] BYREF
  unsigned __int8 temp_pcb_name[12]; // [sp+908h] [bp-D8h] BYREF
  unsigned __int8 no_value[2]; // [sp+914h] [bp-CCh] BYREF
  unsigned __int8 temp3_name[12]; // [sp+918h] [bp-C8h] BYREF
  unsigned __int8 temp2_name[12]; // [sp+924h] [bp-BCh] BYREF
  unsigned __int8 temp_name[12]; // [sp+930h] [bp-B0h] BYREF
  unsigned __int8 fan_name[12]; // [sp+93Ch] [bp-A4h] BYREF
  unsigned __int8 chain_freq[12]; // [sp+948h] [bp-98h] BYREF
  unsigned __int8 tmp[12]; // [sp+954h] [bp-8Ch] BYREF
  double dev_hwp; // [sp+960h] [bp-80h] BYREF
  int temp; // [sp+96Ch] [bp-74h]
  int temp_2; // [sp+970h] [bp-70h]
  int temp_1; // [sp+974h] [bp-6Ch]
  int temp_0; // [sp+978h] [bp-68h]
  bool copy_data; // [sp+97Fh] [bp-61h]
  int j_4; // [sp+980h] [bp-60h]
  bool first; // [sp+987h] [bp-59h]
  int j_3; // [sp+988h] [bp-58h]
  int total_acn_num; // [sp+98Ch] [bp-54h]
  int j_2; // [sp+990h] [bp-50h]
  int j_1; // [sp+994h] [bp-4Ch]
  int len_0; // [sp+998h] [bp-48h]
  int j_0; // [sp+99Ch] [bp-44h]
  int len; // [sp+9A0h] [bp-40h]
  int j; // [sp+9A4h] [bp-3Ch]
  uint64_t hash_rate_all; // [sp+9A8h] [bp-38h]
  int i; // [sp+9B0h] [bp-30h]
  api_data *root; // [sp+9B4h] [bp-2Ch]

  hash_rate_all = 0LL;
  copy_data = 1;
  v2 = api_add_uint8(0, "miner_count", &dev->chain_num, 1);
  root = api_add_string(v2, "frequency", dev->frequency_t, 1);
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_freq, "freq%d", i + 1);
    if ( freq_mode == 2 )
      sprintf((char *)tmp, "%u", (int)freq_from_board[i]);
    else
      sprintf((char *)tmp, "%u", scan_freq_average[i]);
    root = api_add_string(root, chain_freq, tmp, copy_data);
  }
  root = api_add_uint8(root, "fan_num", &dev->fan_num, copy_data);
  for ( i = 0; i <= 7; ++i )
  {
    sprintf((char *)fan_name, "fan%d", i + 1);
    root = api_add_uint(root, fan_name, &dev->fan_speed_value[i], copy_data);
  }
  root = api_add_uint8(root, "temp_num", &dev->chain_num, copy_data);
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp_name, "temp%d", i + 1);
    root = api_add_int16(root, temp_name, (uint16_t *)dev->chain_asic_maxtemp[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp2_name, "temp2_%d", i + 1);
    root = api_add_int16(root, temp2_name, (uint16_t *)&dev->chain_asic_temp[i][0][1], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)temp3_name, "temp3_%d", i + 1);
    root = api_add_int16(root, temp3_name, (uint16_t *)&dev->chain_asic_temp[i][1][1], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    strcpy((char *)no_value, "-");
    len = 0;
    for ( j = 0; j < dev->chain_asic_temp_num[i]; ++j )
    {
      v3 = sprintf(&param_name[len], "%d", dev->chain_asic_temp[i][j][0]);
      len += v3;
      if ( j + 1 < dev->chain_asic_temp_num[i] )
        strcpy(&param_name[len++], "-");
    }
    sprintf((char *)temp_pcb_name, "temp_pcb%d", i + 1);
    if ( len <= 0 )
      root = api_add_string(root, temp_pcb_name, no_value, copy_data);
    else
      root = api_add_string(root, temp_pcb_name, param_name, copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    strcpy((char *)no_value_0, "-");
    len_0 = 0;
    for ( j_0 = 0; j_0 < dev->chain_asic_temp_num[i]; ++j_0 )
    {
      v4 = sprintf(&param_name[len_0], "%d", dev->chain_asic_temp[i][j_0][1]);
      len_0 += v4;
      if ( j_0 + 1 < dev->chain_asic_temp_num[i] )
        strcpy(&param_name[len_0++], "-");
    }
    sprintf((char *)temp_chip_name, "temp_chip%d", i + 1);
    if ( len_0 <= 0 )
      root = api_add_string(root, temp_chip_name, no_value_0, copy_data);
    else
      root = api_add_string(root, temp_chip_name, param_name, copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    j_1 = 0;
    dev_sum_freq = 0.0;
    sprintf((char *)freq_sum, "freq_avg%d", i + 1);
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_1 = 0; j_1 < dev->chain_asic_num[i]; ++j_1 )
      {
        if ( chain_badcore_num[i][j_1] > 14 )
          dev_sum_freq = (double)freq_pll_1391[12].freq + dev_sum_freq;
        else
          dev_sum_freq = (double)freq_pll_1391[last_freq[i][2 * j_1 + 3]].freq + dev_sum_freq;
      }
      if ( dev->chain_asic_num[i] )
        dev_sum_freq = dev_sum_freq / (double)dev->chain_asic_num[i];
    }
    temp = (int)(dev_sum_freq * 100.0);
    dev_sum_freq = (double)temp / 100.0;
    root = api_add_mhs(root, freq_sum, &dev_sum_freq, 1);
  }
  dev_sum_freq_0 = 0.0;
  strcpy(param_name, "total_rateideal");
  dev_sum_freq_0 = (double)get_total_rate();
  root = api_add_mhs(root, param_name, &dev_sum_freq_0, 1);
  j_2 = 0;
  total_acn_num = 0;
  dev_sum_freq_1 = 0.0;
  strcpy(param_name, "total_freqavg");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_2 = 0; j_2 < dev->chain_asic_num[i]; ++j_2 )
      {
        if ( chain_badcore_num[i][j_2] > 14 )
          dev_sum_freq_1 = (double)freq_pll_1391[12].freq + dev_sum_freq_1;
        else
          dev_sum_freq_1 = (double)freq_pll_1391[last_freq[i][2 * j_2 + 3]].freq + dev_sum_freq_1;
        ++total_acn_num;
      }
    }
  }
  dev_sum_freq_1 = dev_sum_freq_1 / (double)total_acn_num;
  temp_0 = (int)(dev_sum_freq_1 * 100.0);
  dev_sum_freq_1 = (double)temp_0 / 100.0;
  root = api_add_mhs(root, param_name, &dev_sum_freq_1, 1);
  asic_num_total = 0;
  strcpy(param_name, "total_acn");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      asic_num_total += dev->chain_asic_num[i];
  }
  root = api_add_int16(root, param_name, &asic_num_total, 1);
  total_rate = 0.0;
  strcpy(param_name, "total_rate");
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 && displayed_rate[i][0] )
    {
      atof((const char *)displayed_rate[i]);
      total_rate = v1 + total_rate;
    }
  }
  temp_1 = (int)(total_rate * 100.0);
  total_rate = (double)temp_1 / 100.0;
  root = api_add_mhs(root, param_name, &total_rate, 1);
  for ( i = 0; i <= 15; ++i )
  {
    j_3 = 0;
    dev_sum_freq_2 = 0.0;
    sprintf(param_name, "chain_rateideal%d", i + 1);
    if ( dev->chain_exist[i] == 1 && last_freq[i][1] == 125 )
    {
      for ( j_3 = 0; j_3 < dev->chain_asic_num[i]; ++j_3 )
      {
        if ( chain_badcore_num[i][j_3] <= 14 )
          dev_sum_freq_2 = (double)((672 - chain_badcore_num[i][j_3]) * freq_pll_1391[last_freq[i][2 * j_3 + 3]].freq)
                         + dev_sum_freq_2;
      }
    }
    dev_sum_freq_2 = dev_sum_freq_2 / 1000.0;
    temp_2 = (int)(dev_sum_freq_2 * 100.0);
    dev_sum_freq_2 = (double)temp_2 / 100.0;
    root = api_add_mhs(root, param_name, &dev_sum_freq_2, 1);
  }
  root = api_add_int(root, "temp_max", dev->temp_top1, copy_data);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  if ( hw_errors + total_diff1 )
    v5 = (double)hw_errors / (double)(hw_errors + total_diff1);
  else
    v5 = 0.0;
  dev_hwp = v5;
  root = api_add_percent(root, "Device Hardware%", &dev_hwp, 1);
  root = api_add_int(root, "no_matching_work", &hw_errors, copy_data);
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_name, "chain_acn%d", i + 1);
    root = api_add_uint8(root, chain_name, &dev->chain_asic_num[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_asic_name, "chain_acs%d", i + 1);
    root = api_add_string(root, chain_asic_name, dev->chain_asic_status_string[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_hw, "chain_hw%d", i + 1);
    root = api_add_uint32(root, chain_hw, &dev->chain_hw[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    sprintf((char *)chain_rate, "chain_rate%d", i + 1);
    root = api_add_string(root, chain_rate, displayed_rate[i], copy_data);
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      printf("chain_rate[%d]=(%s) ", i + 1, (const char *)displayed_rate[i]);
  }
  putchar(10);
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      first = 1;
      j_4 = 0;
      *(_DWORD *)param_name = 123;
      memset(&param_name[4], 0, 0x7FCu);
      memset(tmp_0, 0, sizeof(tmp_0));
      sprintf((char *)chain_xtime, "chain_xtime%d", i + 1);
      if ( x_time[i][0] )
      {
        sprintf((char *)tmp_0, "X%d=%d", 0, x_time[i][0]);
        strcat(param_name, (const char *)tmp_0);
        first = 0;
      }
      for ( j_4 = 1; j_4 < dev->chain_asic_num[i]; ++j_4 )
      {
        if ( x_time[i][j_4] )
        {
          if ( first )
          {
            sprintf((char *)tmp_0, "X%d=%d", j_4, x_time[i][j_4]);
            first = 0;
          }
          else
          {
            sprintf((char *)tmp_0, ",X%d=%d", j_4, x_time[i][j_4]);
          }
          strcat(param_name, (const char *)tmp_0);
        }
      }
      strcat(param_name, "}");
      root = api_add_string(root, chain_xtime, param_name, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      sprintf((char *)chain_offside, "chain_offside_%d", i + 1);
      sprintf((char *)tmp_1, "%d", temp_offside[i]);
      root = api_add_string(root, chain_offside, tmp_1, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      sprintf((char *)chain_opencore, "chain_opencore_%d", i + 1);
      if ( isChainAllCoresOpened[i] )
        strcpy((char *)tmp_2, "1");
      else
        strcpy((char *)tmp_2, "0");
      root = api_add_string(root, chain_opencore, tmp_2, copy_data);
    }
  }
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
      hash_rate_all += rate[i];
  }
  strcpy(param_name, "miner_version");
  root = api_add_string(root, param_name, g_miner_version, copy_data);
  strcpy(param_name, "miner_id");
  return api_add_string(root, param_name, FPGA_ID_str, copy_data);
}
// 34E18: variables would overlap: ^C.2048 and stkvar "param_name" ^C.32(has user info)

//----- (00036730) --------------------------------------------------------
void __cdecl bitmain_soc_shutdown(thr_info *thr)
{
  int dhash_acc_control; // r0
  unsigned int ret; // [sp+Ch] [bp-8h]

  thr_info_cancel(check_system_work_id);
  thr_info_cancel(read_nonce_reg_id);
  thr_info_cancel(read_temp_id);
  ret = get_BC_write_command() & 0xFFBFFFFF;
  set_BC_write_command(ret);
  dhash_acc_control = get_dhash_acc_control();
  set_dhash_acc_control(dhash_acc_control & 0xFFFFFFBF);
}

//----- (000367BC) --------------------------------------------------------
void __cdecl stop_scan(FREQ_SCAN_ERRNO error_num, uint8_t chain)
{
  FILE *pFile_4; // [sp+18h] [bp-1Ch]
  FILE *pFile; // [sp+1Ch] [bp-18h]
  FILE *pFile_0; // [sp+20h] [bp-14h]
  FILE *pFile_1; // [sp+24h] [bp-10h]
  FILE *pFile_2; // [sp+28h] [bp-Ch]
  FILE *pFile_3; // [sp+2Ch] [bp-8h]

  switch ( error_num )
  {
    case ASIC_NUM_ERR_0:
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: J[%d]:2 Error for chain[%d] asic number not enough\n",
            "freq_scan.c",
            54,
            (const char *)_FUNCTION___13485,
            chain,
            chain);
        fclose(pFile);
      }
      break;
    case HASH_RATE_ERR_0:
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: T[%d]:1 Error for chain[%d] hash rate too low\n",
            "freq_scan.c",
            57,
            (const char *)_FUNCTION___13485,
            chain,
            chain);
        fclose(pFile_0);
      }
      break;
    case EEPROM_SET_ERR_0:
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(
            pFile_1,
            "%s:%d:%s: E[%d]:1 Error for chain[%d] saving freq info into eeprom\n",
            "freq_scan.c",
            60,
            (const char *)_FUNCTION___13485,
            chain,
            chain);
        fclose(pFile_1);
      }
      break;
    case FAN_NUM_ERR_0:
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: F:1 Error for fan number not enough\n",
            "freq_scan.c",
            63,
            (const char *)_FUNCTION___13485);
        fclose(pFile_2);
      }
      break;
    case INBALANCE_NUM_ERR_0:
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_3 = fopen((const char *)log_file, "a+");
        if ( pFile_3 )
          fprintf(
            pFile_3,
            "%s:%d:%s: J[%d]:3 Error for chain[%d] inbalance asic number is more than 4\n",
            "freq_scan.c",
            66,
            (const char *)_FUNCTION___13485,
            chain,
            chain);
        fclose(pFile_3);
      }
      break;
    default:
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fprintf(pFile_4, "%s:%d:%s: X:X Error for unkwon error\n", "freq_scan.c", 69, (const char *)_FUNCTION___13485);
        fclose(pFile_4);
      }
      break;
  }
  while ( 1 )
  {
    process_TEST();
    sleep(1u);
  }
}
// 367E0: control flows out of bounds to 367E4

//----- (00036BBC) --------------------------------------------------------
void __cdecl __noreturn stop_mining(const unsigned __int8 *str)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  if ( log_level > 1 )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: fetal error: stop ming: %s\n",
        "power.c",
        108,
        (const char *)_FUNCTION___12445,
        (const char *)str);
    fclose(pFile);
  }
  while ( 1 )
    sleep(1u);
}

//----- (00036C68) --------------------------------------------------------
void power_on()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  if ( access("/sys/class/gpio/gpio907", 0) == -1 )
  {
    system("echo 907 > /sys/class/gpio/export");
    system("echo out > /sys/class/gpio/gpio907/direction");
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: init gpio907\n", "power.c", 152, (const char *)_FUNCTION___12466);
      fclose(pFile);
    }
  }
  system("echo 0 > /sys/class/gpio/gpio907/value");
  sleep(1u);
}

//----- (00036D50) --------------------------------------------------------
void power_check_protocal_type()
{
  FILE *pFile_0; // [sp+Ch] [bp-18h]
  FILE *pFile; // [sp+10h] [bp-14h]
  FILE *pFile_2; // [sp+14h] [bp-10h]
  FILE *pFile_1; // [sp+18h] [bp-Ch]
  uint8_t ret; // [sp+1Fh] [bp-5h]

  pthread_mutex_lock(&iic_mutex);
  ret = znyq_set_iic(power_iic_addr, power_iic_no, 1, 1, 0, 0);
  if ( ret == 245 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: power protocal %02x, using package cmd\n",
          "power.c",
          181,
          (const char *)_FUNCTION___12475,
          ret);
      fclose(pFile);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: power type APW9 3600W\n", "power.c", 182, (const char *)_FUNCTION___12475);
      fclose(pFile_0);
    }
    power_protocal_type = 2;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: power protocal %02x, using simple cmd\n",
          "power.c",
          187,
          (const char *)_FUNCTION___12475,
          ret);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%s:%d:%s: power type APW8 2000W\n", "power.c", 188, (const char *)_FUNCTION___12475);
      fclose(pFile_2);
    }
    power_protocal_type = 1;
  }
  pthread_mutex_unlock(&iic_mutex);
}

//----- (00037024) --------------------------------------------------------
void power_init()
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: power init ... \n", "power.c", 196, (const char *)_FUNCTION___12483);
    fclose(pFile);
  }
  power_info.is_voltage_stable = 0;
  power_info.current_voltage = 0.0;
  power_info.working_voltage = 18.2999992;
  power_info.higher_voltage = 0.0;
  power_info.highest_voltage = 20.0;
  power_info.current_iic_data = 0;
  power_check_protocal_type();
}

//----- (00037140) --------------------------------------------------------
void __cdecl set_working_voltage(double working_voltage)
{
  double v1; // d0
  FILE *pFile; // [sp+1Ch] [bp-8h]

  power_info.working_voltage = v1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: working_voltage = %f\n",
        "power.c",
        213,
        (const char *)_FUNCTION___12488,
        power_info.working_voltage);
    fclose(pFile);
  }
}
// 3715C: variable 'v1' is possibly undefined

//----- (00037204) --------------------------------------------------------
void get_working_voltage()
{
  ;
}

//----- (0003722C) --------------------------------------------------------
void get_current_voltage()
{
  ;
}

//----- (00037254) --------------------------------------------------------
bool power_is_support_cmd_package()
{
  return power_protocal_type == 2;
}

//----- (00037288) --------------------------------------------------------
bool __cdecl power_check_reply(uint8_t *cmd, uint8_t *reply_buf, uint8_t reply_len)
{
  FILE *pFile_0; // [sp+20h] [bp-24h]
  FILE *pFile_1; // [sp+24h] [bp-20h]
  FILE *pFile; // [sp+28h] [bp-1Ch]
  FILE *pFile_3; // [sp+2Ch] [bp-18h]
  FILE *pFile_4; // [sp+30h] [bp-14h]
  FILE *pFile_2; // [sp+34h] [bp-10h]
  uint16_t crc_reply; // [sp+3Ah] [bp-Ah]
  uint16_t i; // [sp+3Ch] [bp-8h]
  uint16_t ia; // [sp+3Ch] [bp-8h]
  uint16_t ib; // [sp+3Ch] [bp-8h]
  uint16_t crc; // [sp+3Eh] [bp-6h]

  crc = 0;
  if ( *cmd == *reply_buf && cmd[1] == reply_buf[1] && cmd[3] == reply_buf[3] && reply_buf[2] + 2 == reply_len )
  {
    for ( ia = 2; ia < reply_len - 2; ++ia )
      crc += reply_buf[ia];
    crc_reply = (reply_buf[reply_len - 1] << 8) + reply_buf[reply_len - 2];
    if ( crc == crc_reply )
    {
      return 1;
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: power reply crc error, crc %04x != crc_reply %04x:\n",
            "power.c",
            266,
            (const char *)_FUNCTION___12515,
            crc,
            crc_reply);
        fclose(pFile_2);
      }
      for ( ib = 0; ib < (unsigned int)reply_len; ++ib )
      {
        if ( log_level > 3 )
        {
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(pFile_3, "%02x ", reply_buf[ib]);
          fclose(pFile_3);
        }
      }
      if ( log_level > 3 )
      {
        pFile_4 = fopen((const char *)log_file, "a+");
        if ( pFile_4 )
          fputc(10, pFile_4);
        fclose(pFile_4);
      }
      return 0;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: power reply data error:\n", "power.c", 250, (const char *)_FUNCTION___12515);
      fclose(pFile);
    }
    for ( i = 0; i < (unsigned int)reply_len; ++i )
    {
      if ( log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%02x ", reply_buf[i]);
        fclose(pFile_0);
      }
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fputc(10, pFile_1);
      fclose(pFile_1);
    }
    return 0;
  }
}

//----- (000376EC) --------------------------------------------------------
bool __cdecl power_send_cmd(uint8_t *cmd, uint8_t len, uint8_t *reply_buf, uint8_t reply_len)
{
  FILE *pFile; // [sp+24h] [bp-18h]
  uint8_t retry; // [sp+2Eh] [bp-Eh]
  uint8_t i; // [sp+2Fh] [bp-Dh]
  uint8_t ia; // [sp+2Fh] [bp-Dh]

  retry = 0;
  pthread_mutex_lock(&iic_mutex);
  while ( retry <= 2u )
  {
    for ( i = 0; i < (unsigned int)len; znyq_set_iic(0x10u, 1u, 0, 1, 0x11u, cmd[i++]) )
      ;
    usleep(0x7A120u);
    for ( ia = 0; ia < (unsigned int)reply_len; reply_buf[ia++] = znyq_set_iic(0x10u, 1u, 1, 0, 0x11u, 0) )
      ;
    if ( power_check_reply(cmd, reply_buf, reply_len) )
      break;
    ++retry;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: power send cmd 0x%02x failed, retry for %d times\n",
          "power.c",
          301,
          (const char *)_FUNCTION___12549,
          cmd[3],
          retry);
      fclose(pFile);
    }
  }
  pthread_mutex_unlock(&iic_mutex);
  return retry <= 2u;
}

//----- (00037924) --------------------------------------------------------
void __cdecl power_set_da_value(uint8_t da_value)
{
  uint8_t reply[32]; // [sp+Ch] [bp-30h] BYREF
  uint8_t cmd[8]; // [sp+2Ch] [bp-10h] BYREF
  uint16_t i; // [sp+34h] [bp-8h]
  uint16_t crc; // [sp+36h] [bp-6h]

  *(_DWORD *)cmd = -2096715179;
  memset(reply, 0, sizeof(reply));
  crc = 0;
  *(_DWORD *)&cmd[4] = da_value;
  for ( i = 2; i <= 5u; ++i )
    crc += cmd[i];
  *(_WORD *)&cmd[6] = crc;
  power_send_cmd(cmd, 8u, reply, 8u);
}

//----- (000379F4) --------------------------------------------------------
uint8_t __cdecl power_set_da_value_simple(uint8_t data)
{
  uint8_t ret; // [sp+15h] [bp-7h]

  pthread_mutex_lock(&iic_mutex);
  usleep(0x186A0u);
  ret = znyq_set_iic(power_iic_addr, power_iic_no, 0, 1, 2u, data);
  pthread_mutex_unlock(&iic_mutex);
  return ret;
}

//----- (00037A94) --------------------------------------------------------
void __cdecl power_set_voltage(uint8_t da_value)
{
  if ( power_is_support_cmd_package() )
    power_set_da_value(da_value);
  else
    power_set_da_value_simple(da_value);
}

//----- (00037AE0) --------------------------------------------------------
uint8_t __cdecl get_power_iic_value_from_voltage(double voltage)
{
  double v1; // d0
  double iic_index; // [sp+18h] [bp-Ch]

  if ( power_is_support_cmd_package() )
    iic_index = 765.411764 - v1 * 35.833333;
  else
    iic_index = 1215.89444 - v1 * 59.9315068;
  if ( iic_index > 255.0 )
    return (unsigned int)255.0;
  return (unsigned int)iic_index;
}
// 37B14: variable 'v1' is possibly undefined

//----- (00037BB0) --------------------------------------------------------
double __cdecl get_power_voltage_from_iic_value(uint8_t data)
{
  double result; // r0
  FILE *pFile; // [sp+1Ch] [bp-10h]
  double voltage; // [sp+20h] [bp-Ch]

  LODWORD(result) = power_is_support_cmd_package();
  if ( LODWORD(result) )
    voltage = (765.411764 - (double)data) / 35.833333;
  else
    voltage = (1215.89444 - (double)data) / 59.9315068;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: iic_index for voltage[%d] = %f\n",
        "power.c",
        522,
        (const char *)_FUNCTION___12652,
        data,
        voltage);
    LODWORD(result) = fclose(pFile);
  }
  return result;
}

//----- (00037CE8) --------------------------------------------------------
bool __cdecl set_iic_power_by_voltage(double target_vol, power_info_t *power)
{
  double v2; // d0
  power_info_t *powera; // [sp+14h] [bp-18h]
  FILE *pFile; // [sp+20h] [bp-Ch]
  uint8_t iic_vol_data; // [sp+27h] [bp-5h]

  powera = (power_info_t *)LODWORD(target_vol);
  *(_BYTE *)LODWORD(target_vol) = 1;
  iic_vol_data = get_power_iic_value_from_voltage(target_vol);
  power_set_voltage(iic_vol_data);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: now setting voltage to : %f \n", "power.c", 540, (const char *)_FUNCTION___12659, v2);
    fclose(pFile);
  }
  usleep(0x493E0u);
  powera->current_voltage = v2;
  powera->current_iic_data = iic_vol_data;
  return 1;
}
// 37DB0: variable 'v2' is possibly undefined

//----- (00037DF0) --------------------------------------------------------
bool __cdecl set_iic_power_by_iic_data(uint8_t target_data, power_info_t *power)
{
  double v2; // d0
  FILE *pFile; // [sp+1Ch] [bp-10h]

  power->is_voltage_stable = 1;
  get_power_voltage_from_iic_value(target_data);
  power_set_voltage(target_data);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: now setting voltage to : %f \n",
        "power.c",
        561,
        (const char *)_FUNCTION___12667,
        power->current_voltage);
    fclose(pFile);
  }
  usleep(0x493E0u);
  power->current_voltage = v2;
  power->current_iic_data = target_data;
  return 1;
}
// 37ED8: variable 'v2' is possibly undefined

//----- (00037EF8) --------------------------------------------------------
int __fastcall set_iic_power_to_highest_voltage(double a1)
{
  power_info_t *highest_voltage_low; // r2
  FILE *pFile; // [sp+14h] [bp-18h]
  double target_vol; // [sp+18h] [bp-14h]

  highest_voltage_low = (power_info_t *)LODWORD(power_info.highest_voltage);
  target_vol = power_info.highest_voltage;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: setting to voltage: %0.2f ...\n",
        "power.c",
        591,
        (const char *)_FUNCTION___12681,
        target_vol);
    fclose(pFile);
  }
  LODWORD(a1) = &power_info;
  if ( !set_iic_power_by_voltage(a1, highest_voltage_low) )
    stop_mining("power set failed!\n");
  return 1;
}
// 37FB4: variable 'a1' is possibly undefined
// 37FB4: variable 'highest_voltage_low' is possibly undefined

//----- (00037FF0) --------------------------------------------------------
bool __cdecl slowly_adapt_voltage(double target_vol, uint32_t ms_delay)
{
  double v2; // d0
  double v3; // r0
  int v5; // r3
  int v6; // r3
  int v7; // r3
  bool ret; // [sp+11h] [bp-1Bh]
  uint8_t threshold_iic_data; // [sp+12h] [bp-1Ah]
  uint8_t target_iic_data; // [sp+13h] [bp-19h]
  uint8_t diff_iic_data; // [sp+1Ah] [bp-12h]
  uint8_t temp_iic_data; // [sp+1Bh] [bp-11h]
  char negate; // [sp+1Ch] [bp-10h]
  int sleep_ms; // [sp+20h] [bp-Ch]
  int i; // [sp+24h] [bp-8h]

  i = 0;
  if ( LODWORD(target_vol) )
    sleep_ms = LODWORD(target_vol);
  else
    sleep_ms = 1000;
  if ( v2 > power_info.current_voltage )
    negate = -1;
  else
    negate = 1;
  LODWORD(v3) = get_power_iic_value_from_voltage(target_vol);
  temp_iic_data = LOBYTE(v3);
  target_iic_data = get_power_iic_value_from_voltage(v3);
  threshold_iic_data = (int)abs32(temp_iic_data - target_iic_data) / 6;
  while ( i <= 4 )
  {
    temp_iic_data += threshold_iic_data * negate;
    if ( !set_iic_power_by_iic_data(temp_iic_data, &power_info) )
      return 0;
    usleep(500 * sleep_ms);
    ++i;
  }
  while ( 1 )
  {
    v5 = temp_iic_data - target_iic_data;
    if ( v5 < 0 )
      LOBYTE(v5) = target_iic_data - temp_iic_data;
    if ( (unsigned __int8)v5 <= 0x20u )
    {
      if ( (unsigned __int8)v5 <= 0x10u )
        diff_iic_data = 2;
      else
        diff_iic_data = 8;
    }
    else
    {
      diff_iic_data = 16;
    }
    v6 = temp_iic_data - target_iic_data;
    if ( v6 < 0 )
      v6 = target_iic_data - temp_iic_data;
    if ( v6 > 2 )
    {
      temp_iic_data += diff_iic_data * negate;
      if ( !set_iic_power_by_iic_data(temp_iic_data, &power_info) )
        return 0;
      goto LABEL_24;
    }
    v7 = temp_iic_data - target_iic_data;
    if ( v7 < 0 )
      v7 = target_iic_data - temp_iic_data;
    if ( v7 <= 1 )
      break;
    temp_iic_data += negate;
    if ( !set_iic_power_by_iic_data(temp_iic_data, &power_info) )
      return 0;
LABEL_24:
    usleep(500 * sleep_ms);
  }
  ret = set_iic_power_by_iic_data(target_iic_data, &power_info);
  if ( !ret )
    return 0;
  usleep(500 * sleep_ms);
  power_info.current_voltage = v2;
  power_info.current_iic_data = target_iic_data;
  return ret;
}
// 3804C: variable 'v2' is possibly undefined
// 38080: variable 'v3' is possibly undefined

//----- (00038320) --------------------------------------------------------
int slowly_set_iic_power_to_working_voltage()
{
  double v0; // r0
  uint32_t v1; // r2
  FILE *pFile; // [sp+14h] [bp-18h]
  double target_vol; // [sp+18h] [bp-14h]

  target_vol = power_info.working_voltage;
  sprintf((char *)displayed_working_voltage, "%.2f", power_info.working_voltage);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: slowly setting to voltage: %0.2f ...\n",
        "power.c",
        744,
        (const char *)_FUNCTION___12724,
        target_vol);
    fclose(pFile);
  }
  LODWORD(v0) = 0;
  if ( !slowly_adapt_voltage(v0, v1) )
    stop_mining("power set failed!\n");
  return 1;
}
// 383F4: variable 'v0' is possibly undefined
// 383F4: variable 'v1' is possibly undefined

//----- (00038430) --------------------------------------------------------
bool __cdecl check_pic_crc(unsigned __int8 *buf)
{
  unsigned __int8 *v2; // r3
  unsigned __int8 *bufa; // [sp+14h] [bp-20h]
  FILE *pFile; // [sp+1Ch] [bp-18h]
  uint16_t sum2; // [sp+26h] [bp-Eh]
  unsigned int i; // [sp+28h] [bp-Ch]
  uint16_t sum1; // [sp+2Eh] [bp-6h]

  bufa = buf;
  sum1 = 0;
  if ( !buf || *buf <= 3u )
    return 0;
  for ( i = 0; (unsigned int)*buf - 2 > i; ++i )
  {
    v2 = bufa++;
    sum1 += *v2;
  }
  sum2 = _byteswap_ushort(*(_WORD *)bufa);
  if ( log_level > 5 )
  {
    print_crt_time_to_file(log_file, 5u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: sum1,sum2 = %d,%d\n", "power.c", 977, (const char *)_FUNCTION___12798, sum1, sum2);
    fclose(pFile);
  }
  return sum1 == sum2;
}

//----- (000385D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl decode_an_voltage_buf(unsigned __int8 *buf)
{
  double result; // r0
  unsigned __int8 *bufa; // [sp+14h] [bp-30h]
  FILE *pFile; // [sp+18h] [bp-2Ch]
  FILE *pFile_2; // [sp+1Ch] [bp-28h]
  FILE *pFile_1; // [sp+2Ch] [bp-18h]
  double v_an2; // [sp+30h] [bp-14h]
  FILE *pFile_0; // [sp+38h] [bp-Ch]
  uint16_t v_n; // [sp+3Eh] [bp-6h]

  bufa = buf;
  if ( buf )
  {
    buf = (unsigned __int8 *)check_pic_crc(buf);
    if ( (unsigned __int8)buf != 1 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, "%s:%d:%s: crc error!\n", "power.c", 991, (const char *)_FUNCTION___12803);
        buf = (unsigned __int8 *)fclose(pFile);
      }
    }
    else
    {
      v_n = _byteswap_ushort(*(_WORD *)(bufa + 3));
      if ( log_level > 5 )
      {
        print_crt_time_to_file(log_file, 5u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: voltage = %d\n", "power.c", 999, (const char *)_FUNCTION___12803, v_n);
        buf = (unsigned __int8 *)fclose(pFile_0);
      }
      v_an2 = (double)v_n * 3.3 / 4096.0;
      if ( log_level > 5 )
      {
        print_crt_time_to_file(log_file, 5u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: v_an2 = %f\n", "power.c", 1004, (const char *)_FUNCTION___12803, v_an2);
        buf = (unsigned __int8 *)fclose(pFile_1);
      }
      if ( log_level > 5 )
      {
        print_crt_time_to_file(log_file, 5u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(pFile_2, "%s:%d:%s: v_10 = %f\n", "power.c", 1007, (const char *)_FUNCTION___12803, v_an2 * 7.5999999);
        buf = (unsigned __int8 *)fclose(pFile_2);
      }
    }
  }
  LODWORD(result) = buf;
  return result;
}
// 385D0: variables would overlap: r0.4 and r0.8
// 385D0: bad return variable

//----- (00038900) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl dsPIC33EP16GS202_pic_get_an_voltage2(unsigned __int8 which_iic)
{
  int v1; // r3
  double result; // r0
  uint8_t which_iica; // [sp+Fh] [bp-25h]
  unsigned __int8 read_back_data[9]; // [sp+10h] [bp-24h] BYREF
  unsigned __int8 crc_data[2]; // [sp+1Ch] [bp-18h]
  FILE *pFile; // [sp+20h] [bp-14h]
  FILE *pFile_0; // [sp+24h] [bp-10h]
  unsigned __int16 crc; // [sp+28h] [bp-Ch]
  unsigned __int8 length; // [sp+2Bh] [bp-9h]
  int retry_count; // [sp+2Ch] [bp-8h]

  which_iica = which_iic;
  length = 4;
  *(_DWORD *)read_back_data = 255;
  *(_DWORD *)&read_back_data[4] = 0;
  read_back_data[8] = 0;
  retry_count = 0;
  crc = 45;
  crc_data[0] = 0;
  crc_data[1] = 45;
  while ( 1 )
  {
    v1 = retry_count++;
    if ( v1 > 1 )
      break;
    pthread_mutex_lock(&iic_mutex);
    write_pic_iic(which_iica, 0x55u);
    write_pic_iic(which_iica, 0xAAu);
    write_pic_iic(which_iica, length);
    write_pic_iic(which_iica, 0x29u);
    write_pic_iic(which_iica, crc_data[0]);
    write_pic_iic(which_iica, crc_data[1]);
    usleep(0x7A120u);
    read_back_data[0] = read_pic_iic(which_iica);
    read_back_data[1] = read_pic_iic(which_iica);
    read_back_data[2] = read_pic_iic(which_iica);
    read_back_data[3] = read_pic_iic(which_iica);
    read_back_data[4] = read_pic_iic(which_iica);
    read_back_data[5] = read_pic_iic(which_iica);
    read_back_data[6] = read_pic_iic(which_iica);
    read_back_data[7] = read_pic_iic(which_iica);
    read_back_data[8] = read_pic_iic(which_iica);
    pthread_mutex_unlock(&iic_mutex);
    if ( read_back_data[1] == 41 && read_back_data[2] == 1 )
    {
      if ( log_level > 5 )
      {
        print_crt_time_to_file(log_file, 5u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Receive AN voltage response from IIC[%d]\n",
            "power.c",
            1052,
            (const char *)_FUNCTION___12819,
            which_iica);
        fclose(pFile_0);
      }
      *(double *)&which_iic = decode_an_voltage_buf(read_back_data);
      break;
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Couldn't hear AN voltage response from IIC[%d]\n",
          "power.c",
          1046,
          (const char *)_FUNCTION___12819,
          which_iica);
      fclose(pFile);
    }
    dump_mem("read_back_data:", read_back_data, 9);
    *(_DWORD *)&which_iic = sleep(1u);
  }
  LOBYTE(result) = which_iic;
  return result;
}
// 38900: variables would overlap: r0.1 and r0.8
// 38900: bad return variable

//----- (00038C70) --------------------------------------------------------
void get_average_voltage()
{
  double v0; // d0
  FILE *pFile; // [sp+14h] [bp-28h]
  FILE *pFile_0; // [sp+18h] [bp-24h]
  FILE *pFile_1; // [sp+1Ch] [bp-20h]
  double volt; // [sp+28h] [bp-14h]
  double volta; // [sp+28h] [bp-14h]
  int i; // [sp+30h] [bp-Ch]
  int total_chain; // [sp+34h] [bp-8h]

  total_chain = 0;
  volt = 0.0;
  for ( i = 0; i <= 15; ++i )
  {
    if ( dev->chain_exist[i] == 1 )
    {
      dsPIC33EP16GS202_pic_get_an_voltage2(i);
      volt = volt + v0;
      ++total_chain;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(power_log_file, 3u);
        pFile = fopen((const char *)power_log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: chain[%d], voltage is: %f \n",
            "power.c",
            1080,
            (const char *)_FUNCTION___12836,
            i,
            v0);
        fclose(pFile);
      }
    }
  }
  if ( total_chain )
  {
    volta = volt / (double)total_chain;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(power_log_file, 3u);
      pFile_1 = fopen((const char *)power_log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%s:%d:%s: aveage voltage is: %f \n", "power.c", 1091, (const char *)_FUNCTION___12836, volta);
      fclose(pFile_1);
    }
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(power_log_file, 3u);
    pFile_0 = fopen((const char *)power_log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: error: total_chain get 0 !!", "power.c", 1086, (const char *)_FUNCTION___12836);
    fclose(pFile_0);
  }
}
// 38CE8: variable 'v0' is possibly undefined

//----- (00038F0C) --------------------------------------------------------
__uint32_t __cdecl _uint32_identity(__uint32_t __x)
{
  return __x;
}

//----- (00038F30) --------------------------------------------------------
void __cdecl json_decref(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (00038F94) --------------------------------------------------------
void __cdecl _list_add(list_head *a1, list_head *prev, list_head *next)
{
  next->prev = a1;
  a1->next = next;
  a1->prev = prev;
  prev->next = a1;
}

//----- (00038FEC) --------------------------------------------------------
void __cdecl list_add_tail(list_head *a1, list_head *head)
{
  _list_add(a1, head->prev, head);
}

//----- (00039024) --------------------------------------------------------
void __cdecl _list_del(list_head *prev, list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

//----- (00039060) --------------------------------------------------------
void __cdecl list_del(list_head *entry)
{
  _list_del(entry->prev, entry->next);
  entry->next = 0;
  entry->prev = 0;
}

//----- (000390B0) --------------------------------------------------------
int __cdecl list_empty(list_head *head)
{
  return head == head->next;
}

//----- (000390EC) --------------------------------------------------------
int sock_blocks()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (00039138) --------------------------------------------------------
bool sock_timeout()
{
  return *_errno_location() == 110;
}

//----- (00039164) --------------------------------------------------------
bool interrupted()
{
  return *_errno_location() == 4;
}

//----- (00039190) --------------------------------------------------------
void __cdecl align_len(size_t *len)
{
  if ( (*len & 3) != 0 )
    *len = (*len & 0xFFFFFFFC) + 4;
}

//----- (000391DC) --------------------------------------------------------
uint32_t __cdecl swab32_1(uint32_t v)
{
  return bswap32(v);
}

//----- (00039204) --------------------------------------------------------
void __cdecl swab256(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = swab32_1(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = swab32_1(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = swab32_1(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = swab32_1(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = swab32_1(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = swab32_1(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = swab32_1(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = swab32_1(*(_DWORD *)src_p);
}

//----- (0003934C) --------------------------------------------------------
void __cdecl mutex_lock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000393E8) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00039484) --------------------------------------------------------
void __cdecl mutex_unlock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_0(lock, file, func, line);
  selective_yield();
}

//----- (000394D0) --------------------------------------------------------
int __cdecl mutex_trylock(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_mutex_trylock(lock);
}

//----- (00039508) --------------------------------------------------------
void __cdecl wr_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000395A4) --------------------------------------------------------
void __cdecl rw_unlock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00039640) --------------------------------------------------------
void __cdecl wr_unlock_noyield_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_0(lock, file, func, line);
}

//----- (0003967C) --------------------------------------------------------
void __cdecl cg_wlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_0(&lock->mutex, file, func, line);
  wr_lock_0(&lock->rwlock, file, func, line);
}

//----- (000396D0) --------------------------------------------------------
void __cdecl cg_wunlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_0(&lock->rwlock, file, func, line);
  mutex_unlock_0(&lock->mutex, file, func, line);
}

//----- (00039724) --------------------------------------------------------
int no_yield()
{
  return 0;
}

//----- (00039740) --------------------------------------------------------
void __cdecl keep_sockalive(int fd)
{
  int tcp_keepintvl; // [sp+10h] [bp-14h] BYREF
  int tcp_keepidle; // [sp+14h] [bp-10h] BYREF
  int tcp_one; // [sp+18h] [bp-Ch] BYREF
  int flags; // [sp+1Ch] [bp-8h]

  tcp_one = 1;
  tcp_keepidle = 45;
  tcp_keepintvl = 30;
  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags | 0x800);
  setsockopt(fd, 1, 9, &tcp_one, 4u);
  if ( !opt_delaynet )
    fcntl(fd, 2, 1);
  setsockopt(fd, 6, 1, &tcp_one, 4u);
  setsockopt(fd, 6, 6, &tcp_one, 4u);
  setsockopt(fd, 6, 4, &tcp_keepidle, 4u);
  setsockopt(fd, 6, 5, &tcp_keepintvl, 4u);
}

//----- (0003986C) --------------------------------------------------------
void *__cdecl cgmalloc(uint32_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  uint32_t sizea[2]; // [sp+1Ch] [bp-810h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-808h] BYREF
  void *ret; // [sp+824h] [bp-8h]

  sizea[0] = size;
  align_len(sizea);
  ret = malloc(sizea[0]);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to malloc size %d from %s %s:%d",
      sizea[0],
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}
// 3986C: using guessed type uint32_t size[2];

//----- (00039930) --------------------------------------------------------
void *__cdecl cgcalloc(int memb, size_t size, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  size_t sizea; // [sp+18h] [bp-814h] BYREF
  int memba; // [sp+1Ch] [bp-810h]
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-808h] BYREF
  void *ret; // [sp+824h] [bp-8h]

  memba = memb;
  sizea = size;
  align_len(&sizea);
  ret = calloc(memba, sizea);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc memb %d size %d from %s %s:%d",
      memba,
      sizea,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}

//----- (000399FC) --------------------------------------------------------
void *__cdecl cgrealloc(
        void *ptr,
        size_t size,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  size_t sizea; // [sp+18h] [bp-814h] BYREF
  void *ptra; // [sp+1Ch] [bp-810h]
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-808h] BYREF
  void *ret; // [sp+824h] [bp-8h]

  ptra = ptr;
  sizea = size;
  align_len(&sizea);
  ret = realloc(ptra, sizea);
  if ( !ret )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to realloc size %d from %s %s:%d",
      sizea,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
  return ret;
}

//----- (00039ABC) --------------------------------------------------------
const unsigned __int8 *__cdecl proxytype(proxytypes_t a1)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; proxynames[i].name; ++i )
  {
    if ( a1 == proxynames[i].proxytype )
      return proxynames[i].name;
  }
  return "invalid";
}

//----- (00039B4C) --------------------------------------------------------
unsigned __int8 *__cdecl get_proxy(unsigned __int8 *url, pool *pool)
{
  unsigned __int8 *split; // [sp+Ch] [bp-10h]
  int plen; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  pool->rpc_proxy = 0;
  for ( i = 0; proxynames[i].name; ++i )
  {
    plen = strlen((const char *)proxynames[i].name);
    if ( !strncmp((const char *)url, (const char *)proxynames[i].name, plen) )
    {
      split = (unsigned __int8 *)strchr((const char *)url, 124);
      if ( !split )
        return url;
      *split = 0;
      pool->rpc_proxy = (unsigned __int8 *)cgmalloc(split - url - plen + 1, "util.c", _func___11478, 758);
      strcpy((char *)pool->rpc_proxy, (const char *)&url[plen]);
      extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
      pool->rpc_proxytype = proxynames[i].proxytype;
      return split + 1;
    }
  }
  return url;
}

//----- (00039CD8) --------------------------------------------------------
void __cdecl _bin2hex(unsigned __int8 *s, const unsigned __int8 *p, size_t len)
{
  unsigned __int8 *v3; // r2
  int i; // [sp+14h] [bp-8h]

  for ( i = 0; i < (int)len; ++i )
  {
    *s = hex_11488[p[i] >> 4];
    v3 = s + 1;
    s += 2;
    *v3 = hex_11488[p[i] & 0xF];
  }
  *s = 0;
}

//----- (00039DA4) --------------------------------------------------------
unsigned __int8 *__cdecl bin2hex(const unsigned __int8 *p, size_t len)
{
  int v2; // r3
  unsigned __int8 *s; // [sp+10h] [bp-Ch]
  int slen; // [sp+14h] [bp-8h]

  slen = 2 * len + 1;
  if ( ((2 * (_BYTE)len + 1) & 3) != 0 )
  {
    v2 = slen & 3;
    if ( slen <= 0 )
      v2 = -(-slen & 3);
    slen += 4 - v2;
  }
  s = (unsigned __int8 *)cgcalloc(slen, 1u, "util.c", _func___11498, 798);
  _bin2hex(s, p, len);
  return s;
}

//----- (00039E44) --------------------------------------------------------
bool __cdecl hex2bin(unsigned __int8 *p, const unsigned __int8 *hexstr, size_t len)
{
  unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-810h] BYREF
  int nibble2; // [sp+814h] [bp-10h]
  int nibble1; // [sp+818h] [bp-Ch]
  unsigned __int8 idx; // [sp+81Eh] [bp-6h]
  bool ret; // [sp+81Fh] [bp-5h]

  ret = 0;
  while ( 1 )
  {
    if ( !*hexstr || !len )
    {
      if ( !len && !*hexstr )
        return 1;
      return ret;
    }
    if ( !hexstr[1] )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "hex2bin str truncated");
        applog(3, tmp42, 0);
      }
      return ret;
    }
    idx = *hexstr;
    nibble1 = hex2bin_tbl[idx];
    v4 = (unsigned __int8 *)(hexstr + 1);
    hexstr += 2;
    idx = *v4;
    nibble2 = hex2bin_tbl[idx];
    if ( nibble1 < 0 || nibble2 < 0 )
      break;
    v5 = p++;
    *v5 = (16 * nibble1) | nibble2;
    --len;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "hex2bin scan failed");
    applog(3, tmp42, 0);
  }
  return ret;
}

//----- (0003A094) --------------------------------------------------------
bool __cdecl valid_hex(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-814h] BYREF
  unsigned __int8 idx; // [sp+823h] [bp-11h]
  int len; // [sp+824h] [bp-10h]
  bool ret; // [sp+82Bh] [bp-9h]
  int i; // [sp+82Ch] [bp-8h]

  ret = 0;
  if ( s )
  {
    len = strlen((const char *)s);
    for ( i = 0; ; ++i )
    {
      if ( i >= len )
      {
        ret = 1;
        return 1;
      }
      idx = s[i];
      if ( hex2bin_tbl[idx] < 0 )
        break;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Invalid char 0x%x passed to valid_hex from in %s %s():%d",
        idx,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Null string passed to valid_hex from in %s %s():%d",
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
}

//----- (0003A25C) --------------------------------------------------------
bool __cdecl valid_ascii(unsigned __int8 *s, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-814h] BYREF
  unsigned __int8 idx; // [sp+823h] [bp-11h]
  int len; // [sp+824h] [bp-10h]
  bool ret; // [sp+82Bh] [bp-9h]
  int i; // [sp+82Ch] [bp-8h]

  ret = 0;
  if ( s )
  {
    len = strlen((const char *)s);
    if ( len )
    {
      for ( i = 0; ; ++i )
      {
        if ( i >= len )
        {
          ret = 1;
          return 1;
        }
        idx = s[i];
        if ( idx <= 0x1Fu || idx > 0x7Eu )
          break;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Invalid char 0x%x passed to valid_ascii from in %s %s():%d",
          idx,
          (const char *)file,
          (const char *)func,
          line);
        applog(3, tmp42, 0);
      }
      return ret;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Zero length string passed to valid_ascii from in %s %s():%d",
          (const char *)file,
          (const char *)func,
          line);
        applog(3, tmp42, 0);
      }
      return ret;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Null string passed to valid_ascii from in %s %s():%d",
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
    return ret;
  }
}

//----- (0003A4B8) --------------------------------------------------------
bool __cdecl fulltest(const unsigned __int8 *hash, const unsigned __int8 *target)
{
  const char *v2; // r3
  unsigned __int8 hash_swap[32]; // [sp+10h] [bp-864h] BYREF
  unsigned __int8 target_swap[32]; // [sp+30h] [bp-844h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+50h] [bp-824h] BYREF
  unsigned __int8 *target_str; // [sp+850h] [bp-24h]
  unsigned __int8 *hash_str; // [sp+854h] [bp-20h]
  uint32_t t32tmp; // [sp+858h] [bp-1Ch]
  uint32_t h32tmp; // [sp+85Ch] [bp-18h]
  uint32_t *target32; // [sp+860h] [bp-14h]
  uint32_t *hash32; // [sp+864h] [bp-10h]
  int i; // [sp+868h] [bp-Ch]
  bool rc; // [sp+86Fh] [bp-5h]

  hash32 = (uint32_t *)hash;
  target32 = (uint32_t *)target;
  rc = 1;
  for ( i = 7; i >= 0; --i )
  {
    h32tmp = _uint32_identity(hash32[i]);
    t32tmp = _uint32_identity(target32[i]);
    if ( h32tmp > t32tmp )
    {
      rc = 0;
      break;
    }
    if ( h32tmp < t32tmp )
    {
      rc = 1;
      break;
    }
  }
  if ( opt_debug )
  {
    swab256(hash_swap, hash);
    swab256(target_swap, target);
    hash_str = bin2hex(hash_swap, 0x20u);
    target_str = bin2hex(target_swap, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      if ( rc )
        v2 = "YES (hash <= target)";
      else
        v2 = "no (false positive; hash > target)";
      snprintf(
        (char *)tmp42,
        0x800u,
        " Proof: %s\nTarget: %s\nTrgVal? %s",
        (const char *)hash_str,
        (const char *)target_str,
        v2);
      applog(7, tmp42, 0);
    }
    free(hash_str);
    free(target_str);
  }
  return rc;
}

//----- (0003A6BC) --------------------------------------------------------
thread_q *tq_new()
{
  thread_q *tq; // [sp+Ch] [bp-8h]

  tq = (thread_q *)cgcalloc(1, 0x58u, "util.c", _func___11610, 1087);
  tq->q.next = &tq->q;
  tq->q.prev = &tq->q;
  pthread_mutex_init(&tq->mutex, 0);
  pthread_cond_init(&tq->cond, 0);
  return tq;
}

//----- (0003A740) --------------------------------------------------------
void __cdecl tq_freezethaw(thread_q *tq, bool frozen)
{
  mutex_lock_0(&tq->mutex, "util.c", _func___11623, 1119);
  tq->frozen = frozen;
  pthread_cond_signal(&tq->cond);
  mutex_unlock_0(&tq->mutex, "util.c", _func___11623, 1122);
}

//----- (0003A7C0) --------------------------------------------------------
void __cdecl tq_freeze(thread_q *tq)
{
  tq_freezethaw(tq, 1);
}

//----- (0003A7E8) --------------------------------------------------------
bool __cdecl tq_push(thread_q *tq, void *data)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-80Ch] BYREF
  tq_ent *ent; // [sp+810h] [bp-Ch]
  bool rc; // [sp+817h] [bp-5h]

  rc = 1;
  ent = (tq_ent *)cgcalloc(1, 0xCu, "util.c", _func___11636, 1140);
  ent->data = data;
  ent->q_node.next = &ent->q_node;
  ent->q_node.prev = &ent->q_node;
  mutex_lock_0(&tq->mutex, "util.c", _func___11636, 1144);
  if ( !tq->frozen )
  {
    list_add_tail(&ent->q_node, &tq->q);
  }
  else
  {
    free(ent);
    rc = 0;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11638, 1155);
    applog(7, tmp42, 0);
  }
  pthread_cond_signal(&tq->cond);
  mutex_unlock_0(&tq->mutex, "util.c", _func___11636, 1157);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11638, 1158);
    applog(7, tmp42, 0);
  }
  return rc;
}

//----- (0003AA30) --------------------------------------------------------
void *__cdecl tq_pop(thread_q *tq, const timespec *abstime)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-814h] BYREF
  tq_ent *ent; // [sp+810h] [bp-14h]
  int ret; // [sp+814h] [bp-10h]
  int rc; // [sp+818h] [bp-Ch]
  void *rval; // [sp+81Ch] [bp-8h]

  rval = 0;
  ret = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11649, 1170);
    applog(7, tmp42, 0);
  }
  ret = mutex_trylock(&tq->mutex, "util.c", _func___11650, 1171);
  if ( ret )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "mutex_trylock failed in %s %d", (const char *)_FUNCTION___11649, ret);
      applog(4, tmp42, 0);
    }
    return rval;
  }
  else
  {
    if ( !list_empty(&tq->q)
      || (!abstime ? (rc = pthread_cond_wait(&tq->cond, &tq->mutex)) : (rc = pthread_cond_timedwait(
                                                                               &tq->cond,
                                                                               &tq->mutex,
                                                                               abstime)),
          !rc && !list_empty(&tq->q)) )
    {
      ent = (tq_ent *)&tq->q.next[-1].prev;
      rval = ent->data;
      list_del(&ent->q_node);
      free(ent);
    }
    mutex_unlock_0(&tq->mutex, "util.c", _func___11650, 1207);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "%s line %d", (const char *)_FUNCTION___11649, 1208);
      applog(7, tmp42, 0);
    }
    return rval;
  }
}

//----- (0003AD30) --------------------------------------------------------
int __cdecl thr_info_create(thr_info *thr, pthread_attr_t_0 *attr, void *(*start)(void *), void *arg)
{
  cgsem_init(&thr->sem, "util.c", _func___11662, 1214);
  return pthread_create(&thr->pth, attr, start, arg);
}

//----- (0003AD94) --------------------------------------------------------
void __cdecl thr_info_cancel(thr_info *thr)
{
  if ( thr )
  {
    if ( thr->pth )
    {
      pthread_cancel(thr->pth);
      thr->pth = 0;
    }
    cgsem_destroy(&thr->sem);
  }
}

//----- (0003ADFC) --------------------------------------------------------
void __cdecl subtime(timeval *a, timeval *b)
{
  b->tv_sec = a->tv_sec - b->tv_sec;
  b->tv_usec = a->tv_usec - b->tv_usec;
  if ( b->tv_usec < 0 )
  {
    --b->tv_sec;
    b->tv_usec += 1000000;
  }
}

//----- (0003AE94) --------------------------------------------------------
void __cdecl addtime(timeval *a, timeval *b)
{
  b->tv_sec += a->tv_sec;
  b->tv_usec += a->tv_usec;
  if ( b->tv_usec > 999999 )
  {
    ++b->tv_sec;
    b->tv_usec -= 1000000;
  }
}

//----- (0003AF34) --------------------------------------------------------
bool __cdecl time_more(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec > b->tv_usec;
  else
    return a->tv_sec > b->tv_sec;
}

//----- (0003AFB4) --------------------------------------------------------
bool __cdecl time_less(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec < b->tv_usec;
  else
    return a->tv_sec < b->tv_sec;
}

//----- (0003B034) --------------------------------------------------------
void __cdecl copy_time(timeval *dest, const timeval *src)
{
  memcpy(dest, src, sizeof(timeval));
}

//----- (0003B064) --------------------------------------------------------
void __cdecl timeval_to_spec(timespec *spec, const timeval *val)
{
  spec->tv_sec = val->tv_sec;
  spec->tv_nsec = 1000 * val->tv_usec;
}

//----- (0003B0B0) --------------------------------------------------------
void __cdecl us_to_timespec(timespec *spec, int64_t us)
{
  lldiv_t tvdiv; // [sp+18h] [bp-14h] BYREF

  lldiv(&tvdiv, &tvdiv, us, HIDWORD(us), &calc_nonce_info.chain_asic_core_nonce_num[1][23][377], 0, us, HIDWORD(us));
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = 1000 * LODWORD(tvdiv.rem);
}
// 12588: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003B114) --------------------------------------------------------
void __cdecl ms_to_timespec(timespec *spec, int64_t ms)
{
  lldiv_t tvdiv; // [sp+18h] [bp-14h] BYREF

  lldiv(&tvdiv, &tvdiv, ms, HIDWORD(ms), 1000, 0, ms, HIDWORD(ms));
  spec->tv_sec = tvdiv.quot;
  spec->tv_nsec = (_DWORD)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377] * LODWORD(tvdiv.rem);
}
// 12588: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003B178) --------------------------------------------------------
void __cdecl spec_nscheck(timespec *ts)
{
  while ( ts->tv_nsec > 999999999 )
  {
    ts->tv_nsec -= 1000000000;
    ++ts->tv_sec;
  }
  while ( ts->tv_nsec < 0 )
  {
    ts->tv_nsec += 1000000000;
    --ts->tv_sec;
  }
}

//----- (0003B228) --------------------------------------------------------
void __cdecl timeraddspec(timespec *a, const timespec *b)
{
  a->tv_sec += b->tv_sec;
  a->tv_nsec += b->tv_nsec;
  spec_nscheck(a);
}

//----- (0003B288) --------------------------------------------------------
void __cdecl cgtime(timeval *tv)
{
  gettimeofday(tv, 0);
}

//----- (0003B2B0) --------------------------------------------------------
void __cdecl cgtimer_time(cgtimer_t *ts_start)
{
  clock_gettime(1, ts_start);
}

//----- (0003B2D8) --------------------------------------------------------
void __cdecl nanosleep_abstime(timespec *ts_end)
{
  while ( clock_nanosleep(1, 1, ts_end, 0) == 4 )
    ;
}

//----- (0003B318) --------------------------------------------------------
void __cdecl cgsleep_ms_r(cgtimer_t *ts_start, int ms)
{
  timespec ts_end; // [sp+8h] [bp-Ch] BYREF

  ms_to_timespec(&ts_end, ms);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (0003B36C) --------------------------------------------------------
void __cdecl cgsleep_us_r(cgtimer_t *ts_start, int64_t us)
{
  timespec ts_end; // [sp+10h] [bp-Ch] BYREF

  us_to_timespec(&ts_end, us);
  timeraddspec(&ts_end, ts_start);
  nanosleep_abstime(&ts_end);
}

//----- (0003B3B8) --------------------------------------------------------
void __cdecl cgsleep_ms(int ms)
{
  cgtimer_t ts_start; // [sp+8h] [bp-Ch] BYREF

  cgtimer_time(&ts_start);
  cgsleep_ms_r(&ts_start, ms);
}

//----- (0003B3F0) --------------------------------------------------------
void __cdecl cgsleep_us(int64_t us)
{
  cgtimer_t ts_start; // [sp+8h] [bp-Ch] BYREF

  cgtimer_time(&ts_start);
  cgsleep_us_r(&ts_start, us);
}

//----- (0003B428) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl tdiff(timeval *end, timeval *start)
{
  double result; // r0

  LODWORD(result) = end;
  return result;
}
// 3B428: variables would overlap: r0.4 and r0.8
// 3B428: bad return variable

//----- (0003B498) --------------------------------------------------------
bool __cdecl extract_sockaddr(unsigned __int8 *url, unsigned __int8 **sockaddr_url, unsigned __int8 **sockaddr_port)
{
  unsigned __int8 port[6]; // [sp+18h] [bp-12Ch] BYREF
  unsigned __int8 url_address[256]; // [sp+20h] [bp-124h] BYREF
  unsigned __int8 *slash; // [sp+120h] [bp-24h]
  unsigned __int8 *ipv6_end; // [sp+124h] [bp-20h]
  unsigned __int8 *ipv6_begin; // [sp+128h] [bp-1Ch]
  int port_len; // [sp+12Ch] [bp-18h]
  int url_len; // [sp+130h] [bp-14h]
  unsigned __int8 *port_start; // [sp+134h] [bp-10h]
  unsigned __int8 *url_end; // [sp+138h] [bp-Ch]
  unsigned __int8 *url_begin; // [sp+13Ch] [bp-8h]

  port_start = 0;
  port_len = 0;
  *sockaddr_url = url;
  url_begin = (unsigned __int8 *)strstr((const char *)url, "//");
  if ( url_begin )
    url_begin += 2;
  else
    url_begin = url;
  ipv6_begin = (unsigned __int8 *)strchr((const char *)url_begin, 91);
  ipv6_end = (unsigned __int8 *)strchr((const char *)url_begin, 93);
  if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin )
    url_end = (unsigned __int8 *)strchr((const char *)ipv6_end, 58);
  else
    url_end = (unsigned __int8 *)strchr((const char *)url_begin, 58);
  if ( url_end )
  {
    url_len = url_end - url_begin;
    port_len = strlen((const char *)url_begin) - (url_end - url_begin) - 1;
    if ( port_len <= 0 )
      return 0;
    port_start = url_end + 1;
  }
  else
  {
    url_len = strlen((const char *)url_begin);
  }
  if ( url_len <= 0 )
    return 0;
  if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin )
  {
    url_len -= 2;
    ++url_begin;
  }
  snprintf((char *)url_address, 0xFEu, "%.*s", url_len, (const char *)url_begin);
  if ( port_len )
  {
    snprintf((char *)port, 6u, "%.*s", port_len, (const char *)port_start);
    slash = (unsigned __int8 *)strpbrk((const char *)port, "/#");
    if ( slash )
      *slash = 0;
  }
  else
  {
    strcpy((char *)port, "80");
  }
  *sockaddr_port = (unsigned __int8 *)strdup((const char *)port);
  *sockaddr_url = (unsigned __int8 *)strdup((const char *)url_address);
  return 1;
}

//----- (0003B718) --------------------------------------------------------
send_ret __cdecl _stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  int v3; // r3
  signed int lenb; // [sp+Ch] [bp-848h]
  fd_set wd; // [sp+1Ch] [bp-838h] BYREF
  timeval timeout; // [sp+81Ch] [bp-38h] BYREF
  fd_set *__arr; // [sp+824h] [bp-30h]
  int sock; // [sp+828h] [bp-2Ch]
  unsigned int __i; // [sp+82Ch] [bp-28h]
  ssize_t sent; // [sp+830h] [bp-24h]
  ssize_t ssent; // [sp+834h] [bp-20h]

  sock = pool->sock;
  ssent = 0;
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)&wd, 0x800u, "SEND: %s", (const char *)s);
    applog(7, (const unsigned __int8 *)&wd, 0);
  }
  strcat((char *)s, "\n");
  for ( lenb = len + 1; lenb > 0; lenb -= sent )
  {
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    while ( 1 )
    {
      __arr = &wd;
      for ( __i = 0; __i <= 0x1F; ++__i )
        __arr->fds_bits[__i] = 0;
      LOBYTE(v3) = sock & 0x1F;
      if ( sock <= 0 )
        v3 = -(-sock & 0x1F);
      wd.fds_bits[sock / 32] |= 1 << v3;
      if ( select(sock + 1, 0, &wd, 0, &timeout) > 0 )
        break;
      if ( !interrupted() )
        return 1;
    }
    sent = send(pool->sock, &s[ssent], lenb, 0x4000);
    if ( sent < 0 )
    {
      if ( (unsigned __int8)sock_blocks() != 1 )
        return 2;
      sent = 0;
    }
    ssent += sent;
  }
  ++pool->cgminer_pool_stats.times_sent;
  pool->cgminer_pool_stats.bytes_sent += ssent;
  pool->cgminer_pool_stats.net_bytes_sent += ssent;
  return 0;
}

//----- (0003BA2C) --------------------------------------------------------
bool __cdecl stratum_send(pool *pool, unsigned __int8 *s, ssize_t len)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-808h] BYREF
  send_ret ret; // [sp+814h] [bp-8h]

  ret = SEND_INACTIVE;
  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "SEND: %s", (const char *)s);
    applog(7, tmp42, 0);
  }
  mutex_lock_0(&pool->stratum_lock, "util.c", _func___11864, 1743);
  if ( pool->stratum_active )
    ret = _stratum_send(pool, s, len);
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___11864, 1750);
  switch ( ret )
  {
    case SEND_SENDFAIL:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Failed to send in stratum_send");
        applog(7, tmp42, 0);
      }
      goto LABEL_17;
    case SEND_INACTIVE:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Stratum send failed due to no pool stratum_active");
        applog(7, tmp42, 0);
      }
      break;
    case SEND_SELECTFAIL:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Write select failed on pool %d sock", pool->pool_no);
        applog(7, tmp42, 0);
      }
LABEL_17:
      suspend_stratum(pool);
      break;
  }
  return ret == SEND_OK;
}

//----- (0003BD90) --------------------------------------------------------
bool __cdecl socket_full(pool *pool, int wait)
{
  int v2; // r3
  __time_t waita; // [sp+8h] [bp-A4h]
  fd_set rd; // [sp+14h] [bp-98h] BYREF
  timeval timeout; // [sp+94h] [bp-18h] BYREF
  fd_set *__arr; // [sp+9Ch] [bp-10h]
  int sock; // [sp+A0h] [bp-Ch]
  unsigned int __i; // [sp+A4h] [bp-8h]

  waita = wait;
  sock = pool->sock;
  if ( wait < 0 )
    waita = 0;
  __arr = &rd;
  for ( __i = 0; __i <= 0x1F; ++__i )
    __arr->fds_bits[__i] = 0;
  LOBYTE(v2) = sock & 0x1F;
  if ( sock <= 0 )
    v2 = -(-sock & 0x1F);
  rd.fds_bits[sock / 32] |= 1 << v2;
  timeout.tv_usec = 0;
  timeout.tv_sec = waita;
  return select(sock + 1, &rd, 0, 0, &timeout) > 0;
}

//----- (0003BEB0) --------------------------------------------------------
bool __cdecl sock_full(pool *pool)
{
  return *pool->sockbuf || socket_full(pool, 0);
}

//----- (0003BEF8) --------------------------------------------------------
void __cdecl clear_sockbuf(pool *pool)
{
  if ( pool->sockbuf )
    *pool->sockbuf = 0;
}

//----- (0003BF38) --------------------------------------------------------
void __cdecl clear_sock(pool *pool)
{
  int n; // [sp+Ch] [bp-8h]

  mutex_lock_0(&pool->stratum_lock, "util.c", _func___11896, 1825);
  do
  {
    if ( pool->sock )
      n = recv(pool->sock, pool->sockbuf, 0x1FFCu, 0);
    else
      n = 0;
  }
  while ( n > 0 );
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___11896, 1834);
  clear_sockbuf(pool);
}

//----- (0003BFE4) --------------------------------------------------------
void __cdecl recalloc_sock(pool *pool, size_t len)
{
  size_t news; // [sp+10h] [bp-Ch]
  size_t old; // [sp+14h] [bp-8h]

  old = strlen((const char *)pool->sockbuf);
  if ( old + len + 1 >= pool->sockbuf_size )
  {
    news = ((old + len + 1) & 0xFFFFE000) + 0x2000;
    pool->sockbuf = (unsigned __int8 *)cgrealloc(pool->sockbuf, news, "util.c", _func___11913, 1863);
    memset(&pool->sockbuf[old], 0, news - old);
    pool->sockbuf_size = news;
  }
}

//----- (0003C0C0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned __int8 *__cdecl recv_line(pool *pool)
{
  double v1; // d0
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-2848h] BYREF
  _BYTE tmp42_0[8192]; // [sp+80Ch] [bp-2048h] OVERLAPPED BYREF
  timeval now; // [sp+280Ch] [bp-48h] BYREF
  timeval rstart; // [sp+2814h] [bp-40h] BYREF
  ssize_t len; // [sp+281Ch] [bp-38h]
  unsigned __int8 *tok; // [sp+2820h] [bp-34h]
  ssize_t buflen; // [sp+2824h] [bp-30h]
  size_t slen; // [sp+2828h] [bp-2Ch]
  ssize_t n; // [sp+282Ch] [bp-28h]
  int waited; // [sp+2830h] [bp-24h]
  unsigned __int8 *sret; // [sp+2834h] [bp-20h]

  sret = 0;
  waited = 0;
  if ( strchr((const char *)pool->sockbuf, 10) )
    goto LABEL_27;
  cgtime(&rstart);
  if ( !socket_full(pool, 60) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42_0, "Timed out waiting for data on socket_full");
      applog(7, tmp42_0, 0);
    }
    goto out;
  }
  while ( 1 )
  {
    memset(tmp42_0, 0, sizeof(tmp42_0));
    n = recv(pool->sock, tmp42_0, 0x1FFCu, 0);
    if ( !n )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Socket closed waiting in recv_line");
        applog(7, tmp42, 0);
      }
      goto LABEL_14;
    }
    cgtime(&now);
    tdiff(&now, &rstart);
    waited = (int)v1;
    if ( n < 0 )
      break;
    slen = strlen(tmp42_0);
    recalloc_sock(pool, slen);
    strcat((char *)pool->sockbuf, tmp42_0);
LABEL_25:
    if ( waited > 59 || strchr((const char *)pool->sockbuf, 10) )
      goto LABEL_27;
  }
  if ( (unsigned __int8)sock_blocks() == 1 && socket_full(pool, 60 - waited) )
    goto LABEL_25;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Failed to recv sock in recv_line");
    applog(7, tmp42, 0);
  }
LABEL_14:
  suspend_stratum(pool);
LABEL_27:
  buflen = strlen((const char *)pool->sockbuf);
  tok = (unsigned __int8 *)strtok((char *)pool->sockbuf, "\n");
  if ( tok )
  {
    sret = (unsigned __int8 *)strdup((const char *)tok);
    len = strlen((const char *)sret);
    if ( buflen <= len + 1 )
      *pool->sockbuf = 0;
    else
      memmove(pool->sockbuf, &pool->sockbuf[len + 1], buflen - len + 1);
    ++pool->cgminer_pool_stats.times_received;
    pool->cgminer_pool_stats.bytes_received += len;
    pool->cgminer_pool_stats.net_bytes_received += len;
  }
  else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42_0, "Failed to parse a \\n terminated string in recv_line");
    applog(7, tmp42_0, 0);
  }
out:
  if ( sret )
  {
    if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42_0, 0x800u, "RECVD: %s", (const char *)sret);
      applog(7, tmp42_0, 0);
    }
  }
  else
  {
    clear_sock(pool);
  }
  return sret;
}
// 3C0C0: variables would overlap: ^80C.8192 and stkvar "tmp42_0" ^80C.2048(has user info)

//----- (0003C7E0) --------------------------------------------------------
unsigned __int8 *__cdecl _json_array_string(json_t_0 *val, unsigned int entry)
{
  const json_t_0 *arr_entry; // [sp+Ch] [bp-8h]

  if ( val && val->type == JSON_NULL )
    return 0;
  if ( !val || val->type != JSON_ARRAY )
    return 0;
  if ( entry > json_array_size(val) )
    return 0;
  arr_entry = json_array_get(val, entry);
  if ( arr_entry && arr_entry->type == JSON_STRING )
    return (unsigned __int8 *)json_string_value(arr_entry);
  else
    return 0;
}

//----- (0003C8A8) --------------------------------------------------------
unsigned __int8 *__cdecl json_array_string(json_t_0 *val, unsigned int entry)
{
  unsigned __int8 *buf; // [sp+Ch] [bp-8h]

  buf = _json_array_string(val, entry);
  if ( buf )
    return (unsigned __int8 *)strdup((const char *)buf);
  else
    return 0;
}

//----- (0003C8F8) --------------------------------------------------------
bool __cdecl parse_notify(pool *pool, json_t_0 *val)
{
  bool v2; // r3
  unsigned __int8 **v3; // r8
  unsigned __int8 *v4; // r0
  const char *v5; // r3
  json_t_0 *vala; // [sp+18h] [bp-954h] BYREF
  pool *poola; // [sp+1Ch] [bp-950h]
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-94Ch] BYREF
  unsigned __int8 header[228]; // [sp+820h] [bp-14Ch] BYREF
  unsigned __int8 *cb; // [sp+904h] [bp-68h]
  unsigned __int8 *merkle; // [sp+908h] [bp-64h]
  size_t alloc_len; // [sp+90Ch] [bp-60h]
  size_t cb2_len; // [sp+910h] [bp-5Ch]
  size_t cb1_len; // [sp+914h] [bp-58h]
  bool clean; // [sp+91Bh] [bp-51h]
  unsigned __int8 *ntime; // [sp+91Ch] [bp-50h]
  unsigned __int8 *nbit; // [sp+920h] [bp-4Ch]
  unsigned __int8 *bbversion; // [sp+924h] [bp-48h]
  unsigned __int8 *coinbase2; // [sp+928h] [bp-44h]
  unsigned __int8 *coinbase1; // [sp+92Ch] [bp-40h]
  unsigned __int8 *prev_hash; // [sp+930h] [bp-3Ch]
  unsigned __int8 *job_id; // [sp+934h] [bp-38h]
  int merkles; // [sp+938h] [bp-34h]
  json_t_0 *arr; // [sp+93Ch] [bp-30h]
  unsigned __int8 *cb2; // [sp+940h] [bp-2Ch]
  unsigned __int8 *cb1; // [sp+944h] [bp-28h]
  int i; // [sp+948h] [bp-24h]
  bool ret; // [sp+94Fh] [bp-1Dh]

  poola = pool;
  vala = val;
  cb1 = 0;
  cb2 = 0;
  ret = 0;
  arr = json_array_get(val, 4u);
  if ( arr && arr->type == JSON_ARRAY )
  {
    merkles = json_array_size(arr);
    job_id = json_array_string(vala, 0);
    prev_hash = _json_array_string(vala, 1u);
    coinbase1 = json_array_string(vala, 2u);
    coinbase2 = json_array_string(vala, 3u);
    bbversion = _json_array_string(vala, 5u);
    nbit = _json_array_string(vala, 6u);
    ntime = _json_array_string(vala, 7u);
    v2 = json_array_get(vala, 8u) && json_array_get(vala, 8u)->type == JSON_TRUE;
    clean = v2;
    if ( !valid_ascii(job_id, "util.c", _func___11969, 2007)
      || !valid_hex(prev_hash, "util.c", _func___11969, 2007)
      || !valid_hex(coinbase1, "util.c", _func___11969, 2007)
      || !valid_hex(coinbase2, "util.c", _func___11969, 2008)
      || !valid_hex(bbversion, "util.c", _func___11969, 2008)
      || !valid_hex(nbit, "util.c", _func___11969, 2008)
      || !valid_hex(ntime, "util.c", _func___11969, 2009) )
    {
      free(job_id);
      free(coinbase1);
      free(coinbase2);
    }
    else
    {
      cg_wlock_0(&poola->data_lock, "util.c", _func___11969, 2018);
      free(poola->swork.job_id);
      poola->swork.job_id = job_id;
      snprintf((char *)poola->prev_hash, 0x41u, "%s", (const char *)prev_hash);
      cb1_len = strlen((const char *)coinbase1) >> 1;
      cb2_len = strlen((const char *)coinbase2) >> 1;
      snprintf((char *)poola->bbversion, 9u, "%s", (const char *)bbversion);
      snprintf((char *)poola->nbit, 9u, "%s", (const char *)nbit);
      snprintf((char *)poola->ntime, 9u, "%s", (const char *)ntime);
      poola->swork.clean = clean;
      if ( poola->next_diff > 0.0 )
        poola->sdiff = poola->next_diff;
      poola->coinbase_len = poola->n1_len + cb1_len + poola->n2size + cb2_len;
      alloc_len = poola->coinbase_len;
      poola->nonce2_offset = poola->n1_len + cb1_len;
      for ( i = 0; i < poola->merkles; ++i )
        free(poola->swork.merkle_bin[i]);
      if ( merkles )
      {
        poola->swork.merkle_bin = (unsigned __int8 **)cgrealloc(
                                                        poola->swork.merkle_bin,
                                                        4 * merkles + 1,
                                                        "util.c",
                                                        _func___11969,
                                                        2040);
        for ( i = 0; i < merkles; ++i )
        {
          merkle = json_array_string(arr, i);
          v3 = &poola->swork.merkle_bin[i];
          *v3 = (unsigned __int8 *)cgmalloc(0x20u, "util.c", _func___11969, 2045);
          if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "merkle %d: %s", i, (const char *)merkle);
            applog(7, tmp42, 0);
          }
          ret = hex2bin(poola->swork.merkle_bin[i], merkle, 0x20u);
          free(merkle);
          if ( !ret )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              strcpy((char *)tmp42, "Failed to convert merkle to merkle_bin in parse_notify");
              applog(3, tmp42, 0);
            }
            goto out_unlock;
          }
        }
      }
      poola->merkles = merkles;
      if ( poola->merkles <= 1 )
        ++poola->bad_work;
      if ( clean )
        poola->nonce2 = 0LL;
      snprintf(
        (char *)header,
        0xE1u,
        "%s%s%s%s%s%s%s",
        (const char *)poola->bbversion,
        (const char *)poola->prev_hash,
        (const char *)blank_merkle,
        (const char *)poola->ntime,
        (const char *)poola->nbit,
        "00000000",
        (const char *)workpadding);
      ret = hex2bin(poola->header_bin, header, 0x70u);
      if ( !ret )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "Failed to convert header to header_bin in parse_notify");
          applog(3, tmp42, 0);
        }
      }
      else
      {
        cb1 = (unsigned __int8 *)&vala;
        ret = hex2bin((unsigned __int8 *)&vala, coinbase1, cb1_len);
        if ( !ret )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            strcpy((char *)tmp42, "Failed to convert cb1 to cb1_bin in parse_notify");
            applog(3, tmp42, 0);
          }
        }
        else
        {
          cb2 = (unsigned __int8 *)&vala;
          ret = hex2bin((unsigned __int8 *)&vala, coinbase2, cb2_len);
          if ( !ret )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              strcpy((char *)tmp42, "Failed to convert cb2 to cb2_bin in parse_notify");
              applog(3, tmp42, 0);
            }
          }
          else
          {
            free(poola->coinbase);
            v4 = (unsigned __int8 *)cgcalloc(alloc_len, 1u, "util.c", _func___11969, 2102);
            poola->coinbase = v4;
            cg_memcpy(poola->coinbase, cb1, cb1_len, "util.c", _func___11969, 2103);
            if ( poola->n1_len )
              cg_memcpy(&poola->coinbase[cb1_len], poola->nonce1bin, poola->n1_len, "util.c", _func___11969, 2105);
            cg_memcpy(
              &poola->coinbase[poola->n1_len + cb1_len + poola->n2size],
              cb2,
              cb2_len,
              "util.c",
              _func___11969,
              2106);
            if ( opt_debug )
            {
              cb = bin2hex(poola->coinbase, poola->coinbase_len);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "Pool %d coinbase %s", poola->pool_no, (const char *)cb);
                applog(7, tmp42, 0);
              }
              free(cb);
            }
          }
        }
      }
out_unlock:
      cg_wunlock_0(&poola->data_lock, "util.c", _func___11969, 2115);
      if ( opt_protocol )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "job_id: %s", (const char *)job_id);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "prev_hash: %s", (const char *)prev_hash);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "coinbase1: %s", (const char *)coinbase1);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "coinbase2: %s", (const char *)coinbase2);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "bbversion: %s", (const char *)bbversion);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "nbit: %s", (const char *)nbit);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "ntime: %s", (const char *)ntime);
          applog(7, tmp42, 0);
        }
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          if ( clean )
            v5 = "yes";
          else
            v5 = "no";
          snprintf((char *)tmp42, 0x800u, "clean: %s", v5);
          applog(7, tmp42, 0);
        }
      }
      free(coinbase1);
      free(coinbase2);
      ++poola->getwork_requested;
      ++total_getworks;
      if ( poola == current_pool() )
        opt_work_update = 1;
    }
  }
  return ret;
}

//----- (0003DA20) --------------------------------------------------------
uint32_t __cdecl real_mask(uint32_t mask, int need_bit)
{
  int bits; // [sp+Ch] [bp-10h]
  int i; // [sp+10h] [bp-Ch]
  uint32_t real_mask_bit; // [sp+14h] [bp-8h]

  real_mask_bit = 0;
  bits = 0;
  for ( i = 0; i <= 31; ++i )
  {
    if ( ((mask >> i) & 1) != 0 )
    {
      real_mask_bit |= 1 << i;
      if ( ++bits == need_bit )
        break;
    }
  }
  return real_mask_bit;
}

//----- (0003DADC) --------------------------------------------------------
void __cdecl process_version_mask(pool *pool, unsigned __int8 *mask)
{
  int v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp-808h] BYREF
  FILE *pFile; // [sp+81Ch] [bp-8h]

  if ( mask )
  {
    v2 = strtol((const char *)mask, 0, 16);
    pool->ab_mask = swab32_1(v2);
    pool->ab_mask = real_mask(pool->ab_mask & 0xC000, 2);
    if ( (pool->ab_mask & 0xC000) != 0 )
    {
      pool->support_ab = 1;
      pool->version_num = 4;
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Pool %d Verion num is %d\n",
            "util.c",
            2178,
            (const char *)_FUNCTION___12009,
            pool->pool_no,
            pool->version_num);
        fclose(pFile);
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d rolling mask do not match!", pool->pool_no);
        applog(5, tmp42, 0);
      }
      pool->support_ab = 0;
      pool->version_num = 1;
    }
  }
  else
  {
    pool->support_ab = 0;
    pool->version_num = 1;
  }
}

//----- (0003DCD8) --------------------------------------------------------
bool __cdecl parse_version_mask(pool *pool, json_t_0 *val)
{
  json_t_0 *v2; // r0
  unsigned __int8 *mask; // [sp+Ch] [bp-8h]

  v2 = json_array_get(val, 0);
  mask = (unsigned __int8 *)json_string_value(v2);
  process_version_mask(pool, mask);
  return 1;
}

//----- (0003DD2C) --------------------------------------------------------
bool __cdecl parse_version_rolling_mask(pool *pool, unsigned __int8 *sret)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-91Ch] BYREF
  json_error_t err; // [sp+810h] [bp-11Ch] BYREF
  json_t_0 *value; // [sp+90Ch] [bp-20h]
  json_t_0 *err_val; // [sp+910h] [bp-1Ch]
  json_t_0 *res_val; // [sp+914h] [bp-18h]
  json_t_0 *val; // [sp+918h] [bp-14h]
  unsigned __int8 *mask; // [sp+91Ch] [bp-10h]
  const unsigned __int8 *key; // [sp+920h] [bp-Ch]
  bool ret; // [sp+927h] [bp-5h]

  ret = 0;
  mask = 0;
  val = 0;
  val = json_loads(sret, 0, &err);
  if ( val )
  {
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    if ( res_val && res_val->type != JSON_NULL && (!err_val || err_val->type == JSON_NULL) )
    {
      v2 = json_object_iter(res_val);
      for ( key = json_object_iter_key(v2); key; key = json_object_iter_key(v4) )
      {
        v5 = json_object_key_to_iter(key);
        value = json_object_iter_value(v5);
        if ( !value )
          break;
        if ( !strcasecmp((const char *)key, "version-rolling") && strlen((const char *)key) == 15 )
        {
          if ( !value || value->type != JSON_TRUE )
          {
            pool->support_ab = 0;
            pool->version_num = 1;
            goto out;
          }
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf((char *)tmp42, 0x800u, "POOL %d support ab mode!", pool->pool_no);
            applog(5, tmp42, 0);
          }
        }
        else if ( !strcasecmp((const char *)key, "version-rolling.mask") )
        {
          mask = (unsigned __int8 *)json_string_value(value);
          process_version_mask(pool, mask);
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "JSON-RPC unexpected mining.configure value: %s", (const char *)key);
          applog(3, tmp42, 0);
        }
        v3 = json_object_key_to_iter(key);
        v4 = json_object_iter_next(res_val, v3);
      }
      ret = 1;
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
    applog(6, tmp42, 0);
  }
out:
  json_decref(val);
  return ret;
}
// 3DE48: conditional instruction was optimized away because %res_val.4!=0
// 3DE70: conditional instruction was optimized away because %err_val.4!=0

//----- (0003E0C8) --------------------------------------------------------
bool __cdecl parse_version(pool *pool, json_t_0 *val)
{
  size_t j; // r0
  json_t_0 *v3; // r0
  unsigned int i; // [sp+Ch] [bp-8h]

  i = 0;
  for ( j = json_array_size(val); j > i; j = json_array_size(val) )
  {
    v3 = json_array_get(val, i);
    pool->version[i++] = json_integer_value(v3);
  }
  return 1;
}

//----- (0003E154) --------------------------------------------------------
bool __cdecl parse_diff(pool *pool, json_t_0 *val)
{
  double v2; // d0
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-818h] BYREF
  int idiff; // [sp+814h] [bp-18h]
  double diff; // [sp+818h] [bp-14h]
  double old_diff; // [sp+820h] [bp-Ch]

  v3 = json_array_get(val, 0);
  json_number_value(v3);
  diff = v2;
  if ( v2 == 0.0 )
    return 0;
  cg_wlock_0(&pool->data_lock, "util.c", _func___12048, 2261);
  if ( pool->next_diff <= 0.0 )
  {
    old_diff = pool->sdiff;
    pool->sdiff = diff;
    pool->next_diff = pool->sdiff;
  }
  else
  {
    old_diff = pool->next_diff;
    pool->next_diff = diff;
  }
  cg_wunlock_0(&pool->data_lock, "util.c", _func___12048, 2274);
  if ( old_diff == diff )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d difficulty set to %f", pool->pool_no, diff);
      applog(7, tmp42, 0);
    }
  }
  else
  {
    idiff = (int)diff;
    if ( diff == (double)(int)diff )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %d", pool->pool_no, idiff);
        applog(5, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d difficulty changed to %.1f", pool->pool_no, diff);
      applog(5, tmp42, 0);
    }
  }
  return 1;
}
// 3E184: variable 'v2' is possibly undefined

//----- (0003E460) --------------------------------------------------------
bool __cdecl parse_extranonce(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-80Ch] BYREF
  int n2size; // [sp+810h] [bp-Ch]
  unsigned __int8 *nonce1; // [sp+814h] [bp-8h]

  nonce1 = json_array_string(val, 0);
  if ( !valid_hex(nonce1, "util.c", _func___12059, 2304) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Failed to get valid nonce1 in parse_extranonce");
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    v3 = json_array_get(val, 1u);
    n2size = json_integer_value(v3);
    if ( n2size )
    {
      cg_wlock_0(&pool->data_lock, "util.c", _func___12059, 2317);
      free(pool->nonce1);
      pool->nonce1 = nonce1;
      pool->n1_len = strlen((const char *)nonce1) >> 1;
      free(pool->nonce1bin);
      pool->nonce1bin = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", _func___12059, 2322);
      if ( !pool->nonce1bin )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to calloc pool->nonce1bin in %s %s():%d",
          "util.c",
          (const char *)_func___12059,
          2324);
        applog(3, tmp42, 1);
        quit(1);
      }
      hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
      pool->n2size = n2size;
      cg_wunlock_0(&pool->data_lock, "util.c", _func___12059, 2327);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d extranonce change requested", pool->pool_no);
        applog(5, tmp42, 0);
      }
      opt_work_update = 1;
      return 1;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        strcpy((char *)tmp42, "Failed to get valid n2size in parse_extranonce");
        applog(6, tmp42, 0);
      }
      free(nonce1);
      return 0;
    }
  }
}

//----- (0003E82C) --------------------------------------------------------
void __cdecl _suspend_stratum(pool *pool)
{
  clear_sockbuf(pool);
  pool->stratum_notify = 0;
  pool->stratum_active = pool->stratum_notify;
  if ( pool->sock )
    close(pool->sock);
  pool->sock = 0;
}

//----- (0003E898) --------------------------------------------------------
bool __cdecl parse_reconnect(pool *pool, json_t_0 *val)
{
  json_t_0 *v2; // r0
  json_t_0 *v4; // r0
  json_t_0 *v5; // r0
  char v7[264]; // [sp+8h] [bp-A34h] BYREF
  json_t_0 *vala; // [sp+110h] [bp-92Ch]
  pool *poola; // [sp+114h] [bp-928h]
  unsigned __int8 tmp42[2048]; // [sp+118h] [bp-924h] BYREF
  unsigned __int8 address[256]; // [sp+918h] [bp-124h] BYREF
  unsigned __int8 *stratum_port; // [sp+A18h] [bp-24h] BYREF
  unsigned __int8 *sockaddr_url; // [sp+A1Ch] [bp-20h] BYREF
  unsigned __int8 *tmp; // [sp+A20h] [bp-1Ch]
  int port_no; // [sp+A24h] [bp-18h]
  unsigned __int8 *dot_reconnect; // [sp+A28h] [bp-14h]
  unsigned __int8 *dot_pool; // [sp+A2Ch] [bp-10h]
  unsigned __int8 *port; // [sp+A30h] [bp-Ch]
  unsigned __int8 *url; // [sp+A34h] [bp-8h]

  poola = pool;
  vala = val;
  memset(address, 0, 0xFFu);
  v2 = json_array_get(vala, 0);
  url = (unsigned __int8 *)json_string_value(v2);
  if ( !url )
  {
    url = poola->sockaddr_url;
LABEL_21:
    v4 = json_array_get(vala, 1u);
    port_no = json_integer_value(v4);
    if ( port_no )
    {
      port = (unsigned __int8 *)v7;
      sprintf(v7, "%d", port_no);
    }
    else
    {
      v5 = json_array_get(vala, 1u);
      port = (unsigned __int8 *)json_string_value(v5);
      if ( !port )
        port = poola->stratum_port;
    }
    snprintf((char *)address, 0xFEu, "%s:%s", (const char *)url, (const char *)port);
    if ( !extract_sockaddr(address, &sockaddr_url, &stratum_port) )
      return 0;
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Stratum reconnect requested from pool %d to %s",
        poola->pool_no,
        (const char *)address);
      applog(4, tmp42, 0);
    }
    clear_pool_work(poola);
    mutex_lock_0(&poola->stratum_lock, "util.c", _func___12084, 2401);
    _suspend_stratum(poola);
    tmp = poola->sockaddr_url;
    poola->sockaddr_url = sockaddr_url;
    poola->stratum_url = poola->sockaddr_url;
    free(tmp);
    tmp = poola->stratum_port;
    poola->stratum_port = stratum_port;
    free(tmp);
    mutex_unlock_0(&poola->stratum_lock, "util.c", _func___12084, 2410);
    return restart_stratum(poola);
  }
  dot_pool = (unsigned __int8 *)strchr((const char *)poola->sockaddr_url, 46);
  if ( dot_pool )
  {
    dot_reconnect = (unsigned __int8 *)strchr((const char *)url, 46);
    if ( dot_reconnect )
    {
      if ( !strcmp((const char *)dot_pool, (const char *)dot_reconnect) )
        goto LABEL_21;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Denied stratum reconnect request to non-matching domain url '%s'",
          (const char *)poola->sockaddr_url);
        applog(3, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Denied stratum reconnect request to url without domain '%s'",
          (const char *)url);
        applog(3, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Denied stratum reconnect request for pool without domain '%s'",
        (const char *)poola->sockaddr_url);
      applog(3, tmp42, 0);
    }
    return 0;
  }
}

//----- (0003ECE0) --------------------------------------------------------
bool __cdecl send_version(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  size_t v4; // r0
  unsigned __int8 s[8192]; // [sp+8h] [bp-200Ch] BYREF
  int id; // [sp+2008h] [bp-Ch]

  if ( !json_object_get(val, "id") )
    return 0;
  v3 = json_object_get(val, "id");
  id = json_integer_value(v3);
  sprintf((char *)s, "{\"id\": %d, \"result\": \"cgminer/2.0.0\", \"error\": null}", id);
  v4 = strlen((const char *)s);
  return stratum_send(pool, s, v4);
}

//----- (0003EDFC) --------------------------------------------------------
bool __cdecl send_pong(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  size_t v4; // r0
  unsigned __int8 s[8192]; // [sp+8h] [bp-200Ch] BYREF
  int id; // [sp+2008h] [bp-Ch]

  if ( !json_object_get(val, "id") )
    return 0;
  v3 = json_object_get(val, "id");
  id = json_integer_value(v3);
  sprintf((char *)s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", id);
  v4 = strlen((const char *)s);
  return stratum_send(pool, s, v4);
}

//----- (0003EF18) --------------------------------------------------------
bool __cdecl show_message(pool *pool, json_t_0 *val)
{
  json_t_0 *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-808h] BYREF
  unsigned __int8 *msg; // [sp+814h] [bp-8h]

  if ( !val || val->type != JSON_ARRAY )
    return 0;
  v3 = json_array_get(val, 0);
  msg = (unsigned __int8 *)json_string_value(v3);
  if ( !msg )
    return 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d message: %s", pool->pool_no, (const char *)msg);
    applog(5, tmp42, 0);
  }
  return 1;
}

//----- (0003F01C) --------------------------------------------------------
bool __cdecl parse_method(pool *pool, unsigned __int8 *s)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-91Ch] BYREF
  json_error_t err; // [sp+810h] [bp-11Ch] BYREF
  unsigned __int8 *buf; // [sp+90Ch] [bp-20h]
  json_t_0 *params; // [sp+910h] [bp-1Ch]
  json_t_0 *err_val; // [sp+914h] [bp-18h]
  json_t_0 *method; // [sp+918h] [bp-14h]
  json_t_0 *val; // [sp+91Ch] [bp-10h]
  unsigned __int8 *ss; // [sp+920h] [bp-Ch]
  bool ret; // [sp+927h] [bp-5h]

  val = 0;
  ret = 0;
  if ( s )
  {
    val = json_loads(s, 0, &err);
    if ( val )
    {
      method = json_object_get(val, "method");
      if ( method )
      {
        err_val = json_object_get(val, "error");
        params = json_object_get(val, "params");
        if ( !err_val || err_val->type == JSON_NULL )
        {
          buf = (unsigned __int8 *)json_string_value(method);
          if ( buf )
          {
            if ( !strncasecmp((const char *)buf, "mining.multi_version", 0x14u) )
            {
              pool->support_ab = 1;
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                strcpy((char *)tmp42, "Pool support multi version");
                applog(6, tmp42, 0);
              }
              ret = parse_version(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.notify", 0xDu) )
            {
              if ( parse_notify(pool, params) )
              {
                ret = 1;
                pool->stratum_notify = 1;
              }
              else
              {
                ret = 0;
                pool->stratum_notify = 0;
              }
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_version_mask", 0x17u) )
            {
              if ( parse_version_mask(pool, params) )
              {
                ret = 1;
                pool->stratum_notify = 1;
              }
              else
              {
                ret = 0;
                pool->stratum_notify = 0;
              }
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_difficulty", 0x15u) )
            {
              ret = parse_diff(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.set_extranonce", 0x15u) )
            {
              ret = parse_extranonce(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "client.reconnect", 0x10u) )
            {
              ret = parse_reconnect(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "client.get_version", 0x12u) )
            {
              ret = send_version(pool, val);
            }
            else if ( !strncasecmp((const char *)buf, "client.show_message", 0x13u) )
            {
              ret = show_message(pool, params);
            }
            else if ( !strncasecmp((const char *)buf, "mining.ping", 0xBu) )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                snprintf((char *)tmp42, 0x800u, "Pool %d ping", pool->pool_no);
                applog(6, tmp42, 0);
              }
              ret = send_pong(pool, val);
            }
          }
        }
        else
        {
          ss = json_dumps(err_val, 3u);
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "JSON-RPC method decode failed: %s", (const char *)ss);
            applog(6, tmp42, 0);
          }
          free(ss);
        }
      }
      json_decref(val);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
      applog(6, tmp42, 0);
    }
  }
  return ret;
}
// 3F15C: conditional instruction was optimized away because %err_val.4!=0
// 3F178: conditional instruction was optimized away because %err_val.4!=0

//----- (0003F5F0) --------------------------------------------------------
bool __cdecl subscribe_extranonce(pool *pool)
{
  int v1; // r2
  size_t v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-2918h] BYREF
  json_error_t err; // [sp+814h] [bp-2118h] BYREF
  unsigned __int8 s[8192]; // [sp+910h] [bp-201Ch] BYREF
  json_t_0 *err_val; // [sp+2910h] [bp-1Ch]
  json_t_0 *res_val; // [sp+2914h] [bp-18h]
  unsigned __int8 *sret; // [sp+2918h] [bp-14h]
  unsigned __int8 *ss; // [sp+291Ch] [bp-10h]
  bool ret; // [sp+2923h] [bp-9h]
  json_t_0 *val; // [sp+2924h] [bp-8h]

  val = 0;
  sret = 0;
  ret = 0;
  v1 = swork_id++;
  sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v1);
  v2 = strlen((const char *)s);
  if ( stratum_send(pool, s, v2) )
  {
    while ( 1 )
    {
      if ( !socket_full(pool, 2) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Timed out waiting for response extranonce.subscribe");
          applog(7, tmp42, 0);
        }
        ret = 1;
        goto out;
      }
      sret = recv_line(pool);
      if ( !sret )
        return ret;
      if ( !parse_method(pool, sret) )
        break;
      free(sret);
    }
    val = json_loads(sret, 0, &err);
    free(sret);
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    if ( res_val && res_val->type != JSON_FALSE && (!err_val || err_val->type == JSON_NULL) )
    {
      ret = 1;
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum extranonce subscribe for pool %d", pool->pool_no);
        applog(6, tmp42, 0);
      }
      goto out;
    }
    if ( err_val )
    {
      ss = _json_array_string(err_val, 1u);
      if ( !ss )
        ss = (unsigned __int8 *)json_string_value(err_val);
      if ( ss && !strcmp((const char *)ss, "Method 'subscribe' not found for service 'mining.extranonce'") )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        ret = 1;
out:
        json_decref(val);
        return ret;
      }
      if ( ss && !strcmp((const char *)ss, "Unrecognized request provided") )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        ret = 1;
        goto out;
      }
      ss = json_dumps(err_val, 3u);
    }
    else
    {
      ss = (unsigned __int8 *)strdup("(unknown reason)");
    }
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d JSON extranonce subscribe failed: %s", pool->pool_no, (const char *)ss);
      applog(6, tmp42, 0);
    }
    free(ss);
    goto out;
  }
  return ret;
}
// 3F854: conditional instruction was optimized away because %res_val.4!=0
// 3F87C: conditional instruction was optimized away because %err_val.4!=0

//----- (0003FBA4) --------------------------------------------------------
bool __cdecl auth_stratum(pool *pool)
{
  int v1; // r2
  size_t v2; // r0
  int v4; // r2
  size_t v5; // r0
  int v6; // r4
  uint32_t v7; // r0
  size_t v8; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-2920h] BYREF
  json_error_t err; // [sp+814h] [bp-2120h] BYREF
  unsigned __int8 s[8192]; // [sp+910h] [bp-2024h] BYREF
  json_t_0 *err_val; // [sp+2910h] [bp-24h]
  json_t_0 *res_val; // [sp+2914h] [bp-20h]
  unsigned __int8 *sret; // [sp+2918h] [bp-1Ch]
  json_t_0 *val; // [sp+291Ch] [bp-18h]
  unsigned __int8 *ss; // [sp+2920h] [bp-14h]
  bool ret; // [sp+2927h] [bp-Dh]

  val = 0;
  sret = 0;
  ret = 0;
  v1 = swork_id++;
  sprintf(
    (char *)s,
    "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}",
    v1,
    (const char *)pool->rpc_user,
    (const char *)pool->rpc_pass);
  v2 = strlen((const char *)s);
  if ( !stratum_send(pool, s, v2) )
    return ret;
  while ( 1 )
  {
    sret = recv_line(pool);
    if ( !sret )
      return ret;
    if ( !parse_method(pool, sret) )
      break;
    free(sret);
  }
  val = json_loads(sret, 0, &err);
  free(sret);
  res_val = json_object_get(val, "result");
  err_val = json_object_get(val, "error");
  if ( res_val && res_val->type != JSON_FALSE && (!err_val || err_val->type == JSON_NULL) )
  {
    ret = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Stratum authorisation success for pool %d", pool->pool_no);
      applog(6, tmp42, 0);
    }
    pool->probed = 1;
    successful_connect = 1;
    if ( opt_suggest_diff )
    {
      v4 = swork_id++;
      sprintf(
        (char *)s,
        "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}",
        v4,
        opt_suggest_diff);
      v5 = strlen((const char *)s);
      stratum_send(pool, s, v5);
    }
    if ( opt_bitmain_ab )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "LOW POWER MODE!");
        applog(5, tmp42, 0);
      }
      v6 = swork_id++;
      v7 = swab32_1(0xC000u);
      sprintf(
        (char *)s,
        "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%08x\""
        ",\"version-rolling.min-bit-count\":%d}]}",
        v6,
        v7,
        2);
      v8 = strlen((const char *)s);
      stratum_send(pool, s, v8);
      pool->version_num = 1;
    }
  }
  else
  {
    if ( err_val )
      ss = json_dumps(err_val, 3u);
    else
      ss = (unsigned __int8 *)strdup("(unknown reason)");
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "pool %d JSON stratum auth failed: %s", pool->pool_no, (const char *)ss);
      applog(6, tmp42, 0);
    }
    free(ss);
    suspend_stratum(pool);
  }
  json_decref(val);
  return ret;
}
// 3FD50: conditional instruction was optimized away because %res_val.4!=0
// 3FD78: conditional instruction was optimized away because %err_val.4!=0

//----- (0004010C) --------------------------------------------------------
int __cdecl recv_byte(int sockd)
{
  unsigned __int8 c[5]; // [sp+Fh] [bp-5h] BYREF

  if ( recv(sockd, c, 1u, 0) == -1 )
    return -1;
  else
    return c[0];
}
// 4010C: using guessed type unsigned __int8 c[5];

//----- (00040154) --------------------------------------------------------
bool __cdecl http_negotiate(pool *pool, int sockd, bool http0)
{
  size_t v3; // r0
  unsigned __int8 v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-C0Ch] BYREF
  unsigned __int8 buf[1024]; // [sp+820h] [bp-40Ch] BYREF
  int len; // [sp+C20h] [bp-Ch]
  int i; // [sp+C24h] [bp-8h]

  if ( http0 )
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.0\r\n\r\n",
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port);
  else
    snprintf(
      (char *)buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n",
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port,
      (const char *)pool->sockaddr_url,
      (const char *)pool->stratum_port);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Sending proxy %s:%s - %s",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port,
      (const char *)buf);
    applog(7, tmp42, 0);
  }
  v3 = strlen((const char *)buf);
  send(sockd, buf, v3, 0);
  len = recv(sockd, buf, 0xCu, 0);
  if ( len > 0 )
  {
    buf[len] = 0;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Received from proxy %s:%s - %s",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port,
        (const char *)buf);
      applog(7, tmp42, 0);
    }
    if ( !strcmp((const char *)buf, "HTTP/1.1 200") || !strcmp((const char *)buf, "HTTP/1.0 200") )
    {
      for ( i = 0; i <= 3; ++i )
      {
        v5 = recv_byte(sockd);
        buf[i] = v5;
        if ( buf[i] == 255 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Couldn't read HTTP byte from proxy %s:%s",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(4, tmp42, 0);
          }
          return 0;
        }
      }
      do
      {
        if ( !strncmp((const char *)buf, "\r\n\r\n", 4u) )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Success negotiating with %s:%s HTTP proxy",
              (const char *)pool->sockaddr_proxy_url,
              (const char *)pool->sockaddr_proxy_port);
            applog(7, tmp42, 0);
          }
          return 1;
        }
        for ( i = 0; i <= 2; ++i )
          buf[i] = buf[i + 1];
        buf[3] = recv_byte(sockd);
      }
      while ( buf[3] != 255 );
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Couldn't read HTTP byte from proxy %s:%s",
          (const char *)pool->sockaddr_proxy_url,
          (const char *)pool->sockaddr_proxy_port);
        applog(4, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "HTTP Error from proxy %s:%s - %s",
          (const char *)pool->sockaddr_proxy_url,
          (const char *)pool->sockaddr_proxy_port,
          (const char *)buf);
        applog(4, tmp42, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Couldn't read from proxy %s:%s after sending CONNECT",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
}

//----- (00040850) --------------------------------------------------------
bool __cdecl socks5_negotiate(pool *pool, int sockd)
{
  int v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-A14h] BYREF
  unsigned __int8 buf[515]; // [sp+810h] [bp-214h] BYREF
  unsigned __int8 atyp; // [sp+A13h] [bp-11h]
  unsigned __int16 port; // [sp+A14h] [bp-10h]
  unsigned __int8 uclen; // [sp+A17h] [bp-Dh]
  int len; // [sp+A18h] [bp-Ch]
  int i; // [sp+A1Ch] [bp-8h]

  buf[0] = 5;
  buf[1] = 1;
  buf[2] = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Attempting to negotiate with %s:%s SOCKS5 proxy",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port);
    applog(7, tmp42, 0);
  }
  send(sockd, buf, 3u, 0);
  if ( recv_byte(sockd) != 5 || (v2 = recv_byte(sockd), v2 != buf[2]) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS5 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  buf[0] = 5;
  buf[1] = 1;
  buf[2] = 0;
  buf[3] = 3;
  len = strlen((const char *)pool->sockaddr_url);
  if ( len > 255 )
    len = 255;
  uclen = len;
  buf[4] = len;
  cg_memcpy(&buf[5], pool->sockaddr_url, len, "util.c", _func___12199, 2821);
  port = atoi((const char *)pool->stratum_port);
  buf[len + 5] = HIBYTE(port);
  buf[len + 6] = port;
  send(sockd, buf, len + 7, 0);
  if ( recv_byte(sockd) != 5 || recv_byte(sockd) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS5 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  recv_byte(sockd);
  atyp = recv_byte(sockd);
  if ( atyp == 1 )
  {
    for ( i = 0; i <= 3; ++i )
      recv_byte(sockd);
LABEL_37:
    for ( i = 0; i <= 1; ++i )
      recv_byte(sockd);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Success negotiating with %s:%s SOCKS5 proxy",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(7, tmp42, 0);
    }
    return 1;
  }
  if ( atyp == 3 )
  {
    len = recv_byte(sockd);
    for ( i = 0; i < len; ++i )
      recv_byte(sockd);
    goto LABEL_37;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Bad response from %s:%s SOCKS5 server",
      (const char *)pool->sockaddr_proxy_url,
      (const char *)pool->sockaddr_proxy_port);
    applog(4, tmp42, 0);
  }
  return 0;
}

//----- (00040D98) --------------------------------------------------------
bool __cdecl socks4_negotiate(pool *pool, int sockd, bool socks4a)
{
  uint32_t v3; // r0
  int v5; // r3
  addrinfo servinfobase; // [sp+1Ch] [bp-A40h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+3Ch] [bp-A20h] BYREF
  addrinfo *servinfo; // [sp+83Ch] [bp-220h] BYREF
  unsigned __int8 buf[515]; // [sp+840h] [bp-21Ch] BYREF
  sockaddr_in *saddr_in; // [sp+A44h] [bp-18h]
  unsigned __int16 port; // [sp+A4Ah] [bp-12h]
  int len; // [sp+A4Ch] [bp-10h]
  int i; // [sp+A50h] [bp-Ch]
  in_addr_t inp; // [sp+A54h] [bp-8h]

  buf[0] = 4;
  buf[1] = 1;
  port = atoi((const char *)pool->stratum_port);
  buf[2] = HIBYTE(port);
  buf[3] = port;
  strcpy((char *)&buf[8], "CGMINER");
  v3 = inet_addr((const char *)pool->sockaddr_url);
  inp = ntohl(v3);
  if ( inp == -1 )
  {
    servinfo = &servinfobase;
    memset(tmp42, 0, 0x20u);
    *(_DWORD *)&tmp42[4] = 2;
    if ( !getaddrinfo((const char *)pool->sockaddr_url, 0, (const struct addrinfo *)tmp42, &servinfo) )
    {
      saddr_in = (sockaddr_in *)servinfo->ai_addr;
      inp = ntohl(saddr_in->sin_addr.s_addr);
      socks4a = 0;
      freeaddrinfo(servinfo);
    }
  }
  else
  {
    socks4a = 0;
  }
  if ( !socks4a )
  {
    if ( inp == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Invalid IP address specified for socks4 proxy: %s",
          (const char *)pool->sockaddr_url);
        applog(4, tmp42, 0);
      }
      return 0;
    }
    buf[4] = HIBYTE(inp);
    buf[5] = BYTE2(inp);
    buf[6] = BYTE1(inp);
    buf[7] = inp;
    send(sockd, buf, 0x10u, 0);
  }
  else
  {
    buf[4] = 0;
    buf[5] = 0;
    buf[6] = 0;
    buf[7] = 1;
    len = strlen((const char *)pool->sockaddr_url);
    if ( len > 255 )
      len = 255;
    cg_memcpy(&buf[16], pool->sockaddr_url, len, "util.c", _func___12227, 2923);
    len += 16;
    v5 = len++;
    buf[v5] = 0;
    send(sockd, buf, len, 0);
  }
  if ( !recv_byte(sockd) && recv_byte(sockd) == 90 )
  {
    for ( i = 0; i <= 5; ++i )
      recv_byte(sockd);
    return 1;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Bad response from %s:%s SOCKS4 server",
        (const char *)pool->sockaddr_proxy_url,
        (const char *)pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
    }
    return 0;
  }
}

//----- (00041190) --------------------------------------------------------
void __cdecl noblock_socket(int fd)
{
  int flags; // [sp+Ch] [bp-8h]

  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags | 0x800);
}

//----- (000411D8) --------------------------------------------------------
void __cdecl block_socket(int fd)
{
  int flags; // [sp+Ch] [bp-8h]

  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags & 0xFFFFF7FF);
}

//----- (00041220) --------------------------------------------------------
bool sock_connecting()
{
  return *_errno_location() == 115;
}

//----- (0004124C) --------------------------------------------------------
bool __cdecl setup_stratum_socket(pool *pool)
{
  bool v1; // r3
  int v2; // r3
  int v3; // r3
  fd_set rw; // [sp+14h] [bp-8D8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+94h] [bp-858h] BYREF
  int err; // [sp+894h] [bp-58h] BYREF
  socklen_t len; // [sp+898h] [bp-54h] BYREF
  timeval tv_timeout; // [sp+89Ch] [bp-50h] BYREF
  addrinfo hints; // [sp+8A4h] [bp-48h] BYREF
  addrinfo *servinfo; // [sp+8C4h] [bp-28h] BYREF
  int n; // [sp+8C8h] [bp-24h]
  int selret; // [sp+8CCh] [bp-20h]
  fd_set *__arr; // [sp+8D0h] [bp-1Ch]
  unsigned int __i; // [sp+8D4h] [bp-18h]
  int sockd; // [sp+8D8h] [bp-14h]
  unsigned __int8 *sockaddr_port; // [sp+8DCh] [bp-10h]
  unsigned __int8 *sockaddr_url; // [sp+8E0h] [bp-Ch]
  addrinfo *p; // [sp+8E4h] [bp-8h]

  mutex_lock_0(&pool->stratum_lock, "util.c", _func___12252, 2970);
  pool->stratum_active = 0;
  if ( pool->sock )
    close(pool->sock);
  pool->sock = 0;
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___12252, 2975);
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  if ( !pool->rpc_proxy && opt_socks_proxy )
  {
    pool->rpc_proxy = opt_socks_proxy;
    extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
    pool->rpc_proxytype = 3;
  }
  if ( pool->rpc_proxy )
  {
    sockaddr_url = pool->sockaddr_proxy_url;
    sockaddr_port = pool->sockaddr_proxy_port;
  }
  else
  {
    sockaddr_url = pool->sockaddr_url;
    sockaddr_port = pool->stratum_port;
  }
  if ( getaddrinfo((const char *)sockaddr_url, (const char *)sockaddr_port, &hints, &servinfo) )
  {
    if ( !pool->probed )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to resolve (?wrong URL) %s:%s",
          (const char *)sockaddr_url,
          (const char *)sockaddr_port);
        applog(4, tmp42, 0);
      }
      pool->probed = 1;
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to getaddrinfo for %s:%s",
        (const char *)sockaddr_url,
        (const char *)sockaddr_port);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    for ( p = servinfo; p; p = p->ai_next )
    {
      sockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
      if ( sockd == -1 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Failed socket");
          applog(7, tmp42, 0);
        }
      }
      else
      {
        noblock_socket(sockd);
        if ( connect(sockd, p->ai_addr, p->ai_addrlen) != -1 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy((char *)tmp42, "Succeeded immediate connect");
            applog(4, tmp42, 0);
          }
LABEL_63:
          block_socket(sockd);
          break;
        }
        tv_timeout.tv_sec = 1;
        tv_timeout.tv_usec = 0;
        if ( !sock_connecting() )
        {
          close(sockd);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Failed sock connect");
            applog(7, tmp42, 0);
          }
        }
        else
        {
          do
          {
            __arr = &rw;
            for ( __i = 0; __i <= 0x1F; ++__i )
              __arr->fds_bits[__i] = 0;
            LOBYTE(v2) = sockd & 0x1F;
            if ( sockd <= 0 )
              v2 = -(-sockd & 0x1F);
            rw.fds_bits[sockd / 32] |= 1 << v2;
            selret = select(sockd + 1, 0, &rw, 0, &tv_timeout);
            if ( selret > 0 )
            {
              LOBYTE(v3) = sockd & 0x1F;
              if ( sockd <= 0 )
                v3 = -(-sockd & 0x1F);
              if ( ((1 << v3) & rw.fds_bits[sockd / 32]) != 0 )
              {
                len = 4;
                n = getsockopt(sockd, 1, 4, &err, &len);
                if ( !n && !err )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    strcpy((char *)tmp42, "Succeeded delayed connect");
                    applog(7, tmp42, 0);
                  }
                  goto LABEL_63;
                }
              }
            }
          }
          while ( selret < 0 && interrupted() );
          close(sockd);
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Select timeout/failed connect");
            applog(7, tmp42, 0);
          }
        }
      }
    }
    if ( p )
    {
      freeaddrinfo(servinfo);
      if ( pool->rpc_proxy )
      {
        switch ( pool->rpc_proxytype )
        {
          case 0:
            if ( http_negotiate(pool, sockd, 0) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 1:
            if ( http_negotiate(pool, sockd, 1) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 2:
            if ( socks4_negotiate(pool, sockd, 0) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 3:
          case 5:
            if ( socks5_negotiate(pool, sockd) )
              goto LABEL_89;
            v1 = 0;
            break;
          case 4:
            if ( socks4_negotiate(pool, sockd, 1) )
              goto LABEL_89;
            v1 = 0;
            break;
          default:
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Unsupported proxy type for %s:%s",
                (const char *)pool->sockaddr_proxy_url,
                (const char *)pool->sockaddr_proxy_port);
              applog(4, tmp42, 0);
            }
            v1 = 0;
            break;
        }
      }
      else
      {
LABEL_89:
        if ( !pool->sockbuf )
        {
          pool->sockbuf = (unsigned __int8 *)cgcalloc(0x2000, 1u, "util.c", _func___12252, 3112);
          pool->sockbuf_size = 0x2000;
        }
        pool->sock = sockd;
        keep_sockalive(sockd);
        return 1;
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Failed to connect to stratum on %s:%s",
          (const char *)sockaddr_url,
          (const char *)sockaddr_port);
        applog(6, tmp42, 0);
      }
      freeaddrinfo(servinfo);
      return 0;
    }
  }
  return v1;
}
// 41B34: control flows out of bounds to 41B38

//----- (00041D58) --------------------------------------------------------
unsigned __int8 *__cdecl get_sessionid(json_t_0 *val)
{
  bool v1; // r3
  unsigned __int8 *notify; // [sp+8h] [bp-1Ch]
  json_t_0 *arr; // [sp+Ch] [bp-18h]
  int arrsize; // [sp+10h] [bp-14h]
  const json_t_0 *arr_val; // [sp+14h] [bp-10h]
  int i; // [sp+18h] [bp-Ch]
  unsigned __int8 *ret; // [sp+1Ch] [bp-8h]

  ret = 0;
  arr_val = json_array_get(val, 0);
  if ( arr_val && arr_val->type == JSON_ARRAY )
  {
    arrsize = json_array_size(arr_val);
    for ( i = 0; i < arrsize; ++i )
    {
      arr = json_array_get(arr_val, i);
      v1 = !arr || arr->type != JSON_ARRAY;
      if ( arr == 0 || v1 )
        break;
      notify = _json_array_string(arr, 0);
      if ( notify && !strncasecmp((const char *)notify, "mining.notify", 0xDu) )
        return json_array_string(arr, 1u);
    }
  }
  return ret;
}

//----- (00041EB8) --------------------------------------------------------
void __cdecl suspend_stratum(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-804h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Closing socket for stratum pool %d", pool->pool_no);
    applog(6, tmp42, 0);
  }
  mutex_lock_0(&pool->stratum_lock, "util.c", _func___12304, 3155);
  _suspend_stratum(pool);
  mutex_unlock_0(&pool->stratum_lock, "util.c", _func___12304, 3157);
}

//----- (00041F94) --------------------------------------------------------
bool __cdecl initiate_stratum(pool *pool)
{
  int v1; // r2
  int v2; // r2
  size_t v3; // r0
  json_t_0 *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-2924h] BYREF
  json_error_t err; // [sp+810h] [bp-2124h] BYREF
  unsigned __int8 s[8192]; // [sp+90Ch] [bp-2028h] BYREF
  int n2size; // [sp+290Ch] [bp-28h]
  unsigned __int8 *nonce1; // [sp+2910h] [bp-24h]
  unsigned __int8 *sessionid; // [sp+2914h] [bp-20h]
  json_t_0 *err_val; // [sp+2918h] [bp-1Ch]
  json_t_0 *res_val; // [sp+291Ch] [bp-18h]
  unsigned __int8 *sret; // [sp+2920h] [bp-14h]
  unsigned __int8 *ss; // [sp+2924h] [bp-10h]
  json_t_0 *val; // [sp+2928h] [bp-Ch]
  bool sockd; // [sp+292Ch] [bp-8h]
  bool noresume; // [sp+292Dh] [bp-7h]
  bool recvd; // [sp+292Eh] [bp-6h]
  bool ret; // [sp+292Fh] [bp-5h]

  ret = 0;
  recvd = 0;
  noresume = 0;
  sockd = 0;
  sret = 0;
  for ( val = 0; ; json_decref(val) )
  {
    cgsleep_us(100LL);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "initiate_stratum");
      applog(5, tmp42, 0);
    }
    if ( !setup_stratum_socket(pool) )
    {
      sockd = 0;
    }
    else
    {
      sockd = 1;
      if ( recvd )
      {
        clear_sock(pool);
        v1 = swork_id++;
        sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v1);
      }
      else
      {
        v2 = swork_id;
        if ( pool->sessionid )
        {
          ++swork_id;
          sprintf(
            (char *)s,
            "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/2.0.0\", \"%s\"]}",
            v2,
            (const char *)pool->sessionid);
        }
        else
        {
          ++swork_id;
          sprintf((char *)s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/2.0.0\"]}", v2);
        }
      }
      v3 = strlen((const char *)s);
      if ( _stratum_send(pool, s, v3) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Failed to send s in initiate_stratum");
          applog(7, tmp42, 0);
        }
      }
      else if ( !socket_full(pool, 60) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Timed out waiting for response in initiate_stratum");
          applog(7, tmp42, 0);
        }
      }
      else
      {
        sret = recv_line(pool);
        if ( sret )
        {
          recvd = 1;
          val = json_loads(sret, 0, &err);
          free(sret);
          if ( val )
          {
            res_val = json_object_get(val, "result");
            err_val = json_object_get(val, "error");
            if ( res_val && res_val->type != JSON_NULL && (!err_val || err_val->type == JSON_NULL) )
            {
              sessionid = get_sessionid(res_val);
              if ( !sessionid && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "Failed to get sessionid in initiate_stratum");
                applog(7, tmp42, 0);
              }
              nonce1 = json_array_string(res_val, 1u);
              if ( !valid_hex(nonce1, "util.c", _func___12353, 3325) )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 5 )
                {
                  strcpy((char *)tmp42, "Failed to get valid nonce1 in initiate_stratum");
                  applog(6, tmp42, 0);
                }
                free(sessionid);
              }
              else
              {
                v4 = json_array_get(res_val, 2u);
                n2size = json_integer_value(v4);
                if ( n2size > 1 && n2size <= 16 )
                {
                  if ( sessionid
                    && pool->sessionid
                    && !strcmp((const char *)sessionid, (const char *)pool->sessionid)
                    && (use_syslog || opt_log_output || opt_log_level > 4) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "Pool %d successfully negotiated resume with the same session ID",
                      pool->pool_no);
                    applog(5, tmp42, 0);
                  }
                  cg_wlock_0(&pool->data_lock, "util.c", _func___12353, 3346);
                  pool->sessionid = sessionid;
                  pool->nonce1 = nonce1;
                  pool->n1_len = strlen((const char *)nonce1) >> 1;
                  free(pool->nonce1bin);
                  pool->nonce1bin = (unsigned __int8 *)cgcalloc(pool->n1_len, 1u, "util.c", _func___12353, 3353);
                  hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
                  pool->n2size = n2size;
                  cg_wunlock_0(&pool->data_lock, "util.c", _func___12353, 3356);
                  if ( sessionid && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "Pool %d stratum session id: %s",
                      pool->pool_no,
                      (const char *)pool->sessionid);
                    applog(7, tmp42, 0);
                  }
                  ret = 1;
                }
                else
                {
                  if ( use_syslog || opt_log_output || opt_log_level > 5 )
                  {
                    strcpy((char *)tmp42, "Failed to get valid n2size in initiate_stratum");
                    applog(6, tmp42, 0);
                  }
                  free(sessionid);
                  free(nonce1);
                }
              }
            }
            else
            {
              if ( err_val )
                ss = json_dumps(err_val, 3u);
              else
                ss = (unsigned __int8 *)strdup("(unknown reason)");
              if ( use_syslog || opt_log_output || opt_log_level > 5 )
              {
                snprintf((char *)tmp42, 0x800u, "JSON-RPC decode failed: %s", (const char *)ss);
                applog(6, tmp42, 0);
              }
              free(ss);
            }
          }
          else if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
            applog(6, tmp42, 0);
          }
        }
      }
    }
    if ( ret )
    {
      if ( !pool->stratum_url )
        pool->stratum_url = pool->sockaddr_url;
      pool->stratum_active = 1;
      pool->next_diff = 0.0;
      pool->sdiff = 1.0;
      if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
          pool->pool_no,
          (const char *)pool->nonce1,
          pool->n2size);
        applog(7, tmp42, 0);
      }
      goto LABEL_100;
    }
    if ( !recvd || noresume )
      break;
    cg_wlock_0(&pool->data_lock, "util.c", _func___12353, 3384);
    free(pool->sessionid);
    free(pool->nonce1);
    pool->nonce1 = 0;
    pool->sessionid = pool->nonce1;
    cg_wunlock_0(&pool->data_lock, "util.c", _func___12353, 3388);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Failed to resume stratum, trying afresh");
      applog(7, tmp42, 0);
    }
    noresume = 1;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Initiate stratum failed");
    applog(7, tmp42, 0);
  }
  if ( sockd )
    suspend_stratum(pool);
LABEL_100:
  json_decref(val);
  return ret;
}
// 424A8: conditional instruction was optimized away because %res_val.4!=0
// 424D0: conditional instruction was optimized away because %err_val.4!=0

//----- (00042EF0) --------------------------------------------------------
bool __cdecl restart_stratum(pool *pool)
{
  bool ret; // [sp+Fh] [bp-5h]

  ret = 0;
  if ( pool->stratum_active )
    suspend_stratum(pool);
  if ( initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool) )
    ret = 1;
  if ( !ret )
    pool_died(pool);
  else
    stratum_resumed(pool);
  return ret;
}

//----- (00042FDC) --------------------------------------------------------
void __cdecl dev_error(cgpu_info *dev, dev_reason reason)
{
  dev->device_last_not_well = time(0);
  dev->device_not_well_reason = reason;
  switch ( reason )
  {
    case REASON_THREAD_FAIL_INIT:
      ++dev->thread_fail_init_count;
      break;
    case REASON_THREAD_ZERO_HASH:
      ++dev->thread_zero_hash_count;
      break;
    case REASON_THREAD_FAIL_QUEUE:
      ++dev->thread_fail_queue_count;
      break;
    case REASON_DEV_SICK_IDLE_60:
      ++dev->dev_sick_idle_60_count;
      break;
    case REASON_DEV_DEAD_IDLE_600:
      ++dev->dev_dead_idle_600_count;
      break;
    case REASON_DEV_NOSTART:
      ++dev->dev_nostart_count;
      break;
    case REASON_DEV_OVER_HEAT:
      ++dev->dev_over_heat_count;
      break;
    case REASON_DEV_THERMAL_CUTOFF:
      ++dev->dev_thermal_cutoff_count;
      break;
    case REASON_DEV_COMMS_ERROR:
      ++dev->dev_comms_error_count;
      break;
    case REASON_DEV_THROTTLE:
      ++dev->dev_throttle_count;
      break;
    default:
      return;
  }
}
// 4301C: control flows out of bounds to 43020

//----- (00043144) --------------------------------------------------------
void __cdecl RenameThread(const unsigned __int8 *name)
{
  unsigned __int8 buf[16]; // [sp+10h] [bp-14h] BYREF

  snprintf((char *)buf, 0x10u, "cg@%s", (const char *)name);
  prctl(15, buf, 0, 0, 0);
}

//----- (00043194) --------------------------------------------------------
void __cdecl cgsem_init(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-808h] BYREF
  int ret; // [sp+824h] [bp-8h]

  ret = sem_init(cgsem, 0, 0);
  if ( ret )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_init ret=%d errno=%d in %s %s():%d",
      ret,
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0004324C) --------------------------------------------------------
void __cdecl cgsem_post(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( sem_post(cgsem) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d",
      *v4,
      cgsem,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000432F0) --------------------------------------------------------
void __cdecl cgsem_wait(cgsem_t *cgsem, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  while ( sem_wait(cgsem) )
  {
    if ( !interrupted() )
    {
      v4 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d",
        *v4,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (000433A8) --------------------------------------------------------
int __cdecl cgsem_mswait(
        cgsem_t *cgsem,
        int ms,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v6; // r0
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-820h] BYREF
  timeval tv_now; // [sp+824h] [bp-20h] BYREF
  timespec ts_now; // [sp+82Ch] [bp-18h] BYREF
  timespec abs_timeout; // [sp+834h] [bp-10h] BYREF

  cgtime(&tv_now);
  timeval_to_spec(&ts_now, &tv_now);
  ms_to_timespec(&abs_timeout, ms);
  while ( 1 )
  {
    timeraddspec(&abs_timeout, &ts_now);
    if ( !sem_timedwait(cgsem, &abs_timeout) )
      break;
    if ( sock_timeout() )
      return 110;
    if ( !interrupted() )
    {
      v6 = _errno_location();
      snprintf(
        (char *)tmp42,
        0x800u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        *v6,
        cgsem,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  return 0;
}

//----- (000434DC) --------------------------------------------------------
void __cdecl cgsem_destroy(cgsem_t *cgsem)
{
  sem_destroy(cgsem);
}

//----- (00043500) --------------------------------------------------------
void *__cdecl completion_thread(void *arg)
{
  pthread_setcanceltype(1, 0);
  (*((void (__fastcall **)(_DWORD))arg + 4))(*((_DWORD *)arg + 5));
  cgsem_post((cgsem_t *)arg, "util.c", _func___12457, 3736);
  return 0;
}

//----- (00043568) --------------------------------------------------------
bool __cdecl cg_completion_timeout(void *fn, void *fnarg, int timeout)
{
  pthread_t pthread; // [sp+1Ch] [bp-10h] BYREF
  cg_completion *cgc; // [sp+20h] [bp-Ch]
  bool ret; // [sp+27h] [bp-5h]

  ret = 0;
  cgc = (cg_completion *)cgmalloc(0x18u, "util.c", _func___12466, 3747);
  cgsem_init(&cgc->cgsem, "util.c", _func___12466, 3748);
  cgc->fn = (void (*)(void *))fn;
  cgc->fnarg = fnarg;
  pthread_create(&pthread, 0, (void *(*)(void *))completion_thread, cgc);
  ret = cgsem_mswait(&cgc->cgsem, timeout, "util.c", _func___12466, 3754) != 0;
  if ( !ret )
  {
    pthread_join(pthread, 0);
    free(cgc);
  }
  else
  {
    pthread_cancel(pthread);
  }
  return !ret;
}

//----- (00043698) --------------------------------------------------------
void __cdecl cg_memcpy(
        void *dest,
        const void *src,
        unsigned int n,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( n && n <= 0x80000000 )
  {
    if ( dest )
    {
      if ( src )
      {
        memcpy(dest, src, n);
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d",
          n,
          (const char *)file,
          (const char *)func,
          line);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d",
        n,
        (const char *)file,
        (const char *)func,
        line);
      applog(3, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "ERR: Asked to memcpy %u bytes from %s %s():%d",
      n,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (000438B8) --------------------------------------------------------
void __cdecl rev(unsigned __int8 *s, size_t l)
{
  unsigned __int8 t; // [sp+Fh] [bp-Dh]
  size_t j; // [sp+10h] [bp-Ch]
  size_t i; // [sp+14h] [bp-8h]

  i = 0;
  for ( j = l - 1; i < j; --j )
  {
    t = s[i];
    s[i] = s[j];
    s[j] = t;
    ++i;
  }
}

//----- (00043964) --------------------------------------------------------
unsigned int get_iic()
{
  return axi_fpga_addr[12];
}

//----- (000439A4) --------------------------------------------------------
unsigned __int8 __cdecl set_iic(unsigned int data)
{
  int v2; // r3
  FILE *pFile; // [sp+10h] [bp-14h]
  signed int ret; // [sp+18h] [bp-Ch]
  int wait_counter; // [sp+1Ch] [bp-8h]

  wait_counter = 0;
  axi_fpga_addr[12] = data & 0x3FFFFFFF;
  while ( 1 )
  {
    ret = get_iic();
    if ( ret < 0 )
      return ret;
    v2 = wait_counter++;
    if ( v2 > 100 )
      break;
    usleep(0x1388u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: could not get iic, ret = 0x%08x\n", "zynq.c", 41, (const char *)_FUNCTION___10983, ret);
    fclose(pFile);
  }
  return 0;
}

//----- (00043AD0) --------------------------------------------------------
uint8_t __cdecl znyq_set_iic(
        unsigned __int8 dev_addr,
        unsigned __int8 which_iic,
        bool read,
        bool reg_addr_valid,
        unsigned __int8 reg_addr,
        unsigned __int8 data)
{
  uint32_t value; // [sp+Ch] [bp-8h]

  value = 0;
  if ( read )
    value = 0x2000000;
  if ( reg_addr_valid )
    value |= (reg_addr << 8) | 0x1000000;
  return set_iic(value | (which_iic << 26) & 0xC000000 | (dev_addr >> 3 << 20) & 0xF00000 | (dev_addr << 16) & 0x70000 | data);
}

//----- (00043BD4) --------------------------------------------------------
void __cdecl read_fpga_id(unsigned __int8 *pFpgaID)
{
  sprintf((char *)pFpgaID, "%08x%08x", axi_fpga_addr[61], axi_fpga_addr[60]);
}

//----- (00043C40) --------------------------------------------------------
unsigned int get_nonce2_and_job_id_store_address()
{
  return axi_fpga_addr[68];
}

//----- (00043C80) --------------------------------------------------------
void __cdecl set_nonce2_and_job_id_store_address(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  get_nonce2_and_job_id_store_address();
  axi_fpga_addr[68] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set NONCE2_AND_JOBID_STORE_ADDRESS is 0x%x\n",
        "zynq.c",
        132,
        (const char *)_FUNCTION___11021,
        value);
    fclose(pFile);
  }
  get_nonce2_and_job_id_store_address();
}

//----- (00043D4C) --------------------------------------------------------
int get_job_start_address()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[70];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: JOB_START_ADDRESS is 0x%x\n", "zynq.c", 141, (const char *)_FUNCTION___11027, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00043E18) --------------------------------------------------------
void __cdecl set_job_start_address(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[70] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set JOB_START_ADDRESS is 0x%x\n", "zynq.c", 148, (const char *)_FUNCTION___11032, value);
    fclose(pFile);
  }
  get_job_start_address();
}

//----- (00043EE0) --------------------------------------------------------
int get_QN_write_data_command()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[32];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: QN_WRITE_DATA_COMMAND is 0x%x\n", "zynq.c", 168, (const char *)_FUNCTION___11044, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00043FAC) --------------------------------------------------------
void __cdecl set_QN_write_data_command(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[32] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set QN_WRITE_DATA_COMMAND is 0x%x\n",
        "zynq.c",
        175,
        (const char *)_FUNCTION___11049,
        value);
    fclose(pFile);
  }
  get_QN_write_data_command();
}

//----- (00044074) --------------------------------------------------------
void __cdecl set_reset_hashboard(int chainIndex, int resetBit)
{
  FILE *pFile; // [sp+14h] [bp-10h]
  unsigned int resetFlag; // [sp+18h] [bp-Ch]
  unsigned int ret; // [sp+1Ch] [bp-8h]
  int reta; // [sp+1Ch] [bp-8h]

  ret = axi_fpga_addr[13];
  resetFlag = 1 << chainIndex;
  if ( resetBit <= 0 )
    reta = ~resetFlag & ret;
  else
    reta = ret | resetFlag;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set_reset_hashboard = 0x%08x\n", "zynq.c", 191, (const char *)_FUNCTION___11057, reta);
    fclose(pFile);
  }
  axi_fpga_addr[13] = reta;
}

//----- (00044194) --------------------------------------------------------
int get_fan_control()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[33];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: FAN_CONTROL is 0x%x\n", "zynq.c", 231, (const char *)_FUNCTION___11078, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00044260) --------------------------------------------------------
void __cdecl set_fan_control(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[33] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set FAN_CONTROL is 0x%x\n", "zynq.c", 238, (const char *)_FUNCTION___11083, value);
    fclose(pFile);
  }
  get_fan_control();
}

//----- (00044328) --------------------------------------------------------
int get_hash_on_plug()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[2];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: HASH_ON_PLUG is 0x%x\n", "zynq.c", 247, (const char *)_FUNCTION___11089, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000443F4) --------------------------------------------------------
unsigned int get_crc_count()
{
  return (unsigned __int16)axi_fpga_addr[62];
}

//----- (0004442C) --------------------------------------------------------
int get_hardware_version()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = *axi_fpga_addr;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: HARDWARE_VERSION is 0x%x\n", "zynq.c", 263, (const char *)_FUNCTION___11098, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000444F4) --------------------------------------------------------
void __cdecl set_Hardware_version(unsigned int value)
{
  *axi_fpga_addr = value;
}

//----- (00044528) --------------------------------------------------------
int __cdecl get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed)
{
  FILE *pFile; // [sp+18h] [bp-Ch]
  unsigned int ret; // [sp+1Ch] [bp-8h]

  ret = axi_fpga_addr[1];
  *fan_speed = (unsigned __int8)ret;
  *fan_id = BYTE1(ret) & 7;
  if ( *fan_speed && log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: fan_id is 0x%x, fan_speed is 0x%x\n",
        "zynq.c",
        280,
        (const char *)_FUNCTION___11108,
        *fan_id,
        *fan_speed);
    fclose(pFile);
  }
  return ret;
}

//----- (0004464C) --------------------------------------------------------
int get_time_out_control()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[34];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TIME_OUT_CONTROL is 0x%x\n", "zynq.c", 321, (const char *)_FUNCTION___11130, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00044718) --------------------------------------------------------
void __cdecl set_time_out_control(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[34] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TIME_OUT_CONTROL is 0x%x\n", "zynq.c", 328, (const char *)_FUNCTION___11135, value);
    fclose(pFile);
  }
  get_time_out_control();
}

//----- (000447E0) --------------------------------------------------------
int get_bt8d_control()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[15];
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: get_bt8d_control is 0x%x\n", "zynq.c", 336, (const char *)_FUNCTION___11141, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000448AC) --------------------------------------------------------
void __cdecl set_bt8d_control(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[15] = value;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set_bt8d_control is 0x%x\n", "zynq.c", 343, (const char *)_FUNCTION___11146, value);
    fclose(pFile);
  }
  get_bt8d_control();
}

//----- (00044974) --------------------------------------------------------
int __cdecl get_BC_command_buffer(unsigned int *buf)
{
  FILE *pFile; // [sp+18h] [bp-Ch]
  unsigned int ret; // [sp+1Ch] [bp-8h]

  *buf = axi_fpga_addr[49];
  buf[1] = axi_fpga_addr[50];
  ret = axi_fpga_addr[51];
  buf[2] = ret;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: BC_COMMAND_BUFFER buf[0]: 0x%x, buf[1]: 0x%x, buf[2]: 0x%x\n",
        "zynq.c",
        356,
        (const char *)_FUNCTION___11152,
        *buf,
        buf[1],
        buf[2]);
    fclose(pFile);
  }
  return ret;
}

//----- (00044AC4) --------------------------------------------------------
void __cdecl set_BC_command_buffer(unsigned int *value)
{
  unsigned int buf[4]; // [sp+1Ch] [bp-18h] BYREF
  FILE *pFile; // [sp+2Ch] [bp-8h]

  memset(buf, 0, sizeof(buf));
  axi_fpga_addr[49] = *value;
  axi_fpga_addr[50] = value[1];
  axi_fpga_addr[51] = value[2];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set BC_COMMAND_BUFFER value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x\n",
        "zynq.c",
        366,
        (const char *)_FUNCTION___11158,
        *value,
        value[1],
        value[2]);
    fclose(pFile);
  }
  get_BC_command_buffer(buf);
}

//----- (00044C0C) --------------------------------------------------------
int get_BC_write_command()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[48];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: BC_WRITE_COMMAND is 0x%x\n", "zynq.c", 374, (const char *)_FUNCTION___11164, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00044CD8) --------------------------------------------------------
unsigned int get_nonce_number_in_fifo()
{
  return axi_fpga_addr[6];
}

//----- (00044D18) --------------------------------------------------------
int __cdecl get_return_nonce(unsigned int *buf)
{
  int v1; // r2

  *buf = axi_fpga_addr[4];
  v1 = axi_fpga_addr[5];
  buf[1] = v1;
  return v1;
}

//----- (00044D90) --------------------------------------------------------
void __cdecl set_BC_write_command(unsigned int value)
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  int wait_count; // [sp+14h] [bp-8h]

  wait_count = 0;
  axi_fpga_addr[48] = value;
  if ( (value & 0x80000000) == 0 )
  {
    get_BC_write_command();
  }
  else
  {
    while ( get_BC_write_command() < 0 )
    {
      cgsleep_ms(1);
      if ( ++wait_count > 3000 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Error: set_BC_write_command wait buffer ready timeout!\n",
              "zynq.c",
              434,
              (const char *)_FUNCTION___11190_0);
          fclose(pFile);
        }
        return;
      }
    }
  }
}

//----- (00044EAC) --------------------------------------------------------
int get_ticket_mask()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[35];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TICKET_MASK_FPGA is 0x%x\n", "zynq.c", 450, (const char *)_FUNCTION___11199, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00044F78) --------------------------------------------------------
void __cdecl set_ticket_mask(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[35] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TICKET_MASK_FPGA is 0x%x\n", "zynq.c", 457, (const char *)_FUNCTION___11204, value);
    fclose(pFile);
  }
  get_ticket_mask();
}

//----- (00045040) --------------------------------------------------------
int get_job_id()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[73];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: JOB_ID is 0x%x\n", "zynq.c", 465, (const char *)_FUNCTION___11210, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (0004510C) --------------------------------------------------------
void __cdecl set_job_id(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[73] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set JOB_ID is 0x%x\n", "zynq.c", 472, (const char *)_FUNCTION___11215, value);
    fclose(pFile);
  }
  get_job_id();
}

//----- (000451D4) --------------------------------------------------------
void __cdecl set_job_length(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[71] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set JOB_LENGTH is 0x%x\n", "zynq.c", 487, (const char *)_FUNCTION___11226, value);
    fclose(pFile);
  }
  get_job_id();
}

//----- (0004529C) --------------------------------------------------------
int get_block_header_version()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[76];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: BLOCK_HEADER_VERSION is 0x%x\n", "zynq.c", 496, (const char *)_FUNCTION___11232, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045368) --------------------------------------------------------
int get_block_header_version_1()
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  int ret; // [sp+14h] [bp-8h]

  ret = axi_fpga_addr[89];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: BLOCK_HEADER_VERSION 1 is 0x%x\n",
        "zynq.c",
        503,
        (const char *)_FUNCTION___11238,
        (const char *)_FUNCTION___11238,
        ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045440) --------------------------------------------------------
int get_block_header_version_2()
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  int ret; // [sp+14h] [bp-8h]

  ret = axi_fpga_addr[90];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: BLOCK_HEADER_VERSION 2 is 0x%x\n",
        "zynq.c",
        510,
        (const char *)_FUNCTION___11244,
        (const char *)_FUNCTION___11244,
        ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045518) --------------------------------------------------------
int get_block_header_version_3()
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  int ret; // [sp+14h] [bp-8h]

  ret = axi_fpga_addr[91];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: BLOCK_HEADER_VERSION 3 is 0x%x\n",
        "zynq.c",
        517,
        (const char *)_FUNCTION___11250,
        (const char *)_FUNCTION___11250,
        ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000455F0) --------------------------------------------------------
void __cdecl set_block_header_version(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[76] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set BLOCK_HEADER_VERSION is 0x%x\n",
        "zynq.c",
        524,
        (const char *)_FUNCTION___11255,
        value);
    fclose(pFile);
  }
  get_block_header_version();
}

//----- (000456B8) --------------------------------------------------------
void __cdecl set_block_header_version_1(uint32_t value)
{
  FILE *pFile; // [sp+1Ch] [bp-8h]

  axi_fpga_addr[89] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: set BLOCK_HEADER_VERSION is 0x%x\n",
        "zynq.c",
        530,
        (const char *)_FUNCTION___11260,
        (const char *)_FUNCTION___11260,
        value);
    fclose(pFile);
  }
  get_block_header_version_1();
}

//----- (0004578C) --------------------------------------------------------
void __cdecl set_block_header_version_2(uint32_t value)
{
  FILE *pFile; // [sp+1Ch] [bp-8h]

  axi_fpga_addr[90] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: set BLOCK_HEADER_VERSION is 0x%x\n",
        "zynq.c",
        536,
        (const char *)_FUNCTION___11265,
        (const char *)_FUNCTION___11265,
        value);
    fclose(pFile);
  }
  get_block_header_version_2();
}

//----- (00045860) --------------------------------------------------------
void __cdecl set_block_header_version_3(uint32_t value)
{
  FILE *pFile; // [sp+1Ch] [bp-8h]

  axi_fpga_addr[91] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: %s: set BLOCK_HEADER_VERSION is 0x%x\n",
        "zynq.c",
        542,
        (const char *)_FUNCTION___11270,
        (const char *)_FUNCTION___11270,
        value);
    fclose(pFile);
  }
  get_block_header_version_3();
}

//----- (00045934) --------------------------------------------------------
int get_time_stamp()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[77];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TIME_STAMP is 0x%x\n", "zynq.c", 550, (const char *)_FUNCTION___11275, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045A00) --------------------------------------------------------
void __cdecl set_time_stamp(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[77] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TIME_STAMP is 0x%x\n", "zynq.c", 557, (const char *)_FUNCTION___11280, value);
    fclose(pFile);
  }
  get_time_stamp();
}

//----- (00045AC8) --------------------------------------------------------
int get_target_bits()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[78];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: TARGET_BITS is 0x%x\n", "zynq.c", 565, (const char *)_FUNCTION___11286, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045B94) --------------------------------------------------------
void __cdecl set_target_bits(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[78] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set TARGET_BITS is 0x%x\n", "zynq.c", 572, (const char *)_FUNCTION___11291, value);
    fclose(pFile);
  }
  get_target_bits();
}

//----- (00045C5C) --------------------------------------------------------
void __cdecl set_pre_header_hash(unsigned int *value)
{
  FILE *pFile; // [sp+34h] [bp-10h]

  axi_fpga_addr[80] = *value;
  axi_fpga_addr[81] = value[1];
  axi_fpga_addr[82] = value[2];
  axi_fpga_addr[83] = value[3];
  axi_fpga_addr[84] = value[4];
  axi_fpga_addr[85] = value[5];
  axi_fpga_addr[86] = value[6];
  axi_fpga_addr[87] = value[7];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set PRE_HEADER_HASH value[0]: 0x%x, value[1]: 0x%x, value[2]: 0x%x, value[3]: 0x%x, value[4]: 0x%x, va"
        "lue[5]: 0x%x, value[6]: 0x%x, value[7]: 0x%x\n",
        "zynq.c",
        602,
        (const char *)_FUNCTION___11302,
        *value,
        value[1],
        value[2],
        value[3],
        value[4],
        value[5],
        value[6],
        value[7]);
    fclose(pFile);
  }
}

//----- (00045E5C) --------------------------------------------------------
int get_coinbase_length_and_nonce2_length()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[65];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
        "zynq.c",
        610,
        (const char *)_FUNCTION___11308,
        ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00045F28) --------------------------------------------------------
void __cdecl set_coinbase_length_and_nonce2_length(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[65] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set COINBASE_AND_NONCE2_LENGTH is 0x%x\n",
        "zynq.c",
        617,
        (const char *)_FUNCTION___11313,
        value);
    fclose(pFile);
  }
  get_coinbase_length_and_nonce2_length();
}

//----- (00045FF0) --------------------------------------------------------
int __cdecl get_work_nonce2(unsigned int *buf)
{
  FILE *pFile; // [sp+18h] [bp-Ch]

  *buf = axi_fpga_addr[66];
  buf[1] = axi_fpga_addr[67];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: WORK_NONCE_2 buf[0]: 0x%x, buf[1]: 0x%x\n",
        "zynq.c",
        626,
        (const char *)_FUNCTION___11319,
        *buf,
        buf[1]);
    fclose(pFile);
  }
  return -1;
}

//----- (000460F0) --------------------------------------------------------
void __cdecl set_work_nonce2(unsigned int *value)
{
  unsigned int buf[2]; // [sp+1Ch] [bp-10h] BYREF
  FILE *pFile; // [sp+24h] [bp-8h]

  buf[0] = 0;
  buf[1] = 0;
  axi_fpga_addr[66] = *value;
  axi_fpga_addr[67] = value[1];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set WORK_NONCE_2 value[0]: 0x%x, value[1]: 0x%x\n",
        "zynq.c",
        635,
        (const char *)_FUNCTION___11325,
        *value,
        value[1]);
    fclose(pFile);
  }
  get_work_nonce2(buf);
}

//----- (00046204) --------------------------------------------------------
int get_merkle_bin_number()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = (unsigned __int16)axi_fpga_addr[69];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: MERKLE_BIN_NUMBER is 0x%x\n", "zynq.c", 644, (const char *)_FUNCTION___11331, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (000462DC) --------------------------------------------------------
void __cdecl set_merkle_bin_number(unsigned int value)
{
  unsigned __int16 valuea; // [sp+Ch] [bp-10h]
  FILE *pFile; // [sp+14h] [bp-8h]

  valuea = value;
  axi_fpga_addr[69] = (unsigned __int16)value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set MERKLE_BIN_NUMBER is 0x%x\n",
        "zynq.c",
        651,
        (const char *)_FUNCTION___11336,
        valuea);
    fclose(pFile);
  }
  get_merkle_bin_number();
}

//----- (000463AC) --------------------------------------------------------
int get_nonce_fifo_interrupt()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[7];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: NONCE_FIFO_INTERRUPT is 0x%x\n", "zynq.c", 659, (const char *)_FUNCTION___11342, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (00046478) --------------------------------------------------------
void __cdecl set_nonce_fifo_interrupt(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[7] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set NONCE_FIFO_INTERRUPT is 0x%x\n",
        "zynq.c",
        666,
        (const char *)_FUNCTION___11347,
        value);
    fclose(pFile);
  }
  get_nonce_fifo_interrupt();
}

//----- (00046540) --------------------------------------------------------
int get_dhash_acc_control()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[64];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 674, (const char *)_FUNCTION___11353, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (0004660C) --------------------------------------------------------
void __cdecl set_dhash_acc_control(unsigned int value)
{
  FILE *pFile_0; // [sp+14h] [bp-18h]
  FILE *pFile; // [sp+18h] [bp-14h]
  int a; // [sp+1Ch] [bp-10h]

  a = 10;
  axi_fpga_addr[64] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 682, (const char *)_FUNCTION___11359, value);
    fclose(pFile);
  }
  while ( a > 0 && (value | 0x80) != (get_dhash_acc_control() | 0x80) )
  {
    axi_fpga_addr[64] = value;
    --a;
    cgsleep_ms(2);
  }
  if ( !a && log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: set DHASH_ACC_CONTROL failed!", "zynq.c", 692, (const char *)_FUNCTION___11359);
    fclose(pFile_0);
  }
}

//----- (000467CC) --------------------------------------------------------
void __cdecl set_TW_write_command_vil(unsigned int *value)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  pthread_mutex_lock(&fpga_mutex);
  for ( i = 0; i <= 0xC; ++i )
  {
    if ( i )
      axi_fpga_addr[17] = value[i];
    else
      axi_fpga_addr[16] = *value;
  }
  pthread_mutex_unlock(&fpga_mutex);
}

//----- (00046890) --------------------------------------------------------
unsigned int get_buffer_space()
{
  return axi_fpga_addr[3];
}

//----- (000468D0) --------------------------------------------------------
int get_hash_counting_number()
{
  FILE *pFile; // [sp+8h] [bp-Ch]
  int ret; // [sp+Ch] [bp-8h]

  ret = axi_fpga_addr[36];
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 732, (const char *)_FUNCTION___11387_0, ret);
    fclose(pFile);
  }
  return ret;
}

//----- (0004699C) --------------------------------------------------------
void __cdecl set_hash_counting_number(unsigned int value)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  axi_fpga_addr[36] = value;
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: set DHASH_ACC_CONTROL is 0x%x\n", "zynq.c", 739, (const char *)_FUNCTION___11392, value);
    fclose(pFile);
  }
  get_hash_counting_number();
}

//----- (00046A64) --------------------------------------------------------
void reset_fpga_and_hash_board()
{
  set_QN_write_data_command(0x8080800F);
  sleep(2u);
}

//----- (00046A88) --------------------------------------------------------
unsigned int __cdecl _bswap_32_0(unsigned int __bsx)
{
  return bswap32(__bsx);
}

//----- (00046AB0) --------------------------------------------------------
__uint32_t __cdecl _uint32_identity_0(__uint32_t __x)
{
  return __x;
}

//----- (00046AD4) --------------------------------------------------------
__uint64_t __cdecl _uint64_identity_0(__uint64_t __x)
{
  return __x;
}

//----- (00046AFC) --------------------------------------------------------
void __cdecl json_decref_0(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (00046B60) --------------------------------------------------------
void __cdecl _list_del_0(list_head *prev, list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

//----- (00046B9C) --------------------------------------------------------
void __cdecl list_del_0(list_head *entry)
{
  _list_del_0(entry->prev, entry->next);
  entry->next = 0;
  entry->prev = 0;
}

//----- (00046BEC) --------------------------------------------------------
uint32_t __cdecl swab32_2(uint32_t v)
{
  return bswap32(v);
}

//----- (00046C14) --------------------------------------------------------
void __cdecl swap256(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = *((_DWORD *)src_p + 7);
  *((_DWORD *)dest_p + 1) = *((_DWORD *)src_p + 6);
  *((_DWORD *)dest_p + 2) = *((_DWORD *)src_p + 5);
  *((_DWORD *)dest_p + 3) = *((_DWORD *)src_p + 4);
  *((_DWORD *)dest_p + 4) = *((_DWORD *)src_p + 3);
  *((_DWORD *)dest_p + 5) = *((_DWORD *)src_p + 2);
  *((_DWORD *)dest_p + 6) = *((_DWORD *)src_p + 1);
  *((_DWORD *)dest_p + 7) = *(_DWORD *)src_p;
}

//----- (00046CE4) --------------------------------------------------------
void __cdecl swab256_0(void *dest_p, const void *src_p)
{
  *(_DWORD *)dest_p = swab32_2(*((_DWORD *)src_p + 7));
  *((_DWORD *)dest_p + 1) = swab32_2(*((_DWORD *)src_p + 6));
  *((_DWORD *)dest_p + 2) = swab32_2(*((_DWORD *)src_p + 5));
  *((_DWORD *)dest_p + 3) = swab32_2(*((_DWORD *)src_p + 4));
  *((_DWORD *)dest_p + 4) = swab32_2(*((_DWORD *)src_p + 3));
  *((_DWORD *)dest_p + 5) = swab32_2(*((_DWORD *)src_p + 2));
  *((_DWORD *)dest_p + 6) = swab32_2(*((_DWORD *)src_p + 1));
  *((_DWORD *)dest_p + 7) = swab32_2(*(_DWORD *)src_p);
}

//----- (00046E2C) --------------------------------------------------------
void __cdecl flip32_1(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp-10h]

  for ( i = 0; i <= 7; ++i )
    *((_DWORD *)dest_p + i) = swab32_2(*((_DWORD *)src_p + i));
}

//----- (00046EB4) --------------------------------------------------------
void __cdecl flip64(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp-10h]

  for ( i = 0; i <= 15; ++i )
    *((_DWORD *)dest_p + i) = swab32_2(*((_DWORD *)src_p + i));
}

//----- (00046F3C) --------------------------------------------------------
void __cdecl flip80(void *dest_p, const void *src_p)
{
  int i; // [sp+14h] [bp-10h]

  for ( i = 0; i <= 19; ++i )
    *((_DWORD *)dest_p + i) = swab32_2(*((_DWORD *)src_p + i));
}

//----- (00046FC4) --------------------------------------------------------
void __cdecl endian_flip32(void *dest_p, const void *src_p)
{
  ;
}

//----- (00046FE8) --------------------------------------------------------
void __cdecl mutex_lock_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047084) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047120) --------------------------------------------------------
void __cdecl mutex_unlock_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_1(lock, file, func, line);
  selective_yield();
}

//----- (0004716C) --------------------------------------------------------
void __cdecl wr_lock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047208) --------------------------------------------------------
int __cdecl wr_trylock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_rwlock_trywrlock(lock);
}

//----- (00047240) --------------------------------------------------------
void __cdecl rd_lock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000472DC) --------------------------------------------------------
void __cdecl rw_unlock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00047378) --------------------------------------------------------
void __cdecl wr_unlock_noyield_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
}

//----- (000473B4) --------------------------------------------------------
void __cdecl rd_unlock_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
  selective_yield();
}

//----- (00047400) --------------------------------------------------------
void __cdecl wr_unlock(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_1(lock, file, func, line);
  selective_yield();
}

//----- (0004744C) --------------------------------------------------------
void __cdecl mutex_init_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000474EC) --------------------------------------------------------
void __cdecl rwlock_init_0(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0004758C) --------------------------------------------------------
void __cdecl cglock_init_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init_0(&lock->mutex, file, func, line);
  rwlock_init_0(&lock->rwlock, file, func, line);
}

//----- (000475E0) --------------------------------------------------------
void __cdecl cg_rlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_1(&lock->mutex, file, func, line);
  rd_lock_0(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_1(&lock->mutex, file, func, line);
}

//----- (00047648) --------------------------------------------------------
void __cdecl cg_wlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_1(&lock->mutex, file, func, line);
  wr_lock_1(&lock->rwlock, file, func, line);
}

//----- (0004769C) --------------------------------------------------------
void __cdecl cg_dwlock(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_1(&lock->rwlock, file, func, line);
  rd_lock_0(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_1(&lock->mutex, file, func, line);
}

//----- (00047708) --------------------------------------------------------
void __cdecl cg_runlock_0(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock_0(&lock->rwlock, file, func, line);
}

//----- (00047748) --------------------------------------------------------
void __cdecl cg_wunlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_1(&lock->rwlock, file, func, line);
  mutex_unlock_1(&lock->mutex, file, func, line);
}

//----- (0004779C) --------------------------------------------------------
bool __cdecl time_before(tm *tm1, tm *tm2)
{
  return tm1->tm_hour < tm2->tm_hour || tm1->tm_hour == tm2->tm_hour && tm1->tm_min < tm2->tm_min;
}

//----- (0004781C) --------------------------------------------------------
bool should_run()
{
  time_t tmp_time; // [sp+0h] [bp-14h] BYREF
  timeval tv; // [sp+4h] [bp-10h] BYREF
  tm *tm; // [sp+Ch] [bp-8h]

  if ( !schedstart.enable && !schedstop.enable )
    return 1;
  cgtime(&tv);
  tmp_time = tv.tv_sec;
  tm = localtime(&tmp_time);
  if ( !schedstart.enable )
    return time_before(tm, &schedstop.tm);
  if ( !schedstop.enable )
  {
    if ( time_before(tm, &schedstart.tm) )
    {
      return 0;
    }
    else
    {
      schedstart.enable = 0;
      return 1;
    }
  }
  else if ( time_before(&schedstart.tm, &schedstop.tm) )
  {
    return time_before(tm, &schedstop.tm) && !time_before(tm, &schedstart.tm);
  }
  else
  {
    return !time_before(tm, &schedstart.tm) || time_before(tm, &schedstop.tm);
  }
}

//----- (000479DC) --------------------------------------------------------
void __cdecl get_datestamp(unsigned __int8 *f, size_t fsiz, timeval *tv)
{
  time_t tmp_time; // [sp+2Ch] [bp-18h] BYREF
  tm *tm; // [sp+30h] [bp-14h]
  int ms; // [sp+34h] [bp-10h]

  tmp_time = tv->tv_sec;
  ms = tv->tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf(
    (char *)f,
    fsiz,
    "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
    tm->tm_year + 1900,
    tm->tm_mon + 1,
    tm->tm_mday,
    tm->tm_hour,
    tm->tm_min,
    tm->tm_sec,
    ms);
}

//----- (00047AAC) --------------------------------------------------------
void __cdecl get_timestamp(unsigned __int8 *f, size_t fsiz, timeval *tv)
{
  time_t tmp_time; // [sp+24h] [bp-10h] BYREF
  tm *tm; // [sp+28h] [bp-Ch]
  int ms; // [sp+2Ch] [bp-8h]

  tmp_time = tv->tv_sec;
  ms = tv->tv_usec / 1000;
  tm = localtime(&tmp_time);
  snprintf((char *)f, fsiz, "[%02d:%02d:%02d.%03d]", tm->tm_hour, tm->tm_min, tm->tm_sec, ms);
}

//----- (00047B50) --------------------------------------------------------
void __noreturn applog_and_exit(const unsigned __int8 *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, fmt);
  vsnprintf((char *)exit_buf, 0x200u, (const char *)fmt, varg_r1);
  applog(3, exit_buf, 1);
  exit(1);
}

//----- (00047B9C) --------------------------------------------------------
thr_info *__cdecl _get_thread(int thr_id)
{
  return mining_thr[thr_id];
}

//----- (00047BD8) --------------------------------------------------------
thr_info *__cdecl get_thread(int thr_id)
{
  thr_info *thr; // [sp+Ch] [bp-8h]

  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___14216, 587);
  thr = _get_thread(thr_id);
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___14216, 589);
  return thr;
}

//----- (00047C44) --------------------------------------------------------
cgpu_info *__cdecl get_thr_cgpu(int thr_id)
{
  return get_thread(thr_id)->cgpu;
}

//----- (00047C74) --------------------------------------------------------
cgpu_info *__cdecl get_devices(int id)
{
  cgpu_info *cgpu; // [sp+Ch] [bp-8h]

  rd_lock_0(&devices_lock, "cgminer.c", _func___14225, 607);
  cgpu = devices[id];
  rd_unlock_0(&devices_lock, "cgminer.c", _func___14225, 609);
  return cgpu;
}

//----- (00047CF4) --------------------------------------------------------
void __cdecl sharelog(const unsigned __int8 *disposition, const work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+2Ch] [bp-C28h] BYREF
  unsigned __int8 s[1024]; // [sp+82Ch] [bp-428h] BYREF
  size_t ret; // [sp+C2Ch] [bp-28h]
  int rv; // [sp+C30h] [bp-24h]
  unsigned __int8 *data; // [sp+C34h] [bp-20h]
  unsigned __int8 *hash; // [sp+C38h] [bp-1Ch]
  unsigned __int8 *target; // [sp+C3Ch] [bp-18h]
  unsigned int t; // [sp+C40h] [bp-14h]
  pool *pool; // [sp+C44h] [bp-10h]
  cgpu_info *cgpu; // [sp+C48h] [bp-Ch]
  int thr_id; // [sp+C4Ch] [bp-8h]

  if ( !sharelog_file )
    return;
  thr_id = work->thr_id;
  cgpu = get_thr_cgpu(thr_id);
  pool = work->pool;
  t = work->tv_work_found.tv_sec;
  target = bin2hex(work->target, 0x20u);
  hash = bin2hex(work->hash, 0x20u);
  data = bin2hex(work->data, 0x80u);
  rv = snprintf(
         (char *)s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         t,
         (const char *)disposition,
         (const char *)target,
         (const char *)pool->rpc_url,
         (const char *)cgpu->drv->name,
         cgpu->device_id,
         thr_id,
         (const char *)hash,
         (const char *)data);
  free(target);
  free(hash);
  free(data);
  if ( rv >= 1024 )
  {
    s[1023] = 0;
LABEL_9:
    mutex_lock_1(&sharelog_lock, "cgminer.c", _func___14241, 655);
    ret = fwrite(s, rv, 1u, sharelog_file);
    fflush(sharelog_file);
    mutex_unlock_1(&sharelog_lock, "cgminer.c", _func___14241, 658);
    if ( ret != 1 && (use_syslog || opt_log_output || opt_log_level > 2) )
    {
      strcpy((char *)tmp42, "sharelog fwrite error");
      applog(3, tmp42, 0);
    }
    return;
  }
  if ( rv >= 0 )
    goto LABEL_9;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    strcpy((char *)tmp42, "sharelog printf error");
    applog(3, tmp42, 0);
  }
}

//----- (00047FFC) --------------------------------------------------------
void adjust_quota_gcd()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-818h] BYREF
  unsigned int quota; // [sp+804h] [bp-18h]
  pool *pool; // [sp+808h] [bp-14h]
  int i; // [sp+80Ch] [bp-10h]
  unsigned int lowest_quota; // [sp+810h] [bp-Ch]
  unsigned int gcd; // [sp+814h] [bp-8h]

  lowest_quota = -1;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    quota = pool->quota;
    if ( quota && quota < lowest_quota )
      lowest_quota = quota;
  }
  if ( lowest_quota == -1 )
  {
    gcd = 1;
  }
  else
  {
    gcd = lowest_quota;
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      quota = pool->quota;
      if ( quota )
      {
        while ( quota % gcd )
          --gcd;
      }
    }
  }
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->quota_used *= global_quota_gcd;
    pool->quota_used /= gcd;
    pool->quota_gcd = pool->quota / gcd;
  }
  global_quota_gcd = gcd;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Global quota greatest common denominator set to %lu", gcd);
    applog(7, tmp42, 0);
  }
}

//----- (000482C0) --------------------------------------------------------
pool *add_pool()
{
  int v0; // r2
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-808h] BYREF
  pool *pool; // [sp+80Ch] [bp-8h]

  pool = (pool *)cgcalloc(1848, 1u, "cgminer.c", _func___14273, 740);
  pool->support_ab = 0;
  if ( !pool )
  {
    strcpy((char *)tmp42, "Failed to malloc pool in add_pool");
    applog(3, tmp42, 1);
    quit(1);
  }
  pool->prio = total_pools;
  pool->pool_no = pool->prio;
  pools = (pool **)cgrealloc(pools, 4 * (total_pools + 2), "cgminer.c", _func___14273, 752);
  v0 = total_pools++;
  pools[v0] = pool;
  mutex_init_0(&pool->pool_lock, "cgminer.c", _func___14273, 755);
  if ( pthread_cond_init(&pool->cr_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init in add_pool");
    applog(3, tmp42, 1);
    quit(1);
  }
  cglock_init_0(&pool->data_lock, "cgminer.c", _func___14273, 762);
  mutex_init_0(&pool->stratum_lock, "cgminer.c", _func___14273, 763);
  cglock_init_0(&pool->gbt_lock, "cgminer.c", _func___14273, 764);
  pool->curlring.next = &pool->curlring;
  pool->curlring.prev = &pool->curlring;
  pool->tv_idle.tv_sec = -1;
  pool->rpc_req = getwork_req;
  pool->rpc_proxy = 0;
  pool->quota = 1;
  adjust_quota_gcd();
  pool->extranonce_subscribe = 0;
  return pool;
}

//----- (00048580) --------------------------------------------------------
bool __cdecl pool_tset(pool *pool, bool *var)
{
  bool ret; // [sp+Fh] [bp-5h]

  mutex_lock_1(&pool->pool_lock, "cgminer.c", _func___14281, 786);
  ret = *var;
  *var = 1;
  mutex_unlock_1(&pool->pool_lock, "cgminer.c", _func___14281, 791);
  return ret;
}

//----- (000485FC) --------------------------------------------------------
bool __cdecl pool_tclear(pool *pool, bool *var)
{
  bool ret; // [sp+Fh] [bp-5h]

  mutex_lock_1(&pool->pool_lock, "cgminer.c", _func___14287, 801);
  ret = *var;
  *var = 0;
  mutex_unlock_1(&pool->pool_lock, "cgminer.c", _func___14287, 806);
  return ret;
}

//----- (00048678) --------------------------------------------------------
pool *current_pool()
{
  pool *pool; // [sp+4h] [bp-8h]

  cg_rlock_0(&control_lock, "cgminer.c", _func___14292, 816);
  pool = currentpool;
  cg_runlock_0(&control_lock, "cgminer.c", _func___14292, 820);
  return pool;
}

//----- (000486E4) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_range(const unsigned __int8 *arg, int *i, int min, int max)
{
  unsigned __int8 *err; // [sp+14h] [bp-8h]

  err = opt_set_intval(arg, i);
  if ( err )
    return err;
  if ( min <= *i && max >= *i )
    return 0;
  return "Value out of range";
}

//----- (00048768) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_9999(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 9999);
}

//----- (000487A0) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_65535(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 0xFFFF);
}

//----- (000487D8) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 10);
}

//----- (00048810) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_100(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 100);
}

//----- (00048848) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 255);
}

//----- (00048880) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_255(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 255);
}

//----- (000488B8) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_7680(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 7680);
}

//----- (000488F0) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_200(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 200);
}

//----- (00048928) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_32_to_63(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 32, 63);
}

//----- (00048960) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_22_to_75(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 75);
}

//----- (00048998) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_42_to_85(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 85);
}

//----- (000489D0) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_22_to_55(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 22, 55);
}

//----- (00048A08) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_42_to_65(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 42, 62);
}

//----- (00048A40) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_1_to_10(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 1, 10);
}

//----- (00048A78) --------------------------------------------------------
unsigned __int8 *__cdecl set_int_0_to_4(const unsigned __int8 *arg, int *i)
{
  return set_int_range(arg, i, 0, 4);
}

//----- (00048AB0) --------------------------------------------------------
unsigned __int8 *__cdecl set_balance(pool_strategy *strategy)
{
  *strategy = POOL_BALANCE;
  return 0;
}

//----- (00048AE0) --------------------------------------------------------
unsigned __int8 *__cdecl set_loadbalance(pool_strategy *strategy)
{
  *strategy = POOL_LOADBALANCE;
  return 0;
}

//----- (00048B10) --------------------------------------------------------
unsigned __int8 *__cdecl set_rotate(const unsigned __int8 *arg, unsigned __int8 *i)
{
  pool_strategy_0 = POOL_ROTATE;
  return set_int_range(arg, &opt_rotate_period, 0, 9999);
}

//----- (00048B5C) --------------------------------------------------------
unsigned __int8 *__cdecl set_rr(pool_strategy *strategy)
{
  *strategy = POOL_ROUNDROBIN;
  return 0;
}

//----- (00048B8C) --------------------------------------------------------
bool __cdecl detect_stratum(pool *pool, unsigned __int8 *url)
{
  if ( !extract_sockaddr(url, &pool->sockaddr_url, &pool->stratum_port) )
    return 0;
  if ( strncasecmp((const char *)url, "stratum+tcp://", 0xEu) )
    return 0;
  pool->rpc_url = (unsigned __int8 *)strdup((const char *)url);
  pool->has_stratum = 1;
  pool->stratum_url = pool->sockaddr_url;
  return 1;
}

//----- (00048C44) --------------------------------------------------------
pool *add_url()
{
  if ( ++total_urls > total_pools )
    add_pool();
  return *(&pools[total_urls] + 0x3FFFFFFF);
}

//----- (00048CBC) --------------------------------------------------------
unsigned __int8 *__cdecl setup_url(pool *pool, unsigned __int8 *arg)
{
  unsigned __int8 *arga; // [sp+0h] [bp-14h]
  unsigned __int8 *httpinput; // [sp+Ch] [bp-8h]

  arga = get_proxy(arg, pool);
  if ( !detect_stratum(pool, arga) )
  {
    opt_set_charp(arga, &pool->rpc_url);
    if ( strncmp((const char *)arga, "http://", 7u) )
    {
      if ( strncmp((const char *)arga, "https://", 8u) )
      {
        httpinput = (unsigned __int8 *)cgmalloc(0x100u, "cgminer.c", _func___14391, 1020);
        strcpy((char *)httpinput, "stratum+tcp://");
        strncat((char *)httpinput, (const char *)arga, 0xF2u);
        detect_stratum(pool, httpinput);
      }
    }
  }
  return pool->rpc_url;
}

//----- (00048DDC) --------------------------------------------------------
unsigned __int8 *__cdecl set_url(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-808h] BYREF
  pool *pool; // [sp+80Ch] [bp-8h]

  pool = add_url();
  setup_url(pool, arg);
  if ( strstr((const char *)pool->rpc_url, ".nicehash.com") || strstr((const char *)pool->rpc_url, "#xnsub") )
  {
    pool->extranonce_subscribe = 1;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d extranonce subscribing enabled.", pool->pool_no);
      applog(7, tmp42, 0);
    }
  }
  return 0;
}

//----- (00048EF4) --------------------------------------------------------
unsigned __int8 *__cdecl set_quota(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-81Ch] BYREF
  pool *pool; // [sp+810h] [bp-1Ch]
  unsigned __int8 *url; // [sp+814h] [bp-18h]
  int quota; // [sp+818h] [bp-14h]
  int qlen; // [sp+81Ch] [bp-10h]
  int len; // [sp+820h] [bp-Ch]
  unsigned __int8 *semicolon; // [sp+824h] [bp-8h]

  semicolon = (unsigned __int8 *)strchr((const char *)arg, 59);
  if ( !semicolon )
    return "No semicolon separated quota;URL pair found";
  len = strlen((const char *)arg);
  *semicolon = 0;
  qlen = strlen((const char *)arg);
  if ( !qlen )
    return "No parameter for quota found";
  len -= qlen + 1;
  if ( len <= 0 )
    return "No parameter for URL found";
  quota = atoi((const char *)arg);
  if ( quota < 0 )
    return "Invalid negative parameter for quota set";
  url = &arg[qlen + 1];
  pool = add_url();
  setup_url(pool, url);
  pool->quota = quota;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Setting pool %d to quota %d", pool->pool_no, pool->quota);
    applog(6, tmp42, 0);
  }
  adjust_quota_gcd();
  return 0;
}

//----- (00049098) --------------------------------------------------------
unsigned __int8 *__cdecl set_user(const unsigned __int8 *arg)
{
  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_users > total_pools )
    add_pool();
  opt_set_charp(arg, &(*(&pools[total_users] + 0x3FFFFFFF))->rpc_user);
  return 0;
}

//----- (00049158) --------------------------------------------------------
unsigned __int8 *__cdecl set_pass(const unsigned __int8 *arg)
{
  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_passes > total_pools )
    add_pool();
  opt_set_charp(arg, &(*(&pools[total_passes] + 0x3FFFFFFF))->rpc_pass);
  return 0;
}

//----- (00049218) --------------------------------------------------------
unsigned __int8 *__cdecl set_userpass(const unsigned __int8 *arg)
{
  char *updup; // [sp+8h] [bp-Ch]
  pool *pool; // [sp+Ch] [bp-8h]

  if ( total_users || total_passes )
    return "Use only user + pass or userpass, but not both";
  if ( ++total_userpasses > total_pools )
    add_pool();
  pool = *(&pools[total_userpasses] + 0x3FFFFFFF);
  updup = strdup((const char *)arg);
  opt_set_charp(arg, &pool->rpc_userpass);
  pool->rpc_user = (unsigned __int8 *)strtok(updup, ":");
  if ( !pool->rpc_user )
    return "Failed to find : delimited user info";
  pool->rpc_pass = (unsigned __int8 *)strtok(0, ":");
  if ( !pool->rpc_pass )
    pool->rpc_pass = (unsigned __int8 *)strdup((const char *)byte_A1BD4);
  return 0;
}
// A1BD4: using guessed type unsigned __int8 byte_A1BD4[4];

//----- (0004937C) --------------------------------------------------------
unsigned __int8 *__cdecl set_extranonce_subscribe(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-808h] BYREF
  pool *pool; // [sp+80Ch] [bp-8h]

  if ( ++total_extranonce > total_pools )
    add_pool();
  pool = *(&pools[total_extranonce] + 0x3FFFFFFF);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Enable extranonce subscribe on %d", pool->pool_no);
    applog(7, tmp42, 0);
  }
  opt_set_bool(&pool->extranonce_subscribe);
  return 0;
}

//----- (000494A8) --------------------------------------------------------
unsigned __int8 *__cdecl enable_debug(bool *flag)
{
  *flag = 1;
  opt_log_output = 1;
  return 0;
}

//----- (000494E8) --------------------------------------------------------
unsigned __int8 *__cdecl set_schedtime(const unsigned __int8 *arg, schedtime *st)
{
  if ( sscanf((const char *)arg, "%d:%d", &st->tm.tm_hour, &st->tm.tm_min) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( st->tm.tm_hour > 23 || st->tm.tm_min > 59 || st->tm.tm_hour < 0 || st->tm.tm_min < 0 )
    return "Invalid time set.";
  st->enable = 1;
  return 0;
}

//----- (0004959C) --------------------------------------------------------
unsigned __int8 *__cdecl set_sched_start(const unsigned __int8 *arg)
{
  return set_schedtime(arg, &schedstart);
}

//----- (000495CC) --------------------------------------------------------
unsigned __int8 *__cdecl set_sched_stop(const unsigned __int8 *arg)
{
  return set_schedtime(arg, &schedstop);
}

//----- (000495FC) --------------------------------------------------------
unsigned __int8 *__cdecl set_sharelog(unsigned __int8 *arg)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-80Ch] BYREF
  unsigned __int8 *r; // [sp+808h] [bp-Ch] BYREF
  int i; // [sp+80Ch] [bp-8h]

  r = byte_A1BD4;
  i = strtol((const char *)arg, (char **)&r, 10);
  if ( *r || i < 0 )
  {
    if ( !strcmp((const char *)arg, "-") )
    {
      sharelog_file = (FILE *)stdout;
      if ( !stdout && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        strcpy((char *)tmp42, "Standard output missing for share log");
        applog(3, tmp42, 0);
      }
    }
    else
    {
      sharelog_file = fopen((const char *)arg, "a");
      if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        snprintf((char *)tmp42, 0x800u, "Failed to open %s for share log", (const char *)arg);
        applog(3, tmp42, 0);
      }
    }
  }
  else
  {
    sharelog_file = fdopen(i, "a");
    if ( !sharelog_file && (use_syslog || opt_log_output || opt_log_level > 2) )
    {
      snprintf((char *)tmp42, 0x800u, "Failed to open fd %u for share log", i);
      applog(3, tmp42, 0);
    }
  }
  return 0;
}
// A1BD4: using guessed type unsigned __int8 byte_A1BD4[4];
// C4484: using guessed type int stdout;

//----- (000498A0) --------------------------------------------------------
void load_temp_cutoffs()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-814h] BYREF
  unsigned __int8 *nextptr; // [sp+800h] [bp-14h]
  int device; // [sp+804h] [bp-10h]
  int val; // [sp+808h] [bp-Ch]
  int i; // [sp+80Ch] [bp-8h]

  val = 0;
  device = 0;
  if ( temp_cutoff_str )
  {
    device = 0;
    for ( nextptr = (unsigned __int8 *)strtok((char *)temp_cutoff_str, ",");
          nextptr;
          nextptr = (unsigned __int8 *)strtok(0, ",") )
    {
      if ( device >= total_devices )
      {
        strcpy((char *)tmp42, "Too many values passed to set temp cutoff");
        applog(3, tmp42, 1);
        quit(1);
      }
      val = atoi((const char *)nextptr);
      if ( val < 0 || val > 200 )
      {
        strcpy((char *)tmp42, "Invalid value passed to set temp cutoff");
        applog(3, tmp42, 1);
        quit(1);
      }
      rd_lock_0(&devices_lock, "cgminer.c", _func___14463, 1314);
      devices[device]->cutofftemp = val;
      rd_unlock_0(&devices_lock, "cgminer.c", _func___14463, 1316);
      ++device;
    }
    if ( device <= 1 )
    {
      rd_lock_0(&devices_lock, "cgminer.c", _func___14463, 1337);
      for ( i = device; i < total_devices; ++i )
        devices[i]->cutofftemp = val;
      rd_unlock_0(&devices_lock, "cgminer.c", _func___14463, 1343);
    }
  }
  else
  {
    rd_lock_0(&devices_lock, "cgminer.c", _func___14463, 1321);
    for ( i = device; i < total_devices; ++i )
    {
      if ( !devices[i]->cutofftemp )
        devices[i]->cutofftemp = 95;
    }
    rd_unlock_0(&devices_lock, "cgminer.c", _func___14463, 1330);
  }
}

//----- (00049BD8) --------------------------------------------------------
unsigned __int8 *__cdecl set_logfile_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_path);
  return 0;
}

//----- (00049C08) --------------------------------------------------------
unsigned __int8 *__cdecl set_logfile_openflag(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logfile_openflag);
  return 0;
}

//----- (00049C38) --------------------------------------------------------
unsigned __int8 *__cdecl set_logwork_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_path);
  return 0;
}

//----- (00049C68) --------------------------------------------------------
unsigned __int8 *__cdecl set_logwork_asicnum(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_logwork_asicnum);
  return 0;
}

//----- (00049C98) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_125_to_500(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp-8h]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 125.0 && *i <= 500.0 )
    return 0;
  return "Value out of range";
}

//----- (00049D24) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_100_to_250(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp-8h]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 100.0 && *i <= 250.0 )
    return 0;
  return "Value out of range";
}

//----- (00049DB0) --------------------------------------------------------
unsigned __int8 *__cdecl set_float_0_to_500(const unsigned __int8 *arg, float *i)
{
  unsigned __int8 *err; // [sp+Ch] [bp-8h]

  err = opt_set_floatval(arg, i);
  if ( err )
    return err;
  if ( *i >= 100.0 && *i <= 250.0 )
    return 0;
  return "Value out of range";
}

//----- (00049E3C) --------------------------------------------------------
unsigned __int8 *__cdecl set_null(const unsigned __int8 *arg)
{
  return 0;
}

//----- (00049E60) --------------------------------------------------------
unsigned __int8 *__cdecl set_version_path(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &opt_version_path);
  return 0;
}

//----- (00049E90) --------------------------------------------------------
unsigned __int8 *__cdecl parse_config(json_t_0 *config, bool fileconf)
{
  size_t v2; // r0
  const unsigned __int8 *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-824h] BYREF
  json_t_0 *arr_val; // [sp+810h] [bp-24h]
  const unsigned __int8 *str; // [sp+814h] [bp-20h]
  unsigned __int8 *name; // [sp+818h] [bp-1Ch]
  json_t_0 *val; // [sp+81Ch] [bp-18h]
  size_t index; // [sp+820h] [bp-14h]
  unsigned __int8 *err; // [sp+824h] [bp-10h]
  unsigned __int8 *p; // [sp+828h] [bp-Ch]
  opt_table *opt; // [sp+82Ch] [bp-8h]

  if ( fileconf && !fileconf_load )
    fileconf_load = 1;
  for ( opt = opt_config_table; opt->type != OPT_END; ++opt )
  {
    if ( (opt->type & 8) != 0 )
      _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x795u, (const char *)_PRETTY_FUNCTION___14967);
    if ( opt->names )
    {
      name = (unsigned __int8 *)strdup((const char *)opt->names);
      for ( p = (unsigned __int8 *)strtok((char *)name, "|"); p; p = (unsigned __int8 *)strtok(0, "|") )
      {
        err = 0;
        if ( p[1] == 45 )
        {
          val = json_object_get(config, p + 2);
          if ( val )
          {
            if ( (opt->type & 6) != 0 && val->type == JSON_STRING )
            {
              str = json_string_value(val);
              err = opt->cb_arg(str, opt->u.tlen);
              if ( opt->type == OPT_PROCESSARG )
                opt_set_charp(str, (unsigned __int8 **)opt->u.carg);
            }
            else if ( (opt->type & 6) != 0 && val->type == JSON_ARRAY )
            {
              for ( index = 0; ; ++index )
              {
                v2 = json_array_size(val);
                if ( index >= v2 )
                  break;
                arr_val = json_array_get(val, index);
                if ( !arr_val )
                  break;
                if ( arr_val->type == JSON_STRING )
                {
                  str = json_string_value(arr_val);
                  err = opt->cb_arg(str, opt->u.tlen);
                  if ( opt->type == OPT_PROCESSARG )
                    opt_set_charp(str, (unsigned __int8 **)opt->u.carg);
                }
                else if ( arr_val->type == JSON_OBJECT )
                {
                  err = parse_config(arr_val, 0);
                }
                if ( err )
                  break;
              }
            }
            else
            {
              err = (opt->type & 1) != 0 && (val->type == JSON_TRUE || val->type == JSON_FALSE) ? opt->cb(opt->u.tlen) : "Invalid value";
            }
            if ( err )
            {
              if ( !fileconf )
              {
                snprintf((char *)err_buf_14961, 0xC8u, "Parsing JSON option %s: %s", (const char *)p, (const char *)err);
                return err_buf_14961;
              }
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf((char *)tmp42, 0x800u, "Invalid config option %s: %s", (const char *)p, (const char *)err);
                applog(3, tmp42, 0);
              }
              fileconf_load = -1;
            }
          }
        }
      }
      free(name);
    }
  }
  val = json_object_get(config, "include");
  if ( !val || val->type != JSON_STRING )
    return 0;
  v4 = json_string_value(val);
  return load_config(v4, 0);
}
// 49FB8: conditional instruction was optimized away because %val.4!=0
// 4A03C: conditional instruction was optimized away because %val.4!=0
// 4A0D4: conditional instruction was optimized away because %arr_val.4!=0
// 4A16C: conditional instruction was optimized away because %val.4!=0
// 4A188: conditional instruction was optimized away because %val.4!=0

//----- (0004A368) --------------------------------------------------------
unsigned __int8 *__cdecl load_config(const unsigned __int8 *arg, void *unused)
{
  size_t v3; // r4
  json_error_t err; // [sp+10h] [bp-114h] BYREF
  unsigned __int8 *json_error; // [sp+10Ch] [bp-18h]
  size_t siz; // [sp+110h] [bp-14h]
  json_t_0 *config; // [sp+114h] [bp-10h]

  if ( !cnfbuf )
    cnfbuf = (unsigned __int8 *)strdup((const char *)arg);
  if ( ++include_count > 10 )
    return "Too many levels of JSON includes (limit 10) or a loop";
  config = json_load_file(arg, 0, &err);
  if ( config && config->type == JSON_OBJECT )
  {
    config_loaded = 1;
    return parse_config(config, 1);
  }
  else
  {
    v3 = strlen((const char *)arg);
    siz = v3 + strlen((const char *)err.text) + 35;
    json_error = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___14992, 2095);
    snprintf((char *)json_error, siz, "JSON decode of file '%s' failed\n %s", (const char *)arg, (const char *)err.text);
    return json_error;
  }
}

//----- (0004A4C0) --------------------------------------------------------
unsigned __int8 *__cdecl set_default_config(const unsigned __int8 *arg)
{
  opt_set_charp(arg, &default_config);
  return 0;
}

//----- (0004A4F0) --------------------------------------------------------
void load_default_config()
{
  cnfbuf = (unsigned __int8 *)cgmalloc(0x1000u, "cgminer.c", _func___15001, 2120);
  default_save_file(cnfbuf);
  if ( access((const char *)cnfbuf, 4) )
  {
    free(cnfbuf);
    cnfbuf = 0;
  }
  else
  {
    load_config(cnfbuf, 0);
  }
}

//----- (0004A5A4) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_verusage_and_exit(const unsigned __int8 *extra)
{
  unsigned __int8 *v1; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", (const char *)packagename);
  v1 = opt_usage(opt_argv0, extra);
  printf("%s", (const char *)v1);
  fflush((FILE *)stdout);
  exit(0);
}
// C4484: using guessed type int stdout;

//----- (0004A610) --------------------------------------------------------
void __cdecl calc_midstate(work *work)
{
  sha256_ctx ctx; // [sp+14h] [bp-F0h] BYREF
  unsigned __int8 data[64]; // [sp+BCh] [bp-48h] BYREF
  uint32_t *data32; // [sp+FCh] [bp-8h]

  data32 = (uint32_t *)data;
  flip64(data, work);
  sha256_init(&ctx);
  sha256_update(&ctx, data, 0x40u);
  cg_memcpy(work->midstate, ctx.h, 0x20u, "cgminer.c", _func___15035, 2227);
  endian_flip32(work->midstate, work->midstate);
}

//----- (0004A6B4) --------------------------------------------------------
int total_work_inc()
{
  uint32_t v0; // r2
  int ret; // [sp+4h] [bp-8h]

  cg_wlock_1(&control_lock, "cgminer.c", _func___15040, 2236);
  v0 = total_work++;
  ret = v0;
  cg_wunlock_1(&control_lock, "cgminer.c", _func___15040, 2238);
  return ret;
}

//----- (0004A730) --------------------------------------------------------
work *make_work()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-808h] BYREF
  work *work; // [sp+80Ch] [bp-8h]

  work = (work *)cgcalloc(1, 0x1C0u, "cgminer.c", _func___15045, 2245);
  if ( !work )
  {
    strcpy((char *)tmp42, "Failed to calloc work in make_work");
    applog(3, tmp42, 1);
    quit(1);
  }
  work->id = total_work_inc();
  return work;
}

//----- (0004A7F8) --------------------------------------------------------
void __cdecl clean_work(work *work)
{
  free(work->job_id);
  free(work->ntime);
  free(work->coinbase);
  free(work->nonce1);
  memset(work, 0, sizeof(work));
}

//----- (0004A864) --------------------------------------------------------
void __cdecl free_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp-808h] BYREF
  work *work; // [sp+81Ch] [bp-8h]

  work = *workptr;
  if ( work )
  {
    clean_work(work);
    free(work);
    *workptr = 0;
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Free work called with NULL work from %s %s:%d",
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (0004A950) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl decay_time(double *f, double fadd, double fsecs, double interval)
{
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double fprop; // [sp+28h] [bp-Ch]

  if ( v5 > 0.0 )
  {
    exp(*(double *)&f);
    fprop = 1.0 - 1.0 / (v5 / v6);
    *f = *f + v4 / v5 * fprop;
    *f = *f / (fprop + 1.0);
  }
}
// 4A950: variables would overlap: r0.4 and r0.8

//----- (0004AA08) --------------------------------------------------------
unsigned int _total_staged()
{
  if ( staged_work )
    return staged_work->hh.tbl->num_items;
  else
    return 0;
}

//----- (0004AA50) --------------------------------------------------------
void __cdecl suffix_string(uint64_t val, unsigned __int8 *buf, size_t bufsiz, int sigdigits)
{
  double v4; // r0
  double v5; // r0
  double v6; // d7
  unsigned __int8 suffix[2]; // [sp+28h] [bp-60h] BYREF
  int ndigits; // [sp+2Ch] [bp-5Ch]
  uint64_t exa; // [sp+30h] [bp-58h]
  uint64_t peta; // [sp+38h] [bp-50h]
  uint64_t tera; // [sp+40h] [bp-48h]
  uint64_t giga; // [sp+48h] [bp-40h]
  uint64_t mega; // [sp+50h] [bp-38h]
  uint64_t kilo; // [sp+58h] [bp-30h]
  double dkilo; // [sp+60h] [bp-28h]
  bool decimal; // [sp+6Fh] [bp-19h]
  double dval; // [sp+70h] [bp-18h]

  dkilo = 1000.0;
  kilo = 1000LL;
  mega = (unsigned int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377];
  giga = 1000000000LL;
  tera = 1000000000000LL;
  peta = 1000000000000000LL;
  exa = 1000000000000000000LL;
  *(_WORD *)suffix = 0;
  decimal = 1;
  if ( val < 0xDE0B6B3A7640000LL )
  {
    if ( val < peta )
    {
      if ( val < tera )
      {
        if ( val < giga )
        {
          if ( val < mega )
          {
            v4 = (double)val;
            if ( val >= kilo )
            {
              dval = (double)val / dkilo;
              strcpy((char *)suffix, "K");
            }
            else
            {
              dval = (double)val;
              decimal = 0;
            }
          }
          else
          {
            v4 = (double)(val / kilo);
            dval = v4 / dkilo;
            strcpy((char *)suffix, "M");
          }
        }
        else
        {
          v4 = (double)(val / mega);
          dval = v4 / dkilo;
          strcpy((char *)suffix, "G");
        }
      }
      else
      {
        v4 = (double)(val / giga);
        dval = v4 / dkilo;
        strcpy((char *)suffix, "T");
      }
    }
    else
    {
      v4 = (double)(val / tera);
      dval = v4 / dkilo;
      strcpy((char *)suffix, "P");
    }
  }
  else
  {
    v4 = (double)(val / peta);
    dval = v4 / dkilo;
    strcpy((char *)suffix, "E");
  }
  if ( sigdigits )
  {
    if ( dval <= 0.0 )
    {
      v6 = 0.0;
    }
    else
    {
      v5 = log10(v4);
      floor(v5);
      v6 = dval;
    }
    ndigits = (int)((double)(sigdigits - 1) - v6);
    snprintf((char *)buf, bufsiz, "%*.*f%s", sigdigits + 1, ndigits, dval, (const char *)suffix);
  }
  else if ( decimal )
  {
    snprintf((char *)buf, bufsiz, "%.3g%s", dval, (const char *)suffix);
  }
  else
  {
    snprintf((char *)buf, bufsiz, "%d%s", (unsigned int)dval, (const char *)suffix);
  }
}

//----- (0004ADE8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl cgpu_runtime(cgpu_info *cgpu)
{
  double result; // r0
  cgpu_info *cgpua; // [sp+4h] [bp-18h]
  timeval now; // [sp+8h] [bp-14h] BYREF
  double dev_runtime; // [sp+10h] [bp-Ch]

  cgpua = cgpu;
  if ( cgpu->dev_start_tv.tv_sec )
  {
    cgtime(&now);
    *(double *)&cgpu = tdiff(&now, &cgpua->dev_start_tv);
  }
  else
  {
    dev_runtime = total_secs;
  }
  LODWORD(result) = cgpu;
  return result;
}
// 4ADE8: variables would overlap: r0.4 and r0.8
// 4ADE8: bad return variable

//----- (0004AE80) --------------------------------------------------------
void __cdecl get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  double v3; // d0
  unsigned __int8 tmp13[64]; // [sp+38h] [bp-89Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+78h] [bp-85Ch] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+878h] [bp-5Ch] BYREF
  unsigned __int8 displayed_hashes[16]; // [sp+888h] [bp-4Ch] BYREF
  size_t len13; // [sp+898h] [bp-3Ch]
  size_t buflen; // [sp+89Ch] [bp-38h]
  uint64_t dr64; // [sp+8A0h] [bp-34h]
  uint64_t dh64; // [sp+8A8h] [bp-2Ch]
  double wu; // [sp+8B0h] [bp-24h]
  double dev_runtime; // [sp+8B8h] [bp-1Ch]

  cgpu_runtime(cgpu);
  dev_runtime = v3;
  wu = (double)cgpu->diff1 / v3 * 60.0;
  dh64 = (unsigned __int64)(cgpu->total_mhashes / v3 * 1000000.0);
  dr64 = (unsigned __int64)(cgpu->rolling * 1000000.0);
  suffix_string(dh64, displayed_hashes, 0x10u, 4);
  suffix_string(dr64, displayed_rolling, 0x10u, 4);
  snprintf((char *)buf, bufsiz, "%s%d ", (const char *)cgpu->drv->name, cgpu->device_id);
  cgpu->drv->get_statline_before(buf, bufsiz, cgpu);
  buflen = strlen((const char *)buf);
  snprintf(
    (char *)tmp13,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    opt_log_interval,
    (const char *)displayed_rolling,
    (const char *)displayed_hashes,
    cgpu->diff_accepted,
    cgpu->diff_rejected,
    cgpu->hw_errors,
    wu);
  len13 = strlen((const char *)tmp13);
  if ( bufsiz <= buflen + len13 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "tailsprintf buffer overflow in %s %s line %d",
      "cgminer.c",
      (const char *)_func___15133,
      3089);
    applog(3, tmp42, 1);
    quit(1);
  }
  strcat((char *)buf, (const char *)tmp13);
  cgpu->drv->get_statline(buf, bufsiz, cgpu);
}
// 4AEA0: variable 'v3' is possibly undefined

//----- (0004B0F0) --------------------------------------------------------
bool shared_strategy()
{
  return pool_strategy_0 == POOL_LOADBALANCE || pool_strategy_0 == POOL_BALANCE;
}

//----- (0004B144) --------------------------------------------------------
void __cdecl enable_pool(pool *pool)
{
  if ( pool->enabled != POOL_ENABLED )
  {
    ++enabled_pools;
    pool->enabled = POOL_ENABLED;
  }
}

//----- (0004B19C) --------------------------------------------------------
void __cdecl reject_pool(pool *pool)
{
  if ( pool->enabled == POOL_ENABLED )
    --enabled_pools;
  pool->enabled = POOL_REJECTING;
}

//----- (0004B1F8) --------------------------------------------------------
void __cdecl share_result(
        json_t_0 *val,
        json_t_0 *res,
        json_t_0 *err,
        const work *work,
        unsigned __int8 *hashshow,
        bool resubmit,
        unsigned __int8 *worktime)
{
  const char *v7; // r3
  const char *v8; // r3
  const char *v9; // r3
  unsigned __int8 reason[32]; // [sp+38h] [bp-89Ch] BYREF
  unsigned __int8 disposition[36]; // [sp+58h] [bp-87Ch] BYREF
  unsigned __int8 tmp42[2048]; // [sp+7Ch] [bp-858h] BYREF
  unsigned __int8 where[20]; // [sp+87Ch] [bp-58h] BYREF
  double utility; // [sp+890h] [bp-44h]
  const unsigned __int8 *reasontmp; // [sp+89Ch] [bp-38h]
  const unsigned __int8 *s; // [sp+8A0h] [bp-34h]
  unsigned __int8 *reason_str; // [sp+8A4h] [bp-30h]
  json_t_0 *reason_val; // [sp+8A8h] [bp-2Ch]
  cgpu_info *cgpu; // [sp+8ACh] [bp-28h]
  pool *pool; // [sp+8B0h] [bp-24h]
  size_t reasonLen; // [sp+8B4h] [bp-20h]

  pool = work->pool;
  cgpu = get_thr_cgpu(work->thr_id);
  if ( res && res->type == JSON_TRUE || work->gbt && res && res->type == JSON_NULL )
  {
    mutex_lock_1(&stats_lock, "cgminer.c", _func___15156, 3499);
    ++cgpu->accepted;
    ++total_accepted;
    ++pool->accepted;
    cgpu->diff_accepted = cgpu->diff_accepted + work->work_difficulty;
    total_diff_accepted = work->work_difficulty + total_diff_accepted;
    pool->diff_accepted = pool->diff_accepted + work->work_difficulty;
    mutex_unlock_1(&stats_lock, "cgminer.c", _func___15156, 3509);
    pool->seq_rejects = 0;
    cgpu->last_share_pool = pool->pool_no;
    cgpu->last_share_pool_time = time(0);
    cgpu->last_share_diff = work->work_difficulty;
    pool->last_share_time = cgpu->last_share_pool_time;
    pool->last_share_diff = work->work_difficulty;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "PROOF OF WORK RESULT: true (yay!!!)");
      applog(7, tmp42, 0);
    }
    if ( !opt_quiet && !opt_realquiet )
    {
      if ( total_pools <= 1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          if ( resubmit )
            v8 = "(resubmit)";
          else
            v8 = (const char *)&unk_A1BD4;
          snprintf(
            (char *)tmp42,
            0x800u,
            "Accepted %s %s %d %s%s",
            (const char *)hashshow,
            (const char *)cgpu->drv->name,
            cgpu->device_id,
            v8,
            (const char *)worktime);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( resubmit )
          v7 = "(resubmit)";
        else
          v7 = (const char *)&unk_A1BD4;
        snprintf(
          (char *)tmp42,
          0x800u,
          "Accepted %s %s %d pool %d %s%s",
          (const char *)hashshow,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          work->pool->pool_no,
          v7,
          (const char *)worktime);
        applog(5, tmp42, 0);
      }
    }
    sharelog("accept", work);
    if ( opt_shares && (double)opt_shares <= total_diff_accepted )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Successfully mined %d accepted shares as requested and exiting.", opt_shares);
        applog(4, tmp42, 0);
      }
      kill_work();
    }
    if ( pool->enabled == POOL_REJECTING )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Rejecting pool %d now accepting shares, re-enabling!", pool->pool_no);
        applog(4, tmp42, 0);
      }
      enable_pool(pool);
      switch_pools(0);
    }
    if ( work->block )
      restart_threads();
  }
  else
  {
    mutex_lock_1(&stats_lock, "cgminer.c", _func___15156, 3562);
    ++cgpu->rejected;
    ++total_rejected;
    ++pool->rejected;
    cgpu->diff_rejected = cgpu->diff_rejected + work->work_difficulty;
    total_diff_rejected = work->work_difficulty + total_diff_rejected;
    pool->diff_rejected = pool->diff_rejected + work->work_difficulty;
    ++pool->seq_rejects;
    mutex_unlock_1(&stats_lock, "cgminer.c", _func___15156, 3570);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "PROOF OF WORK RESULT: false (booooo)");
      applog(7, tmp42, 0);
    }
    if ( !opt_quiet && !opt_realquiet )
    {
      strcpy((char *)disposition, "reject");
      memset(&disposition[7], 0, 0x1Du);
      reason[0] = 0;
      if ( total_pools <= 1 )
        where[0] = 0;
      else
        snprintf((char *)where, 0x14u, "pool %d", work->pool->pool_no);
      if ( !work->gbt )
        res = json_object_get(val, "reject-reason");
      if ( res )
      {
        reasontmp = json_string_value(res);
        reasonLen = strlen((const char *)reasontmp);
        if ( reasonLen > 0x1C )
          reasonLen = 28;
        qmemcpy(reason, " (", 2);
        cg_memcpy(&reason[2], reasontmp, reasonLen, "cgminer.c", _func___15156, 3610);
        reason[reasonLen + 2] = 41;
        reason[reasonLen + 3] = 0;
        cg_memcpy(&disposition[7], reasontmp, reasonLen, "cgminer.c", _func___15156, 3615);
        disposition[6] = 58;
        disposition[reasonLen + 7] = 0;
      }
      else if ( work->stratum && err )
      {
        if ( err->type == JSON_ARRAY )
        {
          reason_val = json_array_get(err, 1u);
          if ( reason_val && reason_val->type == JSON_STRING )
          {
            reason_str = (unsigned __int8 *)json_string_value(reason_val);
            snprintf((char *)reason, 0x1Fu, " (%s)", (const char *)reason_str);
          }
        }
        else if ( err->type == JSON_STRING )
        {
          s = json_string_value(err);
          snprintf((char *)reason, 0x1Fu, " (%s)", (const char *)s);
        }
      }
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( resubmit )
          v9 = "(resubmit)";
        else
          v9 = (const char *)&unk_A1BD4;
        snprintf(
          (char *)tmp42,
          0x800u,
          "Rejected %s %s %d %s%s %s%s version 0x%x",
          (const char *)hashshow,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          (const char *)where,
          (const char *)reason,
          v9,
          (const char *)worktime,
          work->version);
        applog(5, tmp42, 0);
      }
      sharelog(disposition, work);
    }
    if ( pool->seq_rejects > 10 && !work->stale && opt_disable_pool && enabled_pools > 1 )
    {
      utility = (double)total_accepted / total_secs * 60.0;
      if ( (double)pool->seq_rejects > utility * 3.0 && enabled_pools > 1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "Pool %d rejected %d sequential shares, disabling!",
            pool->pool_no,
            pool->seq_rejects);
          applog(4, tmp42, 0);
        }
        reject_pool(pool);
        if ( pool == current_pool() )
          switch_pools(0);
        pool->seq_rejects = 0;
      }
    }
  }
}
// 4BBB4: conditional instruction was optimized away because %err.4!=0
// 4BC34: conditional instruction was optimized away because %err.4!=0

//----- (0004BF00) --------------------------------------------------------
void __cdecl show_hash(work *work, unsigned __int8 *hashshow)
{
  double work_difficulty; // d0
  const char *v3; // r3
  unsigned __int8 diffdisp[16]; // [sp+20h] [bp-4Ch] BYREF
  unsigned __int8 rhash[32]; // [sp+30h] [bp-3Ch] BYREF
  uint64_t uintdiff; // [sp+50h] [bp-1Ch]
  unsigned int h32; // [sp+5Ch] [bp-10h]
  uint32_t *hash32; // [sp+60h] [bp-Ch]
  int ofs; // [sp+64h] [bp-8h]

  swab256_0(rhash, work->hash);
  for ( ofs = 0; ofs <= 28 && !rhash[ofs]; ++ofs )
    ;
  hash32 = (uint32_t *)&rhash[ofs];
  h32 = _bswap_32_0(*(_DWORD *)&rhash[ofs]);
  work_difficulty = work->work_difficulty;
  round();
  uintdiff = (unsigned __int64)work_difficulty;
  suffix_string(work->share_diff, diffdisp, 0x10u, 0);
  if ( work->block )
    v3 = " BLOCK!";
  else
    v3 = (const char *)&unk_A1BD4;
  snprintf((char *)hashshow, 0x40u, "%08lx Diff %s/%llu%s", h32, (const char *)diffdisp, uintdiff, v3);
}
// 12360: using guessed type int round(void);

//----- (0004C038) --------------------------------------------------------
bool __cdecl pool_unusable(pool *pool)
{
  if ( pool->idle )
    return 1;
  if ( pool->enabled == POOL_ENABLED )
    return pool->has_stratum && (!pool->stratum_active || !pool->stratum_notify);
  return 1;
}

//----- (0004C0D4) --------------------------------------------------------
pool *__cdecl select_balanced(pool *cp)
{
  pool *pool; // [sp+8h] [bp-14h]
  pool *ret; // [sp+Ch] [bp-10h]
  int lowest; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  lowest = cp->shares;
  ret = cp;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    if ( !pool_unusable(pool) && lowest > pool->shares )
    {
      lowest = pool->shares;
      ret = pool;
    }
  }
  ++ret->shares;
  return ret;
}

//----- (0004C1B0) --------------------------------------------------------
pool *select_pool()
{
  int quota_used; // r3
  pool *v1; // r0
  int v2; // r2
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-820h] BYREF
  pool *tp_0; // [sp+804h] [bp-20h]
  pool *tp; // [sp+808h] [bp-1Ch]
  pool *cp; // [sp+80Ch] [bp-18h]
  int i; // [sp+810h] [bp-14h]
  int tested; // [sp+814h] [bp-10h]
  bool avail; // [sp+81Bh] [bp-9h]
  pool *pool; // [sp+81Ch] [bp-8h]

  avail = 0;
  cp = current_pool();
  if ( pool_strategy_0 == POOL_BALANCE )
  {
    pool = select_balanced(cp);
  }
  else if ( pool_strategy_0 == POOL_LOADBALANCE )
  {
    pool = 0;
    for ( i = 0; i < total_pools; ++i )
    {
      tp = pools[i];
      if ( tp->quota_used < tp->quota_gcd )
      {
        avail = 1;
        break;
      }
    }
    if ( !avail )
    {
      for ( i = 0; i < total_pools; ++i )
        pools[i]->quota_used = 0;
      if ( ++rotating_pool_15206 >= total_pools )
        rotating_pool_15206 = 0;
    }
    tested = 0;
    while ( !pool )
    {
      v2 = tested++;
      if ( v2 >= total_pools )
        break;
      pool = pools[rotating_pool_15206];
      quota_used = pool->quota_used;
      pool->quota_used = quota_used + 1;
      if ( quota_used < pool->quota_gcd )
      {
        if ( !pool_unusable(pool) )
          break;
        if ( opt_fail_only )
        {
          v1 = priority_pool(0);
          --v1->quota_used;
        }
      }
      pool = 0;
      if ( ++rotating_pool_15206 >= total_pools )
        rotating_pool_15206 = 0;
    }
    if ( !pool )
    {
      for ( i = 0; i < total_pools; ++i )
      {
        tp_0 = priority_pool(i);
        if ( !pool_unusable(tp_0) )
        {
          pool = tp_0;
          break;
        }
      }
    }
    if ( !pool )
      pool = cp;
  }
  else
  {
    pool = cp;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Selecting pool %d for work", pool->pool_no);
    applog(7, tmp42, 0);
  }
  return pool;
}

//----- (0004C598) --------------------------------------------------------
double __cdecl le256todouble(const void *target)
{
  _uint64_identity_0(*((_QWORD *)target + 3));
  _uint64_identity_0(*((_QWORD *)target + 2));
  _uint64_identity_0(*((_QWORD *)target + 1));
  return (double)_uint64_identity_0(*(_QWORD *)target);
}

//----- (0004C6F0) --------------------------------------------------------
double __cdecl diff_from_target(void *target)
{
  return le256todouble(target);
}

//----- (0004C758) --------------------------------------------------------
void __cdecl calc_diff(work *work, double known)
{
  double v2; // d0
  double difficulty; // [sp+20h] [bp-14h]
  cgminer_pool_stats *pool_stats; // [sp+2Ch] [bp-8h]

  pool_stats = &work->pool->cgminer_pool_stats;
  if ( v2 == 0.0 )
  {
    diff_from_target(work->target);
    work->work_difficulty = v2;
  }
  else
  {
    work->work_difficulty = v2;
  }
  difficulty = work->work_difficulty;
  pool_stats->last_diff = difficulty;
  round();
  suffix_string((unsigned __int64)difficulty, work->pool->diff, 8u, 0);
  if ( difficulty == pool_stats->min_diff )
  {
    ++pool_stats->min_diff_count;
  }
  else if ( difficulty < pool_stats->min_diff || pool_stats->min_diff == 0.0 )
  {
    pool_stats->min_diff = difficulty;
    pool_stats->min_diff_count = 1;
  }
  if ( difficulty == pool_stats->max_diff )
  {
    ++pool_stats->max_diff_count;
  }
  else if ( difficulty > pool_stats->max_diff )
  {
    pool_stats->max_diff = difficulty;
    pool_stats->max_diff_count = 1;
  }
}
// 4C788: variable 'v2' is possibly undefined
// 12360: using guessed type int round(void);

//----- (0004C900) --------------------------------------------------------
void __cdecl get_benchmark_work(work *work)
{
  work->work_difficulty = 0x4040000000000000LL;
  cg_memcpy(work->target, bench_target, 0x20u, "cgminer.c", _func___15255, 4243);
  work->drv_rolllimit = 0;
  work->mandatory = 1;
  work->pool = *pools;
  cgtime(&work->tv_getwork);
  copy_time(&work->tv_getwork_reply, &work->tv_getwork);
  work->getwork_mode = 66;
}

//----- (0004C9D0) --------------------------------------------------------
void __cdecl benchfile_dspwork(work *work, uint32_t nonce)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-C0Ch] BYREF
  unsigned __int8 buf[1024]; // [sp+810h] [bp-40Ch] BYREF
  int i; // [sp+C10h] [bp-Ch]
  uint32_t dn; // [sp+C14h] [bp-8h]

  dn = 0;
  for ( i = 0; i <= 3; ++i )
  {
    dn = (dn << 8) + (unsigned __int8)nonce;
    nonce >>= 8;
  }
  _bin2hex(buf, work->data, 0x80u);
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", dn, dn, (const char *)buf);
    applog(3, tmp42, 0);
  }
}

//----- (0004CAF8) --------------------------------------------------------
bool __cdecl benchfile_get_work(work *work)
{
  unsigned __int8 *v1; // r0
  unsigned __int8 *v2; // r2
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-102Ch] BYREF
  unsigned __int8 *commas[5]; // [sp+818h] [bp-82Ch]
  unsigned __int8 item[1024]; // [sp+82Ch] [bp-818h] BYREF
  unsigned __int8 buf[1024]; // [sp+C2Ch] [bp-418h] BYREF
  int nonce_time; // [sp+102Ch] [bp-18h]
  int len; // [sp+1030h] [bp-14h]
  int j; // [sp+1034h] [bp-10h]
  int i; // [sp+1038h] [bp-Ch]
  bool got; // [sp+103Fh] [bp-5h]

  got = 0;
  if ( !benchfile_in )
  {
    if ( !opt_benchfile )
    {
      strcpy((char *)tmp42, "BENCHFILE Invalid benchfile NULL");
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_in = fopen((const char *)opt_benchfile, "r");
    if ( !benchfile_in )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to open benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    benchfile_line = 0;
    if ( !fgets((char *)buf, 1024, benchfile_in) )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE Failed to read benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
    got = 1;
    benchfile_work = 0;
  }
  if ( got || fgets((char *)buf, 1024, benchfile_in) )
  {
    do
    {
      ++benchfile_line;
      if ( buf[0] && buf[0] != 35 && buf[0] != 47 )
      {
        commas[0] = buf;
        for ( i = 1; i <= 4; ++i )
        {
          v1 = (unsigned __int8 *)strchr((const char *)commas[i - 1], 44);
          commas[i] = v1;
          if ( !commas[i] )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
              benchfile_line,
              i,
              5);
            applog(3, tmp42, 1);
            quit(1);
          }
          len = commas[i] - commas[i - 1];
          if ( benchfile_data[i - 1].length && len != benchfile_data[i - 1].length )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
              benchfile_line,
              i,
              (const char *)benchfile_data[i - 1].name,
              len,
              benchfile_data[i - 1].length);
            applog(3, tmp42, 1);
            quit(1);
          }
          v2 = commas[i];
          commas[i] = v2 + 1;
          *v2 = 0;
        }
        len = strlen((const char *)commas[4]);
        if ( len < benchfile_data[4].length )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
            benchfile_line,
            5,
            (const char *)benchfile_data[4].name,
            len,
            benchfile_data[4].length);
          applog(3, tmp42, 1);
          quit(1);
        }
        sprintf((char *)item, "0000000%c", *commas[0]);
        j = strlen((const char *)item);
        for ( i = benchfile_data[2].length - 8; i >= 0; i -= 8 )
        {
          sprintf((char *)&item[j], "%.8s", (const char *)&commas[2][i]);
          j += 8;
        }
        for ( i = benchfile_data[1].length - 8; i >= 0; i -= 8 )
        {
          sprintf((char *)&item[j], "%.8s", (const char *)&commas[1][i]);
          j += 8;
        }
        nonce_time = atol((const char *)commas[4]);
        sprintf((char *)&item[j], "%08lx", nonce_time);
        j += 8;
        strcpy((char *)&item[j], (const char *)commas[3]);
        j += benchfile_data[3].length;
        memset(work, 0, sizeof(work));
        hex2bin(work->data, item, j >> 1);
        calc_midstate(work);
        ++benchfile_work;
        return 1;
      }
    }
    while ( fgets((char *)buf, 1024, benchfile_in) );
    if ( !benchfile_work )
    {
      snprintf((char *)tmp42, 0x800u, "BENCHFILE No work in benchfile '%s'", (const char *)opt_benchfile);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  else if ( !benchfile_work )
  {
    snprintf((char *)tmp42, 0x800u, "BENCHFILE No work in benchfile '%s'", (const char *)opt_benchfile);
    applog(3, tmp42, 1);
    quit(1);
  }
  fclose(benchfile_in);
  benchfile_in = 0;
  return benchfile_get_work(work);
}

//----- (0004D3B0) --------------------------------------------------------
void __cdecl get_benchfile_work(work *work)
{
  double v1; // r2

  benchfile_get_work(work);
  work->mandatory = 1;
  work->pool = *pools;
  cgtime(&work->tv_getwork);
  copy_time(&work->tv_getwork_reply, &work->tv_getwork);
  HIDWORD(v1) = work;
  LODWORD(v1) = 66;
  work->getwork_mode = 66;
  calc_diff(work, v1);
}

//----- (0004D448) --------------------------------------------------------
void __cdecl kill_timeout(thr_info *thr)
{
  cg_completion_timeout(thr_info_cancel, thr, 1000);
}

//----- (0004D478) --------------------------------------------------------
void kill_mining()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-810h] BYREF
  thr_info *thr; // [sp+804h] [bp-10h]
  pthread_t *pth; // [sp+808h] [bp-Ch]
  int i; // [sp+80Ch] [bp-8h]

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Killing off mining threads");
    applog(7, tmp42, 1);
  }
  for ( i = 0; i < mining_threads; ++i )
  {
    pth = 0;
    thr = get_thread(i);
    if ( thr && thr->pth )
      pth = &thr->pth;
    thr_info_cancel(thr);
    if ( pth )
    {
      if ( *pth )
        pthread_join(*pth, 0);
    }
  }
}

//----- (0004D5DC) --------------------------------------------------------
void _kill_work()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-810h] BYREF
  cgpu_info *cgpu; // [sp+804h] [bp-10h]
  thr_info *thr; // [sp+808h] [bp-Ch]
  int i; // [sp+80Ch] [bp-8h]

  if ( successful_connect )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      strcpy((char *)tmp42, "Received kill message");
      applog(6, tmp42, 1);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off watchpool thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[watchpool_thr_id];
    kill_timeout(thr);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off watchdog thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[watchdog_thr_id];
    kill_timeout(thr);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Shutting down mining threads");
      applog(7, tmp42, 1);
    }
    for ( i = 0; i < mining_threads; ++i )
    {
      thr = get_thread(i);
      if ( thr )
      {
        cgpu = thr->cgpu;
        if ( cgpu )
          cgpu->shutdown = 1;
      }
    }
    sleep(1u);
    cg_completion_timeout(kill_mining, 0, 3000);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Killing off API thread");
      applog(7, tmp42, 1);
    }
    thr = &control_thr[api_thr_id];
    kill_timeout(thr);
  }
}

//----- (0004DA38) --------------------------------------------------------
void __noreturn kill_work()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-804h] BYREF

  cg_completion_timeout(_kill_work, 0, 5000);
  strcpy((char *)tmp42, "Shutdown signal received.");
  applog(3, tmp42, 1);
  quit(0);
}

//----- (0004DAA8) --------------------------------------------------------
void __fastcall sub_4DAA8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R11,PC} }
}
// 4DAAC: unbalanced stack, ignored a potential tail call

//----- (0004DAB0) --------------------------------------------------------
void app_restart()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-804h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Attempting to restart %s", (const char *)packagename);
    applog(4, tmp42, 0);
  }
  cg_completion_timeout(_kill_work, 0, 5000);
  clean_up(1);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  execv((const char *)*initial_args, (char *const *)initial_args);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Failed to restart application");
    applog(4, tmp42, 0);
  }
}

//----- (0004DC3C) --------------------------------------------------------
void __cdecl __noreturn sighandler(int sig)
{
  sigaction_0(15, &termhandler, 0);
  sigaction_0(2, &inthandler, 0);
  sigaction_0(6, &abrthandler, 0);
  kill_work();
}

//----- (0004DC90) --------------------------------------------------------
void __fastcall sub_4DC90(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R11,PC} }
}
// 4DC94: unbalanced stack, ignored a potential tail call

//----- (0004DC98) --------------------------------------------------------
void *__cdecl submit_work_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0004DCC8) --------------------------------------------------------
unsigned __int8 *__cdecl offset_ntime(const unsigned __int8 *ntime, int noffset)
{
  unsigned int v2; // r0
  unsigned __int8 bin[4]; // [sp+Ch] [bp-10h] BYREF
  uint32_t h32; // [sp+10h] [bp-Ch]
  uint32_t *be32; // [sp+14h] [bp-8h]

  be32 = (uint32_t *)bin;
  hex2bin(bin, ntime, 4u);
  h32 = _bswap_32_0(*be32) + noffset;
  v2 = _bswap_32_0(h32);
  *be32 = v2;
  return bin2hex(bin, 4u);
}

//----- (0004DD4C) --------------------------------------------------------
void __cdecl copy_work(work *work, const work *base_work, int noffset)
{
  unsigned __int8 *v3; // r0
  unsigned int ntime; // [sp+1Ch] [bp-18h]
  unsigned int ntime_0; // [sp+24h] [bp-10h]
  uint32_t id; // [sp+2Ch] [bp-8h]

  id = work->id;
  clean_work(work);
  cg_memcpy(work, base_work, 0x1C0u, "cgminer.c", _func___15378, 4929);
  work->id = id;
  if ( base_work->job_id )
    work->job_id = (unsigned __int8 *)strdup((const char *)base_work->job_id);
  if ( base_work->nonce1 )
    work->nonce1 = (unsigned __int8 *)strdup((const char *)base_work->nonce1);
  if ( base_work->ntime )
  {
    if ( noffset )
    {
      ntime = _bswap_32_0(*(_DWORD *)&work->data[68]) + noffset;
      *(_DWORD *)&work->data[68] = _bswap_32_0(ntime);
      v3 = offset_ntime(base_work->ntime, noffset);
    }
    else
    {
      v3 = (unsigned __int8 *)strdup((const char *)base_work->ntime);
    }
    work->ntime = v3;
  }
  else if ( noffset )
  {
    ntime_0 = _bswap_32_0(*(_DWORD *)&work->data[68]) + noffset;
    *(_DWORD *)&work->data[68] = _bswap_32_0(ntime_0);
  }
  if ( base_work->coinbase )
    work->coinbase = (unsigned __int8 *)strdup((const char *)base_work->coinbase);
  work->version = base_work->version;
}

//----- (0004DF54) --------------------------------------------------------
work *__cdecl copy_work_noffset(work *base_work, int noffset)
{
  work *work; // [sp+Ch] [bp-8h]

  work = make_work();
  copy_work(work, base_work, noffset);
  return work;
}

//----- (0004DF90) --------------------------------------------------------
void __cdecl pool_died(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-804h] BYREF

  if ( !pool_tset(pool, &pool->idle) )
  {
    cgtime(&pool->tv_idle);
    if ( pool == current_pool() )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %d %s not responding!", pool->pool_no, (const char *)pool->rpc_url);
        applog(4, tmp42, 0);
      }
      switch_pools(0);
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s failed to return work", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
}

//----- (0004E10C) --------------------------------------------------------
bool __cdecl stale_work(work *work, bool share)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-81Ch] BYREF
  timeval now; // [sp+808h] [bp-1Ch] BYREF
  int getwork_delay; // [sp+810h] [bp-14h]
  pool *pool; // [sp+814h] [bp-10h]
  bool same_job; // [sp+81Bh] [bp-9h]
  time_t work_expiry; // [sp+81Ch] [bp-8h]

  if ( opt_benchmark || opt_benchfile )
    return 0;
  if ( work->work_block != work_block )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to block mismatch");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  if ( work->rolltime <= opt_scantime )
    work_expiry = opt_expiry;
  else
    work_expiry = work->rolltime;
  pool = work->pool;
  if ( share || !pool->has_stratum )
    goto LABEL_33;
  if ( !pool->stratum_active || !pool->stratum_notify )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to stratum inactive");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  same_job = 1;
  cg_rlock_0(&pool->data_lock, "cgminer.c", _func___15409, 5067);
  if ( strcmp((const char *)work->job_id, (const char *)pool->swork.job_id) )
    same_job = 0;
  cg_runlock_0(&pool->data_lock, "cgminer.c", _func___15409, 5074);
  if ( !same_job )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Work stale due to stratum job_id mismatch");
      applog(7, tmp42, 0);
    }
    return 1;
  }
  else
  {
LABEL_33:
    getwork_delay = (int)(pool->cgminer_pool_stats.getwork_wait_rolling * 5.0 + 1.0);
    work_expiry -= getwork_delay;
    if ( work_expiry <= 4 )
      work_expiry = 5;
    cgtime(&now);
    if ( work_expiry > now.tv_sec - work->tv_staged.tv_sec )
    {
      if ( !opt_fail_only
        || share
        || pool == current_pool()
        || work->mandatory
        || pool_strategy_0 == POOL_LOADBALANCE
        || pool_strategy_0 == POOL_BALANCE )
      {
        return 0;
      }
      else
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Work stale due to fail only pool mismatch");
          applog(7, tmp42, 0);
        }
        return 1;
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Work stale due to expiry");
        applog(7, tmp42, 0);
      }
      return 1;
    }
  }
}

//----- (0004E6EC) --------------------------------------------------------
uint64_t __cdecl share_diff(const work *work)
{
  double v1; // d0
  double v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-824h] BYREF
  uint64_t ret; // [sp+810h] [bp-24h]
  double d64; // [sp+818h] [bp-1Ch]
  double s64; // [sp+820h] [bp-14h]
  bool new_best; // [sp+82Fh] [bp-5h]

  new_best = 0;
  d64 = 2.69595353e67;
  v2 = le256todouble(work->hash);
  s64 = v1;
  if ( v1 == 0.0 )
    s64 = 0.0;
  round(LODWORD(v2), HIDWORD(v2));
  ret = (unsigned __int64)(d64 / s64);
  cg_wlock_1(&control_lock, "cgminer.c", _func___15420, 5128);
  if ( ret > best_diff )
  {
    new_best = 1;
    best_diff = ret;
    suffix_string(ret, best_share, 8u, 0);
  }
  if ( ret > work->pool->best_diff )
    work->pool->best_diff = ret;
  cg_wunlock_1(&control_lock, "cgminer.c", _func___15420, 5142);
  if ( new_best && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "New best share: %s", (const char *)best_share);
    applog(6, tmp42, 0);
  }
  return ret;
}
// 4E724: variable 'v1' is possibly undefined
// 12360: using guessed type int __fastcall round(_DWORD, _DWORD);

//----- (0004E8D8) --------------------------------------------------------
void __cdecl regen_hash(work *work)
{
  unsigned __int8 hash1[32]; // [sp+8h] [bp-7Ch] BYREF
  unsigned __int8 swap[80]; // [sp+28h] [bp-5Ch] BYREF
  uint32_t *swap32; // [sp+78h] [bp-Ch]
  uint32_t *data32; // [sp+7Ch] [bp-8h]

  data32 = (uint32_t *)work;
  swap32 = (uint32_t *)swap;
  flip80(swap, work);
  sha256(swap, 0x50u, hash1);
  sha256(hash1, 0x20u, work->hash);
}

//----- (0004E93C) --------------------------------------------------------
pool *__cdecl priority_pool(int choice)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-810h] BYREF
  pool *pool; // [sp+80Ch] [bp-10h]
  int i; // [sp+810h] [bp-Ch]
  pool *ret; // [sp+814h] [bp-8h]

  ret = 0;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    if ( choice == pool->prio )
    {
      ret = pool;
      break;
    }
  }
  if ( ret )
    return ret;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf((char *)tmp42, 0x800u, "WTF No pool %d found!", choice);
    applog(3, tmp42, 0);
  }
  return pools[choice];
}

//----- (0004EA7C) --------------------------------------------------------
void __cdecl switch_pools(pool *selected)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-818h] BYREF
  pool *pool; // [sp+814h] [bp-18h]
  pool *last_pool; // [sp+818h] [bp-14h]
  int next_pool; // [sp+81Ch] [bp-10h]
  int pool_no; // [sp+820h] [bp-Ch]
  int i; // [sp+824h] [bp-8h]

  cg_wlock_1(&control_lock, "cgminer.c", _func___15455, 5221);
  last_pool = currentpool;
  pool_no = currentpool->pool_no;
  if ( selected && selected->prio )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( pool->prio < selected->prio )
        ++pool->prio;
    }
    selected->prio = 0;
  }
  switch ( pool_strategy_0 )
  {
    case POOL_FAILOVER:
    case POOL_LOADBALANCE:
    case POOL_BALANCE:
      for ( i = 0; i < total_pools; ++i )
      {
        pool = priority_pool(i);
        if ( !pool_unusable(pool) )
        {
          pool_no = pool->pool_no;
          goto LABEL_26;
        }
      }
      break;
    case POOL_ROUNDROBIN:
    case POOL_ROTATE:
      if ( selected && !selected->idle )
      {
        pool_no = selected->pool_no;
      }
      else
      {
        next_pool = pool_no;
        for ( i = 1; i < total_pools; ++i )
        {
          if ( ++next_pool >= total_pools )
            next_pool = 0;
          pool = pools[next_pool];
          if ( !pool_unusable(pool) )
          {
            pool_no = next_pool;
            goto LABEL_26;
          }
        }
      }
      break;
    default:
      break;
  }
LABEL_26:
  currentpool = pools[pool_no];
  pool = currentpool;
  cg_wunlock_1(&control_lock, "cgminer.c", _func___15455, 5302);
  if ( pool != last_pool && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Switching to pool %d %s", pool->pool_no, (const char *)pool->rpc_url);
      applog(4, tmp42, 0);
    }
    clear_pool_work(last_pool);
  }
  mutex_lock_1(&lp_lock, "cgminer.c", _func___15455, 5310);
  pthread_cond_broadcast(&lp_cond);
  mutex_unlock_1(&lp_lock, "cgminer.c", _func___15455, 5312);
}
// 4EB8C: control flows out of bounds to 4EB90

//----- (0004EE74) --------------------------------------------------------
void __cdecl discard_work(work **workptr, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp-810h] BYREF
  work *work; // [sp+81Ch] [bp-10h]

  work = *workptr;
  if ( work )
  {
    if ( !work->clone && !work->rolls && !work->mined )
    {
      if ( work->pool )
      {
        ++work->pool->discarded_work;
        --work->pool->quota_used;
        --work->pool->works;
      }
      ++total_discarded;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Discarded work");
        applog(7, tmp42, 0);
      }
    }
    else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Discarded cloned or rolled work");
      applog(7, tmp42, 0);
    }
    free_work(workptr, file, func, line);
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Discard work called with NULL work from %s %s:%d",
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 0);
  }
}

//----- (0004F148) --------------------------------------------------------
void wake_gws()
{
  mutex_lock_1(stgd_lock, "cgminer.c", _func___15488, 5346);
  pthread_cond_signal(&gws_cond);
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___15488, 5348);
}

//----- (0004F1AC) --------------------------------------------------------
void discard_stale()
{
  work *next; // r3
  UT_hash_bucket_0 *v1; // r3
  work *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-818h] BYREF
  work *work; // [sp+804h] [bp-18h] BYREF
  unsigned int _hd_bkt; // [sp+808h] [bp-14h]
  UT_hash_handle *_hd_hh_del; // [sp+80Ch] [bp-10h]
  int stale; // [sp+810h] [bp-Ch]
  work *tmp; // [sp+814h] [bp-8h]

  stale = 0;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___15495, 5356);
  work = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( stale_work(work, 0) )
    {
      if ( work->hh.prev || work->hh.next )
      {
        _hd_hh_del = &work->hh;
        if ( (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) == work )
          staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
        if ( work->hh.prev )
          *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
        else
          staged_work = (work *)work->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v1 = &staged_work->hh.tbl->buckets[_hd_bkt];
        --v1->count;
        if ( _hd_hh_del == staged_work->hh.tbl->buckets[_hd_bkt].hh_head )
          staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --staged_work->hh.tbl->num_items;
      }
      else
      {
        free(staged_work->hh.tbl->buckets);
        free(staged_work->hh.tbl);
        staged_work = 0;
      }
      discard_work(&work, "cgminer.c", _func___15495, 5363);
      ++stale;
    }
    work = tmp;
    if ( tmp )
      v2 = (work *)tmp->hh.next;
    else
      v2 = 0;
    tmp = v2;
  }
  pthread_cond_signal(&gws_cond);
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___15495, 5369);
  if ( stale && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Discarded %d stales that didn't match current hash", stale);
    applog(7, tmp42, 0);
  }
}

//----- (0004F638) --------------------------------------------------------
void *__cdecl restart_thread(void *arg)
{
  pthread_t v1; // r0
  cgpu_info *cgpu; // [sp+Ch] [bp-10h]
  int mt; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v1 = pthread_self();
  pthread_detach(v1);
  discard_stale();
  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___15518, 5422);
  mt = mining_threads;
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___15518, 5424);
  for ( i = 0; i < mt; ++i )
  {
    cgpu = mining_thr[i]->cgpu;
    if ( cgpu && cgpu->deven == DEV_ENABLED )
    {
      mining_thr[i]->work_restart = 1;
      flush_queue(cgpu);
      cgpu->drv->flush_work(cgpu);
    }
  }
  mutex_lock_1(&restart_lock, "cgminer.c", _func___15518, 5445);
  pthread_cond_broadcast(&restart_cond);
  mutex_unlock_1(&restart_lock, "cgminer.c", _func___15518, 5447);
  return 0;
}

//----- (0004F7C0) --------------------------------------------------------
void restart_threads()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-808h] BYREF
  pthread_t rthread[2]; // [sp+804h] [bp-8h] BYREF

  cgtime(&restart_tv_start);
  if ( pthread_create(rthread, 0, (void *(*)(void *))restart_thread, 0) )
  {
    strcpy((char *)tmp42, "Failed to create restart thread");
    applog(3, tmp42, 1);
    quit(1);
  }
}
// 4F7C0: using guessed type pthread_t rthread[2];

//----- (0004F85C) --------------------------------------------------------
void signal_work_update()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-808h] BYREF
  int i; // [sp+804h] [bp-8h]

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    strcpy((char *)tmp42, "Work update message received");
    applog(6, tmp42, 0);
  }
  cgtime(&update_tv_start);
  rd_lock_0(&mining_thr_lock, "cgminer.c", _func___15533, 5480);
  for ( i = 0; i < mining_threads; ++i )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, " %s set work_update true", (const char *)_FUNCTION___15535);
      applog(5, tmp42, 0);
    }
    mining_thr[i]->work_update = 1;
  }
  rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___15533, 5488);
}

//----- (0004FA1C) --------------------------------------------------------
void __cdecl set_curblock(const unsigned __int8 *hexstr, const unsigned __int8 *bedata)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-808h] BYREF
  int ofs; // [sp+814h] [bp-8h]

  cg_wlock_1(&ch_lock, "cgminer.c", _func___15544, 5495);
  cgtime(&block_timeval);
  strcpy((char *)current_hash, (const char *)hexstr);
  cg_memcpy(current_block, bedata, 0x20u, "cgminer.c", _func___15544, 5498);
  get_timestamp(blocktime, 0x20u, &block_timeval);
  cg_wunlock_1(&ch_lock, "cgminer.c", _func___15544, 5500);
  for ( ofs = 0; ofs <= 56 && current_hash[ofs] == (unsigned __int8)a0_0[0]; ++ofs )
    ;
  strncpy((char *)prev_block, (const char *)&current_hash[ofs], 8u);
  prev_block[8] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "New block: %s... diff %s", (const char *)current_hash, (const char *)block_diff);
    applog(6, tmp42, 0);
  }
}

//----- (0004FBF4) --------------------------------------------------------
int __cdecl block_sort(block *blocka, block *blockb)
{
  return blocka->block_no - blockb->block_no;
}

//----- (0004FC2C) --------------------------------------------------------
void __cdecl set_blockdiff(const work *work)
{
  unsigned __int64 v1; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-82Ch] BYREF
  double ddiff; // [sp+810h] [bp-2Ch]
  double numerator; // [sp+818h] [bp-24h]
  uint32_t diff32; // [sp+824h] [bp-18h]
  uint8_t pow; // [sp+82Bh] [bp-11h]
  int powdiff; // [sp+82Ch] [bp-10h]

  pow = work->data[72];
  powdiff = 8 * (29 - pow);
  if ( powdiff <= 7 )
    powdiff = 8;
  diff32 = _bswap_32_0(*(_DWORD *)&work->data[72]) & 0xFFFFFF;
  LODWORD(v1) = 0xFFFF << powdiff;
  HIDWORD(v1) = (0xFFFF << (powdiff - 32)) | (0xFFFFu >> (32 - powdiff));
  numerator = (double)v1;
  ddiff = (double)v1 / (double)diff32;
  if ( ddiff != current_diff )
  {
    suffix_string((unsigned __int64)ddiff, block_diff, 8u, 0);
    current_diff = ddiff;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Network diff set to %s", (const char *)block_diff);
      applog(5, tmp42, 0);
    }
  }
}

//----- (0004FDAC) --------------------------------------------------------
bool __cdecl block_exists(const unsigned __int8 *hexstr, const unsigned __int8 *bedata, const work *work)
{
  size_t v3; // r0
  int v4; // r2
  UT_hash_handle *v5; // r3
  UT_hash_handle *v6; // r3
  UT_hash_handle *v7; // r3
  UT_hash_handle *v8; // r3
  UT_hash_handle *v9; // r3
  char *v10; // r3
  char *v11; // r3
  UT_hash_bucket_0 *v12; // r3
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v14; // r3
  unsigned int v15; // r3
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp-898h] BYREF
  UT_hash_bucket_0 *_he_newbkt; // [sp+81Ch] [bp-98h]
  unsigned int _he_bkt; // [sp+820h] [bp-94h]
  UT_hash_handle *_he_hh_nxt; // [sp+824h] [bp-90h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+828h] [bp-8Ch]
  unsigned int _ha_bkt; // [sp+82Ch] [bp-88h]
  unsigned int _hd_bkt; // [sp+830h] [bp-84h]
  UT_hash_handle *_hd_hh_del; // [sp+834h] [bp-80h]
  block *oldblock; // [sp+838h] [bp-7Ch]
  unsigned int _hf_bkt; // [sp+83Ch] [bp-78h]
  UT_hash_handle *_he_thh; // [sp+840h] [bp-74h]
  unsigned int _he_bkt_i; // [sp+844h] [bp-70h]
  const unsigned __int8 *_hj_key_0; // [sp+848h] [bp-6Ch]
  unsigned int _hj_k_0; // [sp+84Ch] [bp-68h]
  unsigned int _hj_j_0; // [sp+850h] [bp-64h]
  unsigned int _hj_i_0; // [sp+854h] [bp-60h]
  unsigned int _ha_hashv; // [sp+858h] [bp-5Ch]
  UT_hash_handle *_hs_tail; // [sp+85Ch] [bp-58h]
  UT_hash_handle *_hs_list; // [sp+860h] [bp-54h]
  UT_hash_handle *_hs_e; // [sp+864h] [bp-50h]
  UT_hash_handle *_hs_q; // [sp+868h] [bp-4Ch]
  UT_hash_handle *_hs_p; // [sp+86Ch] [bp-48h]
  unsigned int _hs_qsize; // [sp+870h] [bp-44h]
  unsigned int _hs_psize; // [sp+874h] [bp-40h]
  unsigned int _hs_insize; // [sp+878h] [bp-3Ch]
  unsigned int _hs_nmerges; // [sp+87Ch] [bp-38h]
  unsigned int _hs_looping; // [sp+880h] [bp-34h]
  unsigned int _hs_i; // [sp+884h] [bp-30h]
  const unsigned __int8 *_hj_key; // [sp+888h] [bp-2Ch]
  unsigned int _hj_k; // [sp+88Ch] [bp-28h]
  unsigned int _hj_j; // [sp+890h] [bp-24h]
  unsigned int _hj_i; // [sp+894h] [bp-20h]
  unsigned int _hf_hashv; // [sp+898h] [bp-1Ch]
  bool ret; // [sp+89Fh] [bp-15h]
  block *s; // [sp+8A0h] [bp-14h]
  int deleted_block; // [sp+8A4h] [bp-10h]

  deleted_block = 0;
  ret = 1;
  wr_lock_1(&blk_lock, "cgminer.c", _func___15570, 5550);
  _hj_key = hexstr;
  _hf_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)hexstr); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_i += *_hj_key + (_hj_key[1] << 8) + (_hj_key[2] << 16) + (_hj_key[3] << 24);
    _hj_j += _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16) + (_hj_key[7] << 24);
    _hf_hashv += _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16) + (_hj_key[11] << 24);
    _hj_i = (_hf_hashv >> 13) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 8) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 13) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_i = (_hf_hashv >> 12) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 16) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 5) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_i = (_hf_hashv >> 3) ^ (_hj_i - _hj_j - _hf_hashv);
    _hj_j = (_hj_i << 10) ^ (_hj_j - _hf_hashv - _hj_i);
    _hf_hashv = (_hj_j >> 15) ^ (_hf_hashv - _hj_i - _hj_j);
    _hj_key += 12;
  }
  _hf_hashv += strlen((const char *)hexstr);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      goto LABEL_9;
    case 8u:
      goto LABEL_8;
    case 9u:
      goto LABEL_7;
    case 0xAu:
      goto LABEL_6;
    case 0xBu:
      _hf_hashv += _hj_key[10] << 24;
LABEL_6:
      _hf_hashv += _hj_key[9] << 16;
LABEL_7:
      _hf_hashv += _hj_key[8] << 8;
LABEL_8:
      _hj_j += _hj_key[7] << 24;
LABEL_9:
      _hj_j += _hj_key[6] << 16;
LABEL_10:
      _hj_j += _hj_key[5] << 8;
LABEL_11:
      _hj_j += _hj_key[4];
LABEL_12:
      _hj_i += _hj_key[3] << 24;
LABEL_13:
      _hj_i += _hj_key[2] << 16;
LABEL_14:
      _hj_i += _hj_key[1] << 8;
LABEL_15:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_i = (_hf_hashv >> 13) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 8) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 13) ^ (_hf_hashv - _hj_i - _hj_j);
  _hj_i = (_hf_hashv >> 12) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 16) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 5) ^ (_hf_hashv - _hj_i - _hj_j);
  _hj_i = (_hf_hashv >> 3) ^ (_hj_i - _hj_j - _hf_hashv);
  _hj_j = (_hj_i << 10) ^ (_hj_j - _hf_hashv - _hj_i);
  _hf_hashv = (_hj_j >> 15) ^ (_hf_hashv - _hj_i - _hj_j);
  s = 0;
  if ( blocks )
  {
    _hf_bkt = (blocks->hh.tbl->num_buckets - 1) & _hf_hashv;
    if ( blocks->hh.tbl->buckets[_hf_bkt].hh_head )
      s = (block *)((char *)blocks->hh.tbl->buckets[_hf_bkt].hh_head - blocks->hh.tbl->hho);
    else
      s = 0;
    while ( s )
    {
      if ( _hf_hashv == s->hh.hashv && s->hh.keylen == strlen((const char *)hexstr) )
      {
        v3 = strlen((const char *)hexstr);
        if ( !memcmp(s->hh.key, hexstr, v3) )
          break;
      }
      if ( s->hh.hh_next )
        s = (block *)((char *)s->hh.hh_next - blocks->hh.tbl->hho);
      else
        s = 0;
    }
  }
  if ( !s )
  {
    s = (block *)cgcalloc(104, 1u, "cgminer.c", _func___15570, 5554);
    if ( !s )
    {
      strcpy((char *)tmp42, "block_exists OOM");
      applog(3, tmp42, 1);
      quit(1);
    }
    strcpy((char *)s, (const char *)hexstr);
    v4 = new_blocks++;
    s->block_no = v4;
    ret = 0;
    if ( blocks && blocks->hh.tbl->num_items > 3 )
    {
      if ( blocks )
      {
        _hs_insize = 1;
        _hs_looping = 1;
        _hs_list = &blocks->hh;
        while ( _hs_looping )
        {
          _hs_p = _hs_list;
          _hs_list = 0;
          _hs_tail = 0;
          _hs_nmerges = 0;
          while ( _hs_p )
          {
            ++_hs_nmerges;
            _hs_q = _hs_p;
            _hs_psize = 0;
            for ( _hs_i = 0; _hs_i < _hs_insize; ++_hs_i )
            {
              ++_hs_psize;
              v5 = _hs_q->next ? (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho) : 0;
              _hs_q = v5;
              if ( !v5 )
                break;
            }
            _hs_qsize = _hs_insize;
            while ( _hs_psize || _hs_qsize && _hs_q )
            {
              if ( _hs_psize )
              {
                if ( _hs_qsize && _hs_q )
                {
                  if ( block_sort(
                         (block *)((char *)_hs_p - blocks->hh.tbl->hho),
                         (block *)((char *)_hs_q - blocks->hh.tbl->hho)) > 0 )
                  {
                    _hs_e = _hs_q;
                    if ( _hs_q->next )
                      v9 = (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho);
                    else
                      v9 = 0;
                    _hs_q = v9;
                    --_hs_qsize;
                  }
                  else
                  {
                    _hs_e = _hs_p;
                    if ( _hs_p )
                    {
                      if ( _hs_p->next )
                        v8 = (UT_hash_handle *)((char *)_hs_p->next + blocks->hh.tbl->hho);
                      else
                        v8 = 0;
                      _hs_p = v8;
                    }
                    --_hs_psize;
                  }
                }
                else
                {
                  _hs_e = _hs_p;
                  if ( _hs_p )
                  {
                    if ( _hs_p->next )
                      v7 = (UT_hash_handle *)((char *)_hs_p->next + blocks->hh.tbl->hho);
                    else
                      v7 = 0;
                    _hs_p = v7;
                  }
                  --_hs_psize;
                }
              }
              else
              {
                _hs_e = _hs_q;
                if ( _hs_q->next )
                  v6 = (UT_hash_handle *)((char *)_hs_q->next + blocks->hh.tbl->hho);
                else
                  v6 = 0;
                _hs_q = v6;
                --_hs_qsize;
              }
              if ( _hs_tail )
              {
                if ( _hs_e )
                  v10 = (char *)_hs_e - blocks->hh.tbl->hho;
                else
                  v10 = 0;
                _hs_tail->next = v10;
              }
              else
              {
                _hs_list = _hs_e;
              }
              if ( _hs_e )
              {
                if ( _hs_tail )
                  v11 = (char *)_hs_tail - blocks->hh.tbl->hho;
                else
                  v11 = 0;
                _hs_e->prev = v11;
              }
              _hs_tail = _hs_e;
            }
            _hs_p = _hs_q;
          }
          if ( _hs_tail )
            _hs_tail->next = 0;
          if ( _hs_nmerges <= 1 )
          {
            _hs_looping = 0;
            blocks->hh.tbl->tail = _hs_tail;
            blocks = (block *)((char *)_hs_list - blocks->hh.tbl->hho);
          }
          _hs_insize *= 2;
        }
      }
      oldblock = blocks;
      deleted_block = blocks->block_no;
      if ( blocks->hh.prev || oldblock->hh.next )
      {
        _hd_hh_del = &oldblock->hh;
        if ( oldblock == (block *)((char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho) )
          blocks->hh.tbl->tail = (UT_hash_handle *)((char *)oldblock->hh.prev + blocks->hh.tbl->hho);
        if ( oldblock->hh.prev )
          *(_DWORD *)((char *)oldblock->hh.prev + blocks->hh.tbl->hho + 8) = oldblock->hh.next;
        else
          blocks = (block *)oldblock->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + blocks->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (blocks->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v12 = &blocks->hh.tbl->buckets[_hd_bkt];
        --v12->count;
        if ( _hd_hh_del == blocks->hh.tbl->buckets[_hd_bkt].hh_head )
          blocks->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --blocks->hh.tbl->num_items;
      }
      else
      {
        free(blocks->hh.tbl->buckets);
        free(blocks->hh.tbl);
        blocks = 0;
      }
      free(oldblock);
    }
    _hj_key_0 = (const unsigned __int8 *)s;
    _ha_hashv = -17973521;
    _hj_j_0 = -1640531527;
    _hj_i_0 = -1640531527;
    for ( _hj_k_0 = strlen((const char *)s); _hj_k_0 > 0xB; _hj_k_0 -= 12 )
    {
      _hj_i_0 += *_hj_key_0 + (_hj_key_0[1] << 8) + (_hj_key_0[2] << 16) + (_hj_key_0[3] << 24);
      _hj_j_0 += _hj_key_0[4] + (_hj_key_0[5] << 8) + (_hj_key_0[6] << 16) + (_hj_key_0[7] << 24);
      _ha_hashv += _hj_key_0[8] + (_hj_key_0[9] << 8) + (_hj_key_0[10] << 16) + (_hj_key_0[11] << 24);
      _hj_i_0 = (_ha_hashv >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 8) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 13) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_i_0 = (_ha_hashv >> 12) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 16) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 5) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_i_0 = (_ha_hashv >> 3) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
      _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
      _hj_key_0 += 12;
    }
    _ha_hashv += strlen((const char *)s);
    switch ( _hj_k_0 )
    {
      case 1u:
        goto LABEL_122;
      case 2u:
        goto LABEL_121;
      case 3u:
        goto LABEL_120;
      case 4u:
        goto LABEL_119;
      case 5u:
        goto LABEL_118;
      case 6u:
        goto LABEL_117;
      case 7u:
        goto LABEL_116;
      case 8u:
        goto LABEL_115;
      case 9u:
        goto LABEL_114;
      case 0xAu:
        goto LABEL_113;
      case 0xBu:
        _ha_hashv += _hj_key_0[10] << 24;
LABEL_113:
        _ha_hashv += _hj_key_0[9] << 16;
LABEL_114:
        _ha_hashv += _hj_key_0[8] << 8;
LABEL_115:
        _hj_j_0 += _hj_key_0[7] << 24;
LABEL_116:
        _hj_j_0 += _hj_key_0[6] << 16;
LABEL_117:
        _hj_j_0 += _hj_key_0[5] << 8;
LABEL_118:
        _hj_j_0 += _hj_key_0[4];
LABEL_119:
        _hj_i_0 += _hj_key_0[3] << 24;
LABEL_120:
        _hj_i_0 += _hj_key_0[2] << 16;
LABEL_121:
        _hj_i_0 += _hj_key_0[1] << 8;
LABEL_122:
        _hj_i_0 += *_hj_key_0;
        break;
      default:
        break;
    }
    _hj_i_0 = (_ha_hashv >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 8) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 13) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    _hj_i_0 = (_ha_hashv >> 12) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 16) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 5) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    _hj_i_0 = (_ha_hashv >> 3) ^ (_hj_i_0 - _hj_j_0 - _ha_hashv);
    _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0 - _ha_hashv - _hj_i_0);
    _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashv - _hj_i_0 - _hj_j_0);
    s->hh.hashv = _ha_hashv;
    s->hh.key = s;
    s->hh.keylen = strlen((const char *)s);
    if ( blocks )
    {
      s->hh.tbl = blocks->hh.tbl;
      s->hh.next = 0;
      s->hh.prev = (char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho;
      blocks->hh.tbl->tail->next = s;
      blocks->hh.tbl->tail = &s->hh;
    }
    else
    {
      s->hh.next = 0;
      s->hh.prev = 0;
      blocks = s;
      s->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !blocks->hh.tbl )
        exit(-1);
      memset(blocks->hh.tbl, 0, sizeof(UT_hash_table));
      blocks->hh.tbl->tail = &blocks->hh;
      blocks->hh.tbl->num_buckets = 32;
      blocks->hh.tbl->log2_num_buckets = 5;
      blocks->hh.tbl->hho = 68;
      tbl = blocks->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !blocks->hh.tbl->buckets )
        exit(-1);
      memset(blocks->hh.tbl->buckets, 0, 0x180u);
      blocks->hh.tbl->signature = -1609490463;
    }
    ++blocks->hh.tbl->num_items;
    _ha_bkt = (blocks->hh.tbl->num_buckets - 1) & _ha_hashv;
    v14 = &blocks->hh.tbl->buckets[_ha_bkt];
    ++v14->count;
    s->hh.hh_next = blocks->hh.tbl->buckets[_ha_bkt].hh_head;
    s->hh.hh_prev = 0;
    if ( blocks->hh.tbl->buckets[_ha_bkt].hh_head )
      blocks->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &s->hh;
    blocks->hh.tbl->buckets[_ha_bkt].hh_head = &s->hh;
    if ( blocks->hh.tbl->buckets[_ha_bkt].count >= 10 * (blocks->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && s->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * s->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * s->hh.tbl->num_buckets);
      s->hh.tbl->ideal_chain_maxlen = (((2 * s->hh.tbl->num_buckets - 1) & s->hh.tbl->num_items) != 0)
                                    + (s->hh.tbl->num_items >> (s->hh.tbl->log2_num_buckets + 1));
      s->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; _he_bkt_i < s->hh.tbl->num_buckets; ++_he_bkt_i )
      {
        for ( _he_thh = s->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_bkt = (2 * s->hh.tbl->num_buckets - 1) & _he_thh->hashv;
          _he_newbkt = &_he_new_buckets[_he_bkt];
          if ( ++_he_newbkt->count > s->hh.tbl->ideal_chain_maxlen )
          {
            ++s->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / s->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(s->hh.tbl->buckets);
      s->hh.tbl->num_buckets *= 2;
      ++s->hh.tbl->log2_num_buckets;
      s->hh.tbl->buckets = _he_new_buckets;
      if ( s->hh.tbl->nonideal_items <= s->hh.tbl->num_items >> 1 )
        v15 = 0;
      else
        v15 = s->hh.tbl->ineff_expands + 1;
      s->hh.tbl->ineff_expands = v15;
      if ( s->hh.tbl->ineff_expands > 1 )
        s->hh.tbl->noexpand = 1;
    }
    set_blockdiff(work);
    if ( deleted_block && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", deleted_block);
      applog(7, tmp42, 0);
    }
  }
  wr_unlock(&blk_lock, "cgminer.c", _func___15570, 5588);
  if ( !ret )
    set_curblock(hexstr, bedata);
  if ( deleted_block && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Deleted block %d from database", deleted_block);
    applog(7, tmp42, 0);
  }
  return ret;
}
// 50154: control flows out of bounds to 50158
// 511A8: control flows out of bounds to 511AC

//----- (00051DD4) --------------------------------------------------------
bool __cdecl test_work_current(work *work)
{
  const char *v2; // r3
  pool *v3; // r4
  const char *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-884h] BYREF
  uint32_t height; // [sp+810h] [bp-84h] BYREF
  unsigned __int8 hexstr[68]; // [sp+814h] [bp-80h] BYREF
  unsigned __int8 bedata[32]; // [sp+858h] [bp-3Ch] BYREF
  uint8_t cb_height_sz; // [sp+87Bh] [bp-19h]
  unsigned __int8 *bin_height; // [sp+87Ch] [bp-18h]
  pool *pool; // [sp+880h] [bp-14h]
  bool ret; // [sp+887h] [bp-Dh]

  pool = work->pool;
  ret = 1;
  bin_height = pool->coinbase + 43;
  cb_height_sz = *(bin_height - 1);
  height = 0;
  if ( !work->mandatory )
  {
    swap256(bedata, &work->data[4]);
    _bin2hex(hexstr, bedata, 0x20u);
    if ( cb_height_sz <= 4u )
    {
      cg_memcpy(&height, bin_height, cb_height_sz, "cgminer.c", _func___15665, 5624);
      height = _uint32_identity_0(height) - 1;
    }
    cg_wlock_1(&pool->data_lock, "cgminer.c", _func___15665, 5629);
    if ( pool->swork.clean )
    {
      pool->swork.clean = 0;
      work->longpoll = 1;
    }
    cg_wunlock_1(&pool->data_lock, "cgminer.c", _func___15665, 5637);
    if ( !block_exists(hexstr, bedata, work) )
    {
      cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", _func___15665, 5645);
      if ( new_blocks == 1 )
      {
        ret = 0;
out:
        work->longpoll = 0;
        return ret;
      }
      work->work_block = ++work_block;
      if ( work->longpoll )
      {
        if ( work->stratum )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Stratum from pool %d detected new block at height %d",
              pool->pool_no,
              height);
            applog(5, tmp42, 0);
          }
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          if ( work->gbt )
            v2 = "GBT ";
          else
            v2 = (const char *)&unk_A1BD4;
          snprintf((char *)tmp42, 0x800u, "%sLONGPOLL from pool %d detected new block", v2, work->pool->pool_no);
          applog(5, tmp42, 0);
        }
      }
      else if ( have_longpoll && !pool->gbt_solo )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy((char *)tmp42, "New block detected on network before pool notification");
          applog(5, tmp42, 0);
        }
      }
      else if ( !pool->gbt_solo && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        strcpy((char *)tmp42, "New block detected on network");
        applog(5, tmp42, 0);
      }
    }
    else
    {
      if ( memcmp(pool->prev_block, bedata, 0x20u) )
      {
        if ( !memcmp(bedata, current_block, 0x20u) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 5 )
          {
            snprintf((char *)tmp42, 0x800u, "Pool %d now up to date at height %d", pool->pool_no, height);
            applog(6, tmp42, 0);
          }
          cg_memcpy(pool->prev_block, bedata, 0x20u, "cgminer.c", _func___15665, 5695);
        }
        else
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "Stale data from pool %d at height %d", pool->pool_no, height);
            applog(7, tmp42, 0);
          }
          ret = 0;
        }
      }
      if ( !work->longpoll )
        goto out;
      work->work_block = ++work_block;
      if ( !shared_strategy() )
      {
        v3 = work->pool;
        if ( v3 != current_pool() )
          goto out;
      }
      if ( work->stratum )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf((char *)tmp42, 0x800u, "Stratum from pool %d requested work restart", pool->pool_no);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        if ( work->gbt )
          v4 = "GBT ";
        else
          v4 = (const char *)&unk_A1BD4;
        snprintf((char *)tmp42, 0x800u, "%sLONGPOLL from pool %d requested work restart", v4, work->pool->pool_no);
        applog(5, tmp42, 0);
      }
    }
    restart_threads();
    goto out;
  }
  return ret;
}

//----- (0005261C) --------------------------------------------------------
int __cdecl tv_sort(work *worka, work *workb)
{
  return worka->tv_staged.tv_sec - workb->tv_staged.tv_sec;
}

//----- (00052654) --------------------------------------------------------
bool __cdecl work_rollable(work *work)
{
  return !work->clone && work->rolltime;
}
// 526A0: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (000526B0) --------------------------------------------------------
bool __cdecl hash_push(work *work)
{
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v2; // r3
  unsigned int v3; // r3
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  char *v9; // r3
  char *v10; // r3
  UT_hash_bucket_0 *_he_newbkt; // [sp+8h] [bp-6Ch]
  UT_hash_handle *_he_hh_nxt; // [sp+10h] [bp-64h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+14h] [bp-60h]
  unsigned int _ha_bkt; // [sp+18h] [bp-5Ch]
  UT_hash_handle *_hs_tail; // [sp+1Ch] [bp-58h]
  UT_hash_handle *_hs_list; // [sp+20h] [bp-54h]
  UT_hash_handle *_hs_e; // [sp+24h] [bp-50h]
  UT_hash_handle *_hs_q; // [sp+28h] [bp-4Ch]
  UT_hash_handle *_hs_p; // [sp+2Ch] [bp-48h]
  unsigned int _hs_qsize; // [sp+30h] [bp-44h]
  unsigned int _hs_psize; // [sp+34h] [bp-40h]
  unsigned int _hs_insize; // [sp+38h] [bp-3Ch]
  unsigned int _hs_nmerges; // [sp+3Ch] [bp-38h]
  unsigned int _hs_looping; // [sp+40h] [bp-34h]
  unsigned int _hs_i; // [sp+44h] [bp-30h]
  UT_hash_handle *_he_thh; // [sp+48h] [bp-2Ch]
  unsigned int _he_bkt_i; // [sp+4Ch] [bp-28h]
  unsigned int _hj_j; // [sp+58h] [bp-1Ch]
  unsigned int _hj_ja; // [sp+58h] [bp-1Ch]
  int _hj_i; // [sp+5Ch] [bp-18h]
  int _hj_ia; // [sp+5Ch] [bp-18h]
  int _hj_ib; // [sp+5Ch] [bp-18h]
  unsigned int _ha_hashva; // [sp+60h] [bp-14h]
  unsigned int _ha_hashvb; // [sp+60h] [bp-14h]
  unsigned int _ha_hashv; // [sp+60h] [bp-14h]
  bool rc; // [sp+67h] [bp-Dh]

  rc = 1;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___15686, 5751);
  if ( work_rollable(work) )
    ++staged_rollable;
  if ( !getq->frozen )
  {
    _hj_i = ((HIBYTE(work->id) << 24) + (BYTE2(work->id) << 16) + (BYTE1(work->id) << 8) + LOBYTE(work->id) + 17973517) ^ 0x7F76D;
    _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
    _ha_hashva = (_hj_j >> 13) ^ (-17973517 - _hj_i - _hj_j);
    _hj_ia = (_ha_hashva >> 12) ^ (_hj_i - _hj_j - _ha_hashva);
    _hj_ja = (_hj_ia << 16) ^ (_hj_j - _ha_hashva - _hj_ia);
    _ha_hashvb = (_hj_ja >> 5) ^ (_ha_hashva - _hj_ia - _hj_ja);
    _hj_ib = (_ha_hashvb >> 3) ^ (_hj_ia - _hj_ja - _ha_hashvb);
    _ha_hashv = (((_hj_ib << 10) ^ (_hj_ja - _ha_hashvb - _hj_ib)) >> 15) ^ (_ha_hashvb
                                                                           - _hj_ib
                                                                           - ((_hj_ib << 10) ^ (_hj_ja
                                                                                              - _ha_hashvb
                                                                                              - _hj_ib)));
    work->hh.hashv = _ha_hashv;
    work->hh.key = &work->id;
    work->hh.keylen = 4;
    if ( staged_work )
    {
      work->hh.tbl = staged_work->hh.tbl;
      work->hh.next = 0;
      work->hh.prev = (char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho;
      staged_work->hh.tbl->tail->next = work;
      staged_work->hh.tbl->tail = &work->hh;
    }
    else
    {
      work->hh.next = 0;
      work->hh.prev = 0;
      staged_work = work;
      work->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !staged_work->hh.tbl )
        exit(-1);
      memset(staged_work->hh.tbl, 0, sizeof(UT_hash_table));
      staged_work->hh.tbl->tail = &staged_work->hh;
      staged_work->hh.tbl->num_buckets = 32;
      staged_work->hh.tbl->log2_num_buckets = 5;
      staged_work->hh.tbl->hho = 344;
      tbl = staged_work->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !staged_work->hh.tbl->buckets )
        exit(-1);
      memset(staged_work->hh.tbl->buckets, 0, 0x180u);
      staged_work->hh.tbl->signature = -1609490463;
    }
    ++staged_work->hh.tbl->num_items;
    _ha_bkt = (staged_work->hh.tbl->num_buckets - 1) & _ha_hashv;
    v2 = &staged_work->hh.tbl->buckets[_ha_bkt];
    ++v2->count;
    work->hh.hh_next = staged_work->hh.tbl->buckets[_ha_bkt].hh_head;
    work->hh.hh_prev = 0;
    if ( staged_work->hh.tbl->buckets[_ha_bkt].hh_head )
      staged_work->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &work->hh;
    staged_work->hh.tbl->buckets[_ha_bkt].hh_head = &work->hh;
    if ( staged_work->hh.tbl->buckets[_ha_bkt].count >= 10 * (staged_work->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && work->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * work->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * work->hh.tbl->num_buckets);
      work->hh.tbl->ideal_chain_maxlen = (((2 * work->hh.tbl->num_buckets - 1) & work->hh.tbl->num_items) != 0)
                                       + (work->hh.tbl->num_items >> (work->hh.tbl->log2_num_buckets + 1));
      work->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; _he_bkt_i < work->hh.tbl->num_buckets; ++_he_bkt_i )
      {
        for ( _he_thh = work->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_newbkt = &_he_new_buckets[(2 * work->hh.tbl->num_buckets - 1) & _he_thh->hashv];
          if ( ++_he_newbkt->count > work->hh.tbl->ideal_chain_maxlen )
          {
            ++work->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / work->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(work->hh.tbl->buckets);
      work->hh.tbl->num_buckets *= 2;
      ++work->hh.tbl->log2_num_buckets;
      work->hh.tbl->buckets = _he_new_buckets;
      if ( work->hh.tbl->nonideal_items <= work->hh.tbl->num_items >> 1 )
        v3 = 0;
      else
        v3 = work->hh.tbl->ineff_expands + 1;
      work->hh.tbl->ineff_expands = v3;
      if ( work->hh.tbl->ineff_expands > 1 )
        work->hh.tbl->noexpand = 1;
    }
    if ( staged_work )
    {
      _hs_insize = 1;
      _hs_looping = 1;
      _hs_list = &staged_work->hh;
      while ( _hs_looping )
      {
        _hs_p = _hs_list;
        _hs_list = 0;
        _hs_tail = 0;
        _hs_nmerges = 0;
        while ( _hs_p )
        {
          ++_hs_nmerges;
          _hs_q = _hs_p;
          _hs_psize = 0;
          for ( _hs_i = 0; _hs_i < _hs_insize; ++_hs_i )
          {
            ++_hs_psize;
            v4 = _hs_q->next ? (int)_hs_q->next + staged_work->hh.tbl->hho : 0;
            _hs_q = (UT_hash_handle *)v4;
            if ( !v4 )
              break;
          }
          _hs_qsize = _hs_insize;
          while ( _hs_psize || _hs_qsize && _hs_q )
          {
            if ( _hs_psize )
            {
              if ( _hs_qsize && _hs_q )
              {
                if ( tv_sort(
                       (work *)((char *)_hs_p - staged_work->hh.tbl->hho),
                       (work *)((char *)_hs_q - staged_work->hh.tbl->hho)) > 0 )
                {
                  _hs_e = _hs_q;
                  if ( _hs_q->next )
                    v8 = (int)_hs_q->next + staged_work->hh.tbl->hho;
                  else
                    v8 = 0;
                  _hs_q = (UT_hash_handle *)v8;
                  --_hs_qsize;
                }
                else
                {
                  _hs_e = _hs_p;
                  if ( _hs_p )
                  {
                    if ( _hs_p->next )
                      v7 = (int)_hs_p->next + staged_work->hh.tbl->hho;
                    else
                      v7 = 0;
                    _hs_p = (UT_hash_handle *)v7;
                  }
                  --_hs_psize;
                }
              }
              else
              {
                _hs_e = _hs_p;
                if ( _hs_p )
                {
                  if ( _hs_p->next )
                    v6 = (int)_hs_p->next + staged_work->hh.tbl->hho;
                  else
                    v6 = 0;
                  _hs_p = (UT_hash_handle *)v6;
                }
                --_hs_psize;
              }
            }
            else
            {
              _hs_e = _hs_q;
              if ( _hs_q->next )
                v5 = (int)_hs_q->next + staged_work->hh.tbl->hho;
              else
                v5 = 0;
              _hs_q = (UT_hash_handle *)v5;
              --_hs_qsize;
            }
            if ( _hs_tail )
            {
              if ( _hs_e )
                v9 = (char *)_hs_e - staged_work->hh.tbl->hho;
              else
                v9 = 0;
              _hs_tail->next = v9;
            }
            else
            {
              _hs_list = _hs_e;
            }
            if ( _hs_e )
            {
              if ( _hs_tail )
                v10 = (char *)_hs_tail - staged_work->hh.tbl->hho;
              else
                v10 = 0;
              _hs_e->prev = v10;
            }
            _hs_tail = _hs_e;
          }
          _hs_p = _hs_q;
        }
        if ( _hs_tail )
          _hs_tail->next = 0;
        if ( _hs_nmerges <= 1 )
        {
          _hs_looping = 0;
          staged_work->hh.tbl->tail = _hs_tail;
          staged_work = (work *)((char *)_hs_list - staged_work->hh.tbl->hho);
        }
        _hs_insize *= 2;
      }
    }
  }
  else
  {
    rc = 0;
  }
  pthread_cond_broadcast(&getq->cond);
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___15686, 5769);
  return rc;
}
// 52A8C: control flows out of bounds to 52A90
// 52A6C: conditional instruction was optimized away because %_hj_k.4==4

//----- (000539CC) --------------------------------------------------------
void __cdecl stage_work(work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-804h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Pushing work from pool %d to hash queue", work->pool->pool_no);
    applog(7, tmp42, 0);
  }
  work->work_block = work_block;
  test_work_current(work);
  ++work->pool->works;
  hash_push(work);
}

//----- (00053AB0) --------------------------------------------------------
void __cdecl remove_pool(pool *pool)
{
  pool *other; // [sp+Ch] [bp-10h]
  int last_pool; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  last_pool = total_pools - 1;
  for ( i = 0; i < total_pools; ++i )
  {
    other = pools[i];
    if ( other->prio > pool->prio )
      --other->prio;
  }
  if ( last_pool > pool->pool_no )
  {
    pools[last_pool]->pool_no = pool->pool_no;
    pools[pool->pool_no] = pools[last_pool];
  }
  pool->pool_no = total_pools;
  pool->removed = 1;
  --total_pools;
}

//----- (00053C14) --------------------------------------------------------
void json_escape_free()
{
  JE *jenext; // [sp+0h] [bp-Ch]
  JE *jeptr; // [sp+4h] [bp-8h]

  jeptr = jedata;
  jedata = 0;
  while ( jeptr )
  {
    jenext = jeptr->next;
    free(jeptr->buf);
    free(jeptr);
    jeptr = jenext;
  }
}

//----- (00053C88) --------------------------------------------------------
unsigned __int8 *__cdecl json_escape(unsigned __int8 *str)
{
  size_t v1; // r0
  JE *v2; // r0
  unsigned __int8 *v3; // r3
  unsigned __int8 *v4; // r2
  unsigned __int8 *v5; // r3
  unsigned __int8 *stra; // [sp+4h] [bp-18h]
  unsigned __int8 *buf; // [sp+10h] [bp-Ch]
  unsigned __int8 *ptr; // [sp+14h] [bp-8h]

  stra = str;
  v1 = strlen((const char *)str);
  buf = (unsigned __int8 *)cgmalloc(2 * v1 + 1, "cgminer.c", _func___15772, 5895);
  ptr = buf;
  v2 = (JE *)cgmalloc(8u, "cgminer.c", _func___15772, 5896);
  v2->buf = buf;
  v2->next = jedata;
  jedata = v2;
  while ( *stra )
  {
    if ( *stra == 92 || *stra == 34 )
    {
      v3 = ptr++;
      *v3 = 92;
    }
    v4 = stra++;
    v5 = ptr++;
    *v5 = *v4;
  }
  *ptr = 0;
  return buf;
}

//----- (00053DA4) --------------------------------------------------------
void __cdecl write_config(FILE *fcfg)
{
  const char *v1; // r5
  unsigned __int8 *v2; // r0
  unsigned __int8 *v3; // r7
  unsigned __int8 *v4; // r6
  const char *v5; // r4
  int quota; // r8
  unsigned __int8 *v7; // r0
  const char *v8; // r5
  unsigned __int8 *v9; // r0
  unsigned __int8 *v10; // r7
  unsigned __int8 *v11; // r6
  const char *v12; // r4
  unsigned __int8 *v13; // r0
  unsigned __int8 *v14; // r0
  unsigned __int8 *v15; // r0
  unsigned __int8 *v16; // r0
  pool *pool; // [sp+18h] [bp-34h]
  unsigned __int8 *carg; // [sp+1Ch] [bp-30h]
  char *name; // [sp+20h] [bp-2Ch]
  unsigned __int8 *p; // [sp+24h] [bp-28h]
  int i; // [sp+28h] [bp-24h]
  opt_table *opt; // [sp+2Ch] [bp-20h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, fcfg);
  for ( i = 0; i < total_pools; ++i )
  {
    pool = priority_pool(i);
    if ( pool->quota == 1 )
    {
      if ( i <= 0 )
        v8 = (const char *)byte_A1BD4;
      else
        v8 = ",";
      if ( pool->rpc_proxy )
      {
        v9 = (unsigned __int8 *)proxytype(pool->rpc_proxytype);
        v10 = json_escape(v9);
      }
      else
      {
        v10 = byte_A1BD4;
      }
      if ( pool->rpc_proxy )
        v11 = json_escape(pool->rpc_proxy);
      else
        v11 = byte_A1BD4;
      if ( pool->rpc_proxy )
        v12 = "|";
      else
        v12 = (const char *)byte_A1BD4;
      v13 = json_escape(pool->rpc_url);
      fprintf(
        fcfg,
        "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",",
        v8,
        (const char *)v10,
        (const char *)v11,
        v12,
        (const char *)v13);
    }
    else
    {
      if ( i <= 0 )
        v1 = (const char *)byte_A1BD4;
      else
        v1 = ",";
      if ( pool->rpc_proxy )
      {
        v2 = (unsigned __int8 *)proxytype(pool->rpc_proxytype);
        v3 = json_escape(v2);
      }
      else
      {
        v3 = byte_A1BD4;
      }
      if ( pool->rpc_proxy )
        v4 = json_escape(pool->rpc_proxy);
      else
        v4 = byte_A1BD4;
      if ( pool->rpc_proxy )
        v5 = "|";
      else
        v5 = (const char *)byte_A1BD4;
      quota = pool->quota;
      v7 = json_escape(pool->rpc_url);
      fprintf(
        fcfg,
        "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",",
        v1,
        (const char *)v3,
        (const char *)v4,
        v5,
        quota,
        (const char *)v7);
    }
    if ( pool->extranonce_subscribe )
      fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 0x21u, fcfg);
    v14 = json_escape(pool->rpc_user);
    fprintf(fcfg, "\n\t\t\"user\" : \"%s\",", (const char *)v14);
    v15 = json_escape(pool->rpc_pass);
    fprintf(fcfg, "\n\t\t\"pass\" : \"%s\"\n\t}", (const char *)v15);
  }
  fwrite("\n]\n", 1u, 3u, fcfg);
  for ( opt = opt_config_table; opt->type != OPT_END; ++opt )
  {
    name = strdup((const char *)opt->names);
    for ( p = (unsigned __int8 *)strtok(name, "|"); p; p = (unsigned __int8 *)strtok(0, "|") )
    {
      if ( p[1] == 45 && opt->desc != opt_hidden )
      {
        if ( (opt->type & 1) != 0
          && ((unsigned __int8 *(__cdecl *)(bool *))opt->cb == opt_set_bool
           || (unsigned __int8 *(__cdecl *)(bool *))opt->cb == opt_set_invbool)
          && *(_BYTE *)opt->u.carg == (opt->cb == (unsigned __int8 *(*)(void *))opt_set_bool) )
        {
          fprintf(fcfg, ",\n\"%s\" : true", (const char *)p + 2);
        }
        else if ( (opt->type & 2) != 0
               && ((unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == opt_set_intval
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_9999
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_65535
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_10
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_10
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_100
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_255
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_1_to_255
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_7680
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_200
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_0_to_4
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_32_to_63
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_22_to_75
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_42_to_85
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_22_to_55
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, int *))opt->cb_arg == set_int_42_to_65) )
        {
          fprintf(fcfg, ",\n\"%s\" : \"%d\"", (const char *)p + 2, *(_DWORD *)opt->u.carg);
        }
        else if ( (opt->type & 2) != 0
               && ((unsigned __int8 *(__cdecl *)(const unsigned __int8 *, float *))opt->cb_arg == set_float_125_to_500
                || (unsigned __int8 *(__cdecl *)(const unsigned __int8 *, float *))opt->cb_arg == set_float_100_to_250) )
        {
          fprintf(fcfg, ",\n\"%s\" : \"%.1f\"", (const char *)p + 2, *(float *)opt->u.carg);
        }
        else if ( (opt->type & 6) != 0 && opt->u.carg != &opt_set_null )
        {
          carg = *(unsigned __int8 **)opt->u.carg;
          if ( carg )
          {
            v16 = json_escape(carg);
            fprintf(fcfg, ",\n\"%s\" : \"%s\"", (const char *)p + 2, (const char *)v16);
          }
        }
      }
    }
    free(name);
  }
  if ( pool_strategy_0 == POOL_BALANCE )
    fwrite(",\n\"balance\" : true", 1u, 0x12u, fcfg);
  if ( pool_strategy_0 == POOL_LOADBALANCE )
    fwrite(",\n\"load-balance\" : true", 1u, 0x17u, fcfg);
  if ( pool_strategy_0 == POOL_ROUNDROBIN )
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, fcfg);
  if ( pool_strategy_0 == POOL_ROTATE )
    fprintf(fcfg, ",\n\"rotate\" : \"%d\"", opt_rotate_period);
  fwrite("\n}\n", 1u, 3u, fcfg);
  json_escape_free();
}
// A1BD4: using guessed type unsigned __int8 byte_A1BD4[4];

//----- (0005456C) --------------------------------------------------------
void zero_bestshare()
{
  int i; // [sp+Ch] [bp-8h]

  best_diff = 0LL;
  memset(best_share, 0, sizeof(best_share));
  suffix_string(0LL, best_share, 8u, 0);
  for ( i = 0; i < total_pools; ++i )
    pools[i]->best_diff = 0LL;
}

//----- (00054638) --------------------------------------------------------
void zero_stats()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-858h] BYREF
  sysinfo sInfo; // [sp+80Ch] [bp-58h] BYREF
  pool *pool; // [sp+84Ch] [bp-18h]
  cgpu_info *cgpu; // [sp+850h] [bp-14h]
  int i; // [sp+854h] [bp-10h]

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v0 = *_errno_location();
      v1 = _errno_location();
      v2 = strerror(*v1);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v2);
      applog(6, tmp42, 0);
    }
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
  }
  cgtime(&total_tv_start);
  copy_time(&tv_hashmeter, &total_tv_start);
  total_rolling = 0.0;
  rolling1 = 0.0;
  rolling5 = 0.0;
  rolling15 = 0.0;
  total_mhashes_done = 0.0;
  new_total_mhashes_done = 0.0;
  for ( i = 0; i <= 11; ++i )
    g_local_mhashes_dones[i] = 0.0;
  g_local_mhashes_index = 0;
  g_max_fan = 0;
  g_max_temp = 0;
  total_getworks = 0LL;
  total_accepted = 0LL;
  total_rejected = 0LL;
  hw_errors = 0;
  total_stale = 0LL;
  total_discarded = 0LL;
  local_work = 0;
  total_go = 0;
  total_ro = 0;
  total_secs = 1.0;
  new_total_secs = 1.0;
  last_total_secs = 1.0;
  total_diff1 = 0LL;
  found_blocks = 0;
  total_diff_accepted = 0.0;
  total_diff_rejected = 0.0;
  total_diff_stale = 0.0;
  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->getwork_requested = 0;
    pool->accepted = 0LL;
    pool->rejected = 0LL;
    pool->stale_shares = 0;
    pool->discarded_work = 0;
    pool->getfail_occasions = 0;
    pool->remotefail_occasions = 0;
    pool->last_share_time = 0;
    pool->diff1 = 0LL;
    pool->diff_accepted = 0.0;
    pool->diff_rejected = 0.0;
    pool->diff_stale = 0.0;
    pool->last_share_diff = 0LL;
  }
  zero_bestshare();
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu = get_devices(i);
    copy_time(&cgpu->dev_start_tv, &total_tv_start);
    mutex_lock_1(&hash_lock, "cgminer.c", _func___15819, 6149);
    cgpu->total_mhashes = 0.0;
    cgpu->accepted = 0;
    cgpu->rejected = 0;
    cgpu->hw_errors = 0;
    cgpu->utility = 0.0;
    cgpu->last_share_pool_time = 0;
    cgpu->diff1 = 0LL;
    cgpu->diff_accepted = 0.0;
    cgpu->diff_rejected = 0.0;
    cgpu->last_share_diff = 0.0;
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___15819, 6162);
    cgpu->drv->zero_stats(cgpu);
  }
}

//----- (00054BD8) --------------------------------------------------------
void set_highprio()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-808h] BYREF
  int ret; // [sp+804h] [bp-8h]

  ret = nice(-10);
  if ( !ret && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Unable to set thread to high priority");
    applog(7, tmp42, 0);
  }
}

//----- (00054CB4) --------------------------------------------------------
void set_lowprio()
{
  unsigned __int8 tmp42[2048]; // [sp+4h] [bp-808h] BYREF
  int ret; // [sp+804h] [bp-8h]

  ret = nice(10);
  if ( !ret && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    strcpy((char *)tmp42, "Unable to set thread to low priority");
    applog(6, tmp42, 0);
  }
}

//----- (00054D7C) --------------------------------------------------------
void __cdecl default_save_file(unsigned __int8 *filename)
{
  char *v1; // r0

  if ( default_config && *default_config )
  {
    strcpy((char *)filename, (const char *)default_config);
  }
  else
  {
    if ( getenv("HOME") && *getenv("HOME") )
    {
      v1 = getenv("HOME");
      strcpy((char *)filename, v1);
      strcat((char *)filename, "/");
    }
    else
    {
      *filename = 0;
    }
    strcat((char *)filename, ".bmminer/");
    mkdir((const char *)filename, 0x1FFu);
    strcat((char *)filename, "bmminer.conf");
  }
}

//----- (00054EE0) --------------------------------------------------------
void *__cdecl api_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  RenameThread("API");
  set_lowprio();
  api(api_thr_id);
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (00054F54) --------------------------------------------------------
void __cdecl thread_reportin(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 0;
  cgtime(&thr->last);
  thr->cgpu->status = LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00054FB4) --------------------------------------------------------
void __cdecl thread_reportout(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 1;
  cgtime(&thr->last);
  thr->cgpu->status = LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00055018) --------------------------------------------------------
void __cdecl hashmeter(int thr_id, uint64_t hashes_done)
{
  double v2; // d0
  int v3; // r4
  int *v4; // r0
  char *v5; // r0
  double v6; // r2
  double v7; // r2
  double v8; // r2
  double v9; // r2
  double v10; // r2
  uint64_t v11; // r2
  double fsecs; // [sp+0h] [bp-A30h]
  double fsecsa; // [sp+0h] [bp-A30h]
  double fsecsb; // [sp+0h] [bp-A30h]
  double fsecsc; // [sp+0h] [bp-A30h]
  double fsecsd; // [sp+0h] [bp-A30h]
  double fsecse; // [sp+0h] [bp-A30h]
  double fsecsf; // [sp+0h] [bp-A30h]
  double fsecsg; // [sp+0h] [bp-A30h]
  double fsecsh; // [sp+0h] [bp-A30h]
  double fsecsi; // [sp+0h] [bp-A30h]
  double interval; // [sp+8h] [bp-A28h]
  double intervala; // [sp+8h] [bp-A28h]
  double intervalb; // [sp+8h] [bp-A28h]
  double intervalc; // [sp+8h] [bp-A28h]
  double intervald; // [sp+8h] [bp-A28h]
  double intervale; // [sp+8h] [bp-A28h]
  double intervalf; // [sp+8h] [bp-A28h]
  double intervalg; // [sp+8h] [bp-A28h]
  double intervalh; // [sp+8h] [bp-A28h]
  double intervali; // [sp+8h] [bp-A28h]
  int thr_idb; // [sp+24h] [bp-A0Ch]
  unsigned __int8 logline[256]; // [sp+28h] [bp-A08h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+128h] [bp-908h] BYREF
  unsigned __int8 displayed_r15[16]; // [sp+928h] [bp-108h] BYREF
  unsigned __int8 displayed_r5[16]; // [sp+938h] [bp-F8h] BYREF
  unsigned __int8 displayed_r1[16]; // [sp+948h] [bp-E8h] BYREF
  unsigned __int8 displayed_rolling[16]; // [sp+958h] [bp-D8h] BYREF
  unsigned __int8 displayed_hashes[16]; // [sp+968h] [bp-C8h] BYREF
  sysinfo sInfo; // [sp+978h] [bp-B8h] BYREF
  uint64_t d64; // [sp+9B8h] [bp-78h]
  double thr_mhs; // [sp+9C0h] [bp-70h]
  double device_tdiff; // [sp+9C8h] [bp-68h]
  cgpu_info *cgpu; // [sp+9D0h] [bp-60h]
  thr_info *thr; // [sp+9D4h] [bp-5Ch]
  double device_tdiff_0; // [sp+9D8h] [bp-58h]
  cgpu_info *cgpu_0; // [sp+9E0h] [bp-50h]
  thr_info *thr_0; // [sp+9E4h] [bp-4Ch]
  int diff_t; // [sp+9E8h] [bp-48h]
  time_t now_t; // [sp+9ECh] [bp-44h]
  double tv_tdiff; // [sp+9F0h] [bp-40h]
  int i; // [sp+9F8h] [bp-38h]
  int local_mhashes_done_count; // [sp+9FCh] [bp-34h]
  uint64_t local_mhashes_done_avg; // [sp+A00h] [bp-30h]
  uint64_t local_mhashes_done; // [sp+A08h] [bp-28h]
  bool showlog; // [sp+A17h] [bp-19h]

  showlog = 0;
  local_mhashes_done = 0LL;
  local_mhashes_done_avg = 0LL;
  local_mhashes_done_count = 0;
  i = 0;
  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v3 = *_errno_location();
      v4 = _errno_location();
      v5 = strerror(*v4);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v3, v5);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
  }
  cgtime(&total_tv_end);
  tdiff(&total_tv_end, &tv_hashmeter);
  tv_tdiff = v2;
  now_t = total_tv_end.tv_sec;
  diff_t = total_tv_end.tv_sec - hashdisplay_t;
  if ( total_tv_end.tv_sec - hashdisplay_t < opt_log_interval )
  {
    if ( thr_id < 0 )
      return;
  }
  else
  {
    alt_status = switch_status != alt_status;
    hashdisplay_t = now_t;
    showlog = 1;
  }
  copy_time(&tv_hashmeter, &total_tv_end);
  if ( thr_id < 0 )
  {
    mutex_lock_1(&hash_lock, "cgminer.c", _func___15865, 7065);
    for ( thr_idb = 0; thr_idb < mining_threads; ++thr_idb )
    {
      thr_0 = get_thread(thr_idb);
      cgpu_0 = thr_0->cgpu;
      tdiff(&total_tv_end, &cgpu_0->last_message_tv);
      device_tdiff_0 = v2;
      copy_time(&cgpu_0->last_message_tv, &total_tv_end);
      LODWORD(v7) = &cgpu_0->rolling;
      HIDWORD(v7) = opt_log_interval;
      decay_time(&cgpu_0->rolling, v7, fsecs, interval);
      HIDWORD(v8) = &cgpu_0->rolling1;
      decay_time(&cgpu_0->rolling1, v8, fsecsd, intervald);
      HIDWORD(v9) = &cgpu_0->rolling5;
      decay_time(&cgpu_0->rolling5, v9, fsecse, intervale);
      HIDWORD(v10) = &cgpu_0->rolling15;
      v2 = 0.0;
      decay_time(&cgpu_0->rolling15, v10, fsecsf, intervalf);
    }
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___15865, 7080);
  }
  else
  {
    thr = get_thread(thr_id);
    cgpu = thr->cgpu;
    copy_time(&thr->last, &total_tv_end);
    cgpu->device_last_well = now_t;
    tdiff(&total_tv_end, &cgpu->last_message_tv);
    device_tdiff = v2;
    copy_time(&cgpu->last_message_tv, &total_tv_end);
    thr_mhs = (double)hashes_done / device_tdiff / 1000000.0;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "[thread %d: %llu hashes, %.1f mhash/sec]", thr_id, hashes_done, thr_mhs);
      applog(7, tmp42, 0);
    }
    hashes_done /= (unsigned int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377];
    mutex_lock_1(&hash_lock, "cgminer.c", _func___15865, 7036);
    cgpu->total_mhashes = cgpu->total_mhashes + (double)hashes_done;
    HIDWORD(v6) = opt_log_interval;
    decay_time(&cgpu->rolling, v6, fsecs, interval);
    decay_time(&cgpu->rolling1, (double)hashes_done, fsecsa, intervala);
    decay_time(&cgpu->rolling5, (double)hashes_done, fsecsb, intervalb);
    decay_time(&cgpu->rolling15, (double)hashes_done, fsecsc, intervalc);
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___15865, 7043);
    if ( want_per_device_stats && showlog )
    {
      get_statline(logline, 0x100u, cgpu);
      printf("%s          \r", (const char *)logline);
      fflush((FILE *)stdout);
    }
  }
  mutex_lock_1(&hash_lock, "cgminer.c", _func___15865, 7083);
  total_mhashes_done = (double)hashes_done + total_mhashes_done;
  if ( showlog )
  {
    if ( ++g_local_mhashes_index > 11 )
      g_local_mhashes_index = 0;
    for ( i = 0; i <= 11; ++i )
    {
      if ( g_local_mhashes_dones[i] >= 0.0 )
      {
        local_mhashes_done_avg = (unsigned __int64)((double)local_mhashes_done_avg + g_local_mhashes_dones[i]);
        ++local_mhashes_done_count;
      }
    }
    if ( local_mhashes_done_count <= 0 )
    {
      LODWORD(v11) = hashes_done;
      local_mhashes_done = hashes_done;
    }
    else
    {
      v11 = local_mhashes_done_avg / local_mhashes_done_count;
      local_mhashes_done = v11;
    }
    HIDWORD(v11) = opt_log_interval;
    decay_time(&total_rolling, *(double *)&v11, fsecs, interval);
    decay_time(&rolling1, (double)hashes_done, fsecsg, intervalg);
    decay_time(&rolling5, (double)hashes_done, fsecsh, intervalh);
    decay_time(&rolling15, (double)hashes_done, fsecsi, intervali);
    global_hashrate = (unsigned __int64)(total_rolling * 1000000.0);
    g_local_mhashes_dones[g_local_mhashes_index] = 0.0;
  }
  g_local_mhashes_dones[g_local_mhashes_index] = g_local_mhashes_dones[g_local_mhashes_index] + (double)hashes_done;
  total_secs = (double)total_tv_end_sys - (double)total_tv_start_sys;
  if ( (double)total_tv_end_sys - (double)total_tv_start_sys - last_total_secs <= 86400.0 )
  {
    last_total_secs = total_secs;
  }
  else
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "cgminer time error total_secs = %f last_total_secs = %f",
        total_secs,
        last_total_secs);
      applog(3, tmp42, 0);
    }
    mutex_unlock_1(&hash_lock, "cgminer.c", _func___15865, 7131);
    zero_stats();
    mutex_lock_1(&hash_lock, "cgminer.c", _func___15865, 7133);
  }
  if ( showlog )
  {
    d64 = (unsigned __int64)(total_mhashes_done / total_secs * 1000000.0);
    suffix_string(d64, displayed_hashes, 0x10u, 4);
    d64 = (unsigned __int64)(total_rolling * 1000000.0);
    g_displayed_rolling = (double)((int)total_rolling / 10) / 100.0;
    suffix_string(d64, displayed_rolling, 0x10u, 4);
    d64 = (unsigned __int64)(rolling1 * 1000000.0);
    suffix_string(d64, displayed_r1, 0x10u, 4);
    d64 = (unsigned __int64)(rolling5 * 1000000.0);
    suffix_string(d64, displayed_r5, 0x10u, 4);
    d64 = (unsigned __int64)(rolling15 * 1000000.0);
    suffix_string(d64, displayed_r15, 0x10u, 4);
    snprintf(
      (char *)statusline,
      0x100u,
      "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
      opt_log_interval,
      (const char *)displayed_rolling,
      (const char *)displayed_r1,
      (const char *)displayed_r5,
      (const char *)displayed_r15,
      (const char *)displayed_hashes);
  }
  mutex_unlock_1(&hash_lock, "cgminer.c", _func___15865, 7174);
  if ( showlog )
  {
    printf("%s          \r", (const char *)statusline);
    fflush((FILE *)stdout);
  }
}
// 55168: variable 'v2' is possibly undefined
// 5541C: variable 'v6' is possibly undefined
// 5541C: variable 'fsecs' is possibly undefined
// 5541C: variable 'interval' is possibly undefined
// 55450: variable 'fsecsa' is possibly undefined
// 55450: variable 'intervala' is possibly undefined
// 55484: variable 'fsecsb' is possibly undefined
// 55484: variable 'intervalb' is possibly undefined
// 554B8: variable 'fsecsc' is possibly undefined
// 554B8: variable 'intervalc' is possibly undefined
// 556BC: variable 'v8' is possibly undefined
// 556BC: variable 'fsecsd' is possibly undefined
// 556BC: variable 'intervald' is possibly undefined
// 556D8: variable 'v9' is possibly undefined
// 556D8: variable 'fsecse' is possibly undefined
// 556D8: variable 'intervale' is possibly undefined
// 556F4: variable 'v10' is possibly undefined
// 556F4: variable 'fsecsf' is possibly undefined
// 556F4: variable 'intervalf' is possibly undefined
// 5591C: variable 'fsecsg' is possibly undefined
// 5591C: variable 'intervalg' is possibly undefined
// 5594C: variable 'fsecsh' is possibly undefined
// 5594C: variable 'intervalh' is possibly undefined
// 5597C: variable 'fsecsi' is possibly undefined
// 5597C: variable 'intervali' is possibly undefined
// C4484: using guessed type int stdout;

//----- (00055E80) --------------------------------------------------------
void __cdecl stratum_share_result(json_t_0 *val, json_t_0 *res_val, json_t_0 *err_val, stratum_share *sshare)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-850h] BYREF
  unsigned __int8 hashshow[64]; // [sp+824h] [bp-50h] BYREF
  int srdiff; // [sp+864h] [bp-10h]
  time_t now_t; // [sp+868h] [bp-Ch]
  work *work; // [sp+86Ch] [bp-8h]

  work = sshare->work;
  now_t = time(0);
  srdiff = now_t - sshare->sshare_sent;
  if ( (opt_debug || srdiff > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stratum share result lag time %d seconds", work->pool->pool_no, srdiff);
    applog(6, tmp42, 0);
  }
  show_hash(work, hashshow);
  share_result(val, res_val, err_val, work, hashshow, 0, byte_A1BD4);
}
// A1BD4: using guessed type unsigned __int8 byte_A1BD4[4];

//----- (00055FC0) --------------------------------------------------------
bool __cdecl parse_stratum_response(pool *pool, unsigned __int8 *s)
{
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-964h] BYREF
  int id; // [sp+818h] [bp-164h] BYREF
  json_error_t err; // [sp+81Ch] [bp-160h] BYREF
  double pool_diff; // [sp+918h] [bp-64h]
  unsigned int _hd_bkt; // [sp+920h] [bp-5Ch]
  UT_hash_handle *_hd_hh_del; // [sp+924h] [bp-58h]
  unsigned int _hf_bkt; // [sp+928h] [bp-54h]
  json_t_0 *version_mask; // [sp+92Ch] [bp-50h]
  json_t_0 *id_val; // [sp+930h] [bp-4Ch]
  json_t_0 *err_val; // [sp+934h] [bp-48h]
  json_t_0 *res_val; // [sp+938h] [bp-44h]
  json_t_0 *val; // [sp+93Ch] [bp-40h]
  const unsigned __int8 *_hj_key; // [sp+940h] [bp-3Ch]
  unsigned int _hj_k; // [sp+944h] [bp-38h]
  unsigned int _hj_j; // [sp+948h] [bp-34h]
  unsigned int _hj_i; // [sp+94Ch] [bp-30h]
  unsigned int _hf_hashv; // [sp+950h] [bp-2Ch]
  unsigned __int8 *ss; // [sp+954h] [bp-28h]
  bool ret; // [sp+95Bh] [bp-21h]
  stratum_share *sshare; // [sp+95Ch] [bp-20h]

  val = 0;
  ret = 0;
  val = json_loads(s, 0, &err);
  if ( val )
  {
    res_val = json_object_get(val, "result");
    err_val = json_object_get(val, "error");
    id_val = json_object_get(val, "id");
    if ( id_val && id_val->type == JSON_NULL || !id_val )
    {
      if ( err_val )
        ss = json_dumps(err_val, 3u);
      else
        ss = (unsigned __int8 *)strdup("(unknown reason)");
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf((char *)tmp42, 0x800u, "JSON-RPC non method decode failed: %s", (const char *)ss);
        applog(6, tmp42, 0);
      }
      free(ss);
    }
    else
    {
      version_mask = json_object_get(res_val, "version-rolling.mask");
      if ( !version_mask
        && !strstr((const char *)s, "mining.configure")
        && !strstr((const char *)s, "mining.set_version_mask") )
      {
        id = json_integer_value(id_val);
        mutex_lock_1(&sshare_lock, "cgminer.c", _func___15913, 7261);
        _hj_key = (const unsigned __int8 *)&id;
        _hj_k = 4;
        _hj_i = (HIBYTE(id) << 24) - 1640531527;
        _hj_i += BYTE2(id) << 16;
        _hj_i += BYTE1(id) << 8;
        _hj_i += (unsigned __int8)id;
        _hj_i += 1640531527;
        _hj_i += 17973517;
        _hj_i ^= 0x7F76Du;
        _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
        _hf_hashv = -17973517 - _hj_i - _hj_j;
        _hf_hashv ^= _hj_j >> 13;
        _hj_i -= _hj_j;
        _hj_i -= _hf_hashv;
        _hj_i ^= _hf_hashv >> 12;
        _hj_j -= _hf_hashv;
        _hj_j -= _hj_i;
        _hj_j ^= _hj_i << 16;
        _hf_hashv -= _hj_i;
        _hf_hashv -= _hj_j;
        _hf_hashv ^= _hj_j >> 5;
        _hj_i -= _hj_j;
        _hj_i -= _hf_hashv;
        _hj_i ^= _hf_hashv >> 3;
        _hj_j -= _hf_hashv;
        _hj_j -= _hj_i;
        _hj_j ^= _hj_i << 10;
        _hf_hashv -= _hj_i;
        _hf_hashv -= _hj_j;
        _hf_hashv ^= _hj_j >> 15;
        sshare = 0;
        if ( stratum_shares )
        {
          _hf_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hf_hashv;
          if ( stratum_shares->hh.tbl->buckets[_hf_bkt].hh_head )
            sshare = (stratum_share *)((char *)stratum_shares->hh.tbl->buckets[_hf_bkt].hh_head
                                     - stratum_shares->hh.tbl->hho);
          else
            sshare = 0;
          while ( sshare && (_hf_hashv != sshare->hh.hashv || sshare->hh.keylen != 4 || memcmp(sshare->hh.key, &id, 4u)) )
          {
            if ( sshare->hh.hh_next )
              sshare = (stratum_share *)((char *)sshare->hh.hh_next - stratum_shares->hh.tbl->hho);
            else
              sshare = 0;
          }
        }
        if ( sshare )
        {
          if ( sshare->hh.prev || sshare->hh.next )
          {
            _hd_hh_del = &sshare->hh;
            if ( sshare == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) )
              stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
            if ( sshare->hh.prev )
              *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
            else
              stratum_shares = (stratum_share *)sshare->hh.next;
            if ( _hd_hh_del->next )
              *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
            _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
            --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
            if ( _hd_hh_del == stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head )
              stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
            if ( _hd_hh_del->hh_prev )
              _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
            if ( _hd_hh_del->hh_next )
              _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
            --stratum_shares->hh.tbl->num_items;
          }
          else
          {
            free(stratum_shares->hh.tbl->buckets);
            free(stratum_shares->hh.tbl);
            stratum_shares = 0;
          }
          --pool->sshares;
        }
        mutex_unlock_1(&sshare_lock, "cgminer.c", _func___15913, 7269);
        if ( sshare )
        {
          stratum_share_result(val, res_val, err_val, sshare);
          free_work(&sshare->work, "cgminer.c", _func___15913, 7314);
          free(sshare);
          ret = 1;
        }
        else if ( res_val )
        {
          cg_rlock_0(&pool->data_lock, "cgminer.c", _func___15913, 7281);
          pool_diff = pool->sdiff;
          cg_runlock_0(&pool->data_lock, "cgminer.c", _func___15913, 7283);
          if ( res_val && res_val->type == JSON_TRUE )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf((char *)tmp42, 0x800u, "Accepted untracked stratum share from pool %d", pool->pool_no);
              applog(5, tmp42, 0);
            }
            mutex_lock_1(&stats_lock, "cgminer.c", _func___15913, 7291);
            ++total_accepted;
            ++pool->accepted;
            total_diff_accepted = total_diff_accepted + pool_diff;
            pool->diff_accepted = pool->diff_accepted + pool_diff;
            mutex_unlock_1(&stats_lock, "cgminer.c", _func___15913, 7296);
          }
          else
          {
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf((char *)tmp42, 0x800u, "Rejected untracked stratum share from pool %d", pool->pool_no);
              applog(5, tmp42, 0);
            }
            mutex_lock_1(&stats_lock, "cgminer.c", _func___15913, 7302);
            ++total_rejected;
            ++pool->rejected;
            total_diff_rejected = total_diff_rejected + pool_diff;
            pool->diff_rejected = pool->diff_rejected + pool_diff;
            mutex_unlock_1(&stats_lock, "cgminer.c", _func___15913, 7307);
          }
        }
      }
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "JSON decode failed(%d): %s", err.line, (const char *)err.text);
    applog(6, tmp42, 0);
  }
  if ( val )
    json_decref_0(val);
  return ret;
}
// 5658C: control flows out of bounds to 56590
// 5656C: conditional instruction was optimized away because %_hj_k.4==4

//----- (000570AC) --------------------------------------------------------
void __cdecl clear_stratum_shares(pool *pool)
{
  stratum_share *next; // r3
  stratum_share *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-828h] BYREF
  unsigned int _hd_bkt; // [sp+814h] [bp-28h]
  UT_hash_handle *_hd_hh_del; // [sp+818h] [bp-24h]
  int cleared; // [sp+81Ch] [bp-20h]
  double diff_cleared; // [sp+820h] [bp-1Ch]
  stratum_share *tmpshare; // [sp+828h] [bp-14h]
  stratum_share *sshare; // [sp+82Ch] [bp-10h]

  diff_cleared = 0.0;
  cleared = 0;
  mutex_lock_1(&sshare_lock, "cgminer.c", _func___15949, 7336);
  sshare = stratum_shares;
  if ( stratum_shares )
    next = (stratum_share *)stratum_shares->hh.next;
  else
    next = 0;
  tmpshare = next;
  while ( sshare )
  {
    if ( pool == sshare->work->pool )
    {
      if ( sshare->hh.prev || sshare->hh.next )
      {
        _hd_hh_del = &sshare->hh;
        if ( sshare == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) )
          stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
        if ( sshare->hh.prev )
          *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
        else
          stratum_shares = (stratum_share *)sshare->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
        if ( _hd_hh_del == stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head )
          stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --stratum_shares->hh.tbl->num_items;
      }
      else
      {
        free(stratum_shares->hh.tbl->buckets);
        free(stratum_shares->hh.tbl);
        stratum_shares = 0;
      }
      diff_cleared = diff_cleared + sshare->work->work_difficulty;
      free_work(&sshare->work, "cgminer.c", _func___15949, 7344);
      --pool->sshares;
      free(sshare);
      ++cleared;
    }
    sshare = tmpshare;
    if ( tmpshare )
      v2 = (stratum_share *)tmpshare->hh.next;
    else
      v2 = 0;
    tmpshare = v2;
  }
  mutex_unlock_1(&sshare_lock, "cgminer.c", _func___15949, 7350);
  if ( cleared )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", cleared, pool->pool_no);
      applog(4, tmp42, 0);
    }
    pool->stale_shares += cleared;
    total_stale += cleared;
    pool->diff_stale = pool->diff_stale + diff_cleared;
    total_diff_stale = total_diff_stale + diff_cleared;
  }
}

//----- (000575D4) --------------------------------------------------------
void __cdecl clear_pool_work(pool *pool)
{
  work *next; // r3
  UT_hash_bucket_0 *v2; // r3
  work *v3; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-818h] BYREF
  work *work; // [sp+814h] [bp-18h] BYREF
  unsigned int _hd_bkt; // [sp+818h] [bp-14h]
  UT_hash_handle *_hd_hh_del; // [sp+81Ch] [bp-10h]
  int cleared; // [sp+820h] [bp-Ch]
  work *tmp; // [sp+824h] [bp-8h]

  cleared = 0;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___15962, 7367);
  work = staged_work;
  if ( staged_work )
    next = (work *)staged_work->hh.next;
  else
    next = 0;
  tmp = next;
  while ( work )
  {
    if ( pool == work->pool )
    {
      if ( work->hh.prev || work->hh.next )
      {
        _hd_hh_del = &work->hh;
        if ( (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) == work )
          staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
        if ( work->hh.prev )
          *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
        else
          staged_work = (work *)work->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        v2 = &staged_work->hh.tbl->buckets[_hd_bkt];
        --v2->count;
        if ( _hd_hh_del == staged_work->hh.tbl->buckets[_hd_bkt].hh_head )
          staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --staged_work->hh.tbl->num_items;
      }
      else
      {
        free(staged_work->hh.tbl->buckets);
        free(staged_work->hh.tbl);
        staged_work = 0;
      }
      free_work(&work, "cgminer.c", _func___15962, 7373);
      ++cleared;
    }
    work = tmp;
    if ( tmp )
      v3 = (work *)tmp->hh.next;
    else
      v3 = 0;
    tmp = v3;
  }
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___15962, 7377);
  if ( cleared && (use_syslog || opt_log_output || opt_log_level > 5) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Cleared %d work items due to stratum disconnect on pool %d",
      cleared,
      pool->pool_no);
    applog(6, tmp42, 0);
  }
}

//----- (00057A48) --------------------------------------------------------
int cp_prio()
{
  int prio; // [sp+4h] [bp-8h]

  cg_rlock_0(&control_lock, "cgminer.c", _func___15973, 7387);
  prio = currentpool->prio;
  cg_runlock_0(&control_lock, "cgminer.c", _func___15973, 7389);
  return prio;
}

//----- (00057AB8) --------------------------------------------------------
bool __cdecl cnx_needed(pool *pool)
{
  bool v1; // r3
  int prio; // r4

  if ( pool->enabled != POOL_ENABLED )
    return 0;
  if ( pool_strategy_0 == POOL_BALANCE )
    return 1;
  if ( pool_strategy_0 == POOL_LOADBALANCE )
    return 1;
  if ( pool->has_stratum && pool->idle )
    return 1;
  if ( current_pool() == pool )
    return 1;
  if ( pool->sshares )
    return 1;
  v1 = pool_strategy_0 == POOL_FAILOVER && (prio = pool->prio, prio < cp_prio()) || no_work;
  return v1;
}

//----- (00057BD8) --------------------------------------------------------
void __cdecl stratum_resumed(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-804h] BYREF

  if ( pool_tclear(pool, &pool->idle) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d resumed", pool->pool_no);
      applog(6, tmp42, 0);
    }
    pool_resus(pool);
  }
}

//----- (00057C94) --------------------------------------------------------
bool __cdecl supports_resume(pool *pool)
{
  bool ret; // [sp+Fh] [bp-5h]

  cg_rlock_0(&pool->data_lock, "cgminer.c", _func___15993, 7452);
  ret = pool->sessionid != 0;
  cg_runlock_0(&pool->data_lock, "cgminer.c", _func___15993, 7454);
  return ret;
}

//----- (00057D0C) --------------------------------------------------------
void *__cdecl stratum_rthread(void *userdata)
{
  pthread_t v1; // r0
  bool v2; // nf
  int v3; // r0
  int sock; // r3
  int v5; // r0
  fd_set rd; // [sp+10h] [bp-8B4h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+90h] [bp-834h] BYREF
  work *work; // [sp+890h] [bp-34h] BYREF
  timeval timeout; // [sp+894h] [bp-30h] BYREF
  unsigned __int8 threadname[16]; // [sp+89Ch] [bp-28h] BYREF
  int sel_ret; // [sp+8ACh] [bp-18h]
  fd_set *__arr; // [sp+8B0h] [bp-14h]
  pool *pool; // [sp+8B4h] [bp-10h]
  unsigned int __i; // [sp+8B8h] [bp-Ch]
  unsigned __int8 *s; // [sp+8BCh] [bp-8h]

  pool = (pool *)userdata;
  v1 = pthread_self();
  pthread_detach(v1);
  snprintf((char *)threadname, 0x10u, "%d/RStratum", pool->pool_no);
  RenameThread(threadname);
  while ( !pool->removed )
  {
    if ( !sock_full(pool) && !cnx_needed(pool) )
    {
      suspend_stratum(pool);
      clear_stratum_shares(pool);
      clear_pool_work(pool);
      wait_lpcurrent(pool);
      while ( !restart_stratum(pool) )
      {
        pool_died(pool);
        if ( pool->removed )
          return 0;
        cgsleep_ms(5000);
      }
    }
    __arr = &rd;
    for ( __i = 0; __i <= 0x1F; ++__i )
      __arr->fds_bits[__i] = 0;
    sock = pool->sock;
    v3 = -sock;
    v2 = -sock < 0;
    LOBYTE(sock) = sock & 0x1F;
    v5 = v3 & 0x1F;
    if ( !v2 )
      sock = -v5;
    rd.fds_bits[pool->sock / 32] |= 1 << sock;
    timeout.tv_sec = 90;
    timeout.tv_usec = 0;
    if ( !sock_full(pool) && (sel_ret = select(pool->sock + 1, &rd, 0, 0, &timeout), sel_ret <= 0) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum select failed on pool %d with value %d", pool->pool_no, sel_ret);
        applog(7, tmp42, 0);
      }
      s = 0;
    }
    else
    {
      s = recv_line(pool);
    }
    if ( s )
    {
      stratum_resumed(pool);
      if ( !parse_method(pool, s) && !parse_stratum_response(pool, s) && !parse_version_rolling_mask(pool, s) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Unknown stratum msg: %s", (const char *)s);
          applog(6, tmp42, 0);
        }
      }
      else if ( pool->swork.clean )
      {
        work = make_work();
        pool->swork.clean = 0;
        gen_stratum_work(pool, work);
        work->longpoll = 1;
        test_work_current(work);
        free_work(&work, "cgminer.c", _func___16021, 7566);
      }
      free(s);
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf((char *)tmp42, 0x800u, "Stratum connection to pool %d interrupted", pool->pool_no);
        applog(5, tmp42, 0);
      }
      ++pool->getfail_occasions;
      ++total_go;
      if ( !supports_resume(pool) || opt_lowmem )
        clear_stratum_shares(pool);
      clear_pool_work(pool);
      if ( pool == current_pool() )
        restart_threads();
      while ( !restart_stratum(pool) )
      {
        pool_died(pool);
        if ( pool->removed )
          return 0;
        cgsleep_ms(5000);
      }
    }
  }
  suspend_stratum(pool);
  return 0;
}

//----- (00058288) --------------------------------------------------------
void *__cdecl stratum_sthread(void *userdata)
{
  pthread_t v1; // r0
  __uint64_t v2; // r0
  int v3; // r2
  unsigned __int8 *rpc_user; // r8
  unsigned __int8 *job_id; // r6
  unsigned __int8 *ntime; // r7
  uint32_t v7; // r9
  uint32_t v8; // r0
  __uint32_t v9; // r0
  size_t v10; // r0
  stratum_share *v11; // r6
  UT_hash_table *tbl; // r6
  unsigned int v13; // r3
  bool v14; // r3
  unsigned __int8 s[1024]; // [sp+24h] [bp-CB8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+424h] [bp-8B8h] BYREF
  uint32_t pool_version; // [sp+C24h] [bp-B8h] BYREF
  work *work; // [sp+C28h] [bp-B4h] BYREF
  unsigned __int8 nonce2[8]; // [sp+C2Ch] [bp-B0h] BYREF
  uint32_t nonce; // [sp+C34h] [bp-A8h] BYREF
  unsigned __int8 nonce2hex[20]; // [sp+C38h] [bp-A4h] BYREF
  unsigned __int8 noncehex[12]; // [sp+C4Ch] [bp-90h] BYREF
  unsigned __int8 threadname[16]; // [sp+C58h] [bp-84h] BYREF
  int ssdiff; // [sp+C68h] [bp-74h]
  UT_hash_bucket_0 *_he_newbkt; // [sp+C6Ch] [bp-70h]
  unsigned int _he_bkt; // [sp+C70h] [bp-6Ch]
  UT_hash_handle *_he_hh_nxt; // [sp+C74h] [bp-68h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+C78h] [bp-64h]
  unsigned int _ha_bkt; // [sp+C7Ch] [bp-60h]
  bool sessionid_match; // [sp+C83h] [bp-59h]
  uint32_t *hash32; // [sp+C84h] [bp-58h]
  stratum_share *sshare; // [sp+C88h] [bp-54h]
  uint64_t *nonce2_64; // [sp+C8Ch] [bp-50h]
  pool *pool; // [sp+C90h] [bp-4Ch]
  UT_hash_handle *_he_thh; // [sp+C94h] [bp-48h]
  unsigned int _he_bkt_i; // [sp+C98h] [bp-44h]
  const unsigned __int8 *_hj_key; // [sp+C9Ch] [bp-40h]
  unsigned int _hj_k; // [sp+CA0h] [bp-3Ch]
  unsigned int _hj_j; // [sp+CA4h] [bp-38h]
  unsigned int _hj_i; // [sp+CA8h] [bp-34h]
  unsigned int _ha_hashv; // [sp+CACh] [bp-30h]
  bool submitted; // [sp+CB3h] [bp-29h]
  uint32_t last_nonce; // [sp+CB4h] [bp-28h]
  uint64_t last_nonce2; // [sp+CB8h] [bp-24h]

  pool = (pool *)userdata;
  last_nonce2 = 0LL;
  last_nonce = 0;
  v1 = pthread_self();
  pthread_detach(v1);
  snprintf((char *)threadname, 0x10u, "%d/SStratum", pool->pool_no);
  RenameThread(threadname);
  pool->stratum_q = tq_new();
  if ( !pool->stratum_q )
  {
    strcpy((char *)tmp42, "Failed to create stratum_q in stratum_sthread");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "in %s ", (const char *)_FUNCTION___16032);
    applog(5, tmp42, 0);
  }
  while ( !pool->removed )
  {
    work = (work *)tq_pop(pool->stratum_q, 0);
    if ( !work )
    {
      strcpy((char *)tmp42, "Stratum q returned empty work");
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( work->nonce2_len <= 8 )
    {
      nonce = *(_DWORD *)&work->data[76];
      nonce2_64 = (uint64_t *)nonce2;
      v2 = _uint64_identity_0(work->nonce2);
      *nonce2_64 = v2;
      if ( last_nonce == nonce && last_nonce2 == *nonce2_64 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          snprintf((char *)tmp42, 0x800u, "Filtering duplicate share to pool %d", pool->pool_no);
          applog(6, tmp42, 0);
        }
        free_work(&work, "cgminer.c", _func___16047, 7633);
      }
      else
      {
        last_nonce = nonce;
        last_nonce2 = *nonce2_64;
        _bin2hex(noncehex, (const unsigned __int8 *)&nonce, 4u);
        _bin2hex(nonce2hex, nonce2, work->nonce2_len);
        sshare = (stratum_share *)cgcalloc(52, 1u, "cgminer.c", _func___16047, 7642);
        hash32 = (uint32_t *)work->hash;
        submitted = 0;
        sshare->sshare_time = time(0);
        sshare->work = work;
        memset(s, 0, sizeof(s));
        mutex_lock_1(&sshare_lock, "cgminer.c", _func___16047, 7651);
        v3 = swork_id++;
        sshare->id = v3;
        mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16047, 7654);
        pool_version = 0;
        hex2bin((unsigned __int8 *)&pool_version, pool->bbversion, 4u);
        if ( pool->support_ab )
        {
          rpc_user = pool->rpc_user;
          job_id = work->job_id;
          ntime = work->ntime;
          v7 = swab32_2(work->version);
          v8 = swab32_2(pool_version);
          snprintf(
            (char *)s,
            0x400u,
            "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
            (const char *)rpc_user,
            (const char *)job_id,
            (const char *)nonce2hex,
            (const char *)ntime,
            (const char *)noncehex,
            ~v8 & v7,
            sshare->id);
        }
        else
        {
          snprintf(
            (char *)s,
            0x400u,
            "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
            (const char *)pool->rpc_user,
            (const char *)work->job_id,
            (const char *)nonce2hex,
            (const char *)work->ntime,
            (const char *)noncehex,
            sshare->id);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 5 )
        {
          v9 = _uint32_identity_0(hash32[6]);
          snprintf((char *)tmp42, 0x800u, "Submitting share %08lx to pool %d", v9, pool->pool_no);
          applog(6, tmp42, 0);
        }
        while ( time(0) < sshare->sshare_time + 120 )
        {
          v10 = strlen((const char *)s);
          if ( stratum_send(pool, s, v10) )
          {
            mutex_lock_1(&sshare_lock, "cgminer.c", _func___16047, 7693);
            _hj_key = (const unsigned __int8 *)&sshare->id;
            _hj_j = -1640531527;
            _hj_i = -1640531527;
            _hj_k = 4;
            _ha_hashv = -17973517;
            _hj_i = (HIBYTE(sshare->id) << 24) - 1640531527;
            _hj_i += BYTE2(sshare->id) << 16;
            _hj_i += BYTE1(sshare->id) << 8;
            _hj_i += LOBYTE(sshare->id);
            _hj_i += 1640531527;
            _hj_i += 17973517;
            _hj_i ^= 0x7F76Du;
            _hj_j = (_hj_i << 8) ^ (-1622558010 - _hj_i);
            _ha_hashv = -17973517 - _hj_i - _hj_j;
            _ha_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _ha_hashv;
            _hj_i ^= _ha_hashv >> 12;
            _hj_j -= _ha_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _ha_hashv -= _hj_i;
            _ha_hashv -= _hj_j;
            _ha_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _ha_hashv;
            _hj_i ^= _ha_hashv >> 3;
            _hj_j -= _ha_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _ha_hashv -= _hj_i;
            _ha_hashv -= _hj_j;
            _ha_hashv ^= _hj_j >> 15;
            sshare->hh.hashv = _ha_hashv;
            sshare->hh.key = &sshare->id;
            sshare->hh.keylen = 4;
            if ( stratum_shares )
            {
              sshare->hh.tbl = stratum_shares->hh.tbl;
              sshare->hh.next = 0;
              sshare->hh.prev = (char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho;
              stratum_shares->hh.tbl->tail->next = sshare;
              stratum_shares->hh.tbl->tail = &sshare->hh;
            }
            else
            {
              sshare->hh.next = 0;
              sshare->hh.prev = 0;
              stratum_shares = sshare;
              v11 = sshare;
              v11->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
              if ( !stratum_shares->hh.tbl )
                exit(-1);
              memset(stratum_shares->hh.tbl, 0, sizeof(UT_hash_table));
              stratum_shares->hh.tbl->tail = &stratum_shares->hh;
              stratum_shares->hh.tbl->num_buckets = 32;
              stratum_shares->hh.tbl->log2_num_buckets = 5;
              stratum_shares->hh.tbl->hho = 0;
              tbl = stratum_shares->hh.tbl;
              tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
              if ( !stratum_shares->hh.tbl->buckets )
                exit(-1);
              memset(stratum_shares->hh.tbl->buckets, 0, 0x180u);
              stratum_shares->hh.tbl->signature = -1609490463;
            }
            ++stratum_shares->hh.tbl->num_items;
            _ha_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _ha_hashv;
            ++stratum_shares->hh.tbl->buckets[_ha_bkt].count;
            sshare->hh.hh_next = stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head;
            sshare->hh.hh_prev = 0;
            if ( stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head )
              stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &sshare->hh;
            stratum_shares->hh.tbl->buckets[_ha_bkt].hh_head = &sshare->hh;
            if ( stratum_shares->hh.tbl->buckets[_ha_bkt].count >= 10
                                                                 * (stratum_shares->hh.tbl->buckets[_ha_bkt].expand_mult
                                                                  + 1)
              && sshare->hh.tbl->noexpand != 1 )
            {
              _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * sshare->hh.tbl->num_buckets);
              if ( !_he_new_buckets )
                exit(-1);
              memset(_he_new_buckets, 0, 24 * sshare->hh.tbl->num_buckets);
              sshare->hh.tbl->ideal_chain_maxlen = (((2 * sshare->hh.tbl->num_buckets - 1) & sshare->hh.tbl->num_items) != 0)
                                                 + (sshare->hh.tbl->num_items >> (sshare->hh.tbl->log2_num_buckets + 1));
              sshare->hh.tbl->nonideal_items = 0;
              for ( _he_bkt_i = 0; _he_bkt_i < sshare->hh.tbl->num_buckets; ++_he_bkt_i )
              {
                for ( _he_thh = sshare->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
                {
                  _he_hh_nxt = _he_thh->hh_next;
                  _he_bkt = (2 * sshare->hh.tbl->num_buckets - 1) & _he_thh->hashv;
                  _he_newbkt = &_he_new_buckets[_he_bkt];
                  if ( ++_he_newbkt->count > sshare->hh.tbl->ideal_chain_maxlen )
                  {
                    ++sshare->hh.tbl->nonideal_items;
                    _he_newbkt->expand_mult = _he_newbkt->count / sshare->hh.tbl->ideal_chain_maxlen;
                  }
                  _he_thh->hh_prev = 0;
                  _he_thh->hh_next = _he_newbkt->hh_head;
                  if ( _he_newbkt->hh_head )
                    _he_newbkt->hh_head->hh_prev = _he_thh;
                  _he_newbkt->hh_head = _he_thh;
                }
              }
              free(sshare->hh.tbl->buckets);
              sshare->hh.tbl->num_buckets *= 2;
              ++sshare->hh.tbl->log2_num_buckets;
              sshare->hh.tbl->buckets = _he_new_buckets;
              if ( sshare->hh.tbl->nonideal_items <= sshare->hh.tbl->num_items >> 1 )
                v13 = 0;
              else
                v13 = sshare->hh.tbl->ineff_expands + 1;
              sshare->hh.tbl->ineff_expands = v13;
              if ( sshare->hh.tbl->ineff_expands > 1 )
                sshare->hh.tbl->noexpand = 1;
            }
            ++pool->sshares;
            mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16047, 7696);
            if ( pool_tclear(pool, &pool->submit_fail) && (use_syslog || opt_log_output || opt_log_level > 3) )
            {
              snprintf((char *)tmp42, 0x800u, "Pool %d communication resumed, submitting work", pool->pool_no);
              applog(4, tmp42, 0);
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "Successfully submitted, adding to stratum_shares db");
              applog(7, tmp42, 0);
            }
            submitted = 1;
            break;
          }
          if ( !pool_tset(pool, &pool->submit_fail) && cnx_needed(pool) )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf((char *)tmp42, 0x800u, "Pool %d stratum share submission failure", pool->pool_no);
              applog(4, tmp42, 0);
            }
            ++total_ro;
            ++pool->remotefail_occasions;
          }
          if ( opt_lowmem )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "Lowmem option prevents resubmitting stratum share");
              applog(7, tmp42, 0);
            }
            break;
          }
          cg_rlock_0(&pool->data_lock, "cgminer.c", _func___16047, 7718);
          v14 = pool->nonce1 && !strcmp((const char *)work->nonce1, (const char *)pool->nonce1);
          sessionid_match = v14;
          cg_runlock_0(&pool->data_lock, "cgminer.c", _func___16047, 7720);
          if ( !sessionid_match )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "No matching session id for resubmitting stratum share");
              applog(7, tmp42, 0);
            }
            break;
          }
          sleep(2u);
        }
        if ( !submitted )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy((char *)tmp42, "Failed to submit stratum share, discarding");
            applog(7, tmp42, 0);
          }
          free_work(&work, "cgminer.c", _func___16047, 7735);
          free(sshare);
          ++pool->stale_shares;
          ++total_stale;
        }
        else
        {
          sshare->sshare_sent = time(0);
          ssdiff = sshare->sshare_sent - sshare->sshare_time;
          if ( (opt_debug || ssdiff > 0) && (use_syslog || opt_log_output || opt_log_level > 5) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Pool %d stratum share submission lag time %d seconds",
              pool->pool_no,
              ssdiff);
            applog(6, tmp42, 0);
          }
        }
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Pool %d asking for inappropriately long nonce2 length %d",
          pool->pool_no,
          work->nonce2_len);
        applog(3, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "Not attempting to submit shares");
        applog(3, tmp42, 0);
      }
      free_work(&work, "cgminer.c", _func___16047, 7621);
    }
  }
  tq_freeze(pool->stratum_q);
  return 0;
}
// 58D58: control flows out of bounds to 58D5C
// 58D38: conditional instruction was optimized away because %_hj_k.4==4

//----- (00059EA8) --------------------------------------------------------
void __cdecl init_stratum_threads(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-804h] BYREF

  have_longpoll = 1;
  if ( pthread_create(&pool->stratum_sthread, 0, (void *(*)(void *))stratum_sthread, pool) )
  {
    strcpy((char *)tmp42, "Failed to create stratum sthread");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_create(&pool->stratum_rthread, 0, (void *(*)(void *))stratum_rthread, pool) )
  {
    strcpy((char *)tmp42, "Failed to create stratum rthread");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00059FC8) --------------------------------------------------------
bool __cdecl stratum_works(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-804h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %d stratum %s", pool->pool_no, (const char *)pool->stratum_url);
    applog(6, tmp42, 0);
  }
  return extract_sockaddr(pool->stratum_url, &pool->sockaddr_url, &pool->stratum_port) && initiate_stratum(pool);
}

//----- (0005A0CC) --------------------------------------------------------
bool __cdecl setup_gbt_solo(CURL *curl, pool *pool)
{
  return 0;
}

//----- (0005A0F4) --------------------------------------------------------
void __cdecl pool_start_lp(pool *pool)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-804h] BYREF

  if ( !pool->lp_started )
  {
    pool->lp_started = 1;
    if ( pthread_create(&pool->longpoll_thread, 0, (void *(*)(void *))longpoll_thread, pool) )
    {
      strcpy((char *)tmp42, "Failed to create pool longpoll thread");
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (0005A1B8) --------------------------------------------------------
bool __cdecl pool_active(pool *pool, bool pinging)
{
  bool v2; // r3
  unsigned __int8 *v4; // r3
  size_t v5; // r4
  const char *v6; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-860h] BYREF
  work *work; // [sp+814h] [bp-60h] BYREF
  timeval tv_getwork_reply; // [sp+818h] [bp-5Ch] BYREF
  timeval tv_getwork; // [sp+820h] [bp-54h] BYREF
  bool ret_0; // [sp+82Ah] [bp-4Ah]
  size_t siz; // [sp+82Ch] [bp-48h]
  unsigned __int8 *copy_start; // [sp+830h] [bp-44h]
  unsigned __int8 *hdr_path; // [sp+834h] [bp-40h]
  bool rc; // [sp+83Bh] [bp-39h]
  CURL *curl; // [sp+848h] [bp-2Ch]
  json_t_0 *val; // [sp+850h] [bp-24h]
  bool need_slash; // [sp+857h] [bp-1Dh]
  bool ret; // [sp+867h] [bp-Dh]

  val = 0;
  ret = 0;
  if ( pool->has_gbt )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Retrieving block template from pool %s", (const char *)pool->rpc_url);
      applog(7, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf((char *)tmp42, 0x800u, "Testing pool %s", (const char *)pool->rpc_url);
    applog(6, tmp42, 0);
  }
  while ( 1 )
  {
    if ( pool->has_stratum )
    {
      if ( pool_tset(pool, &pool->stratum_init) )
        return pool->stratum_active;
      v2 = initiate_stratum(pool) && (!pool->extranonce_subscribe || subscribe_extranonce(pool)) && auth_stratum(pool);
      ret_0 = v2;
      if ( v2 )
        init_stratum_threads(pool);
      else
        pool_tclear(pool, &pool->stratum_init);
      return ret_0;
    }
    curl = curly;
    if ( !curly )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy((char *)tmp42, "CURL initialisation failed");
        applog(3, tmp42, 0);
      }
      return 0;
    }
    if ( !pool->probed )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Probing for GBT support");
        applog(7, tmp42, 0);
      }
      val = 0;
      pool->probed = 0;
      if ( pool->has_gbt )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "GBT coinbase + append support found, switching to GBT protocol");
          applog(7, tmp42, 0);
        }
      }
      else if ( pool->gbt_solo )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "GBT coinbase without append found, switching to GBT solo protocol");
          applog(7, tmp42, 0);
        }
      }
      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "No GBT coinbase + append support found, pool unusable if it has no stratum");
        applog(7, tmp42, 0);
      }
    }
    cgtime(&tv_getwork);
    val = 0;
    cgtime(&tv_getwork_reply);
    if ( !pool->stratum_url || opt_fix_protocol || !stratum_works(pool) )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Switching pool %d %s to %s",
        pool->pool_no,
        (const char *)pool->rpc_url,
        (const char *)pool->stratum_url);
      applog(5, tmp42, 0);
    }
    if ( !pool->rpc_url )
      pool->rpc_url = (unsigned __int8 *)strdup((const char *)pool->stratum_url);
    pool->has_stratum = 1;
  }
  if ( !pool->has_stratum && !pool->gbt_solo && !pool->has_gbt )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "No Stratum, GBT or Solo support in pool %d %s unable to use",
        pool->pool_no,
        (const char *)pool->rpc_url);
      applog(4, tmp42, 0);
    }
    return 0;
  }
  else
  {
    if ( val )
    {
      work = make_work();
      rc = 0;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Successfully retrieved but FAILED to decipher work from pool %u %s",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(7, tmp42, 0);
      }
      free_work(&work, "cgminer.c", _func___16153, 8056);
      if ( !pool->lp_url )
      {
        if ( pool->hdr_path )
        {
          need_slash = 0;
          hdr_path = pool->hdr_path;
          if ( strstr((const char *)hdr_path, "://") )
          {
            pool->lp_url = hdr_path;
            hdr_path = 0;
          }
          else
          {
            if ( *hdr_path == 47 )
              v4 = hdr_path + 1;
            else
              v4 = hdr_path;
            copy_start = v4;
            if ( pool->rpc_url[strlen((const char *)pool->rpc_url) - 1] != 47 )
              need_slash = 1;
            v5 = strlen((const char *)pool->rpc_url);
            siz = v5 + strlen((const char *)copy_start) + 2;
            pool->lp_url = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___16153, 8089);
            if ( need_slash )
              v6 = "/";
            else
              v6 = (const char *)byte_A1BD4;
            snprintf((char *)pool->lp_url, siz, "%s%s%s", (const char *)pool->rpc_url, v6, (const char *)copy_start);
          }
        }
        else
        {
          pool->lp_url = 0;
        }
        pool_start_lp(pool);
      }
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "FAILED to retrieve work from pool %u %s",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(7, tmp42, 0);
      }
      if ( !pinging && !pool->idle && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        snprintf((char *)tmp42, 0x800u, "Pool %u slow/down or URL or credentials invalid", pool->pool_no);
        applog(4, tmp42, 0);
      }
    }
    if ( val )
      json_decref_0(val);
    return ret;
  }
}
// A1BD4: using guessed type unsigned __int8 byte_A1BD4[4];

//----- (0005B1AC) --------------------------------------------------------
void __cdecl pool_resus(pool *pool)
{
  int prio; // r4
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-80Ch] BYREF

  pool->seq_getfails = 0;
  if ( pool_strategy_0 || (prio = pool->prio, prio >= cp_prio()) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d %s alive", pool->pool_no, (const char *)pool->rpc_url);
      applog(6, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d %s alive, testing stability", pool->pool_no, (const char *)pool->rpc_url);
    applog(4, tmp42, 0);
  }
}

//----- (0005B318) --------------------------------------------------------
work *__cdecl hash_pop(bool blocking)
{
  int num_items; // r3
  work *next; // r3
  work *v3; // r3
  UT_hash_bucket_0 *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-82Ch] BYREF
  timeval now; // [sp+808h] [bp-2Ch] BYREF
  timespec then; // [sp+810h] [bp-24h] BYREF
  unsigned int _hd_bkt; // [sp+818h] [bp-1Ch]
  UT_hash_handle *_hd_hh_del; // [sp+81Ch] [bp-18h]
  int hc; // [sp+820h] [bp-14h]
  work *tmp; // [sp+828h] [bp-Ch]
  work *work; // [sp+82Ch] [bp-8h]

  work = 0;
  mutex_lock_1(stgd_lock, "cgminer.c", _func___16174, 8142);
  if ( !staged_work || !staged_work->hh.tbl->num_items )
  {
    work_emptied = 1;
    if ( !blocking )
      goto out_unlock;
    do
    {
      cgtime(&now);
      then.tv_sec = now.tv_sec + 10;
      then.tv_nsec = 1000 * now.tv_usec;
      pthread_cond_signal(&gws_cond);
      if ( pthread_cond_timedwait(&getq->cond, stgd_lock, &then) )
      {
        if ( !no_work )
        {
          no_work = 1;
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy((char *)tmp42, "Waiting for work to be available from pools.");
            applog(4, tmp42, 0);
          }
        }
      }
    }
    while ( !staged_work || !staged_work->hh.tbl->num_items );
  }
  if ( no_work )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Work available from pools, resuming.");
      applog(4, tmp42, 0);
    }
    no_work = 0;
  }
  if ( staged_work )
    num_items = staged_work->hh.tbl->num_items;
  else
    num_items = 0;
  hc = num_items;
  if ( num_items <= staged_rollable )
  {
    work = staged_work;
  }
  else
  {
    work = staged_work;
    if ( staged_work )
      next = (work *)staged_work->hh.next;
    else
      next = 0;
    tmp = next;
    while ( work && work_rollable(work) )
    {
      work = tmp;
      if ( tmp )
        v3 = (work *)tmp->hh.next;
      else
        v3 = 0;
      tmp = v3;
    }
  }
  if ( work->hh.prev || work->hh.next )
  {
    _hd_hh_del = &work->hh;
    if ( work == (work *)((char *)staged_work->hh.tbl->tail - staged_work->hh.tbl->hho) )
      staged_work->hh.tbl->tail = (UT_hash_handle *)((char *)work->hh.prev + staged_work->hh.tbl->hho);
    if ( work->hh.prev )
      *(_DWORD *)((char *)work->hh.prev + staged_work->hh.tbl->hho + 8) = work->hh.next;
    else
      staged_work = (work *)work->hh.next;
    if ( _hd_hh_del->next )
      *(_DWORD *)((char *)_hd_hh_del->next + staged_work->hh.tbl->hho + 4) = _hd_hh_del->prev;
    _hd_bkt = (staged_work->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
    v4 = &staged_work->hh.tbl->buckets[_hd_bkt];
    --v4->count;
    if ( _hd_hh_del == staged_work->hh.tbl->buckets[_hd_bkt].hh_head )
      staged_work->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
    if ( _hd_hh_del->hh_prev )
      _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
    if ( _hd_hh_del->hh_next )
      _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
    --staged_work->hh.tbl->num_items;
  }
  else
  {
    free(staged_work->hh.tbl->buckets);
    free(staged_work->hh.tbl);
    staged_work = 0;
  }
  if ( work_rollable(work) )
    --staged_rollable;
  pthread_cond_signal(&gws_cond);
  pthread_cond_signal(&getq->cond);
  last_getwork = time(0);
out_unlock:
  mutex_unlock_1(stgd_lock, "cgminer.c", _func___16174, 8214);
  return work;
}

//----- (0005BA20) --------------------------------------------------------
void __cdecl gen_hash(unsigned __int8 *data, unsigned __int8 *hash, int len)
{
  unsigned __int8 hash1[32]; // [sp+10h] [bp-24h] BYREF

  sha256(data, len, hash1);
  sha256(hash1, 0x20u, hash);
}

//----- (0005BA70) --------------------------------------------------------
void __cdecl set_target(unsigned __int8 *dest_target, double diff)
{
  double v2; // d0
  __uint64_t v3; // r0
  __uint64_t v4; // r0
  double diffa; // [sp+8h] [bp-854h]
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-844h] BYREF
  unsigned __int8 target[32]; // [sp+818h] [bp-44h] BYREF
  unsigned __int8 *htarget; // [sp+838h] [bp-24h]
  uint64_t *data64; // [sp+83Ch] [bp-20h]
  uint64_t h64; // [sp+840h] [bp-1Ch]
  double dcut64; // [sp+848h] [bp-14h]
  double d64; // [sp+850h] [bp-Ch]

  diffa = v2;
  if ( v2 == 0.0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "Diff zero passed to set_target");
      applog(3, tmp42, 0);
    }
    diffa = 1.0;
  }
  d64 = 2.69595353e67 / diffa;
  dcut64 = 2.69595353e67 / diffa / 6.27710174e57;
  h64 = (unsigned __int64)dcut64;
  data64 = (uint64_t *)&target[24];
  v3 = _uint64_identity_0((unsigned __int64)dcut64);
  *data64 = v3;
  d64 = d64 - (double)h64 * 6.27710174e57;
  dcut64 = d64 / 3.40282367e38;
  h64 = (unsigned __int64)(d64 / 3.40282367e38);
  data64 = (uint64_t *)&target[16];
  *(_QWORD *)&target[16] = _uint64_identity_0(h64);
  d64 = d64 - (double)h64 * 3.40282367e38;
  dcut64 = d64 / 1.84467441e19;
  h64 = (unsigned __int64)(d64 / 1.84467441e19);
  data64 = (uint64_t *)&target[8];
  *(_QWORD *)&target[8] = _uint64_identity_0(h64);
  dcut64 = (double)h64 * 1.84467441e19;
  d64 = d64 - dcut64;
  h64 = (unsigned __int64)d64;
  data64 = (uint64_t *)target;
  v4 = _uint64_identity_0((unsigned __int64)d64);
  *data64 = v4;
  if ( opt_debug )
  {
    htarget = bin2hex(target, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated target %s", (const char *)htarget);
      applog(7, tmp42, 0);
    }
    free(htarget);
  }
  cg_memcpy(dest_target, target, 0x20u, "cgminer.c", _func___16206, 8276);
}
// 5BA8C: variable 'v2' is possibly undefined

//----- (0005BE28) --------------------------------------------------------
void __cdecl get_work_by_nonce2(
        thr_info *thr,
        work **work,
        pool *pool,
        pool *real_pool,
        uint64_t nonce2,
        uint32_t version)
{
  int thr_id; // [sp+1Ch] [bp-8h]

  *work = make_work();
  thr_id = thr->id;
  cg_wlock_1(&pool->data_lock, "cgminer.c", _func___16216, 8291);
  pool->nonce2 = nonce2;
  version = HIBYTE(version) | (version >> 8) & 0xFF00 | (version << 8) & 0xFF0000 | (version << 24);
  cg_memcpy(pool->header_bin, &version, 4u, "cgminer.c", _func___16216, 8294);
  cg_wunlock_1(&pool->data_lock, "cgminer.c", _func___16216, 8295);
  gen_stratum_work(pool, *work);
  (*work)->pool = real_pool;
  (*work)->thr_id = thr_id;
  (*work)->work_block = work_block;
  ++(*work)->pool->works;
  (*work)->mined = 1;
  (*work)->version = version;
}

//----- (0005BFB0) --------------------------------------------------------
void __cdecl gen_stratum_work(pool *pool, work *work)
{
  uint64_t nonce2; // r2
  double v3; // r2
  double v4; // r2
  unsigned __int8 tmp42[2048]; // [sp+18h] [bp-88Ch] BYREF
  uint64_t nonce2le; // [sp+818h] [bp-8Ch] BYREF
  unsigned __int8 merkle_sha[64]; // [sp+824h] [bp-80h] BYREF
  unsigned __int8 merkle_root[32]; // [sp+864h] [bp-40h] BYREF
  unsigned __int8 *merkle_hash; // [sp+884h] [bp-20h]
  unsigned __int8 *header; // [sp+888h] [bp-1Ch]
  uint32_t *swap32; // [sp+88Ch] [bp-18h]
  uint32_t *data32; // [sp+890h] [bp-14h]
  int i; // [sp+894h] [bp-10h]

  cg_wlock_1(&pool->data_lock, "cgminer.c", _func___16227, 8321);
  nonce2le = _uint64_identity_0(pool->nonce2);
  cg_memcpy(&pool->coinbase[pool->nonce2_offset], &nonce2le, pool->n2size, "cgminer.c", _func___16227, 8326);
  nonce2 = pool->nonce2;
  pool->nonce2 = nonce2 + 1;
  work->nonce2 = nonce2;
  work->nonce2_len = pool->n2size;
  cg_dwlock(&pool->data_lock, "cgminer.c", _func___16227, 8332);
  gen_hash(pool->coinbase, merkle_root, pool->coinbase_len);
  cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", _func___16227, 8336);
  for ( i = 0; i < pool->merkles; ++i )
  {
    cg_memcpy(&merkle_sha[32], pool->swork.merkle_bin[i], 0x20u, "cgminer.c", _func___16227, 8340);
    gen_hash(merkle_sha, merkle_root, 64);
    cg_memcpy(merkle_sha, merkle_root, 0x20u, "cgminer.c", _func___16227, 8342);
  }
  data32 = (uint32_t *)merkle_sha;
  swap32 = (uint32_t *)merkle_root;
  flip32_1(merkle_root, merkle_sha);
  cg_memcpy(work, pool->header_bin, 0x70u, "cgminer.c", _func___16227, 8351);
  cg_memcpy(&work->data[36], merkle_root, 0x20u, "cgminer.c", _func___16227, 8352);
  work->sdiff = pool->sdiff;
  work->job_id = (unsigned __int8 *)strdup((const char *)pool->swork.job_id);
  work->nonce1 = (unsigned __int8 *)strdup((const char *)pool->nonce1);
  work->ntime = (unsigned __int8 *)strdup((const char *)pool->ntime);
  cg_runlock_0(&pool->data_lock, "cgminer.c", _func___16227, 8363);
  if ( opt_debug )
  {
    header = bin2hex(work->data, 0x70u);
    merkle_hash = bin2hex(merkle_root, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated stratum merkle %s", (const char *)merkle_hash);
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Generated stratum header %s", (const char *)header);
      applog(7, tmp42, 0);
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Work job_id %s nonce2 %llu ntime %s",
        (const char *)work->job_id,
        work->nonce2,
        (const char *)work->ntime);
      applog(7, tmp42, 0);
    }
    free(header);
    free(merkle_hash);
  }
  calc_midstate(work);
  LODWORD(v3) = work->target;
  HIDWORD(v3) = work;
  set_target(work->target, v3);
  ++local_work;
  if ( time(0) - local_work_lasttime > 5 )
  {
    local_work_lasttime = time(0);
    local_work_last = local_work;
  }
  work->pool = pool;
  work->stratum = 1;
  work->nonce = 0;
  work->longpoll = 0;
  work->getwork_mode = 83;
  work->work_block = work_block;
  LODWORD(v4) = 60;
  work->drv_rolllimit = 60;
  HIDWORD(v4) = work;
  calc_diff(work, v4);
  cgtime(&work->tv_staged);
}

//----- (0005C5DC) --------------------------------------------------------
void __cdecl set_benchmark_work(cgpu_info *cgpu, work *work)
{
  cgpu->lodiff += cgpu->direction;
  if ( cgpu->lodiff <= 0 )
    cgpu->direction = 1;
  if ( cgpu->lodiff <= 15 )
  {
    cg_memcpy(work, bench_lodiff_bins[cgpu->lodiff], 0xA0u, "cgminer.c", _func___16243, 8588);
  }
  else
  {
    cgpu->direction = -1;
    if ( ++cgpu->hidiff > 15 )
      cgpu->hidiff = 0;
    cg_memcpy(work, bench_hidiff_bins[cgpu->hidiff], 0xA0u, "cgminer.c", _func___16243, 8584);
  }
}

//----- (0005C71C) --------------------------------------------------------
work *__cdecl get_work(thr_info *thr, const int thr_id)
{
  double max_diff; // r2
  double device_diff; // r2
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-810h] BYREF
  work *work; // [sp+80Ch] [bp-10h] BYREF
  time_t diff_t; // [sp+810h] [bp-Ch]
  cgpu_info *cgpu; // [sp+814h] [bp-8h]

  cgpu = thr->cgpu;
  work = 0;
  thread_reportout(thr);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Popping work from get queue to get work");
    applog(7, tmp42, 0);
  }
  diff_t = time(0);
  while ( !work )
  {
    work = hash_pop(1);
    if ( stale_work(work, 0) )
    {
      discard_work(&work, "cgminer.c", _func___16252, 8607);
      wake_gws();
    }
  }
  diff_t = time(0) - diff_t;
  if ( diff_t > 0 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "Get work blocked for %ld seconds", diff_t);
      applog(7, tmp42, 0);
    }
    cgpu->last_device_valid_work += diff_t;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "Got work from get queue to get work for thread %d", thr_id);
    applog(7, tmp42, 0);
  }
  work->thr_id = thr_id;
  if ( opt_benchmark )
    set_benchmark_work(cgpu, work);
  thread_reportin(thr);
  work->mined = 1;
  if ( cgpu->drv->max_diff <= work->work_difficulty )
    max_diff = cgpu->drv->max_diff;
  else
    max_diff = work->work_difficulty;
  work->device_diff = max_diff;
  if ( cgpu->drv->min_diff <= work->device_diff )
    device_diff = work->device_diff;
  else
    device_diff = cgpu->drv->min_diff;
  work->device_diff = device_diff;
  return work;
}

//----- (0005CA84) --------------------------------------------------------
void __cdecl submit_work_async(work *work)
{
  work *worka[2]; // [sp+Ch] [bp-830h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-828h] BYREF
  pthread_t submit_thread; // [sp+814h] [bp-28h] BYREF
  cgpu_info *cgpu; // [sp+818h] [bp-24h]
  pool *pool; // [sp+81Ch] [bp-20h]

  worka[0] = work;
  pool = work->pool;
  cgtime(&work->tv_work_found);
  if ( opt_benchmark )
  {
    cgpu = get_thr_cgpu(worka[0]->thr_id);
    mutex_lock_1(&stats_lock, "cgminer.c", _func___16264, 8651);
    ++cgpu->accepted;
    ++total_accepted;
    ++pool->accepted;
    cgpu->diff_accepted = cgpu->diff_accepted + worka[0]->work_difficulty;
    total_diff_accepted = worka[0]->work_difficulty + total_diff_accepted;
    pool->diff_accepted = pool->diff_accepted + worka[0]->work_difficulty;
    mutex_unlock_1(&stats_lock, "cgminer.c", _func___16264, 8658);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Accepted %s %d benchmark share nonce %08x",
        (const char *)cgpu->drv->name,
        cgpu->device_id,
        *(_DWORD *)&worka[0]->data[76]);
      applog(5, tmp42, 0);
    }
    return;
  }
  if ( !stale_work(worka[0], 1) )
    goto LABEL_23;
  if ( opt_submit_stale )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as user requested", pool->pool_no);
      applog(5, tmp42, 0);
    }
LABEL_22:
    worka[0]->stale = 1;
LABEL_23:
    if ( worka[0]->stratum )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "Pushing pool %d work to stratum queue", pool->pool_no);
        applog(7, tmp42, 0);
      }
      if ( !pool->stratum_q || !tq_push(pool->stratum_q, worka[0]) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          strcpy((char *)tmp42, "Discarding work from removed pool");
          applog(4, tmp42, 0);
        }
        if ( !pool->stratum_q && (use_syslog || opt_log_output || opt_log_level > 4) )
        {
          snprintf((char *)tmp42, 0x800u, "Pushing pool %d work to stratum queue", pool->pool_no);
          applog(5, tmp42, 0);
        }
        free_work(worka, "cgminer.c", _func___16264, 8702);
      }
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "Pushing submit work to work thread");
        applog(5, tmp42, 0);
      }
      if ( pthread_create(&submit_thread, 0, (void *(*)(void *))submit_work_thread, worka[0]) )
      {
        strcpy((char *)tmp42, "Failed to create submit_work_thread");
        applog(3, tmp42, 1);
        quit(1);
      }
    }
    return;
  }
  if ( pool->submit_old )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, submitting as pool requested", pool->pool_no);
      applog(5, tmp42, 0);
    }
    goto LABEL_22;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "Pool %d stale share detected, discarding", pool->pool_no);
    applog(5, tmp42, 0);
  }
  sharelog("discard", worka[0]);
  mutex_lock_1(&stats_lock, "cgminer.c", _func___16264, 8679);
  ++total_stale;
  ++pool->stale_shares;
  total_diff_stale = worka[0]->work_difficulty + total_diff_stale;
  pool->diff_stale = pool->diff_stale + worka[0]->work_difficulty;
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___16264, 8686);
  free_work(worka, "cgminer.c", _func___16264, 8688);
}

//----- (0005D25C) --------------------------------------------------------
void __cdecl inc_hw_errors(thr_info *thr)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-804h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 5 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "%s %d: invalid nonce - HW error",
      (const char *)thr->cgpu->drv->name,
      thr->cgpu->device_id);
    applog(6, tmp42, 0);
  }
  mutex_lock_1(&stats_lock, "cgminer.c", _func___16278, 8719);
  ++hw_errors;
  ++thr->cgpu->hw_errors;
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___16278, 8722);
  thr->cgpu->drv->hw_error(thr);
}

//----- (0005D390) --------------------------------------------------------
void __cdecl rebuild_nonce(work *work, uint32_t nonce)
{
  *(_DWORD *)&work->data[76] = _uint32_identity_0(nonce);
  regen_hash(work);
}

//----- (0005D3D8) --------------------------------------------------------
bool __cdecl test_nonce(work *work, uint32_t nonce)
{
  uint32_t *hash_32; // [sp+Ch] [bp-8h]

  hash_32 = (uint32_t *)&work->hash[28];
  rebuild_nonce(work, nonce);
  return *hash_32 == 0;
}

//----- (0005D42C) --------------------------------------------------------
void __cdecl update_work_stats(thr_info *thr, work *work)
{
  cgpu_info *cgpu; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-814h] BYREF
  double test_diff; // [sp+808h] [bp-14h]

  test_diff = current_diff;
  work->share_diff = share_diff(work);
  if ( test_diff <= (double)work->share_diff )
  {
    work->block = 1;
    ++work->pool->solved;
    ++found_blocks;
    work->mandatory = 1;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Found block for pool %d!", work->pool->pool_no);
      applog(5, tmp42, 0);
    }
  }
  mutex_lock_1(&stats_lock, "cgminer.c", _func___16313, 8797);
  total_diff1 = (__int64)((double)total_diff1 + work->device_diff);
  thr->cgpu->diff1 = (__int64)((double)thr->cgpu->diff1 + work->device_diff);
  work->pool->diff1 = (__int64)((double)work->pool->diff1 + work->device_diff);
  cgpu = thr->cgpu;
  cgpu->last_device_valid_work = time(0);
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___16313, 8802);
}

//----- (0005D684) --------------------------------------------------------
bool __cdecl submit_tested_work(thr_info *thr, work *work)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-808h] BYREF
  work *work_out; // [sp+814h] [bp-8h]

  update_work_stats(thr, work);
  if ( !fulltest(work->hash, work->target) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s %s %d: Share above target",
        (const char *)_FUNCTION___16326,
        (const char *)thr->cgpu->drv->name,
        thr->cgpu->device_id);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    work_out = copy_work_noffset(work, 0);
    submit_work_async(work_out);
    return 1;
  }
}

//----- (0005D7A8) --------------------------------------------------------
bool __cdecl new_nonce(thr_info *thr, uint32_t nonce)
{
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-808h] BYREF
  cgpu_info *cgpu; // [sp+814h] [bp-8h]

  cgpu = thr->cgpu;
  if ( nonce == cgpu->last_nonce )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "%s %d duplicate share detected as HW error",
        (const char *)cgpu->drv->name,
        cgpu->device_id);
      applog(6, tmp42, 0);
    }
    return 0;
  }
  else
  {
    cgpu->last_nonce = nonce;
    return 1;
  }
}

//----- (0005D894) --------------------------------------------------------
bool __cdecl submit_nonce(thr_info *thr, work *work, uint32_t nonce)
{
  if ( new_nonce(thr, nonce) && test_nonce(work, nonce) )
  {
    submit_tested_work(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
      benchfile_dspwork(work, nonce);
    return 1;
  }
  else
  {
    inc_hw_errors(thr);
    return 0;
  }
}

//----- (0005D940) --------------------------------------------------------
bool __cdecl abandon_work(work *work, timeval *wdiff, uint64_t hashes)
{
  return wdiff->tv_sec > opt_scantime || hashes > 0xFFFFFFFD || stale_work(work, 0);
}

//----- (0005D9BC) --------------------------------------------------------
void __cdecl mt_disable(thr_info *mythr, const int thr_id, device_drv *drv)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-804h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being disabled", thr_id);
    applog(4, tmp42, 0);
  }
  mythr->cgpu->rolling = 0.0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Waiting on sem in miner thread");
    applog(7, tmp42, 0);
  }
  cgsem_wait(&mythr->sem, "cgminer.c", _func___16403, 9101);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Thread %d being re-enabled", thr_id);
    applog(4, tmp42, 0);
  }
  drv->thread_enable(mythr);
}

//----- (0005DBA4) --------------------------------------------------------
void __cdecl hash_sole_work(thr_info *mythr)
{
  int v1; // r3
  bool v2; // r3
  double max_diff; // r2
  double device_diff; // r2
  int v5; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-894h] BYREF
  timespec rgtp; // [sp+810h] [bp-94h] BYREF
  work *work; // [sp+818h] [bp-8Ch] BYREF
  timeval wdiff; // [sp+81Ch] [bp-88h] BYREF
  timeval diff; // [sp+824h] [bp-80h]
  timeval sdiff; // [sp+82Ch] [bp-78h]
  timeval tv_lastupdate; // [sp+834h] [bp-70h] BYREF
  timeval tv_workstart; // [sp+83Ch] [bp-68h] BYREF
  timeval tv_start; // [sp+844h] [bp-60h] BYREF
  timeval getwork_start; // [sp+84Ch] [bp-58h] BYREF
  int mult; // [sp+854h] [bp-50h]
  int64_t hashes; // [sp+858h] [bp-4Ch]
  cgminer_stats *pool_stats; // [sp+860h] [bp-44h]
  timeval *tv_end; // [sp+864h] [bp-40h]
  bool primary; // [sp+86Bh] [bp-39h]
  int cycle; // [sp+86Ch] [bp-38h]
  cgminer_stats *dev_stats; // [sp+870h] [bp-34h]
  device_drv *drv; // [sp+874h] [bp-30h]
  cgpu_info *cgpu; // [sp+878h] [bp-2Ch]
  int thr_id; // [sp+87Ch] [bp-28h]
  int64_t hashes_done; // [sp+880h] [bp-24h]
  uint32_t max_nonce; // [sp+88Ch] [bp-18h]

  thr_id = mythr->id;
  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  dev_stats = &cgpu->cgminer_stats;
  v1 = opt_log_interval / 5;
  if ( !(opt_log_interval / 5) )
    v1 = 1;
  cycle = v1;
  v2 = !mythr->device_thread || mythr->primary_thread;
  primary = v2;
  wdiff.tv_sec = 0;
  wdiff.tv_usec = 0;
  max_nonce = drv->can_limit_work(mythr);
  hashes_done = 0LL;
  tv_end = &getwork_start;
  cgtime(&getwork_start);
  sdiff.tv_usec = 0;
  sdiff.tv_sec = 0;
  cgtime(&tv_lastupdate);
  while ( !cgpu->shutdown )
  {
    work = get_work(mythr, thr_id);
    mythr->work_restart = 0;
    cgpu->new_work = 1;
    cgtime(&tv_workstart);
    work->nonce = 0;
    cgpu->max_hashes = 0LL;
    if ( !drv->prepare_work(mythr, work) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "work prepare failed, exiting mining thread %d", thr_id);
        applog(3, tmp42, 0);
      }
      break;
    }
    if ( drv->max_diff <= work->work_difficulty )
      max_diff = drv->max_diff;
    else
      max_diff = work->work_difficulty;
    work->device_diff = max_diff;
    if ( drv->min_diff <= work->device_diff )
      device_diff = work->device_diff;
    else
      device_diff = drv->min_diff;
    work->device_diff = device_diff;
    while ( 1 )
    {
      cgtime(&tv_start);
      subtime(&tv_start, &getwork_start);
      addtime(&getwork_start, &dev_stats->getwork_wait);
      if ( time_more(&getwork_start, &dev_stats->getwork_wait_max) )
        copy_time(&dev_stats->getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, &dev_stats->getwork_wait_min) )
        copy_time(&dev_stats->getwork_wait_min, &getwork_start);
      ++dev_stats->getwork_calls;
      pool_stats = &work->pool->cgminer_stats;
      addtime(&getwork_start, &pool_stats->getwork_wait);
      if ( time_more(&getwork_start, &pool_stats->getwork_wait_max) )
        copy_time(&pool_stats->getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, &pool_stats->getwork_wait_min) )
        copy_time(&pool_stats->getwork_wait_min, &getwork_start);
      ++pool_stats->getwork_calls;
      cgtime(&work->tv_work_start);
      pthread_setcancelstate(1, 0);
      thread_reportin(mythr);
      hashes = ((__int64 (__fastcall *)(thr_info *, work *, uint32_t, _DWORD))drv->scanhash)(
                 mythr,
                 work,
                 work->nonce + max_nonce,
                 0);
      thread_reportout(mythr);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      cgtime(&getwork_start);
      if ( hashes == -1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
          applog(3, tmp42, 0);
        }
        cgpu->deven = DEV_DISABLED;
        dev_error(cgpu, REASON_THREAD_ZERO_HASH);
        cgpu->shutdown = 1;
        goto LABEL_68;
      }
      hashes_done += hashes;
      if ( cgpu->max_hashes < hashes )
        cgpu->max_hashes = hashes;
      diff.tv_sec = tv_end->tv_sec - tv_start.tv_sec;
      diff.tv_usec = tv_end->tv_usec - tv_start.tv_usec;
      if ( diff.tv_usec < 0 )
      {
        --diff.tv_sec;
        diff.tv_usec += 1000000;
      }
      sdiff.tv_sec += diff.tv_sec;
      sdiff.tv_usec += diff.tv_usec;
      if ( sdiff.tv_usec > (int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377] )
      {
        ++sdiff.tv_sec;
        sdiff.tv_usec -= 1000000;
      }
      wdiff.tv_sec = tv_end->tv_sec - tv_workstart.tv_sec;
      wdiff.tv_usec = tv_end->tv_usec - tv_workstart.tv_usec;
      if ( wdiff.tv_usec < 0 )
      {
        --wdiff.tv_sec;
        wdiff.tv_usec += 1000000;
      }
      if ( cycle <= sdiff.tv_sec )
        break;
      if ( max_nonce != -1 )
      {
        v5 = sdiff.tv_usec + 1024;
        if ( sdiff.tv_usec + 1024 < 0 )
          v5 = sdiff.tv_usec + 2047;
        mult = cycle * ((int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377] / (v5 >> 10) + 16);
        if ( max_nonce <= 0xFFFFFC00 / mult )
          max_nonce = (max_nonce * mult) >> 10;
        else
          max_nonce = -1;
        goto LABEL_53;
      }
LABEL_67:
      if ( abandon_work(work, &wdiff, cgpu->max_hashes) )
        goto LABEL_68;
    }
    if ( cycle >= sdiff.tv_sec )
    {
      if ( sdiff.tv_usec > 100000 )
        max_nonce = (max_nonce << 10)
                  / (((int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377] * cycle + sdiff.tv_usec)
                   / ((int)&calc_nonce_info.chain_asic_core_nonce_num[1][23][377]
                    * cycle
                    / 1024));
    }
    else
    {
      max_nonce = max_nonce * cycle / sdiff.tv_sec;
    }
LABEL_53:
    diff.tv_sec = tv_end->tv_sec - tv_lastupdate.tv_sec;
    diff.tv_usec = tv_end->tv_usec - tv_lastupdate.tv_usec;
    if ( diff.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    if ( hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000) || diff.tv_sec >= opt_log_interval )
    {
      hashmeter(thr_id, hashes_done);
      hashes_done = 0LL;
      copy_time(&tv_lastupdate, tv_end);
    }
    if ( !mythr->work_restart )
    {
      if ( mythr->pause || cgpu->deven )
        mt_disable(mythr, thr_id, drv);
      sdiff.tv_usec = 0;
      sdiff.tv_sec = 0;
      goto LABEL_67;
    }
    if ( !primary )
    {
      rgtp.tv_sec = 0;
      rgtp.tv_nsec = 250000000 * mythr->device_thread;
      nanosleep(&rgtp, 0);
    }
LABEL_68:
    free_work(&work, "cgminer.c", _func___16435, 9299);
  }
  cgpu->deven = DEV_DISABLED;
}
// 5DC58: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (0005E54C) --------------------------------------------------------
void __cdecl flush_queue(cgpu_info *cgpu)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-808h] BYREF
  work *work; // [sp+80Ch] [bp-8h] BYREF

  work = 0;
  if ( cgpu )
  {
    if ( !wr_trylock(&cgpu->qlock, "cgminer.c", _func___16601, 9582) )
    {
      work = cgpu->unqueued_work;
      cgpu->unqueued_work = 0;
      wr_unlock(&cgpu->qlock, "cgminer.c", _func___16601, 9589);
      if ( work )
      {
        free_work(&work, "cgminer.c", _func___16601, 9593);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "Discarded queued work item");
          applog(7, tmp42, 0);
        }
      }
    }
  }
}

//----- (0005E6BC) --------------------------------------------------------
void __cdecl hash_driver_work(thr_info *mythr)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-844h] BYREF
  timeval diff; // [sp+810h] [bp-44h]
  timeval tv_end; // [sp+818h] [bp-3Ch] BYREF
  timeval tv_start; // [sp+820h] [bp-34h] BYREF
  int64_t hashes; // [sp+828h] [bp-2Ch]
  int thr_id; // [sp+834h] [bp-20h]
  device_drv *drv; // [sp+838h] [bp-1Ch]
  cgpu_info *cgpu; // [sp+83Ch] [bp-18h]
  int64_t hashes_done; // [sp+840h] [bp-14h]

  tv_start.tv_sec = 0;
  tv_start.tv_usec = 0;
  cgpu = mythr->cgpu;
  drv = cgpu->drv;
  thr_id = mythr->id;
  hashes_done = 0LL;
  while ( !cgpu->shutdown )
  {
    mythr->work_update = 0;
    hashes = drv->scanwork(mythr);
    mythr->work_restart = 0;
    if ( hashes == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "%s %d failure, disabling!", (const char *)drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = DEV_DISABLED;
      dev_error(cgpu, REASON_THREAD_ZERO_HASH);
      break;
    }
    hashes_done += hashes;
    cgtime(&tv_end);
    diff.tv_sec = tv_end.tv_sec - tv_start.tv_sec;
    diff.tv_usec = tv_end.tv_usec - tv_start.tv_usec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --diff.tv_sec;
      diff.tv_usec += 1000000;
    }
    if ( hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000) || diff.tv_sec >= opt_log_interval )
    {
      hashmeter(thr_id, hashes_done);
      hashes_done = 0LL;
      copy_time(&tv_start, &tv_end);
    }
    if ( mythr->pause || cgpu->deven )
      mt_disable(mythr, thr_id, drv);
    if ( mythr->work_update )
    {
      mutex_lock_1(&update_job_lock, "cgminer.c", _func___16631, 9712);
      drv->update_work(cgpu);
      mutex_unlock_1(&update_job_lock, "cgminer.c", _func___16631, 9714);
    }
  }
  cgpu->deven = DEV_DISABLED;
}

//----- (0005E998) --------------------------------------------------------
void *__cdecl miner_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-824h] BYREF
  unsigned __int8 threadname[16]; // [sp+808h] [bp-24h] BYREF
  device_drv *drv; // [sp+818h] [bp-14h]
  cgpu_info *cgpu; // [sp+81Ch] [bp-10h]
  int thr_id; // [sp+820h] [bp-Ch]
  thr_info *mythr; // [sp+824h] [bp-8h]

  mythr = (thr_info *)userdata;
  thr_id = *(_DWORD *)userdata;
  cgpu = (cgpu_info *)*((_DWORD *)userdata + 9);
  drv = cgpu->drv;
  snprintf((char *)threadname, 0x10u, "%d/Miner", thr_id);
  RenameThread(threadname);
  thread_reportout(mythr);
  if ( !drv->thread_init(mythr) )
  {
    dev_error(cgpu, REASON_THREAD_FAIL_INIT);
  }
  else
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "Waiting on sem in miner thread");
      applog(7, tmp42, 0);
    }
    cgsem_wait(&mythr->sem, "cgminer.c", _func___16644, 9741);
    cgpu->last_device_valid_work = time(0);
    drv->hash_work(mythr);
    drv->thread_shutdown(mythr);
  }
  return 0;
}

//----- (0005EB3C) --------------------------------------------------------
void __cdecl wait_lpcurrent(pool *pool)
{
  bool i; // r0

  for ( i = cnx_needed(pool);
        !i
     && (pool->enabled == POOL_DISABLED
      || pool != current_pool() && pool_strategy_0 != POOL_LOADBALANCE && pool_strategy_0 != POOL_BALANCE);
        i = cnx_needed(pool) )
  {
    mutex_lock_1(&lp_lock, "cgminer.c", _func___16652, 9853);
    pthread_cond_wait(&lp_cond, &lp_lock);
    mutex_unlock_1(&lp_lock, "cgminer.c", _func___16652, 9855);
  }
}

//----- (0005EC18) --------------------------------------------------------
void *__cdecl longpoll_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0005EC48) --------------------------------------------------------
void __cdecl reinit_device(cgpu_info *cgpu)
{
  if ( cgpu->deven != DEV_DISABLED )
    cgpu->drv->reinit_device(cgpu);
}

//----- (0005EC8C) --------------------------------------------------------
void __cdecl reap_curl(pool *pool)
{
  const char *v1; // r3
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-818h] BYREF
  timeval now; // [sp+814h] [bp-18h] BYREF
  int reaped; // [sp+81Ch] [bp-10h]
  curl_ent *iter; // [sp+820h] [bp-Ch]
  curl_ent *ent; // [sp+824h] [bp-8h]

  reaped = 0;
  cgtime(&now);
  mutex_lock_1(&pool->pool_lock, "cgminer.c", _func___16670, 10098);
  ent = (curl_ent *)&pool->curlring.next[-1].prev;
  iter = CONTAINING_RECORD(ent->node.next, curl_ent, node);
  while ( &ent->node != &pool->curlring )
  {
    if ( pool->curls <= 1 )
      return;
    if ( now.tv_sec - ent->tv.tv_sec > 300 )
    {
      ++reaped;
      --pool->curls;
      list_del_0(&ent->node);
      free(ent);
    }
    ent = iter;
    iter = CONTAINING_RECORD(iter->node.next, curl_ent, node);
  }
  mutex_unlock_1(&pool->pool_lock, "cgminer.c", _func___16670, 10116);
  if ( reaped && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( reaped <= 1 )
      v1 = (const char *)byte_A1BD4;
    else
      v1 = "s";
    snprintf((char *)tmp42, 0x800u, "Reaped %d curl%s from pool %d", reaped, v1, pool->pool_no);
    applog(7, tmp42, 0);
  }
}
// A1BD4: using guessed type unsigned __int8 byte_A1BD4[4];

//----- (0005EE80) --------------------------------------------------------
void __cdecl prune_stratum_shares(pool *pool)
{
  stratum_share *next; // r3
  stratum_share *v2; // r3
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-824h] BYREF
  unsigned int _hd_bkt; // [sp+810h] [bp-24h]
  UT_hash_handle *_hd_hh_del; // [sp+814h] [bp-20h]
  time_t current_time; // [sp+818h] [bp-1Ch]
  int cleared; // [sp+81Ch] [bp-18h]
  stratum_share *tmpshare; // [sp+820h] [bp-14h]
  stratum_share *sshare; // [sp+824h] [bp-10h]

  current_time = time(0);
  cleared = 0;
  mutex_lock_1(&sshare_lock, "cgminer.c", _func___16682, 10134);
  sshare = stratum_shares;
  if ( stratum_shares )
    next = (stratum_share *)stratum_shares->hh.next;
  else
    next = 0;
  tmpshare = next;
  while ( sshare )
  {
    if ( pool == sshare->work->pool && current_time > sshare->sshare_time + 120 )
    {
      if ( sshare->hh.prev || sshare->hh.next )
      {
        _hd_hh_del = &sshare->hh;
        if ( sshare == (stratum_share *)((char *)stratum_shares->hh.tbl->tail - stratum_shares->hh.tbl->hho) )
          stratum_shares->hh.tbl->tail = (UT_hash_handle *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho);
        if ( sshare->hh.prev )
          *(_DWORD *)((char *)sshare->hh.prev + stratum_shares->hh.tbl->hho + 8) = sshare->hh.next;
        else
          stratum_shares = (stratum_share *)sshare->hh.next;
        if ( _hd_hh_del->next )
          *(_DWORD *)((char *)_hd_hh_del->next + stratum_shares->hh.tbl->hho + 4) = _hd_hh_del->prev;
        _hd_bkt = (stratum_shares->hh.tbl->num_buckets - 1) & _hd_hh_del->hashv;
        --stratum_shares->hh.tbl->buckets[_hd_bkt].count;
        if ( _hd_hh_del == stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head )
          stratum_shares->hh.tbl->buckets[_hd_bkt].hh_head = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_prev )
          _hd_hh_del->hh_prev->hh_next = _hd_hh_del->hh_next;
        if ( _hd_hh_del->hh_next )
          _hd_hh_del->hh_next->hh_prev = _hd_hh_del->hh_prev;
        --stratum_shares->hh.tbl->num_items;
      }
      else
      {
        free(stratum_shares->hh.tbl->buckets);
        free(stratum_shares->hh.tbl);
        stratum_shares = 0;
      }
      free_work(&sshare->work, "cgminer.c", _func___16682, 10141);
      free(sshare);
      ++cleared;
    }
    sshare = tmpshare;
    if ( tmpshare )
      v2 = (stratum_share *)tmpshare->hh.next;
    else
      v2 = 0;
    tmpshare = v2;
  }
  mutex_unlock_1(&sshare_lock, "cgminer.c", _func___16682, 10147);
  if ( cleared )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Lost %d shares due to no stratum share response from pool %d",
        cleared,
        pool->pool_no);
      applog(4, tmp42, 0);
    }
    pool->stale_shares += cleared;
    total_stale += cleared;
  }
}

//----- (0005F360) --------------------------------------------------------
void *__cdecl __noreturn watchpool_thread(void *userdata)
{
  int prio; // r6
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-83Ch] BYREF
  timeval now; // [sp+810h] [bp-3Ch] BYREF
  cgtimer_t cgt; // [sp+818h] [bp-34h] BYREF
  double shares; // [sp+820h] [bp-2Ch]
  pool *pool; // [sp+82Ch] [bp-20h]
  int i; // [sp+830h] [bp-1Ch]
  int intervals; // [sp+834h] [bp-18h]

  intervals = 0;
  pthread_setcanceltype(1, 0);
  RenameThread("Watchpool");
  set_lowprio();
  cgtimer_time(&cgt);
  while ( 1 )
  {
    if ( ++intervals > 120 )
      intervals = 0;
    cgtime(&now);
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( !opt_benchmark && !opt_benchfile )
      {
        reap_curl(pool);
        prune_stratum_shares(pool);
      }
      if ( intervals > 119 )
      {
        shares = (double)(pool->diff1 - pool->last_shares);
        pool->last_shares = pool->diff1;
        pool->utility = (pool->utility + shares * 0.63) / 1.63;
        pool->shares = (int)pool->utility;
      }
      if ( pool->enabled && !pool->testing )
      {
        if ( pool_active(pool, 1) )
        {
          if ( pool_tclear(pool, &pool->idle) )
            pool_resus(pool);
        }
        else
        {
          cgtime(&pool->tv_idle);
        }
        if ( !pool->idle && pool_strategy_0 == POOL_FAILOVER )
        {
          prio = pool->prio;
          if ( prio < cp_prio() && now.tv_sec - pool->tv_idle.tv_sec > opt_pool_fallback )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 3 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "Pool %d %s stable for >%d seconds",
                pool->pool_no,
                (const char *)pool->rpc_url,
                opt_pool_fallback);
              applog(4, tmp42, 0);
            }
            switch_pools(0);
          }
        }
      }
    }
    if ( current_pool()->idle )
      switch_pools(0);
    if ( pool_strategy_0 == POOL_ROTATE && now.tv_sec - rotate_tv.tv_sec > 60 * opt_rotate_period )
    {
      cgtime(&rotate_tv);
      switch_pools(0);
    }
    cgsleep_ms_r(&cgt, 5000);
    cgtimer_time(&cgt);
  }
}

//----- (0005F730) --------------------------------------------------------
void *__cdecl __noreturn watchdog_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-834h] BYREF
  unsigned __int8 dev_str[8]; // [sp+810h] [bp-34h] BYREF
  timeval now; // [sp+818h] [bp-2Ch] BYREF
  timeval zero_tv; // [sp+820h] [bp-24h] BYREF
  dev_enable *denable; // [sp+828h] [bp-1Ch]
  thr_info *thr_0; // [sp+82Ch] [bp-18h]
  cgpu_info *cgpu; // [sp+830h] [bp-14h]
  thr_info *thr; // [sp+834h] [bp-10h]
  unsigned int interval; // [sp+838h] [bp-Ch]
  int i; // [sp+83Ch] [bp-8h]

  interval = 2;
  pthread_setcanceltype(1, 0);
  RenameThread("Watchdog");
  set_lowprio();
  memset(&zero_tv, 0, sizeof(zero_tv));
  cgtime(&rotate_tv);
LABEL_2:
  sleep(interval);
  discard_stale();
  hashmeter(-1, 0LL);
  cgtime(&now);
  if ( !sched_paused && !should_run() )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Pausing execution as per stop time %02d:%02d scheduled",
        schedstop.tm.tm_hour,
        schedstop.tm.tm_min);
      applog(4, tmp42, 0);
    }
    if ( !schedstart.enable )
    {
      strcpy((char *)tmp42, "Terminating execution as planned");
      applog(3, tmp42, 1);
      quit(0);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Will restart execution as scheduled at %02d:%02d",
        schedstart.tm.tm_hour,
        schedstart.tm.tm_min);
      applog(4, tmp42, 0);
    }
    sched_paused = 1;
    rd_lock_0(&mining_thr_lock, "cgminer.c", _func___16715, 10365);
    for ( i = 0; i < mining_threads; ++i )
      mining_thr[i]->pause = 1;
    rd_unlock_0(&mining_thr_lock, "cgminer.c", _func___16715, 10372);
  }
  else if ( sched_paused && should_run() )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Restarting execution as per start time %02d:%02d scheduled",
        schedstart.tm.tm_hour,
        schedstart.tm.tm_min);
      applog(4, tmp42, 0);
    }
    if ( schedstop.enable && (use_syslog || opt_log_output || opt_log_level > 3) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Will pause execution as scheduled at %02d:%02d",
        schedstop.tm.tm_hour,
        schedstop.tm.tm_min);
      applog(4, tmp42, 0);
    }
    sched_paused = 0;
    for ( i = 0; i < mining_threads; ++i )
    {
      thr = get_thread(i);
      if ( thr->cgpu->deven != DEV_DISABLED )
      {
        thr->pause = 0;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "Pushing sem post to thread %d", thr->id);
          applog(7, tmp42, 0);
        }
        cgsem_post(&thr->sem, "cgminer.c", _func___16715, 10399);
      }
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= total_devices )
      goto LABEL_2;
    cgpu = get_devices(i);
    thr_0 = *cgpu->thr;
    if ( thr_0 )
    {
      cgpu->drv->get_stats(cgpu);
      denable = &cgpu->deven;
      snprintf((char *)dev_str, 8u, "%s %d", (const char *)cgpu->drv->name, cgpu->device_id);
      if ( !thr_0->getwork && *denable != DEV_DISABLED )
      {
        if ( cgpu->status && now.tv_sec - thr_0->last.tv_sec <= 119 )
        {
          if ( cgpu->status != LIFE_INIT && (use_syslog || opt_log_output || opt_log_level > 2) )
          {
            snprintf((char *)tmp42, 0x800u, "%s: Recovered, declaring WELL!", (const char *)dev_str);
            applog(3, tmp42, 0);
          }
          cgpu->status = LIFE_WELL;
          cgpu->device_last_well = time(0);
        }
        else if ( cgpu->status || now.tv_sec - thr_0->last.tv_sec <= 120 )
        {
          if ( cgpu->status == LIFE_SICK && now.tv_sec - thr_0->last.tv_sec > 600 )
          {
            cgpu->status = LIFE_DEAD;
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "%s: Not responded for more than 10 minutes, declaring DEAD!",
                (const char *)dev_str);
              applog(3, tmp42, 0);
            }
            cgtime(&thr_0->sick);
            dev_error(cgpu, REASON_DEV_DEAD_IDLE_600);
          }
          else if ( now.tv_sec - thr_0->sick.tv_sec > 60 && (cgpu->status == LIFE_SICK || cgpu->status == LIFE_DEAD) )
          {
            cgtime(&thr_0->sick);
            if ( opt_restart )
              goto LABEL_75;
          }
        }
        else
        {
          cgpu->rolling = 0.0;
          cgpu->status = LIFE_SICK;
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf((char *)tmp42, 0x800u, "%s: Idle for more than 60 seconds, declaring SICK!", (const char *)dev_str);
            applog(3, tmp42, 0);
          }
          cgtime(&thr_0->sick);
          dev_error(cgpu, REASON_DEV_SICK_IDLE_60);
          if ( opt_restart && !is_re_open_core_now() )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf((char *)tmp42, 0x800u, "%s: Attempting to restart", (const char *)dev_str);
              applog(3, tmp42, 0);
            }
LABEL_75:
            reinit_device(cgpu);
            continue;
          }
        }
      }
    }
  }
}

//----- (000600DC) --------------------------------------------------------
void __cdecl log_print_status(cgpu_info *cgpu)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-904h] BYREF
  unsigned __int8 logline[255]; // [sp+808h] [bp-104h] BYREF

  get_statline(logline, 0xFFu, cgpu);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "%s", (const char *)logline);
    applog(4, tmp42, 0);
  }
}

//----- (00060180) --------------------------------------------------------
void print_summary()
{
  const char *v0; // r3
  unsigned __int8 tmp42[2048]; // [sp+38h] [bp-860h] BYREF
  timeval diff; // [sp+838h] [bp-60h]
  cgpu_info *cgpu; // [sp+840h] [bp-58h]
  pool *pool; // [sp+844h] [bp-54h]
  double displayed_hashes; // [sp+848h] [bp-50h]
  double work_util; // [sp+850h] [bp-48h]
  double utility; // [sp+858h] [bp-40h]
  int secs; // [sp+860h] [bp-38h]
  int mins; // [sp+864h] [bp-34h]
  int hours; // [sp+868h] [bp-30h]
  int i; // [sp+86Ch] [bp-2Ch]

  diff.tv_sec = total_tv_end.tv_sec - total_tv_start.tv_sec;
  diff.tv_usec = total_tv_end.tv_usec - total_tv_start.tv_usec;
  if ( total_tv_end.tv_usec - total_tv_start.tv_usec < 0 )
  {
    --diff.tv_sec;
    diff.tv_usec += 1000000;
  }
  hours = diff.tv_sec / 3600;
  mins = diff.tv_sec % 3600 / 60;
  secs = diff.tv_sec % 60;
  utility = (double)total_accepted / total_secs * 60.0;
  work_util = (double)total_diff1 / total_secs * 60.0;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "\nSummary of runtime statistics:\n");
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Started at %s", (const char *)datestamp);
    applog(4, tmp42, 0);
  }
  if ( total_pools == 1 && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)(*pools)->rpc_url);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Runtime: %d hrs : %d mins : %d secs", hours, mins, secs);
    applog(4, tmp42, 0);
  }
  displayed_hashes = total_mhashes_done / total_secs;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Average hashrate: %.1f Mhash/s", displayed_hashes);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Solved blocks: %d", found_blocks);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Best share difficulty: %s", (const char *)best_share);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Share submissions: %lld", total_accepted + total_rejected);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Accepted shares: %lld", total_accepted);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Rejected shares: %lld", total_rejected);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Accepted difficulty shares: %1.f", total_diff_accepted);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Rejected difficulty shares: %1.f", total_diff_rejected);
    applog(4, tmp42, 0);
  }
  if ( (total_accepted || total_rejected) && (use_syslog || opt_log_output || opt_log_level > 3) )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Reject ratio: %.1f%%",
      (double)(100 * total_rejected) / (double)(total_accepted + total_rejected));
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Hardware errors: %d", hw_errors);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Utility (accepted shares / min): %.2f/min", utility);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", work_util);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Stale submissions discarded due to new blocks: %lld", total_stale);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Unable to get work from server occasions: %d", total_go);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Work items generated locally: %d", local_work);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Submitting work remotely delay occasions: %d", total_ro);
    applog(4, tmp42, 0);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "New blocks detected on network: %d\n", new_blocks);
    applog(4, tmp42, 0);
  }
  if ( total_pools > 1 )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "Pool: %s", (const char *)pool->rpc_url);
        applog(4, tmp42, 0);
      }
      if ( pool->solved && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        if ( pool->solved <= 1 )
          v0 = (const char *)&unk_A1BD4;
        else
          v0 = "S";
        snprintf((char *)tmp42, 0x800u, "SOLVED %d BLOCK%s!", pool->solved, v0);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Share submissions: %lld", pool->accepted + pool->rejected);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Accepted shares: %lld", pool->accepted);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Rejected shares: %lld", pool->rejected);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Accepted difficulty shares: %1.f", pool->diff_accepted);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Rejected difficulty shares: %1.f", pool->diff_rejected);
        applog(4, tmp42, 0);
      }
      if ( (pool->accepted || pool->rejected) && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          " Reject ratio: %.1f%%",
          (double)(100 * pool->rejected) / (double)(pool->accepted + pool->rejected));
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Items worked on: %d", pool->works);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Stale submissions discarded due to new blocks: %d", pool->stale_shares);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Unable to get work from server occasions: %d", pool->getfail_occasions);
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, " Submitting work remotely delay occasions: %d\n", pool->remotefail_occasions);
        applog(4, tmp42, 0);
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, "Summary of per device statistics:\n");
    applog(4, tmp42, 0);
  }
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu = get_devices(i);
    cgpu->drv->get_statline_before = (void (*)(unsigned __int8 *, size_t, cgpu_info *))blank_get_statline_before;
    cgpu->drv->get_statline = (void (*)(unsigned __int8 *, size_t, cgpu_info *))noop_get_statline;
    log_print_status(cgpu);
  }
  if ( opt_shares )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42, 0x800u, "Mined %.0f accepted shares of %d requested\n", total_diff_accepted, opt_shares);
      applog(4, tmp42, 0);
    }
    if ( (double)opt_shares > total_diff_accepted && (use_syslog || opt_log_output || opt_log_level > 3) )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "WARNING - Mined only %.0f shares of %d requested.",
        total_diff_accepted,
        opt_shares);
      applog(4, tmp42, 0);
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy((char *)tmp42, " ");
    applog(4, tmp42, 0);
  }
  fflush((FILE *)stderr);
  fflush((FILE *)stdout);
}
// C4478: using guessed type int stderr;
// C4484: using guessed type int stdout;

//----- (00061970) --------------------------------------------------------
void __cdecl clean_up(bool restarting)
{
  int v1; // r4
  int *v2; // r0
  char *v3; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-84Ch] BYREF
  sysinfo sInfo; // [sp+810h] [bp-4Ch] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v1 = *_errno_location();
      v2 = _errno_location();
      v3 = strerror(*v2);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v1, v3);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
  }
  cgtime(&total_tv_end);
  if ( !restarting && !opt_realquiet && successful_connect )
    print_summary();
}

//----- (00061AC4) --------------------------------------------------------
void *__cdecl __noreturn killall_thread(void *arg)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (00061B00) --------------------------------------------------------
void __cdecl __noreturn _quit(int status, bool clean)
{
  pthread_t killall_t[2]; // [sp+Ch] [bp-8h] BYREF

  if ( pthread_create(killall_t, 0, (void *(*)(void *))killall_thread, 0) )
    exit(1);
  if ( clean )
    clean_up(0);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  pthread_cancel(killall_t[0]);
  exit(status);
}
// 61B00: using guessed type pthread_t killall_t[2];

//----- (00061BA8) --------------------------------------------------------
void __cdecl __noreturn quit(int status)
{
  _quit(status, 1);
}

//----- (00061BC8) --------------------------------------------------------
void __fastcall sub_61BC8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R11,PC} }
}
// 61BCC: unbalanced stack, ignored a potential tail call

//----- (00061BD0) --------------------------------------------------------
void *__cdecl test_pool_thread(void *arg)
{
  pthread_t v1; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-80Ch] BYREF
  pool *pool; // [sp+810h] [bp-Ch]
  bool first_pool; // [sp+817h] [bp-5h]

  pool = (pool *)arg;
  if ( *((_BYTE *)arg + 107) != 1 )
  {
    v1 = pthread_self();
    pthread_detach(v1);
  }
  while ( !pool->removed )
  {
    if ( pool_active(pool, 0) )
    {
      pool_tclear(pool, &pool->idle);
      first_pool = 0;
      cg_wlock_1(&control_lock, "cgminer.c", _func___16839, 10711);
      if ( !pools_active )
      {
        currentpool = pool;
        if ( pool->pool_no )
          first_pool = 1;
        pools_active = 1;
      }
      cg_wunlock_1(&control_lock, "cgminer.c", _func___16839, 10725);
      if ( first_pool && (use_syslog || opt_log_output || opt_log_level > 4) )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Switching to pool %d %s - first alive pool",
          pool->pool_no,
          (const char *)pool->rpc_url);
        applog(5, tmp42, 0);
      }
      pool_resus(pool);
      switch_pools(0);
LABEL_17:
      pool->testing = 0;
      return 0;
    }
    pool_died(pool);
    if ( pool->blocking )
      goto LABEL_17;
    sleep(0x1Eu);
  }
  return 0;
}

//----- (00061DF0) --------------------------------------------------------
bool __cdecl add_pool_details(
        pool *pool,
        bool live,
        unsigned __int8 *url,
        unsigned __int8 *user,
        unsigned __int8 *pass)
{
  size_t v5; // r4
  size_t siz; // [sp+1Ch] [bp-10h]

  pool->rpc_url = get_proxy(url, pool);
  pool->rpc_user = user;
  pool->rpc_pass = pass;
  v5 = strlen((const char *)pool->rpc_user);
  siz = v5 + strlen((const char *)pool->rpc_pass) + 2;
  pool->rpc_userpass = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___16849, 10764);
  snprintf((char *)pool->rpc_userpass, siz, "%s:%s", (const char *)pool->rpc_user, (const char *)pool->rpc_pass);
  pool->testing = 1;
  pool->idle = 1;
  pool->blocking = !live;
  enable_pool(pool);
  pthread_create(&pool->test_thread, 0, (void *(*)(void *))test_pool_thread, pool);
  if ( live )
    return 1;
  pthread_join(pool->test_thread, 0);
  return pools_active;
}

//----- (00061F80) --------------------------------------------------------
void fork_monitor()
{
  int pfd[2]; // [sp+Ch] [bp-18h] BYREF
  sighandler_t sr1; // [sp+14h] [bp-10h]
  sighandler_t sr0; // [sp+18h] [bp-Ch]
  int r; // [sp+1Ch] [bp-8h]

  r = pipe(pfd);
  if ( r < 0 )
  {
    perror("pipe - failed to create pipe for --monitor");
    exit(1);
  }
  fflush((FILE *)stderr);
  r = dup2(pfd[1], 2);
  if ( r < 0 )
  {
    perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
    exit(1);
  }
  r = close(pfd[1]);
  if ( r < 0 )
  {
    perror("close - failed to close write end of pipe for --monitor");
    exit(1);
  }
  sr0 = signal(13, (__sighandler_t)1);
  sr1 = signal(13, (__sighandler_t)1);
  if ( sr0 == (sighandler_t)-1 || sr1 == (sighandler_t)-1 )
  {
    perror("signal - failed to edit signal mask for --monitor");
    exit(1);
  }
  forkpid = fork();
  if ( forkpid < 0 )
  {
    perror("fork - failed to fork child process for --monitor");
    exit(1);
  }
  if ( !forkpid )
  {
    r = dup2(pfd[0], 0);
    if ( r < 0 )
    {
      perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
      exit(1);
    }
    close(pfd[0]);
    if ( r < 0 )
    {
      perror("close - in child, failed to close read end of  pipe for --monitor");
      exit(1);
    }
    execl("/bin/bash", "/bin/bash", "-c", opt_stderr_cmd, 0);
    perror("execl - in child failed to exec user specified command for --monitor");
    exit(1);
  }
  r = close(pfd[0]);
  if ( r < 0 )
  {
    perror("close - failed to close read end of pipe for --monitor");
    exit(1);
  }
}
// C4478: using guessed type int stderr;

//----- (000621B8) --------------------------------------------------------
void __cdecl noop_reinit_device(cgpu_info *cgpu)
{
  ;
}

//----- (000621D8) --------------------------------------------------------
void __cdecl blank_get_statline_before(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  ;
}

//----- (00062200) --------------------------------------------------------
void __cdecl noop_get_statline(unsigned __int8 *buf, size_t bufsiz, cgpu_info *cgpu)
{
  ;
}

//----- (00062228) --------------------------------------------------------
bool __cdecl noop_get_stats(cgpu_info *cgpu)
{
  return 1;
}

//----- (0006224C) --------------------------------------------------------
bool __cdecl noop_thread_prepare(thr_info *thr)
{
  return 1;
}

//----- (00062270) --------------------------------------------------------
bool __cdecl noop_thread_init(thr_info *thr)
{
  return 1;
}

//----- (00062294) --------------------------------------------------------
bool __cdecl noop_prepare_work(thr_info *thr, work *work)
{
  return 1;
}

//----- (000622BC) --------------------------------------------------------
void __cdecl noop_hw_error(thr_info *thr)
{
  ;
}

//----- (000622DC) --------------------------------------------------------
void __cdecl noop_thread_shutdown(thr_info *thr)
{
  ;
}

//----- (000622FC) --------------------------------------------------------
void __cdecl noop_thread_enable(thr_info *thr)
{
  ;
}

//----- (0006231C) --------------------------------------------------------
void __cdecl noop_detect(bool hotplug)
{
  ;
}

//----- (00062340) --------------------------------------------------------
void __cdecl generic_zero_stats(cgpu_info *cgpu)
{
  cgpu->hw_errors = 0;
  cgpu->diff_rejected = 0.0;
  cgpu->diff_accepted = cgpu->diff_rejected;
}

//----- (0006238C) --------------------------------------------------------
void __cdecl fill_device_drv(device_drv *drv)
{
  if ( !drv->drv_detect )
    drv->drv_detect = (void (*)(bool))noop_detect;
  if ( !drv->reinit_device )
    drv->reinit_device = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->get_statline_before )
    drv->get_statline_before = (void (*)(unsigned __int8 *, size_t, cgpu_info *))blank_get_statline_before;
  if ( !drv->get_statline )
    drv->get_statline = (void (*)(unsigned __int8 *, size_t, cgpu_info *))noop_get_statline;
  if ( !drv->get_stats )
    drv->get_stats = (bool (*)(cgpu_info *))noop_get_stats;
  if ( !drv->thread_prepare )
    drv->thread_prepare = (bool (*)(thr_info *))noop_thread_prepare;
  if ( !drv->thread_init )
    drv->thread_init = (bool (*)(thr_info *))noop_thread_init;
  if ( !drv->prepare_work )
    drv->prepare_work = (bool (*)(thr_info *, work *))noop_prepare_work;
  if ( !drv->hw_error )
    drv->hw_error = (void (*)(thr_info *))noop_hw_error;
  if ( !drv->thread_shutdown )
    drv->thread_shutdown = (void (*)(thr_info *))noop_thread_shutdown;
  if ( !drv->thread_enable )
    drv->thread_enable = (void (*)(thr_info *))noop_thread_enable;
  if ( !drv->hash_work )
    drv->hash_work = (void (*)(thr_info *))hash_sole_work;
  if ( !drv->flush_work )
    drv->flush_work = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->update_work )
    drv->update_work = (void (*)(cgpu_info *))noop_reinit_device;
  if ( !drv->queue_full )
    drv->queue_full = (bool (*)(cgpu_info *))noop_get_stats;
  if ( !drv->zero_stats )
    drv->zero_stats = (void (*)(cgpu_info *))generic_zero_stats;
  if ( drv->max_diff == 0.0 )
    drv->max_diff = 1.0;
}

//----- (000625D4) --------------------------------------------------------
void __cdecl enable_device(cgpu_info *cgpu)
{
  cgpu_info **v1; // r1
  int v2; // r2

  cgpu->deven = DEV_ENABLED;
  wr_lock_1(&devices_lock, "cgminer.c", _func___16943, 11174);
  v1 = devices;
  v2 = cgminer_id_count++;
  cgpu->cgminer_id = v2;
  v1[cgpu->cgminer_id] = cgpu;
  wr_unlock(&devices_lock, "cgminer.c", _func___16943, 11176);
  if ( hotplug_mode )
    new_threads += cgpu->threads;
  else
    mining_threads += cgpu->threads;
  rwlock_init_0(&cgpu->qlock, "cgminer.c", _func___16943, 11187);
  cgpu->queued_work = 0;
}

//----- (00062710) --------------------------------------------------------
void adjust_mostdevs()
{
  if ( total_devices - zombie_devs > most_devices )
    most_devices = total_devices - zombie_devs;
}

//----- (00062780) --------------------------------------------------------
bool __cdecl add_cgpu(cgpu_info *cgpu)
{
  size_t v1; // r0
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v3; // r3
  int v4; // r3
  int v5; // r2
  cgpu_info **v6; // r3
  int v7; // r2
  UT_hash_bucket_0 *_he_newbkt; // [sp+14h] [bp-58h]
  UT_hash_handle *_he_hh_nxt; // [sp+1Ch] [bp-50h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+20h] [bp-4Ch]
  unsigned int _ha_bkt; // [sp+24h] [bp-48h]
  unsigned int _hf_bkt; // [sp+28h] [bp-44h]
  UT_hash_handle *_he_thh; // [sp+2Ch] [bp-40h]
  unsigned int _he_bkt_i; // [sp+30h] [bp-3Ch]
  const unsigned __int8 *_hj_key_0; // [sp+34h] [bp-38h]
  unsigned int _hj_k_0; // [sp+38h] [bp-34h]
  unsigned int _hj_j_0; // [sp+3Ch] [bp-30h]
  unsigned int _hj_j_0a; // [sp+3Ch] [bp-30h]
  unsigned int _hj_j_0b; // [sp+3Ch] [bp-30h]
  unsigned int _hj_j_0c; // [sp+3Ch] [bp-30h]
  unsigned int _hj_j_0d; // [sp+3Ch] [bp-30h]
  unsigned int _hj_j_0e; // [sp+3Ch] [bp-30h]
  int _hj_i_0; // [sp+40h] [bp-2Ch]
  int _hj_i_0a; // [sp+40h] [bp-2Ch]
  int _hj_i_0b; // [sp+40h] [bp-2Ch]
  int _hj_i_0c; // [sp+40h] [bp-2Ch]
  int _hj_i_0d; // [sp+40h] [bp-2Ch]
  int _hj_i_0e; // [sp+40h] [bp-2Ch]
  int _ha_hashv; // [sp+44h] [bp-28h]
  unsigned int _ha_hashvc; // [sp+44h] [bp-28h]
  unsigned int _ha_hashvd; // [sp+44h] [bp-28h]
  unsigned int _ha_hashve; // [sp+44h] [bp-28h]
  unsigned int _ha_hashva; // [sp+44h] [bp-28h]
  unsigned int _ha_hashvf; // [sp+44h] [bp-28h]
  unsigned int _ha_hashvg; // [sp+44h] [bp-28h]
  unsigned int _ha_hashvb; // [sp+44h] [bp-28h]
  unsigned __int8 *_hj_key; // [sp+48h] [bp-24h]
  unsigned int _hj_k; // [sp+4Ch] [bp-20h]
  unsigned int _hj_j; // [sp+50h] [bp-1Ch]
  unsigned int _hj_ja; // [sp+50h] [bp-1Ch]
  unsigned int _hj_jb; // [sp+50h] [bp-1Ch]
  unsigned int _hj_jc; // [sp+50h] [bp-1Ch]
  unsigned int _hj_jd; // [sp+50h] [bp-1Ch]
  unsigned int _hj_je; // [sp+50h] [bp-1Ch]
  int _hj_i; // [sp+54h] [bp-18h]
  int _hj_ia; // [sp+54h] [bp-18h]
  int _hj_ib; // [sp+54h] [bp-18h]
  int _hj_ic; // [sp+54h] [bp-18h]
  int _hj_id; // [sp+54h] [bp-18h]
  int _hj_ie; // [sp+54h] [bp-18h]
  int _hf_hashv; // [sp+58h] [bp-14h]
  unsigned int _hf_hashvc; // [sp+58h] [bp-14h]
  unsigned int _hf_hashvd; // [sp+58h] [bp-14h]
  unsigned int _hf_hashve; // [sp+58h] [bp-14h]
  unsigned int _hf_hashva; // [sp+58h] [bp-14h]
  unsigned int _hf_hashvf; // [sp+58h] [bp-14h]
  unsigned int _hf_hashvg; // [sp+58h] [bp-14h]
  unsigned int _hf_hashvb; // [sp+58h] [bp-14h]
  _cgpu_devid_counter *d; // [sp+5Ch] [bp-10h]
  _cgpu_devid_counter *da; // [sp+5Ch] [bp-10h]

  _hj_key = cgpu->drv->name;
  _hf_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)_hj_key); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_ja = _hj_j + _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16) + (_hj_key[7] << 24);
    _hf_hashvc = _hf_hashv + _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16) + (_hj_key[11] << 24);
    _hj_ia = (_hf_hashvc >> 13) ^ (_hj_i
                                 + *_hj_key
                                 + (_hj_key[1] << 8)
                                 + (_hj_key[2] << 16)
                                 + (_hj_key[3] << 24)
                                 - _hj_ja
                                 - _hf_hashvc);
    _hj_jb = (_hj_ia << 8) ^ (_hj_ja - _hf_hashvc - _hj_ia);
    _hf_hashvd = (_hj_jb >> 13) ^ (_hf_hashvc - _hj_ia - _hj_jb);
    _hj_ib = (_hf_hashvd >> 12) ^ (_hj_ia - _hj_jb - _hf_hashvd);
    _hj_jc = (_hj_ib << 16) ^ (_hj_jb - _hf_hashvd - _hj_ib);
    _hf_hashve = (_hj_jc >> 5) ^ (_hf_hashvd - _hj_ib - _hj_jc);
    _hj_i = (_hf_hashve >> 3) ^ (_hj_ib - _hj_jc - _hf_hashve);
    _hj_j = (_hj_i << 10) ^ (_hj_jc - _hf_hashve - _hj_i);
    _hf_hashv = (_hj_j >> 15) ^ (_hf_hashve - _hj_i - _hj_j);
    _hj_key += 12;
  }
  _hf_hashva = _hf_hashv + strlen((const char *)cgpu->drv->name);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_15;
    case 2u:
      goto LABEL_14;
    case 3u:
      goto LABEL_13;
    case 4u:
      goto LABEL_12;
    case 5u:
      goto LABEL_11;
    case 6u:
      goto LABEL_10;
    case 7u:
      goto LABEL_9;
    case 8u:
      goto LABEL_8;
    case 9u:
      goto LABEL_7;
    case 0xAu:
      goto LABEL_6;
    case 0xBu:
      _hf_hashva += _hj_key[10] << 24;
LABEL_6:
      _hf_hashva += _hj_key[9] << 16;
LABEL_7:
      _hf_hashva += _hj_key[8] << 8;
LABEL_8:
      _hj_j += _hj_key[7] << 24;
LABEL_9:
      _hj_j += _hj_key[6] << 16;
LABEL_10:
      _hj_j += _hj_key[5] << 8;
LABEL_11:
      _hj_j += _hj_key[4];
LABEL_12:
      _hj_i += _hj_key[3] << 24;
LABEL_13:
      _hj_i += _hj_key[2] << 16;
LABEL_14:
      _hj_i += _hj_key[1] << 8;
LABEL_15:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_ic = (_hf_hashva >> 13) ^ (_hj_i - _hj_j - _hf_hashva);
  _hj_jd = (_hj_ic << 8) ^ (_hj_j - _hf_hashva - _hj_ic);
  _hf_hashvf = (_hj_jd >> 13) ^ (_hf_hashva - _hj_ic - _hj_jd);
  _hj_id = (_hf_hashvf >> 12) ^ (_hj_ic - _hj_jd - _hf_hashvf);
  _hj_je = (_hj_id << 16) ^ (_hj_jd - _hf_hashvf - _hj_id);
  _hf_hashvg = (_hj_je >> 5) ^ (_hf_hashvf - _hj_id - _hj_je);
  _hj_ie = (_hf_hashvg >> 3) ^ (_hj_id - _hj_je - _hf_hashvg);
  _hf_hashvb = (((_hj_ie << 10) ^ (_hj_je - _hf_hashvg - _hj_ie)) >> 15) ^ (_hf_hashvg
                                                                          - _hj_ie
                                                                          - ((_hj_ie << 10) ^ (_hj_je
                                                                                             - _hf_hashvg
                                                                                             - _hj_ie)));
  d = 0;
  if ( devids_16954 )
  {
    _hf_bkt = (devids_16954->hh.tbl->num_buckets - 1) & _hf_hashvb;
    if ( devids_16954->hh.tbl->buckets[_hf_bkt].hh_head )
      d = (_cgpu_devid_counter *)((char *)devids_16954->hh.tbl->buckets[_hf_bkt].hh_head - devids_16954->hh.tbl->hho);
    else
      d = 0;
    while ( d )
    {
      if ( _hf_hashvb == d->hh.hashv && d->hh.keylen == strlen((const char *)cgpu->drv->name) )
      {
        v1 = strlen((const char *)cgpu->drv->name);
        if ( !memcmp(d->hh.key, cgpu->drv->name, v1) )
          break;
      }
      if ( d->hh.hh_next )
        d = (_cgpu_devid_counter *)((char *)d->hh.hh_next - devids_16954->hh.tbl->hho);
      else
        d = 0;
    }
  }
  if ( d )
  {
    cgpu->device_id = ++d->lastid;
  }
  else
  {
    da = (_cgpu_devid_counter *)cgmalloc(0x28u, "cgminer.c", _func___16979, 11221);
    cg_memcpy(da, cgpu->drv->name, 4u, "cgminer.c", _func___16979, 11222);
    da->lastid = 0;
    cgpu->device_id = da->lastid;
    _hj_key_0 = (const unsigned __int8 *)da;
    _ha_hashv = -17973521;
    _hj_j_0 = -1640531527;
    _hj_i_0 = -1640531527;
    for ( _hj_k_0 = strlen((const char *)da); _hj_k_0 > 0xB; _hj_k_0 -= 12 )
    {
      _hj_j_0a = _hj_j_0 + _hj_key_0[4] + (_hj_key_0[5] << 8) + (_hj_key_0[6] << 16) + (_hj_key_0[7] << 24);
      _ha_hashvc = _ha_hashv + _hj_key_0[8] + (_hj_key_0[9] << 8) + (_hj_key_0[10] << 16) + (_hj_key_0[11] << 24);
      _hj_i_0a = (_ha_hashvc >> 13) ^ (_hj_i_0
                                     + *_hj_key_0
                                     + (_hj_key_0[1] << 8)
                                     + (_hj_key_0[2] << 16)
                                     + (_hj_key_0[3] << 24)
                                     - _hj_j_0a
                                     - _ha_hashvc);
      _hj_j_0b = (_hj_i_0a << 8) ^ (_hj_j_0a - _ha_hashvc - _hj_i_0a);
      _ha_hashvd = (_hj_j_0b >> 13) ^ (_ha_hashvc - _hj_i_0a - _hj_j_0b);
      _hj_i_0b = (_ha_hashvd >> 12) ^ (_hj_i_0a - _hj_j_0b - _ha_hashvd);
      _hj_j_0c = (_hj_i_0b << 16) ^ (_hj_j_0b - _ha_hashvd - _hj_i_0b);
      _ha_hashve = (_hj_j_0c >> 5) ^ (_ha_hashvd - _hj_i_0b - _hj_j_0c);
      _hj_i_0 = (_ha_hashve >> 3) ^ (_hj_i_0b - _hj_j_0c - _ha_hashve);
      _hj_j_0 = (_hj_i_0 << 10) ^ (_hj_j_0c - _ha_hashve - _hj_i_0);
      _ha_hashv = (_hj_j_0 >> 15) ^ (_ha_hashve - _hj_i_0 - _hj_j_0);
      _hj_key_0 += 12;
    }
    _ha_hashva = _ha_hashv + strlen((const char *)da);
    switch ( _hj_k_0 )
    {
      case 1u:
        goto LABEL_43;
      case 2u:
        goto LABEL_42;
      case 3u:
        goto LABEL_41;
      case 4u:
        goto LABEL_40;
      case 5u:
        goto LABEL_39;
      case 6u:
        goto LABEL_38;
      case 7u:
        goto LABEL_37;
      case 8u:
        goto LABEL_36;
      case 9u:
        goto LABEL_35;
      case 0xAu:
        goto LABEL_34;
      case 0xBu:
        _ha_hashva += _hj_key_0[10] << 24;
LABEL_34:
        _ha_hashva += _hj_key_0[9] << 16;
LABEL_35:
        _ha_hashva += _hj_key_0[8] << 8;
LABEL_36:
        _hj_j_0 += _hj_key_0[7] << 24;
LABEL_37:
        _hj_j_0 += _hj_key_0[6] << 16;
LABEL_38:
        _hj_j_0 += _hj_key_0[5] << 8;
LABEL_39:
        _hj_j_0 += _hj_key_0[4];
LABEL_40:
        _hj_i_0 += _hj_key_0[3] << 24;
LABEL_41:
        _hj_i_0 += _hj_key_0[2] << 16;
LABEL_42:
        _hj_i_0 += _hj_key_0[1] << 8;
LABEL_43:
        _hj_i_0 += *_hj_key_0;
        break;
      default:
        break;
    }
    _hj_i_0c = (_ha_hashva >> 13) ^ (_hj_i_0 - _hj_j_0 - _ha_hashva);
    _hj_j_0d = (_hj_i_0c << 8) ^ (_hj_j_0 - _ha_hashva - _hj_i_0c);
    _ha_hashvf = (_hj_j_0d >> 13) ^ (_ha_hashva - _hj_i_0c - _hj_j_0d);
    _hj_i_0d = (_ha_hashvf >> 12) ^ (_hj_i_0c - _hj_j_0d - _ha_hashvf);
    _hj_j_0e = (_hj_i_0d << 16) ^ (_hj_j_0d - _ha_hashvf - _hj_i_0d);
    _ha_hashvg = (_hj_j_0e >> 5) ^ (_ha_hashvf - _hj_i_0d - _hj_j_0e);
    _hj_i_0e = (_ha_hashvg >> 3) ^ (_hj_i_0d - _hj_j_0e - _ha_hashvg);
    _ha_hashvb = (((_hj_i_0e << 10) ^ (_hj_j_0e - _ha_hashvg - _hj_i_0e)) >> 15) ^ (_ha_hashvg
                                                                                  - _hj_i_0e
                                                                                  - ((_hj_i_0e << 10) ^ (_hj_j_0e - _ha_hashvg - _hj_i_0e)));
    da->hh.hashv = _ha_hashvb;
    da->hh.key = da;
    da->hh.keylen = strlen((const char *)da);
    if ( devids_16954 )
    {
      da->hh.tbl = devids_16954->hh.tbl;
      da->hh.next = 0;
      da->hh.prev = (char *)devids_16954->hh.tbl->tail - devids_16954->hh.tbl->hho;
      devids_16954->hh.tbl->tail->next = da;
      devids_16954->hh.tbl->tail = &da->hh;
    }
    else
    {
      da->hh.next = 0;
      da->hh.prev = 0;
      devids_16954 = da;
      da->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
      if ( !devids_16954->hh.tbl )
        exit(-1);
      memset(devids_16954->hh.tbl, 0, sizeof(UT_hash_table));
      devids_16954->hh.tbl->tail = &devids_16954->hh;
      devids_16954->hh.tbl->num_buckets = 32;
      devids_16954->hh.tbl->log2_num_buckets = 5;
      devids_16954->hh.tbl->hho = 8;
      tbl = devids_16954->hh.tbl;
      tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
      if ( !devids_16954->hh.tbl->buckets )
        exit(-1);
      memset(devids_16954->hh.tbl->buckets, 0, 0x180u);
      devids_16954->hh.tbl->signature = -1609490463;
    }
    ++devids_16954->hh.tbl->num_items;
    _ha_bkt = (devids_16954->hh.tbl->num_buckets - 1) & _ha_hashvb;
    v3 = &devids_16954->hh.tbl->buckets[_ha_bkt];
    ++v3->count;
    da->hh.hh_next = devids_16954->hh.tbl->buckets[_ha_bkt].hh_head;
    da->hh.hh_prev = 0;
    if ( devids_16954->hh.tbl->buckets[_ha_bkt].hh_head )
      devids_16954->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &da->hh;
    devids_16954->hh.tbl->buckets[_ha_bkt].hh_head = &da->hh;
    if ( devids_16954->hh.tbl->buckets[_ha_bkt].count >= 10 * (devids_16954->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
      && da->hh.tbl->noexpand != 1 )
    {
      _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * da->hh.tbl->num_buckets);
      if ( !_he_new_buckets )
        exit(-1);
      memset(_he_new_buckets, 0, 24 * da->hh.tbl->num_buckets);
      da->hh.tbl->ideal_chain_maxlen = (((2 * da->hh.tbl->num_buckets - 1) & da->hh.tbl->num_items) != 0)
                                     + (da->hh.tbl->num_items >> (da->hh.tbl->log2_num_buckets + 1));
      da->hh.tbl->nonideal_items = 0;
      for ( _he_bkt_i = 0; _he_bkt_i < da->hh.tbl->num_buckets; ++_he_bkt_i )
      {
        for ( _he_thh = da->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
        {
          _he_hh_nxt = _he_thh->hh_next;
          _he_newbkt = &_he_new_buckets[(2 * da->hh.tbl->num_buckets - 1) & _he_thh->hashv];
          if ( ++_he_newbkt->count > da->hh.tbl->ideal_chain_maxlen )
          {
            ++da->hh.tbl->nonideal_items;
            _he_newbkt->expand_mult = _he_newbkt->count / da->hh.tbl->ideal_chain_maxlen;
          }
          _he_thh->hh_prev = 0;
          _he_thh->hh_next = _he_newbkt->hh_head;
          if ( _he_newbkt->hh_head )
            _he_newbkt->hh_head->hh_prev = _he_thh;
          _he_newbkt->hh_head = _he_thh;
        }
      }
      free(da->hh.tbl->buckets);
      da->hh.tbl->num_buckets *= 2;
      ++da->hh.tbl->log2_num_buckets;
      da->hh.tbl->buckets = _he_new_buckets;
      if ( da->hh.tbl->nonideal_items <= da->hh.tbl->num_items >> 1 )
        v4 = 0;
      else
        v4 = da->hh.tbl->ineff_expands + 1;
      da->hh.tbl->ineff_expands = v4;
      if ( da->hh.tbl->ineff_expands > 1 )
        da->hh.tbl->noexpand = 1;
    }
  }
  wr_lock_1(&devices_lock, "cgminer.c", _func___16979, 11227);
  devices = (cgpu_info **)cgrealloc(devices, 4 * (total_devices + new_devices + 2), "cgminer.c", _func___16979, 11228);
  wr_unlock(&devices_lock, "cgminer.c", _func___16979, 11229);
  mutex_lock_1(&stats_lock, "cgminer.c", _func___16979, 11231);
  cgpu->last_device_valid_work = time(0);
  mutex_unlock_1(&stats_lock, "cgminer.c", _func___16979, 11233);
  if ( hotplug_mode )
  {
    v5 = new_devices++;
    v6 = &devices[v5] + total_devices;
  }
  else
  {
    v7 = total_devices++;
    v6 = &devices[v7];
  }
  *v6 = cgpu;
  adjust_mostdevs();
  return 1;
}
// 62B0C: control flows out of bounds to 62B10
// 633FC: control flows out of bounds to 63400

//----- (00064040) --------------------------------------------------------
void probe_pools()
{
  pool *pool; // [sp+0h] [bp-Ch]
  int i; // [sp+4h] [bp-8h]

  for ( i = 0; i < total_pools; ++i )
  {
    pool = pools[i];
    pool->testing = 1;
    pthread_create(&pool->test_thread, 0, (void *(*)(void *))test_pool_thread, pool);
  }
}

//----- (000640D0) --------------------------------------------------------
void set_start_time_point()
{
  int v0; // r4
  int *v1; // r0
  char *v2; // r0
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-94Ch] BYREF
  sysinfo sInfo; // [sp+800h] [bp-14Ch] BYREF
  unsigned __int8 logstr[256]; // [sp+840h] [bp-10Ch] BYREF

  if ( sysinfo_0(&sInfo) )
  {
    v0 = *_errno_location();
    v1 = _errno_location();
    v2 = strerror(*v1);
    sprintf((char *)logstr, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v2);
    total_tv_start_sys = time(0);
    total_tv_end_sys = total_tv_start_sys + 1;
  }
  else
  {
    total_tv_start_sys = sInfo.uptime;
    total_tv_end_sys = sInfo.uptime + 1;
    sprintf(
      (char *)logstr,
      "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n",
      sInfo.uptime,
      sInfo.uptime + 1);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "%s", (const char *)logstr);
      applog(5, tmp42, 0);
    }
  }
}

//----- (00064238) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int8 **v3; // r4
  char *v4; // r4
  char *v5; // r0
  block *v6; // r4
  UT_hash_table *tbl; // r4
  UT_hash_bucket_0 *v8; // r3
  unsigned int v9; // r3
  unsigned __int8 *v10; // r0
  double v11; // r2
  FILE *v12; // r0
  FILE *v13; // r0
  unsigned __int8 *v14; // r0
  size_t v15; // r4
  unsigned __int8 *v16; // r0
  thr_info **v17; // r4
  thr_info **v18; // r0
  int v19; // r4
  int *v20; // r0
  char *v21; // r0
  char v23; // [sp+10h] [bp-2A7Ch] BYREF
  char v24[4088]; // [sp+1018h] [bp-1A74h] BYREF
  unsigned __int8 **argva; // [sp+2020h] [bp-A6Ch]
  int argca; // [sp+2024h] [bp-A68h] BYREF
  unsigned __int8 szfilepath[256]; // [sp+2028h] [bp-A64h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+2128h] [bp-964h] BYREF
  sysinfo sInfo; // [sp+2928h] [bp-164h] BYREF
  work *work; // [sp+2968h] [bp-124h] BYREF
  sigaction handler; // [sp+296Ch] [bp-120h] BYREF
  size_t siz; // [sp+29F8h] [bp-94h]
  pool *pool_0; // [sp+29FCh] [bp-90h]
  cgpu_info *cgpu_0; // [sp+2A00h] [bp-8Ch]
  cgpu_info *cgpu_1; // [sp+2A04h] [bp-88h]
  pool *pool_3; // [sp+2A08h] [bp-84h]
  int max_staged; // [sp+2A0Ch] [bp-80h]
  thr_info *thr; // [sp+2A10h] [bp-7Ch]
  pool *pool_1; // [sp+2A14h] [bp-78h]
  pool *pool_2; // [sp+2A18h] [bp-74h]
  cgpu_info *cgpu; // [sp+2A1Ch] [bp-70h]
  unsigned __int8 *start; // [sp+2A20h] [bp-6Ch]
  int len; // [sp+2A24h] [bp-68h]
  FILE *fpversion; // [sp+2A28h] [bp-64h]
  pool *pool; // [sp+2A2Ch] [bp-60h]
  UT_hash_bucket_0 *_he_newbkt; // [sp+2A30h] [bp-5Ch]
  unsigned int _he_bkt; // [sp+2A34h] [bp-58h]
  UT_hash_handle *_he_hh_nxt; // [sp+2A38h] [bp-54h]
  UT_hash_bucket_0 *_he_new_buckets; // [sp+2A3Ch] [bp-50h]
  unsigned int _ha_bkt; // [sp+2A40h] [bp-4Ch]
  block *block; // [sp+2A44h] [bp-48h]
  unsigned __int8 *s; // [sp+2A48h] [bp-44h]
  int ts; // [sp+2A4Ch] [bp-40h]
  UT_hash_handle *_he_thh; // [sp+2A50h] [bp-3Ch]
  unsigned int _he_bkt_i; // [sp+2A54h] [bp-38h]
  const unsigned __int8 *_hj_key; // [sp+2A58h] [bp-34h]
  unsigned int _hj_k; // [sp+2A5Ch] [bp-30h]
  unsigned int _hj_j; // [sp+2A60h] [bp-2Ch]
  unsigned int _hj_i; // [sp+2A64h] [bp-28h]
  unsigned int _ha_hashv; // [sp+2A68h] [bp-24h]
  unsigned int k; // [sp+2A6Ch] [bp-20h]
  int slept; // [sp+2A70h] [bp-1Ch]
  int j; // [sp+2A74h] [bp-18h]
  int i; // [sp+2A78h] [bp-14h]
  bool pool_msg; // [sp+2A7Fh] [bp-Dh]

  argca = argc;
  argva = (unsigned __int8 **)argv;
  work = 0;
  pool_msg = 0;
  slept = 0;
  g_logfile_enable = 0;
  strcpy((char *)g_logfile_path, "bmminer.log");
  strcpy((char *)g_logfile_openflag, "a+");
  if ( sysconf(84) == 1 )
    selective_yield = sched_yield;
  initial_args = (unsigned __int8 **)cgmalloc(4 * (argca + 1), "cgminer.c", _func___17046, 11508);
  for ( i = 0; i < argca; ++i )
  {
    v3 = &initial_args[i];
    *v3 = (unsigned __int8 *)strdup((const char *)argva[i]);
  }
  initial_args[argca] = 0;
  mutex_init_0(&hash_lock, "cgminer.c", _func___17046, 11517);
  mutex_init_0(&update_job_lock, "cgminer.c", _func___17046, 11518);
  mutex_init_0(&console_lock, "cgminer.c", _func___17046, 11519);
  cglock_init_0(&control_lock, "cgminer.c", _func___17046, 11520);
  mutex_init_0(&stats_lock, "cgminer.c", _func___17046, 11521);
  mutex_init_0(&sharelog_lock, "cgminer.c", _func___17046, 11522);
  cglock_init_0(&ch_lock, "cgminer.c", _func___17046, 11523);
  mutex_init_0(&sshare_lock, "cgminer.c", _func___17046, 11524);
  rwlock_init_0(&blk_lock, "cgminer.c", _func___17046, 11525);
  rwlock_init_0(&netacc_lock, "cgminer.c", _func___17046, 11526);
  rwlock_init_0(&mining_thr_lock, "cgminer.c", _func___17046, 11527);
  rwlock_init_0(&devices_lock, "cgminer.c", _func___17046, 11528);
  mutex_init_0(&lp_lock, "cgminer.c", _func___17046, 11530);
  if ( pthread_cond_init(&lp_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init lp_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  mutex_init_0(&restart_lock, "cgminer.c", _func___17046, 11537);
  if ( pthread_cond_init(&restart_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init restart_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( pthread_cond_init(&gws_cond, 0) )
  {
    strcpy((char *)tmp42, "Failed to pthread_cond_init gws_cond");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  getq = tq_new();
  if ( !getq )
  {
    strcpy((char *)tmp42, "Failed to create getq");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  stgd_lock = &getq->mutex;
  snprintf((char *)packagename, 0x100u, "%s %s", "cgminer", "2.0.0");
  handler.sa_handler = (__sighandler_t)sighandler;
  handler.sa_flags = 0;
  sigemptyset(&handler.sa_mask);
  sigaction_0(15, &handler, &termhandler);
  sigaction_0(2, &handler, &inthandler);
  sigaction_0(6, &handler, &abrthandler);
  opt_kernel_path = (unsigned __int8 *)v24;
  strcpy(v24, "/usr/bin");
  cgminer_path = (unsigned __int8 *)&v23;
  s = (unsigned __int8 *)strdup((const char *)*argva);
  v4 = (char *)cgminer_path;
  v5 = dirname((char *)s);
  strcpy(v4, v5);
  free(s);
  strcat((char *)cgminer_path, "/");
  devcursor = 8;
  logstart = 9;
  logcursor = 10;
  block = (block *)cgcalloc(104, 1u, "cgminer.c", _func___17046, 11584);
  for ( i = 0; i <= 35; ++i )
    strcat((char *)block, "0");
  _hj_key = (const unsigned __int8 *)block;
  _ha_hashv = -17973521;
  _hj_j = -1640531527;
  _hj_i = -1640531527;
  for ( _hj_k = strlen((const char *)block); _hj_k > 0xB; _hj_k -= 12 )
  {
    _hj_i += *_hj_key + (_hj_key[1] << 8) + (_hj_key[2] << 16) + (_hj_key[3] << 24);
    _hj_j += _hj_key[4] + (_hj_key[5] << 8) + (_hj_key[6] << 16) + (_hj_key[7] << 24);
    _ha_hashv += _hj_key[8] + (_hj_key[9] << 8) + (_hj_key[10] << 16) + (_hj_key[11] << 24);
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 13;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 8;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 13;
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 12;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 16;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 5;
    _hj_i -= _hj_j;
    _hj_i -= _ha_hashv;
    _hj_i ^= _ha_hashv >> 3;
    _hj_j -= _ha_hashv;
    _hj_j -= _hj_i;
    _hj_j ^= _hj_i << 10;
    _ha_hashv -= _hj_i;
    _ha_hashv -= _hj_j;
    _ha_hashv ^= _hj_j >> 15;
    _hj_key += 12;
  }
  _ha_hashv += strlen((const char *)block);
  switch ( _hj_k )
  {
    case 1u:
      goto LABEL_31;
    case 2u:
      goto LABEL_30;
    case 3u:
      goto LABEL_29;
    case 4u:
      goto LABEL_28;
    case 5u:
      goto LABEL_27;
    case 6u:
      goto LABEL_26;
    case 7u:
      goto LABEL_25;
    case 8u:
      goto LABEL_24;
    case 9u:
      goto LABEL_23;
    case 0xAu:
      goto LABEL_22;
    case 0xBu:
      _ha_hashv += _hj_key[10] << 24;
LABEL_22:
      _ha_hashv += _hj_key[9] << 16;
LABEL_23:
      _ha_hashv += _hj_key[8] << 8;
LABEL_24:
      _hj_j += _hj_key[7] << 24;
LABEL_25:
      _hj_j += _hj_key[6] << 16;
LABEL_26:
      _hj_j += _hj_key[5] << 8;
LABEL_27:
      _hj_j += _hj_key[4];
LABEL_28:
      _hj_i += _hj_key[3] << 24;
LABEL_29:
      _hj_i += _hj_key[2] << 16;
LABEL_30:
      _hj_i += _hj_key[1] << 8;
LABEL_31:
      _hj_i += *_hj_key;
      break;
    default:
      break;
  }
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 13;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 8;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 13;
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 12;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 16;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 5;
  _hj_i -= _hj_j;
  _hj_i -= _ha_hashv;
  _hj_i ^= _ha_hashv >> 3;
  _hj_j -= _ha_hashv;
  _hj_j -= _hj_i;
  _hj_j ^= _hj_i << 10;
  _ha_hashv -= _hj_i;
  _ha_hashv -= _hj_j;
  _ha_hashv ^= _hj_j >> 15;
  block->hh.hashv = _ha_hashv;
  block->hh.key = block;
  block->hh.keylen = strlen((const char *)block);
  if ( blocks )
  {
    block->hh.tbl = blocks->hh.tbl;
    block->hh.next = 0;
    block->hh.prev = (char *)blocks->hh.tbl->tail - blocks->hh.tbl->hho;
    blocks->hh.tbl->tail->next = block;
    blocks->hh.tbl->tail = &block->hh;
  }
  else
  {
    block->hh.next = 0;
    block->hh.prev = 0;
    blocks = block;
    v6 = block;
    v6->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
    if ( !blocks->hh.tbl )
      exit(-1);
    memset(blocks->hh.tbl, 0, sizeof(UT_hash_table));
    blocks->hh.tbl->tail = &blocks->hh;
    blocks->hh.tbl->num_buckets = 32;
    blocks->hh.tbl->log2_num_buckets = 5;
    blocks->hh.tbl->hho = 68;
    tbl = blocks->hh.tbl;
    tbl->buckets = (UT_hash_bucket_0 *)malloc(0x180u);
    if ( !blocks->hh.tbl->buckets )
      exit(-1);
    memset(blocks->hh.tbl->buckets, 0, 0x180u);
    blocks->hh.tbl->signature = -1609490463;
  }
  ++blocks->hh.tbl->num_items;
  _ha_bkt = (blocks->hh.tbl->num_buckets - 1) & _ha_hashv;
  v8 = &blocks->hh.tbl->buckets[_ha_bkt];
  ++v8->count;
  block->hh.hh_next = blocks->hh.tbl->buckets[_ha_bkt].hh_head;
  block->hh.hh_prev = 0;
  if ( blocks->hh.tbl->buckets[_ha_bkt].hh_head )
    blocks->hh.tbl->buckets[_ha_bkt].hh_head->hh_prev = &block->hh;
  blocks->hh.tbl->buckets[_ha_bkt].hh_head = &block->hh;
  if ( blocks->hh.tbl->buckets[_ha_bkt].count >= 10 * (blocks->hh.tbl->buckets[_ha_bkt].expand_mult + 1)
    && block->hh.tbl->noexpand != 1 )
  {
    _he_new_buckets = (UT_hash_bucket_0 *)malloc(24 * block->hh.tbl->num_buckets);
    if ( !_he_new_buckets )
      exit(-1);
    memset(_he_new_buckets, 0, 24 * block->hh.tbl->num_buckets);
    block->hh.tbl->ideal_chain_maxlen = (((2 * block->hh.tbl->num_buckets - 1) & block->hh.tbl->num_items) != 0)
                                      + (block->hh.tbl->num_items >> (block->hh.tbl->log2_num_buckets + 1));
    block->hh.tbl->nonideal_items = 0;
    for ( _he_bkt_i = 0; _he_bkt_i < block->hh.tbl->num_buckets; ++_he_bkt_i )
    {
      for ( _he_thh = block->hh.tbl->buckets[_he_bkt_i].hh_head; _he_thh; _he_thh = _he_hh_nxt )
      {
        _he_hh_nxt = _he_thh->hh_next;
        _he_bkt = (2 * block->hh.tbl->num_buckets - 1) & _he_thh->hashv;
        _he_newbkt = &_he_new_buckets[_he_bkt];
        if ( ++_he_newbkt->count > block->hh.tbl->ideal_chain_maxlen )
        {
          ++block->hh.tbl->nonideal_items;
          _he_newbkt->expand_mult = _he_newbkt->count / block->hh.tbl->ideal_chain_maxlen;
        }
        _he_thh->hh_prev = 0;
        _he_thh->hh_next = _he_newbkt->hh_head;
        if ( _he_newbkt->hh_head )
          _he_newbkt->hh_head->hh_prev = _he_thh;
        _he_newbkt->hh_head = _he_thh;
      }
    }
    free(block->hh.tbl->buckets);
    block->hh.tbl->num_buckets *= 2;
    ++block->hh.tbl->log2_num_buckets;
    block->hh.tbl->buckets = _he_new_buckets;
    if ( block->hh.tbl->nonideal_items <= block->hh.tbl->num_items >> 1 )
      v9 = 0;
    else
      v9 = block->hh.tbl->ineff_expands + 1;
    block->hh.tbl->ineff_expands = v9;
    if ( block->hh.tbl->ineff_expands > 1 )
      block->hh.tbl->noexpand = 1;
  }
  strcpy((char *)current_hash, (const char *)block);
  scan_devices.next = &scan_devices;
  scan_devices.prev = &scan_devices;
  opt_register_table(opt_config_table, "Options for both config file and command line");
  opt_register_table(opt_cmdline_table, "Options for command line only");
  opt_parse(&argca, argva, applog_and_exit);
  if ( argca != 1 )
  {
    strcpy((char *)tmp42, "Unexpected extra commandline arguments");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( !config_loaded )
    load_default_config();
  if ( opt_benchmark || opt_benchfile )
  {
    pool = add_pool();
    v10 = (unsigned __int8 *)cgmalloc(0xFFu, "cgminer.c", _func___17046, 11620);
    pool->rpc_url = v10;
    if ( opt_benchfile )
      strcpy((char *)pool->rpc_url, "Benchfile");
    else
      strcpy((char *)pool->rpc_url, "Benchmark");
    pool->rpc_user = pool->rpc_url;
    pool->rpc_pass = pool->rpc_url;
    pool->rpc_userpass = pool->rpc_url;
    pool->sockaddr_url = pool->rpc_url;
    strncpy((char *)pool->diff, "?", 7u);
    pool->diff[7] = 0;
    enable_pool(pool);
    pool->idle = 0;
    LODWORD(v11) = 1;
    successful_connect = 1;
    for ( i = 0; ; ++i )
    {
      HIDWORD(v11) = i;
      if ( i > 15 )
        break;
      hex2bin(bench_hidiff_bins[i], bench_hidiffs[i], 0xA0u);
      hex2bin(bench_lodiff_bins[i], bench_lodiffs[i], 0xA0u);
    }
    set_target(bench_target, v11);
  }
  if ( opt_version_path )
  {
    fpversion = fopen((const char *)opt_version_path, "rb");
    memset(szfilepath, 0, sizeof(szfilepath));
    len = 0;
    start = 0;
    if ( fpversion )
    {
      len = fread(szfilepath, 1u, 0x100u, fpversion);
      if ( len > 0 )
      {
        start = (unsigned __int8 *)strchr((const char *)szfilepath, 10);
        if ( start )
        {
          cg_memcpy(g_miner_compiletime, szfilepath, start - szfilepath, "cgminer.c", _func___17046, 11679);
          strcpy((char *)szfilepath, (const char *)start + 1);
          start = (unsigned __int8 *)strchr((const char *)szfilepath, 10);
          if ( start )
            cg_memcpy(g_miner_type, szfilepath, start - szfilepath, "cgminer.c", _func___17046, 11688);
          else
            strcpy((char *)g_miner_type, (const char *)szfilepath);
        }
        else
        {
          strcpy((char *)g_miner_compiletime, (const char *)szfilepath);
        }
        if ( g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] == 10 )
          g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] = 0;
        if ( g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] == 13 )
          g_miner_compiletime[strlen((const char *)g_miner_compiletime) - 1] = 0;
        if ( g_miner_type[strlen((const char *)g_miner_type) - 1] == 10 )
          g_miner_type[strlen((const char *)g_miner_type) - 1] = 0;
        if ( g_miner_type[strlen((const char *)g_miner_type) - 1] == 13 )
          g_miner_type[strlen((const char *)g_miner_type) - 1] = 0;
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Read miner version file %s error %d", (const char *)opt_version_path, len);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Open miner version file %s error", (const char *)opt_version_path);
      applog(3, tmp42, 0);
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Miner compile time: %s type: %s",
        (const char *)g_miner_compiletime,
        (const char *)g_miner_type);
      applog(3, tmp42, 0);
    }
  }
  if ( opt_logfile_path )
  {
    g_logfile_enable = 1;
    strcpy((char *)g_logfile_path, (const char *)opt_logfile_path);
    if ( opt_logfile_openflag )
      strcpy((char *)g_logfile_openflag, (const char *)opt_logfile_openflag);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "Log file path: %s Open flag: %s",
        (const char *)g_logfile_path,
        (const char *)g_logfile_openflag);
      applog(3, tmp42, 0);
    }
  }
  if ( opt_logwork_path )
  {
    memset(szfilepath, 0, sizeof(szfilepath));
    if ( opt_logwork_asicnum )
    {
      if ( !*opt_logwork_asicnum )
      {
        strcpy((char *)tmp42, "Log work asic num empty");
        applog(3, tmp42, 1);
        quit(1);
      }
      g_logwork_asicnum = atoi((const char *)opt_logwork_asicnum);
      if ( g_logwork_asicnum != 1 && g_logwork_asicnum != 32 && g_logwork_asicnum != 64 )
      {
        strcpy((char *)tmp42, "Log work asic num must be 1, 32, 64");
        applog(3, tmp42, 1);
        quit(1);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "Log work path: %s Asic num: %s",
          (const char *)opt_logwork_path,
          (const char *)opt_logwork_asicnum);
        applog(3, tmp42, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Log work path: %s", (const char *)opt_logwork_path);
      applog(3, tmp42, 0);
    }
    sprintf((char *)szfilepath, "%s.txt", (const char *)opt_logwork_path);
    g_logwork_file = fopen((const char *)szfilepath, "a+");
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42, 0x800u, "Log work open file %s", (const char *)szfilepath);
      applog(3, tmp42, 0);
    }
    if ( g_logwork_asicnum == 1 )
    {
      sprintf((char *)szfilepath, "%s%02d.txt", (const char *)opt_logwork_path, g_logwork_asicnum);
      g_logwork_files[0] = fopen((const char *)szfilepath, "a+");
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)tmp42, 0x800u, "Log work open asic %d file %s", g_logwork_asicnum, (const char *)szfilepath);
        applog(3, tmp42, 0);
      }
    }
    else if ( g_logwork_asicnum == 32 || g_logwork_asicnum == 64 )
    {
      for ( i = 0; i <= g_logwork_asicnum; ++i )
      {
        sprintf((char *)szfilepath, "%s%02d_%02d.txt", (const char *)opt_logwork_path, g_logwork_asicnum, i);
        v12 = fopen((const char *)szfilepath, "a+");
        g_logwork_files[i] = v12;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "Log work open asic %d file %s", g_logwork_asicnum, (const char *)szfilepath);
          applog(3, tmp42, 0);
        }
      }
    }
    if ( opt_logwork_diff )
    {
      for ( i = 0; i <= 64; ++i )
      {
        sprintf((char *)szfilepath, "%s_diff_%02d.txt", (const char *)opt_logwork_path, i);
        v13 = fopen((const char *)szfilepath, "a+");
        g_logwork_diffs[i] = v13;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "Log work open diff file %s", (const char *)szfilepath);
          applog(3, tmp42, 0);
        }
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf((char *)tmp42, 0x800u, "Started %s", (const char *)packagename);
    applog(4, tmp42, 0);
  }
  if ( cnfbuf )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x800u, "Loaded configuration file %s", (const char *)cnfbuf);
      applog(5, tmp42, 0);
    }
    if ( fileconf_load == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Error in configuration file, partially loaded.");
        applog(4, tmp42, 0);
      }
      if ( use_curses && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        strcpy((char *)tmp42, "Start cgminer with -T to see what failed to load.");
        applog(4, tmp42, 0);
      }
    }
    else if ( !fileconf_load )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Fatal JSON error in configuration file.");
        applog(4, tmp42, 0);
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        strcpy((char *)tmp42, "Configuration file could not be used.");
        applog(4, tmp42, 0);
      }
    }
    free(cnfbuf);
    cnfbuf = 0;
  }
  strcat((char *)opt_kernel_path, "/");
  if ( want_per_device_stats )
    opt_log_output = 1;
  if ( opt_log_output )
    setlogmask(255);
  else
    setlogmask(63);
  if ( opt_scantime < 0 )
    opt_scantime = 60;
  total_control_threads = 8;
  control_thr = (thr_info *)cgcalloc(8, 0x40u, "cgminer.c", _func___17046, 11844);
  gwsched_thr_id = 0;
  fill_device_drv(&bitforce_drv);
  fill_device_drv(&modminer_drv);
  fill_device_drv(&bitmain_drv);
  fill_device_drv(&bitmain_soc_drv);
  bitforce_drv.drv_detect(0);
  modminer_drv.drv_detect(0);
  bitmain_drv.drv_detect(0);
  bitmain_soc_drv.drv_detect(0);
  if ( opt_display_devs )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy((char *)tmp42, "Devices detected:");
      applog(3, tmp42, 0);
    }
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = devices[i];
      if ( cgpu->name )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            " %2d. %s %d: %s (driver: %s)",
            i,
            (const char *)cgpu->drv->name,
            cgpu->device_id,
            (const char *)cgpu->name,
            (const char *)cgpu->drv->dname);
          applog(3, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          " %2d. %s %d (driver: %s)",
          i,
          (const char *)cgpu->drv->name,
          cgpu->device_id,
          (const char *)cgpu->drv->dname);
        applog(3, tmp42, 0);
      }
    }
    snprintf((char *)tmp42, 0x800u, "%d devices listed", total_devices);
    applog(3, tmp42, 1);
    _quit(0, 0);
  }
  mining_threads = 0;
  for ( i = 0; i < total_devices; ++i )
    enable_device(devices[i]);
  if ( !total_devices )
  {
    strcpy((char *)tmp42, "All devices disabled, cannot mint!");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  most_devices = total_devices;
  load_temp_cutoffs();
  for ( i = 0; i < total_devices; ++i )
    devices[i]->cgminer_stats.getwork_wait_min.tv_sec = 99999999;
  if ( !opt_compact )
  {
    logstart += most_devices;
    logcursor = logstart + 1;
  }
  if ( !total_pools )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "Need to specify at least one pool server.");
      applog(4, tmp42, 0);
    }
    strcpy((char *)tmp42, "Pool setup failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  for ( i = 0; i < total_pools; ++i )
  {
    pool_0 = pools[i];
    pool_0->cgminer_stats.getwork_wait_min.tv_sec = 99999999;
    pool_0->cgminer_pool_stats.getwork_wait_min.tv_sec = 99999999;
    if ( !pool_0->rpc_userpass )
    {
      if ( !pool_0->rpc_pass )
      {
        v14 = (unsigned __int8 *)strdup((const char *)byte_A1BD4);
        pool_0->rpc_pass = v14;
      }
      if ( !pool_0->rpc_user )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "No login credentials supplied for pool %u %s",
          i,
          (const char *)pool_0->rpc_url);
        applog(3, tmp42, 1);
        _quit(1, 0);
      }
      v15 = strlen((const char *)pool_0->rpc_user);
      siz = v15 + strlen((const char *)pool_0->rpc_pass) + 2;
      v16 = (unsigned __int8 *)cgmalloc(siz, "cgminer.c", _func___17046, 11953);
      pool_0->rpc_userpass = v16;
      snprintf(
        (char *)pool_0->rpc_userpass,
        siz,
        "%s:%s",
        (const char *)pool_0->rpc_user,
        (const char *)pool_0->rpc_pass);
    }
  }
  currentpool = *pools;
  if ( use_syslog )
    openlog("cgminer", 1, 8);
  if ( opt_stderr_cmd )
    fork_monitor();
  mining_thr = (thr_info **)cgcalloc(mining_threads, 4u, "cgminer.c", _func___17046, 11970);
  for ( i = 0; i < mining_threads; ++i )
  {
    v17 = &mining_thr[i];
    *v17 = (thr_info *)cgcalloc(1, 0x40u, "cgminer.c", _func___17046, 11974);
  }
  k = 0;
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu_0 = devices[i];
    v18 = (thr_info **)cgmalloc(4 * (cgpu_0->threads + 1), "cgminer.c", _func___17046, 11983);
    cgpu_0->thr = v18;
    cgpu_0->thr[cgpu_0->threads] = 0;
    cgpu_0->status = LIFE_INIT;
    j = 0;
    while ( j < cgpu_0->threads )
    {
      thr = get_thread(k);
      thr->id = k;
      thr->cgpu = cgpu_0;
      thr->device_thread = j;
      if ( cgpu_0->drv->thread_prepare(thr) )
      {
        if ( thr_info_create(thr, 0, (void *(*)(void *))miner_thread, thr) )
        {
          snprintf((char *)tmp42, 0x800u, "thread %d create failed", thr->id);
          applog(3, tmp42, 1);
          _quit(1, 0);
        }
        cgpu_0->thr[j] = thr;
        if ( cgpu_0->deven != DEV_DISABLED )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "Pushing sem post to thread %d", thr->id);
            applog(7, tmp42, 0);
          }
          cgsem_post(&thr->sem, "cgminer.c", _func___17046, 12011);
        }
      }
      ++j;
      ++k;
    }
  }
  if ( !opt_benchmark && !opt_benchfile )
  {
    for ( i = 0; i < total_pools; ++i )
    {
      pool_1 = pools[i];
      enable_pool(pool_1);
      pool_1->idle = 1;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      strcpy((char *)tmp42, "Probing for an alive pool");
      applog(5, tmp42, 0);
    }
    probe_pools();
    do
    {
      sleep(1u);
      ++slept;
    }
    while ( !pools_active && slept <= 179 );
    while ( !pools_active )
    {
      if ( !pool_msg )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "No servers were found that could be used to get work from.");
          applog(3, tmp42, 0);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy((char *)tmp42, "Please check the details from the list below of the servers you have input");
          applog(3, tmp42, 0);
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          strcpy(
            (char *)tmp42,
            "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
          applog(3, tmp42, 0);
        }
        for ( i = 0; i < total_pools; ++i )
        {
          pool_2 = pools[i];
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "Pool: %d  URL: %s  User: %s  Password: %s",
              i,
              (const char *)pool_2->rpc_url,
              (const char *)pool_2->rpc_user,
              (const char *)pool_2->rpc_pass);
            applog(4, tmp42, 0);
          }
        }
        pool_msg = 1;
        if ( use_curses && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          strcpy((char *)tmp42, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
          applog(3, tmp42, 0);
        }
      }
      if ( !use_curses )
      {
        strcpy((char *)tmp42, "No servers could be used! Exiting.");
        applog(3, tmp42, 1);
        _quit(0, 0);
      }
    }
  }
  total_mhashes_done = 0.0;
  for ( i = 0; i <= 11; ++i )
    g_local_mhashes_dones[i] = 0.0;
  g_local_mhashes_index = 0;
  for ( i = 0; i < total_devices; ++i )
  {
    cgpu_1 = devices[i];
    cgpu_1->total_mhashes = 0.0;
    cgpu_1->rolling = cgpu_1->total_mhashes;
  }
  if ( sysinfo_0(&sInfo) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      v19 = *_errno_location();
      v20 = _errno_location();
      v21 = strerror(*v20);
      snprintf((char *)tmp42, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v19, v21);
      applog(6, tmp42, 0);
    }
    total_tv_end_sys = time(0);
    total_tv_start_sys = time(0);
  }
  else
  {
    total_tv_end_sys = sInfo.uptime;
    total_tv_start_sys = sInfo.uptime;
  }
  cgtime(&total_tv_start);
  cgtime(&total_tv_end);
  cgtime(&tv_hashmeter);
  get_datestamp(datestamp, 0x28u, &total_tv_start);
  watchpool_thr_id = 2;
  thr = control_thr + 2;
  if ( thr_info_create(control_thr + 2, 0, (void *(*)(void *))watchpool_thread, 0) )
  {
    strcpy((char *)tmp42, "watchpool thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  pthread_detach(thr->pth);
  watchdog_thr_id = 3;
  thr = control_thr + 3;
  if ( thr_info_create(control_thr + 3, 0, (void *(*)(void *))watchdog_thread, 0) )
  {
    strcpy((char *)tmp42, "watchdog thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  pthread_detach(thr->pth);
  api_thr_id = 5;
  thr = control_thr + 5;
  if ( thr_info_create(control_thr + 5, 0, (void *(*)(void *))api_thread, &control_thr[5]) )
  {
    strcpy((char *)tmp42, "API thread create failed");
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  if ( total_control_threads != 8 )
  {
    snprintf((char *)tmp42, 0x800u, "incorrect total_control_threads (%d) should be 8", total_control_threads);
    applog(3, tmp42, 1);
    _quit(1, 0);
  }
  set_highprio();
  while ( 1 )
  {
    while ( 1 )
    {
      max_staged = max_queue;
      if ( opt_work_update )
        signal_work_update();
      opt_work_update = 0;
      mutex_lock_1(stgd_lock, "cgminer.c", _func___17046, 12190);
      ts = _total_staged();
      if ( ts > max_staged )
      {
        work_filled = 1;
        pthread_cond_wait(&gws_cond, stgd_lock);
        ts = _total_staged();
      }
      mutex_unlock_1(stgd_lock, "cgminer.c", _func___17046, 12201);
      if ( ts <= max_staged )
        break;
      work_filled = 1;
      work = hash_pop(0);
      if ( work )
        discard_work(&work, "cgminer.c", _func___17046, 12213);
    }
    if ( work )
      discard_work(&work, "cgminer.c", _func___17046, 12221);
    work = make_work();
    while ( 1 )
    {
      pool_3 = select_pool();
      if ( !pool_unusable(pool_3) )
        break;
      switch_pools(0);
      pool_3 = select_pool();
      if ( pool_unusable(pool_3) )
        cgsleep_ms(11);
    }
    if ( pool_3->has_stratum )
    {
      gen_stratum_work(pool_3, work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated stratum work");
        applog(7, tmp42, 0);
      }
      goto LABEL_362;
    }
    if ( opt_benchfile )
    {
      get_benchfile_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchfile work");
        applog(7, tmp42, 0);
      }
      goto LABEL_362;
    }
    if ( opt_benchmark )
    {
      get_benchmark_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchmark work");
        applog(7, tmp42, 0);
      }
      goto LABEL_362;
    }
    if ( opt_benchfile )
      break;
    if ( opt_benchmark )
    {
      get_benchmark_work(work);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "Generated benchmark work");
        applog(7, tmp42, 0);
      }
LABEL_362:
      stage_work(work);
      work = 0;
    }
  }
  get_benchfile_work(work);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "Generated benchfile work");
    applog(7, tmp42, 0);
  }
  goto LABEL_362;
}
// 64D14: control flows out of bounds to 64D18
// 65AD4: variable 'v11' is possibly undefined
// A1BD4: using guessed type unsigned __int8 byte_A1BD4[4];

//----- (00068714) --------------------------------------------------------
void __cdecl register_parse_clock_delay_ctrl(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp-2Ch]
  clock_delay_ctrl_t reg_value; // [sp+14h] [bp-28h]
  FILE *pFile_6; // [sp+18h] [bp-24h]
  FILE *pFile_5; // [sp+1Ch] [bp-20h]
  FILE *pFile_4; // [sp+20h] [bp-1Ch]
  FILE *pFile_3; // [sp+24h] [bp-18h]
  FILE *pFile_2; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  FILE *pFile; // [sp+34h] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value.v = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[0] = 0x%02X, Clock Delay Ctrl, %s\n",
        HIWORD(core_response),
        reg_value.v,
        v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:6]  CCDLY_SEL", reg_value.v >> 6);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[5:4]  PWTH_SEL", (reg_value.v >> 4) & 3);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[3]    HASH_CLKEN", (reg_value.v & 8) != 0);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[2]    MMEN", (reg_value.v & 4) != 0);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[1]    Reserved", (reg_value.v & 2) != 0);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[0]    SWPF_MODE", reg_value.v & 1);
      fclose(pFile_5);
    }
  }
  if ( log_level > 3 )
  {
    pFile_6 = fopen((const char *)log_file, "a+");
    if ( pFile_6 )
      fputc(10, pFile_6);
    fclose(pFile_6);
  }
}

//----- (00068AC8) --------------------------------------------------------
void __cdecl register_parse_process_monitor_ctrl(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp-20h]
  process_monitor_ctrl_t reg_value; // [sp+18h] [bp-1Ch]
  FILE *pFile_3; // [sp+1Ch] [bp-18h]
  FILE *pFile_2; // [sp+20h] [bp-14h]
  FILE *pFile_1; // [sp+24h] [bp-10h]
  FILE *pFile_0; // [sp+28h] [bp-Ch]
  FILE *pFile; // [sp+2Ch] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value.v = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[1] = 0x%02X, Process Monitor Ctrl, %s\n",
        HIWORD(core_response),
        reg_value.v,
        v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:3]  Reserved", reg_value.v >> 3);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[2]    PM_START", (reg_value.v & 4) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[1:0]  PM_SEL", reg_value.v & 3);
      fclose(pFile_2);
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (00068D38) --------------------------------------------------------
void __cdecl register_parse_process_monitor_data(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp-18h]
  process_monitor_data_t reg_value; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value._FREQ_CNT = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[2] = 0x%04X, Process Monitor Data, %s\n",
        HIWORD(core_response),
        reg_value._FREQ_CNT,
        v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[15:0] FREQ_CNT", reg_value._FREQ_CNT);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (00068EC4) --------------------------------------------------------
void __cdecl register_parse_core_error(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp-20h]
  core_error_t reg_value; // [sp+18h] [bp-1Ch]
  FILE *pFile_3; // [sp+1Ch] [bp-18h]
  FILE *pFile_2; // [sp+20h] [bp-14h]
  FILE *pFile_1; // [sp+24h] [bp-10h]
  FILE *pFile_0; // [sp+28h] [bp-Ch]
  FILE *pFile; // [sp+2Ch] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value.v = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> core_id[%d], CORE_REG[3] = 0x%02X, Core Error, %s\n", HIWORD(core_response), reg_value.v, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:5]  Reserved", reg_value.v >> 5);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[4]    INI_NONCE_ERR", (reg_value.v & 0x10) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[3:0]  CMD_ERR_CNT", reg_value.v & 0xF);
      fclose(pFile_2);
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (00069134) --------------------------------------------------------
void __cdecl register_parse_core_enable(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp-18h]
  core_enable_t reg_value; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value.u._CORE_EN_I = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[4] = 0x%04X, Core Enable, %s\n",
        HIWORD(core_response),
        reg_value.u._CORE_EN_I,
        v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:0]  CORE_EN_I", reg_value.u._CORE_EN_I);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (000692C4) --------------------------------------------------------
void __cdecl register_parse_hash_clock_ctrl(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp-18h]
  hash_clock_ctrl_t reg_value; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value.u._CLOCK_CTRL = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[5] = 0x%02X, Hash Clock Control, %s\n",
        HIWORD(core_response),
        reg_value.u._CLOCK_CTRL,
        v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:0]  CLOCK_CTRL", reg_value.u._CLOCK_CTRL);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (00069454) --------------------------------------------------------
void __cdecl register_parse_hash_clock_counter(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+14h] [bp-18h]
  hash_clock_counter_t reg_value; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value.u._CLOCK_CNT = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[6] = 0x%02X, Hash Clock Counter, %s\n",
        HIWORD(core_response),
        reg_value.u._CLOCK_CNT,
        v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[7:0]  CLOCK_CNT", reg_value.u._CLOCK_CNT);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (000695E4) --------------------------------------------------------
void __cdecl register_parse_sweep_freq_ctrl(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t core_response; // [sp+10h] [bp-24h]
  sweep_freq_ctrl_t reg_value; // [sp+14h] [bp-20h]
  FILE *pFile_4; // [sp+18h] [bp-1Ch]
  FILE *pFile_3; // [sp+1Ch] [bp-18h]
  FILE *pFile_2; // [sp+20h] [bp-14h]
  FILE *pFile_1; // [sp+24h] [bp-10h]
  FILE *pFile_0; // [sp+28h] [bp-Ch]
  FILE *pFile; // [sp+2Ch] [bp-8h]

  core_response = reg_status->reg_response;
  reg_value.v = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(
        pFile,
        ">> core_id[%d], CORE_REG[7] = 0x%04X, Sweep Clock Control, %s\n",
        HIWORD(core_response),
        reg_value.v,
        v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[15:8] Reserved", reg_value.u._RSVD1);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[7]    SWPF_MODE", *(_BYTE *)&reg_value.u >> 7);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[6:4]  Reserved", (*(_BYTE *)&reg_value.u >> 4) & 7);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[3:0]  CLK_SEL", *(_BYTE *)&reg_value.u & 0xF);
      fclose(pFile_3);
    }
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fputc(10, pFile_4);
    fclose(pFile_4);
  }
}

//----- (000698B4) --------------------------------------------------------
void __cdecl register_parse_chip_address(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-1Ch]
  FILE *pFile_3; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile; // [sp+1Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x00] = 0x%08X, Chip Address, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:16]  CHIP_ID", HIWORD(reg_value));
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[15:8]   CORE_NUM", BYTE1(reg_value));
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[7:0]    ADDR", (unsigned __int8)reg_value);
      fclose(pFile_2);
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (00069AF0) --------------------------------------------------------
void __cdecl register_parse_hash_rate(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile; // [sp+1Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x04] = 0x%08X, Hash Rate, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31]    LONG", HIBYTE(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[30:0]  HASHRATE", reg_value & 0x7FFFFFFF);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
}

//----- (00069CD4) --------------------------------------------------------
void __cdecl register_parse_pll0_parameter(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-38h]
  FILE *pFile_10; // [sp+10h] [bp-34h]
  FILE *pFile_9; // [sp+14h] [bp-30h]
  FILE *pFile_8; // [sp+18h] [bp-2Ch]
  FILE *pFile_7; // [sp+1Ch] [bp-28h]
  FILE *pFile_6; // [sp+20h] [bp-24h]
  FILE *pFile_5; // [sp+24h] [bp-20h]
  FILE *pFile_4; // [sp+28h] [bp-1Ch]
  FILE *pFile_3; // [sp+2Ch] [bp-18h]
  FILE *pFile_2; // [sp+30h] [bp-14h]
  FILE *pFile_1; // [sp+34h] [bp-10h]
  FILE *pFile_0; // [sp+38h] [bp-Ch]
  FILE *pFile; // [sp+3Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x08] = 0x%08X, PLL0 Parameter, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31]     LOCKED", HIBYTE(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (reg_value & 0x40000000) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[29:28]  Reserved", (HIBYTE(reg_value) >> 4) & 3);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(reg_value) & 0xFFF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", BYTE1(reg_value) >> 6);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", BYTE1(reg_value) & 0x3F);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7]      Reserved", (unsigned __int8)reg_value >> 7);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", ((unsigned __int8)reg_value >> 4) & 7);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "%-30s = 0x%X\n", "BIT[3]      Reserved", (reg_value & 8) != 0);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(pFile_9, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", reg_value & 7);
      fclose(pFile_9);
    }
  }
  if ( log_level > 3 )
  {
    pFile_10 = fopen((const char *)log_file, "a+");
    if ( pFile_10 )
      fputc(10, pFile_10);
    fclose(pFile_10);
  }
}

//----- (0006A21C) --------------------------------------------------------
void __cdecl register_parse_chip_nonce_offset(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-1Ch]
  FILE *pFile_3; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile; // [sp+1Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x0C] = 0x%08X, Chip Nonce Offset, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31]     CNOV", HIBYTE(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[30:16]  Reserved", HIWORD(reg_value) & 0x7FFF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[2:0]    CNO", (unsigned __int16)reg_value);
      fclose(pFile_2);
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
}

//----- (0006A468) --------------------------------------------------------
void __cdecl register_parse_hash_counting_number(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-14h]
  FILE *pFile_1; // [sp+Ch] [bp-10h]
  FILE *pFile_0; // [sp+10h] [bp-Ch]
  FILE *pFile; // [sp+14h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x10] = 0x%08X, Hash Counting Number, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:0]  HCN", reg_value);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (0006A5DC) --------------------------------------------------------
void __cdecl register_parse_ticket_mask(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-20h]
  FILE *pFile_4; // [sp+10h] [bp-1Ch]
  FILE *pFile_3; // [sp+14h] [bp-18h]
  FILE *pFile_2; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x14] = 0x%08X, Ticket Mask, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:24]  TM3", HIBYTE(reg_value));
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[23:16]  TM2", BYTE2(reg_value));
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[15:8]   TM1", BYTE1(reg_value));
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[7:0]    TM0", (unsigned __int8)reg_value);
      fclose(pFile_3);
    }
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fputc(10, pFile_4);
    fclose(pFile_4);
  }
}

//----- (0006A87C) --------------------------------------------------------
void __cdecl register_parse_misc_control(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-48h]
  FILE *pFile_14; // [sp+10h] [bp-44h]
  FILE *pFile_13; // [sp+14h] [bp-40h]
  FILE *pFile_12; // [sp+18h] [bp-3Ch]
  FILE *pFile_11; // [sp+1Ch] [bp-38h]
  FILE *pFile_10; // [sp+20h] [bp-34h]
  FILE *pFile_9; // [sp+24h] [bp-30h]
  FILE *pFile_8; // [sp+28h] [bp-2Ch]
  FILE *pFile_7; // [sp+2Ch] [bp-28h]
  FILE *pFile_6; // [sp+30h] [bp-24h]
  FILE *pFile_5; // [sp+34h] [bp-20h]
  FILE *pFile_4; // [sp+38h] [bp-1Ch]
  FILE *pFile_3; // [sp+3Ch] [bp-18h]
  FILE *pFile_2; // [sp+40h] [bp-14h]
  FILE *pFile_1; // [sp+44h] [bp-10h]
  FILE *pFile_0; // [sp+48h] [bp-Ch]
  FILE *pFile; // [sp+4Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x18] = 0x%08X, Misc Control, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:23]  Reserved", HIWORD(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[22]     CORE_SRST", (reg_value & 0x400000) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[21]     SPAT_NOD", (reg_value & 0x200000) != 0);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[20]     RVS_K0", (reg_value & 0x100000) != 0);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[19:18]  DSCLK_SEL", (BYTE2(reg_value) >> 2) & 3);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[17:16]  Reserved", BYTE2(reg_value) & 3);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[15]     RET_ERR_NONCE", BYTE1(reg_value) >> 7);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[14]     RFS", (reg_value & 0x4000) != 0);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "%-30s = 0x%X\n", "BIT[13]     INV_CLKO", (reg_value & 0x2000) != 0);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(pFile_9, "%-30s = 0x%X\n", "BIT[12:8]   BT8D", BYTE1(reg_value) & 0x1F);
      fclose(pFile_9);
    }
    if ( log_level > 3 )
    {
      pFile_10 = fopen((const char *)log_file, "a+");
      if ( pFile_10 )
        fprintf(pFile_10, "%-30s = 0x%X\n", "BIT[7]      RET_WORK_ERR_FLAG", (unsigned __int8)reg_value >> 7);
      fclose(pFile_10);
    }
    if ( log_level > 3 )
    {
      pFile_11 = fopen((const char *)log_file, "a+");
      if ( pFile_11 )
        fprintf(pFile_11, "%-30s = 0x%X\n", "BIT[6:4]    TFS", ((unsigned __int8)reg_value >> 4) & 7);
      fclose(pFile_11);
    }
    if ( log_level > 3 )
    {
      pFile_12 = fopen((const char *)log_file, "a+");
      if ( pFile_12 )
        fprintf(pFile_12, "%-30s = 0x%X\n", "BIT[3:2]    Reserved", ((unsigned __int8)reg_value >> 2) & 3);
      fclose(pFile_12);
    }
    if ( log_level > 3 )
    {
      pFile_13 = fopen((const char *)log_file, "a+");
      if ( pFile_13 )
        fprintf(pFile_13, "%-30s = 0x%X\n", "BIT[1:0]    HASHRATE_TWS", reg_value & 3);
      fclose(pFile_13);
    }
  }
  if ( log_level > 3 )
  {
    pFile_14 = fopen((const char *)log_file, "a+");
    if ( pFile_14 )
      fputc(10, pFile_14);
    fclose(pFile_14);
  }
}

//----- (0006AF74) --------------------------------------------------------
void __cdecl register_parse_ordered_clock_enable(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile; // [sp+1Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x20] = 0x%08X, Ordered Clock Enable, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:16]  Reserved", HIWORD(reg_value));
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[15:0]   CLKEN", (unsigned __int16)reg_value);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
}

//----- (0006B14C) --------------------------------------------------------
void __cdecl register_parse_ticket_mask2(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-14h]
  FILE *pFile_1; // [sp+Ch] [bp-10h]
  FILE *pFile_0; // [sp+10h] [bp-Ch]
  FILE *pFile; // [sp+14h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x38] = 0x%08X, Ticket Mask2, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:0]  TM", reg_value);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (0006B2C0) --------------------------------------------------------
void __cdecl register_parse_external_temperature_sensor_read(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-20h]
  FILE *pFile_4; // [sp+10h] [bp-1Ch]
  FILE *pFile_3; // [sp+14h] [bp-18h]
  FILE *pFile_2; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x44] = 0x%08X, External Temperature Sensor Read, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:24]  LOCAL_TEMP_ADDR", HIBYTE(reg_value));
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[23:16]  LOCAL_TEMP_DATA", BYTE2(reg_value));
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[15:8]   EXTERNAL_TEMP_ADDR", BYTE1(reg_value));
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[7:0]    EXTERNAL_TEMP_DATA", (unsigned __int8)reg_value);
      fclose(pFile_3);
    }
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fputc(10, pFile_4);
    fclose(pFile_4);
  }
}

//----- (0006B560) --------------------------------------------------------
void __cdecl register_parse_error_flag(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-20h]
  FILE *pFile_4; // [sp+10h] [bp-1Ch]
  FILE *pFile_3; // [sp+14h] [bp-18h]
  FILE *pFile_2; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x48] = 0x%08X, Error Flag, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:24]  CMD_ERR_CNT", (unsigned __int8)reg_value);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[23:16]  WORK_ERR_CNT", BYTE1(reg_value));
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[15:8]   Reserved", BYTE2(reg_value));
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[7:0]    CORE_RESP_ERR", HIBYTE(reg_value));
      fclose(pFile_3);
    }
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fputc(10, pFile_4);
    fclose(pFile_4);
  }
}

//----- (0006B800) --------------------------------------------------------
void __cdecl register_parse_nonce_error_counter(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-14h]
  FILE *pFile_1; // [sp+Ch] [bp-10h]
  FILE *pFile_0; // [sp+10h] [bp-Ch]
  FILE *pFile; // [sp+14h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x4C] = 0x%08X, Nonce Error Counter, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:0]  ERR_CNT", reg_value);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (0006B974) --------------------------------------------------------
void __cdecl register_parse_nonce_overflow_counter(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-14h]
  FILE *pFile_1; // [sp+Ch] [bp-10h]
  FILE *pFile_0; // [sp+10h] [bp-Ch]
  FILE *pFile; // [sp+14h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x50] = 0x%08X, Nonce Overflow Counter, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:0]  ERR_CNT", reg_value);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (0006BAE8) --------------------------------------------------------
void __cdecl register_parse_analog_mux_control(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile; // [sp+1Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x54] = 0x%08X, Analog Mux Control, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:3]  Reserved", reg_value >> 3);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[2:0]   DIODE_VDD_MUX_SEL", reg_value & 7);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
}

//----- (0006BCCC) --------------------------------------------------------
void __cdecl register_parse_io_drive_strength_configuration(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-3Ch]
  FILE *pFile_11; // [sp+Ch] [bp-38h]
  FILE *pFile_10; // [sp+10h] [bp-34h]
  FILE *pFile_9; // [sp+14h] [bp-30h]
  FILE *pFile_8; // [sp+18h] [bp-2Ch]
  FILE *pFile_7; // [sp+1Ch] [bp-28h]
  FILE *pFile_6; // [sp+20h] [bp-24h]
  FILE *pFile_5; // [sp+24h] [bp-20h]
  FILE *pFile_4; // [sp+28h] [bp-1Ch]
  FILE *pFile_3; // [sp+2Ch] [bp-18h]
  FILE *pFile_2; // [sp+30h] [bp-14h]
  FILE *pFile_1; // [sp+34h] [bp-10h]
  FILE *pFile_0; // [sp+38h] [bp-Ch]
  FILE *pFile; // [sp+3Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x58] = 0x%08X, Io Driver Strenght Configuration, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", HIBYTE(reg_value) >> 4);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[27:24]  RF_DS", HIBYTE(reg_value) & 0xF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23]     D3RS_DISA", BYTE2(reg_value) >> 7);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[22]     D2RS_DISA", (reg_value & 0x400000) != 0);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[21]     D1RS_DISA", (reg_value & 0x200000) != 0);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[20]     D0RS_EN", (reg_value & 0x100000) != 0);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[19:16]  R0_DS", BYTE2(reg_value) & 0xF);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[15:12]  CLKO_DS", BYTE1(reg_value) >> 4);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "%-30s = 0x%X\n", "BIT[11:8]   NRSTO_DS", BYTE1(reg_value) & 0xF);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(pFile_9, "%-30s = 0x%X\n", "BIT[7:4]    BO_DS", (unsigned __int8)reg_value >> 4);
      fclose(pFile_9);
    }
    if ( log_level > 3 )
    {
      pFile_10 = fopen((const char *)log_file, "a+");
      if ( pFile_10 )
        fprintf(pFile_10, "%-30s = 0x%X\n", "BIT[3:0]    CO_DS", reg_value & 0xF);
      fclose(pFile_10);
    }
  }
  if ( log_level > 3 )
  {
    pFile_11 = fopen((const char *)log_file, "a+");
    if ( pFile_11 )
      fputc(10, pFile_11);
    fclose(pFile_11);
  }
}

//----- (0006C280) --------------------------------------------------------
void __cdecl register_parse_time_out(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile; // [sp+1Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x5C] = 0x%08X, Time Out, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:16]  Reserved", HIWORD(reg_value));
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[15:0]   TMOUT", (unsigned __int16)reg_value);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
}

//----- (0006C458) --------------------------------------------------------
void __cdecl register_parse_pll1_parameter(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-38h]
  FILE *pFile_10; // [sp+10h] [bp-34h]
  FILE *pFile_9; // [sp+14h] [bp-30h]
  FILE *pFile_8; // [sp+18h] [bp-2Ch]
  FILE *pFile_7; // [sp+1Ch] [bp-28h]
  FILE *pFile_6; // [sp+20h] [bp-24h]
  FILE *pFile_5; // [sp+24h] [bp-20h]
  FILE *pFile_4; // [sp+28h] [bp-1Ch]
  FILE *pFile_3; // [sp+2Ch] [bp-18h]
  FILE *pFile_2; // [sp+30h] [bp-14h]
  FILE *pFile_1; // [sp+34h] [bp-10h]
  FILE *pFile_0; // [sp+38h] [bp-Ch]
  FILE *pFile; // [sp+3Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x60] = 0x%08X, PLL1 Parameter, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31]     LOCKED", HIBYTE(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (reg_value & 0x40000000) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[29:28]  Reserved", (HIBYTE(reg_value) >> 4) & 3);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(reg_value) & 0xFFF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", BYTE1(reg_value) >> 6);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", BYTE1(reg_value) & 0x3F);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7]      Reserved", (unsigned __int8)reg_value >> 7);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", ((unsigned __int8)reg_value >> 4) & 7);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "%-30s = 0x%X\n", "BIT[3]      Reserved", (reg_value & 8) != 0);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(pFile_9, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", reg_value & 7);
      fclose(pFile_9);
    }
  }
  if ( log_level > 3 )
  {
    pFile_10 = fopen((const char *)log_file, "a+");
    if ( pFile_10 )
      fputc(10, pFile_10);
    fclose(pFile_10);
  }
}

//----- (0006C9A0) --------------------------------------------------------
void __cdecl register_parse_pll2_parameter(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-38h]
  FILE *pFile_10; // [sp+10h] [bp-34h]
  FILE *pFile_9; // [sp+14h] [bp-30h]
  FILE *pFile_8; // [sp+18h] [bp-2Ch]
  FILE *pFile_7; // [sp+1Ch] [bp-28h]
  FILE *pFile_6; // [sp+20h] [bp-24h]
  FILE *pFile_5; // [sp+24h] [bp-20h]
  FILE *pFile_4; // [sp+28h] [bp-1Ch]
  FILE *pFile_3; // [sp+2Ch] [bp-18h]
  FILE *pFile_2; // [sp+30h] [bp-14h]
  FILE *pFile_1; // [sp+34h] [bp-10h]
  FILE *pFile_0; // [sp+38h] [bp-Ch]
  FILE *pFile; // [sp+3Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x64] = 0x%08X, PLL2 Parameter, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31]     LOCKED", HIBYTE(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (reg_value & 0x40000000) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[29:28]  Reserved", (HIBYTE(reg_value) >> 4) & 3);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(reg_value) & 0xFFF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", BYTE1(reg_value) >> 6);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", BYTE1(reg_value) & 0x3F);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7]      Reserved", (unsigned __int8)reg_value >> 7);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", ((unsigned __int8)reg_value >> 4) & 7);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "%-30s = 0x%X\n", "BIT[3]      Reserved", (reg_value & 8) != 0);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(pFile_9, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", reg_value & 7);
      fclose(pFile_9);
    }
  }
  if ( log_level > 3 )
  {
    pFile_10 = fopen((const char *)log_file, "a+");
    if ( pFile_10 )
      fputc(10, pFile_10);
    fclose(pFile_10);
  }
}

//----- (0006CEE8) --------------------------------------------------------
void __cdecl register_parse_pll3_parameter(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-38h]
  FILE *pFile_10; // [sp+10h] [bp-34h]
  FILE *pFile_9; // [sp+14h] [bp-30h]
  FILE *pFile_8; // [sp+18h] [bp-2Ch]
  FILE *pFile_7; // [sp+1Ch] [bp-28h]
  FILE *pFile_6; // [sp+20h] [bp-24h]
  FILE *pFile_5; // [sp+24h] [bp-20h]
  FILE *pFile_4; // [sp+28h] [bp-1Ch]
  FILE *pFile_3; // [sp+2Ch] [bp-18h]
  FILE *pFile_2; // [sp+30h] [bp-14h]
  FILE *pFile_1; // [sp+34h] [bp-10h]
  FILE *pFile_0; // [sp+38h] [bp-Ch]
  FILE *pFile; // [sp+3Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x68] = 0x%08X, PLL3 Parameter, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31]     LOCKED", HIBYTE(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[30]     PLLEN", (reg_value & 0x40000000) != 0);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[29:28]  Reserved", (HIBYTE(reg_value) >> 4) & 3);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[27:16]  FBDIV", HIWORD(reg_value) & 0xFFF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", BYTE1(reg_value) >> 6);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[13:8]   REFDIV", BYTE1(reg_value) & 0x3F);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7]      Reserved", (unsigned __int8)reg_value >> 7);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[6:4]    POSTDIV1", ((unsigned __int8)reg_value >> 4) & 7);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "%-30s = 0x%X\n", "BIT[3]      Reserved", (reg_value & 8) != 0);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(pFile_9, "%-30s = 0x%X\n", "BIT[2:0]    POSTDIV2", reg_value & 7);
      fclose(pFile_9);
    }
  }
  if ( log_level > 3 )
  {
    pFile_10 = fopen((const char *)log_file, "a+");
    if ( pFile_10 )
      fputc(10, pFile_10);
    fclose(pFile_10);
  }
}

//----- (0006D430) --------------------------------------------------------
void __cdecl register_parse_ordered_clock_monitor(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-24h]
  FILE *pFile_5; // [sp+Ch] [bp-20h]
  FILE *pFile_4; // [sp+10h] [bp-1Ch]
  FILE *pFile_3; // [sp+14h] [bp-18h]
  FILE *pFile_2; // [sp+18h] [bp-14h]
  FILE *pFile_1; // [sp+1Ch] [bp-10h]
  FILE *pFile_0; // [sp+20h] [bp-Ch]
  FILE *pFile; // [sp+24h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x6C] = 0x%08X, Ordered Clock Monitor, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31]     START", HIBYTE(reg_value) >> 7);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[30:28]  Reserved", (HIBYTE(reg_value) >> 4) & 7);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[27:24]  CLK_SEL", HIBYTE(reg_value) & 0xF);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[23:16]  Reserved", BYTE2(reg_value));
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:0]   CLK_COUNT", (unsigned __int16)reg_value);
      fclose(pFile_4);
    }
  }
  if ( log_level > 3 )
  {
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fputc(10, pFile_5);
    fclose(pFile_5);
  }
}

//----- (0006D74C) --------------------------------------------------------
void __cdecl register_parse_pll0_divider(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-30h]
  FILE *pFile_8; // [sp+10h] [bp-2Ch]
  FILE *pFile_7; // [sp+14h] [bp-28h]
  FILE *pFile_6; // [sp+18h] [bp-24h]
  FILE *pFile_5; // [sp+1Ch] [bp-20h]
  FILE *pFile_4; // [sp+20h] [bp-1Ch]
  FILE *pFile_3; // [sp+24h] [bp-18h]
  FILE *pFile_2; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  FILE *pFile; // [sp+34h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x70] = 0x%08X, Pll0 Divider, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", HIBYTE(reg_value) >> 4);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[27:24]  PLL_DIV3", HIBYTE(reg_value) & 0xF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23:20]  Reserved", BYTE2(reg_value) >> 4);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[19:16]  PLL_DIV2", BYTE2(reg_value) & 0xF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:12]  Reserved", BYTE1(reg_value) >> 4);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[11:8]   PLL_DIV1", BYTE1(reg_value) & 0xF);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7:4]    Reserved", (unsigned __int8)reg_value >> 4);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[3:0]    PLL_DIV0", reg_value & 0xF);
      fclose(pFile_7);
    }
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fputc(10, pFile_8);
    fclose(pFile_8);
  }
}

//----- (0006DBBC) --------------------------------------------------------
void __cdecl register_parse_pll1_divider(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-30h]
  FILE *pFile_8; // [sp+10h] [bp-2Ch]
  FILE *pFile_7; // [sp+14h] [bp-28h]
  FILE *pFile_6; // [sp+18h] [bp-24h]
  FILE *pFile_5; // [sp+1Ch] [bp-20h]
  FILE *pFile_4; // [sp+20h] [bp-1Ch]
  FILE *pFile_3; // [sp+24h] [bp-18h]
  FILE *pFile_2; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  FILE *pFile; // [sp+34h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x74] = 0x%08X, Pll1 Divider, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", HIBYTE(reg_value) >> 4);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[27:24]  PLL_DIV3", HIBYTE(reg_value) & 0xF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23:20]  Reserved", BYTE2(reg_value) >> 4);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[19:16]  PLL_DIV2", BYTE2(reg_value) & 0xF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:12]  Reserved", BYTE1(reg_value) >> 4);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[11:8]   PLL_DIV1", BYTE1(reg_value) & 0xF);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7:4]    Reserved", (unsigned __int8)reg_value >> 4);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[3:0]    PLL_DIV0", reg_value & 0xF);
      fclose(pFile_7);
    }
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fputc(10, pFile_8);
    fclose(pFile_8);
  }
}

//----- (0006E02C) --------------------------------------------------------
void __cdecl register_parse_pll2_divider(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-30h]
  FILE *pFile_8; // [sp+10h] [bp-2Ch]
  FILE *pFile_7; // [sp+14h] [bp-28h]
  FILE *pFile_6; // [sp+18h] [bp-24h]
  FILE *pFile_5; // [sp+1Ch] [bp-20h]
  FILE *pFile_4; // [sp+20h] [bp-1Ch]
  FILE *pFile_3; // [sp+24h] [bp-18h]
  FILE *pFile_2; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  FILE *pFile; // [sp+34h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x78] = 0x%08X, Pll2 Divider, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", HIBYTE(reg_value) >> 4);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[27:24]  PLL_DIV3", HIBYTE(reg_value) & 0xF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23:20]  Reserved", BYTE2(reg_value) >> 4);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[19:16]  PLL_DIV2", BYTE2(reg_value) & 0xF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:12]  Reserved", BYTE1(reg_value) >> 4);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[11:8]   PLL_DIV1", BYTE1(reg_value) & 0xF);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7:4]    Reserved", (unsigned __int8)reg_value >> 4);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[3:0]    PLL_DIV0", reg_value & 0xF);
      fclose(pFile_7);
    }
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fputc(10, pFile_8);
    fclose(pFile_8);
  }
}

//----- (0006E49C) --------------------------------------------------------
void __cdecl register_parse_pll3_divider(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-30h]
  FILE *pFile_8; // [sp+10h] [bp-2Ch]
  FILE *pFile_7; // [sp+14h] [bp-28h]
  FILE *pFile_6; // [sp+18h] [bp-24h]
  FILE *pFile_5; // [sp+1Ch] [bp-20h]
  FILE *pFile_4; // [sp+20h] [bp-1Ch]
  FILE *pFile_3; // [sp+24h] [bp-18h]
  FILE *pFile_2; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  FILE *pFile; // [sp+34h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x7C] = 0x%08X, Pll3 Divider, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:28]  Reserved", HIBYTE(reg_value) >> 4);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[27:24]  PLL_DIV3", HIBYTE(reg_value) & 0xF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23:20]  Reserved", BYTE2(reg_value) >> 4);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[19:16]  PLL_DIV2", BYTE2(reg_value) & 0xF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:12]  Reserved", BYTE1(reg_value) >> 4);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[11:8]   PLL_DIV1", BYTE1(reg_value) & 0xF);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7:4]    Reserved", (unsigned __int8)reg_value >> 4);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[3:0]    PLL_DIV0", reg_value & 0xF);
      fclose(pFile_7);
    }
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fputc(10, pFile_8);
    fclose(pFile_8);
  }
}

//----- (0006E90C) --------------------------------------------------------
void __cdecl register_parse_clock_order_0(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-30h]
  FILE *pFile_8; // [sp+10h] [bp-2Ch]
  FILE *pFile_7; // [sp+14h] [bp-28h]
  FILE *pFile_6; // [sp+18h] [bp-24h]
  FILE *pFile_5; // [sp+1Ch] [bp-20h]
  FILE *pFile_4; // [sp+20h] [bp-1Ch]
  FILE *pFile_3; // [sp+24h] [bp-18h]
  FILE *pFile_2; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  FILE *pFile; // [sp+34h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x80] = 0x%08X, Clock Order Control0, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:28]  CLK7_SEL", HIBYTE(reg_value) >> 4);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[27:24]  CLK6_SEL", HIBYTE(reg_value) & 0xF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23:20]  CLK5_SEL", BYTE2(reg_value) >> 4);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[19:16]  CLK4_SEL", BYTE2(reg_value) & 0xF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:12]  CLK3_SEL", BYTE1(reg_value) >> 4);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[11:8]   CLK2_SEL", BYTE1(reg_value) & 0xF);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7:4]    CLK1_SEL", (unsigned __int8)reg_value >> 4);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[3:0]    CLK0_SEL", reg_value & 0xF);
      fclose(pFile_7);
    }
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fputc(10, pFile_8);
    fclose(pFile_8);
  }
}

//----- (0006ED7C) --------------------------------------------------------
void __cdecl register_parse_clock_order_1(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-30h]
  FILE *pFile_8; // [sp+10h] [bp-2Ch]
  FILE *pFile_7; // [sp+14h] [bp-28h]
  FILE *pFile_6; // [sp+18h] [bp-24h]
  FILE *pFile_5; // [sp+1Ch] [bp-20h]
  FILE *pFile_4; // [sp+20h] [bp-1Ch]
  FILE *pFile_3; // [sp+24h] [bp-18h]
  FILE *pFile_2; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  FILE *pFile; // [sp+34h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x84] = 0x%08X, Clock Order Control1, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:28]  CLK15_SEL", HIBYTE(reg_value) >> 4);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[27:24]  CLK14_SEL", HIBYTE(reg_value) & 0xF);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23:20]  CLK13_SEL", BYTE2(reg_value) >> 4);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[19:16]  CLK12_SEL", BYTE2(reg_value) & 0xF);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:12]  CLK11_SEL", BYTE1(reg_value) >> 4);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[11:8]   CLK10_SEL", BYTE1(reg_value) & 0xF);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[7:4]    CLK9_SEL", (unsigned __int8)reg_value >> 4);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[3:0]    CLK8_SEL", reg_value & 0xF);
      fclose(pFile_7);
    }
  }
  if ( log_level > 3 )
  {
    pFile_8 = fopen((const char *)log_file, "a+");
    if ( pFile_8 )
      fputc(10, pFile_8);
    fclose(pFile_8);
  }
}

//----- (0006F1EC) --------------------------------------------------------
void __cdecl register_parse_frequency_sweep_control(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-4Ch]
  FILE *pFile_15; // [sp+Ch] [bp-48h]
  FILE *pFile_14; // [sp+10h] [bp-44h]
  FILE *pFile_13; // [sp+14h] [bp-40h]
  FILE *pFile_12; // [sp+18h] [bp-3Ch]
  FILE *pFile_11; // [sp+1Ch] [bp-38h]
  FILE *pFile_10; // [sp+20h] [bp-34h]
  FILE *pFile_9; // [sp+24h] [bp-30h]
  FILE *pFile_8; // [sp+28h] [bp-2Ch]
  FILE *pFile_7; // [sp+2Ch] [bp-28h]
  FILE *pFile_6; // [sp+30h] [bp-24h]
  FILE *pFile_5; // [sp+34h] [bp-20h]
  FILE *pFile_4; // [sp+38h] [bp-1Ch]
  FILE *pFile_3; // [sp+3Ch] [bp-18h]
  FILE *pFile_2; // [sp+40h] [bp-14h]
  FILE *pFile_1; // [sp+44h] [bp-10h]
  FILE *pFile_0; // [sp+48h] [bp-Ch]
  FILE *pFile; // [sp+4Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x90] = 0x%08X, Frequency Sweep Control1, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:27]  Reserved", HIBYTE(reg_value) >> 3);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[26:24]  SWEEP_STATE", HIBYTE(reg_value) & 7);
      fclose(pFile_1);
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, "%-30s = 0x%X\n", "BIT[23:21]  Reserved", BYTE2(reg_value) >> 5);
      fclose(pFile_2);
    }
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fprintf(pFile_3, "%-30s = 0x%X\n", "BIT[20:16]  SWEEP_ST_ADDR", BYTE2(reg_value) & 0x1F);
      fclose(pFile_3);
    }
    if ( log_level > 3 )
    {
      pFile_4 = fopen((const char *)log_file, "a+");
      if ( pFile_4 )
        fprintf(pFile_4, "%-30s = 0x%X\n", "BIT[15:14]  Reserved", BYTE1(reg_value) >> 6);
      fclose(pFile_4);
    }
    if ( log_level > 3 )
    {
      pFile_5 = fopen((const char *)log_file, "a+");
      if ( pFile_5 )
        fprintf(pFile_5, "%-30s = 0x%X\n", "BIT[13]     ALL_CORE_CLK_SEL_CHANGE_ST", (reg_value & 0x2000) != 0);
      fclose(pFile_5);
    }
    if ( log_level > 3 )
    {
      pFile_6 = fopen((const char *)log_file, "a+");
      if ( pFile_6 )
        fprintf(pFile_6, "%-30s = 0x%X\n", "BIT[12]     SWEEP_FAIL_LOCK_EN", (reg_value & 0x1000) != 0);
      fclose(pFile_6);
    }
    if ( log_level > 3 )
    {
      pFile_7 = fopen((const char *)log_file, "a+");
      if ( pFile_7 )
        fprintf(pFile_7, "%-30s = 0x%X\n", "BIT[11]     SWEEP_RESET", (reg_value & 0x800) != 0);
      fclose(pFile_7);
    }
    if ( log_level > 3 )
    {
      pFile_8 = fopen((const char *)log_file, "a+");
      if ( pFile_8 )
        fprintf(pFile_8, "%-30s = 0x%X\n", "BIT[10:8]   CURR_PAT_ADDR", BYTE1(reg_value) & 7);
      fclose(pFile_8);
    }
    if ( log_level > 3 )
    {
      pFile_9 = fopen((const char *)log_file, "a+");
      if ( pFile_9 )
        fprintf(pFile_9, "%-30s = 0x%X\n", "BIT[7]      SWP_ONE_PAT_DONE", (unsigned __int8)reg_value >> 7);
      fclose(pFile_9);
    }
    if ( log_level > 3 )
    {
      pFile_10 = fopen((const char *)log_file, "a+");
      if ( pFile_10 )
        fprintf(pFile_10, "%-30s = 0x%X\n", "BIT[6:4]    SWP_PAD_ADDR", ((unsigned __int8)reg_value >> 4) & 7);
      fclose(pFile_10);
    }
    if ( log_level > 3 )
    {
      pFile_11 = fopen((const char *)log_file, "a+");
      if ( pFile_11 )
        fprintf(pFile_11, "%-30s = 0x%X\n", "BIT[3]      SWP_DONE_ALL", (reg_value & 8) != 0);
      fclose(pFile_11);
    }
    if ( log_level > 3 )
    {
      pFile_12 = fopen((const char *)log_file, "a+");
      if ( pFile_12 )
        fprintf(pFile_12, "%-30s = 0x%X\n", "BIT[2]      SWP_ONGOING", (reg_value & 4) != 0);
      fclose(pFile_12);
    }
    if ( log_level > 3 )
    {
      pFile_13 = fopen((const char *)log_file, "a+");
      if ( pFile_13 )
        fprintf(pFile_13, "%-30s = 0x%X\n", "BIT[1]      SWP_TRIG", (reg_value & 2) != 0);
      fclose(pFile_13);
    }
    if ( log_level > 3 )
    {
      pFile_14 = fopen((const char *)log_file, "a+");
      if ( pFile_14 )
        fprintf(pFile_14, "%-30s = 0x%X\n", "BIT[0]      SWP_EN", reg_value & 1);
      fclose(pFile_14);
    }
  }
  if ( log_level > 3 )
  {
    pFile_15 = fopen((const char *)log_file, "a+");
    if ( pFile_15 )
      fputc(10, pFile_15);
    fclose(pFile_15);
  }
}

//----- (0006F950) --------------------------------------------------------
void __cdecl register_parse_golden_nonce_for_sweep_return(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-14h]
  FILE *pFile_1; // [sp+Ch] [bp-10h]
  FILE *pFile_0; // [sp+10h] [bp-Ch]
  FILE *pFile; // [sp+14h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x94] = 0x%08X, Golden Nonce For Sweep Return, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:0]  GNOSWR", reg_value);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (0006FAC4) --------------------------------------------------------
void __cdecl register_parse_returned_group_pattern_status(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-14h]
  FILE *pFile_1; // [sp+Ch] [bp-10h]
  FILE *pFile_0; // [sp+10h] [bp-Ch]
  FILE *pFile; // [sp+14h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x98] = 0x%08X, Returned Group Pattern Status, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:0]  RSTS", reg_value);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (0006FC38) --------------------------------------------------------
void __cdecl register_parse_nonce_returned_timeout(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+Ch] [bp-18h]
  FILE *pFile_2; // [sp+10h] [bp-14h]
  FILE *pFile_1; // [sp+14h] [bp-10h]
  FILE *pFile_0; // [sp+18h] [bp-Ch]
  FILE *pFile; // [sp+1Ch] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0x9C] = 0x%08X, Nonce Returned Timeout, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found )
  {
    if ( log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:16]  Reserved", HIWORD(reg_value));
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%-30s = 0x%X\n", "BIT[15:0]   SWEEP_TIMEOUT", (unsigned __int16)reg_value);
      fclose(pFile_1);
    }
  }
  if ( log_level > 3 )
  {
    pFile_2 = fopen((const char *)log_file, "a+");
    if ( pFile_2 )
      fputc(10, pFile_2);
    fclose(pFile_2);
  }
}

//----- (0006FE10) --------------------------------------------------------
void __cdecl register_parse_returned_single_pattern_status(reg_status_t *reg_status)
{
  const char *v1; // r3
  uint32_t reg_value; // [sp+8h] [bp-14h]
  FILE *pFile_1; // [sp+Ch] [bp-10h]
  FILE *pFile_0; // [sp+10h] [bp-Ch]
  FILE *pFile; // [sp+14h] [bp-8h]

  reg_value = reg_status->reg_response;
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( reg_status->found )
        v1 = "FOUND";
      else
        v1 = "NOT FOUND";
      fprintf(pFile, ">> ASIC_REG[0xA0] = 0x%08X, Returned Single Pattern Status, %s\n", reg_status->reg_response, v1);
    }
    fclose(pFile);
  }
  if ( reg_status->found && log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s = 0x%X\n", "BIT[31:0]  RSTS", reg_value);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fputc(10, pFile_1);
    fclose(pFile_1);
  }
}

//----- (0006FF84) --------------------------------------------------------
void __cdecl register_build_core_command_read_one(core_command_t *core_cmd, uint32_t core_id, uint8_t reg)
{
  memset(core_cmd, 0, sizeof(core_command_t));
  core_cmd->v[0] = -1;
  core_cmd->v[1] = core_cmd->v[1] & 0xF0 | reg & 0xF;
  core_cmd->v[1] &= ~0x40u;
  core_cmd->v[1] &= ~0x80u;
  *(_WORD *)&core_cmd->v[2] = *(_WORD *)&core_cmd->v[2] & 0xFE00 | (core_id >> 1) & 0x1FF;
  core_cmd->v[3] &= ~0x80u;
}

//----- (00070034) --------------------------------------------------------
void __cdecl register_build_get_status_command(get_status_t *get_st, uint8_t asic, uint8_t reg)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  if ( get_st )
  {
    memset(get_st, 0, sizeof(get_status_t));
    get_st->v[0] = get_st->v[0] & 0xF0 | 2;
    get_st->v[0] &= ~0x10u;
    get_st->v[0] = get_st->v[0] & 0x1F | 0x40;
    get_st->u._Length = 5;
    get_st->u._ADDR = asic * dev->addrInterval;
    get_st->u._REGADDR = reg;
    get_st->v[4] = get_st->v[4] & 0xE0 | CRC5((unsigned __int8 *)get_st, 0x20u) & 0x1F;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Invalid parameter.\n", "register.c", 826, (const char *)_FUNCTION___13303_0);
    fclose(pFile);
  }
}

//----- (000701B0) --------------------------------------------------------
void __cdecl register_build_set_config_command(set_config_t *set_cfg, uint8_t asic, core_command_t *core_cmd)
{
  FILE *pFile; // [sp+1Ch] [bp-8h]

  if ( set_cfg && core_cmd )
  {
    memset(set_cfg, 0, sizeof(set_config_t));
    set_cfg->v[0] = set_cfg->v[0] & 0xF0 | 1;
    set_cfg->v[0] &= ~0x10u;
    set_cfg->v[0] = set_cfg->v[0] & 0x1F | 0x40;
    set_cfg->u._Length = 9;
    set_cfg->u._ADDR = asic * dev->addrInterval;
    set_cfg->u._REGADDR = 60;
    set_cfg->u._REGDATA[0] = core_cmd->v[3];
    set_cfg->u._REGDATA[1] = core_cmd->v[2];
    set_cfg->u._REGDATA[2] = core_cmd->v[1];
    set_cfg->u._REGDATA[3] = core_cmd->v[0];
    set_cfg->v[8] = set_cfg->v[8] & 0xE0 | CRC5((unsigned __int8 *)set_cfg, 0x40u) & 0x1F;
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Invalid parameter.\n", "register.c", 854, (const char *)_FUNCTION___13310);
    fclose(pFile);
  }
}

//----- (00070374) --------------------------------------------------------
void __cdecl register_build_bc_command(uint32_t *bc_cmd, uint8_t *cmd, int len)
{
  int i; // [sp+14h] [bp-8h]

  memset(bc_cmd, 0, 0xCu);
  memcpy(bc_cmd, cmd, len);
  for ( i = 0; i <= 2; ++i )
    bc_cmd[i] = (bc_cmd[i] << 24) | (bc_cmd[i] << 8) & 0xFF0000 | (bc_cmd[i] >> 8) & 0xFF00 | HIBYTE(bc_cmd[i]);
}

//----- (00070468) --------------------------------------------------------
bool __cdecl register_process_asic_response(int chain, uint8_t asic, uint8_t reg, uint32_t *response)
{
  FILE *pFile; // [sp+20h] [bp-24h]
  FILE *pFile_0; // [sp+24h] [bp-20h]
  uint8_t asic_from_reg; // [sp+2Ah] [bp-1Ah]
  unsigned __int8 chain_number; // [sp+2Bh] [bp-19h]
  unsigned int reg_value_num; // [sp+34h] [bp-10h]
  uint32_t i; // [sp+38h] [bp-Ch]
  bool found; // [sp+3Fh] [bp-5h]

  found = 0;
  reg_value_num = reg_value_buf.reg_value_num;
  for ( i = 0; i < reg_value_num && !found; ++i )
  {
    chain_number = reg_value_buf.reg_buffer[reg_value_buf.p_rd].chain_number;
    asic_from_reg = reg_value_buf.reg_buffer[reg_value_buf.p_rd].chip_address / dev->addrInterval;
    if ( reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_address == reg )
    {
      if ( chain == chain_number && asic_from_reg == asic )
      {
        *response = reg_value_buf.reg_buffer[reg_value_buf.p_rd].reg_value;
      }
      else if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(
            pFile,
            "%s:%d:%s: Get another asic response: chain = %d, asic = %d\n",
            "register.c",
            923,
            (const char *)_FUNCTION___13334,
            chain_number,
            asic_from_reg);
        fclose(pFile);
      }
      found = 1;
    }
    else if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Get another register: 0x%X\n",
          "register.c",
          930,
          (const char *)_FUNCTION___13334,
          reg);
      fclose(pFile_0);
    }
    ++reg_value_buf.p_rd;
    --reg_value_buf.reg_value_num;
    if ( reg_value_buf.p_rd > 0x1FE )
      reg_value_buf.p_rd = 0;
  }
  return found;
}

//----- (0007078C) --------------------------------------------------------
void __cdecl register_receive_asic_response(int chain, uint8_t asic, uint8_t reg, reg_status_t *reg_status)
{
  bool found; // [sp+13h] [bp-9h]
  int try_count; // [sp+14h] [bp-8h]

  try_count = 10;
  found = 0;
  while ( !found )
  {
    if ( !try_count-- )
      break;
    cgsleep_ms(300);
    pthread_mutex_lock(&reg_mutex);
    if ( reg_value_buf.reg_value_num )
      found = register_process_asic_response(chain, asic, reg, &reg_status->reg_response);
    pthread_mutex_unlock(&reg_mutex);
  }
  if ( found )
    reg_status->found = 1;
}

//----- (00070860) --------------------------------------------------------
void __cdecl register_send_core_cmd_read_one(int chain, uint8_t asic, uint32_t core_id, uint8_t core_reg)
{
  unsigned int bc_cmd[3]; // [sp+14h] [bp-28h] BYREF
  set_config_t set_cfg; // [sp+20h] [bp-1Ch] BYREF
  core_command_t core_cmd; // [sp+2Ch] [bp-10h] BYREF
  unsigned int value; // [sp+30h] [bp-Ch]

  clear_register_value_buf();
  register_build_core_command_read_one(&core_cmd, core_id, core_reg);
  register_build_set_config_command(&set_cfg, asic, &core_cmd);
  register_build_bc_command(bc_cmd, (uint8_t *)&set_cfg, 9);
  set_BC_command_buffer(bc_cmd);
  value = (chain << 16) | get_BC_write_command() & 0xFFF0FFFF | 0x80800000;
  set_BC_write_command(value);
}

//----- (00070918) --------------------------------------------------------
void __cdecl register_send_asic_cmd_read_one(int chain, uint8_t asic, uint8_t asic_reg)
{
  unsigned int bc_cmd[3]; // [sp+Ch] [bp-20h] BYREF
  get_status_t get_st; // [sp+18h] [bp-14h] BYREF
  unsigned int value; // [sp+20h] [bp-Ch]

  clear_register_value_buf();
  register_build_get_status_command(&get_st, asic, asic_reg);
  register_build_bc_command(bc_cmd, (uint8_t *)&get_st, 5);
  set_BC_command_buffer(bc_cmd);
  value = (chain << 16) | get_BC_write_command() & 0xFFF0FFFF | 0x80800000;
  set_BC_write_command(value);
}

//----- (000709B4) --------------------------------------------------------
void __cdecl register_dump_core_reg(uint8_t core_reg, reg_status_t *reg_status)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  if ( core_reg )
  {
    switch ( core_reg )
    {
      case 1u:
        register_parse_process_monitor_ctrl(reg_status);
        break;
      case 2u:
        register_parse_process_monitor_data(reg_status);
        break;
      case 3u:
        register_parse_core_error(reg_status);
        break;
      case 4u:
        register_parse_core_enable(reg_status);
        break;
      case 5u:
        register_parse_hash_clock_ctrl(reg_status);
        break;
      case 6u:
        register_parse_hash_clock_counter(reg_status);
        break;
      case 7u:
        register_parse_sweep_freq_ctrl(reg_status);
        break;
      default:
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(
              pFile,
              "%s:%d:%s: Unknown reg: %d\n",
              "register.c",
              1067,
              (const char *)_FUNCTION___13386_0,
              core_reg);
          fclose(pFile);
        }
        break;
    }
  }
  else
  {
    register_parse_clock_delay_ctrl(reg_status);
  }
}

//----- (00070B28) --------------------------------------------------------
void __cdecl register_dump_asic_reg(uint8_t asic_reg, reg_status_t *reg_status)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  if ( asic_reg )
  {
    switch ( asic_reg )
    {
      case 4u:
        register_parse_hash_rate(reg_status);
        break;
      case 8u:
        register_parse_pll0_parameter(reg_status);
        break;
      case 0xCu:
        register_parse_chip_nonce_offset(reg_status);
        break;
      case 0x10u:
        register_parse_hash_counting_number(reg_status);
        break;
      case 0x14u:
        register_parse_ticket_mask(reg_status);
        break;
      case 0x18u:
        register_parse_misc_control(reg_status);
        break;
      case 0x20u:
        register_parse_ordered_clock_enable(reg_status);
        break;
      case 0x38u:
        register_parse_ticket_mask2(reg_status);
        break;
      case 0x44u:
        register_parse_external_temperature_sensor_read(reg_status);
        break;
      case 0x48u:
        register_parse_error_flag(reg_status);
        break;
      case 0x4Cu:
        register_parse_nonce_error_counter(reg_status);
        break;
      case 0x50u:
        register_parse_nonce_overflow_counter(reg_status);
        break;
      case 0x54u:
        register_parse_analog_mux_control(reg_status);
        break;
      case 0x58u:
        register_parse_io_drive_strength_configuration(reg_status);
        break;
      case 0x5Cu:
        register_parse_time_out(reg_status);
        break;
      case 0x60u:
        register_parse_pll1_parameter(reg_status);
        break;
      case 0x64u:
        register_parse_pll2_parameter(reg_status);
        break;
      case 0x68u:
        register_parse_pll3_parameter(reg_status);
        break;
      case 0x6Cu:
        register_parse_ordered_clock_monitor(reg_status);
        break;
      case 0x70u:
        register_parse_pll0_divider(reg_status);
        break;
      case 0x74u:
        register_parse_pll1_divider(reg_status);
        break;
      case 0x78u:
        register_parse_pll2_divider(reg_status);
        break;
      case 0x7Cu:
        register_parse_pll3_divider(reg_status);
        break;
      case 0x80u:
        register_parse_clock_order_0(reg_status);
        break;
      case 0x84u:
        register_parse_clock_order_1(reg_status);
        break;
      case 0x90u:
        register_parse_frequency_sweep_control(reg_status);
        break;
      case 0x94u:
        register_parse_golden_nonce_for_sweep_return(reg_status);
        break;
      case 0x98u:
        register_parse_returned_group_pattern_status(reg_status);
        break;
      case 0x9Cu:
        register_parse_nonce_returned_timeout(reg_status);
        break;
      case 0xA0u:
        register_parse_returned_single_pattern_status(reg_status);
        break;
      default:
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile = fopen((const char *)log_file, "a+");
          if ( pFile )
            fprintf(pFile, "%s:%d:%s: Unknown reg: %d\n", "register.c", 1199, (const char *)_FUNCTION___13392, asic_reg);
          fclose(pFile);
        }
        break;
    }
  }
  else
  {
    register_parse_chip_address(reg_status);
  }
}

//----- (00070EC4) --------------------------------------------------------
bool __cdecl register_is_param_valid(int chain, uint8_t asic, uint8_t core)
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  FILE *pFile_0; // [sp+14h] [bp-8h]

  if ( chain <= 15 && dev->chain_exist[chain] )
  {
    if ( asic <= 0x2Fu )
    {
      return 1;
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "%s:%d:%s: Invalid ASIC ID: %d\n", "register.c", 1213, (const char *)_FUNCTION___13399, asic);
        fclose(pFile_0);
      }
      return 0;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: Invalid chain ID: %d\n", "register.c", 1207, (const char *)_FUNCTION___13399, chain);
      fclose(pFile);
    }
    return 0;
  }
}

//----- (0007105C) --------------------------------------------------------
void __cdecl do_dump_core_reg(int chain, uint8_t asic, uint32_t core)
{
  reg_status_t core_regs[8]; // [sp+24h] [bp-50h] BYREF
  FILE *pFile_0; // [sp+64h] [bp-10h]
  FILE *pFile; // [sp+68h] [bp-Ch]
  uint8_t core_reg; // [sp+6Fh] [bp-5h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Dump core register start. chain = %d, asic = %d, core = %d\n",
        "register.c",
        1232,
        (const char *)_FUNCTION___13410,
        chain,
        asic,
        core);
    fclose(pFile);
  }
  memset(core_regs, 0, sizeof(core_regs));
  pthread_mutex_lock(&reopen_core);
  is_reading_core_reg = 1;
  if ( register_is_param_valid(chain, asic, core) )
  {
    for ( core_reg = 0; core_reg <= 7u; ++core_reg )
    {
      register_send_core_cmd_read_one(chain, asic, core, core_reg);
      register_receive_asic_response(chain, asic, 0x40u, &core_regs[core_reg]);
      register_dump_core_reg(core_reg, &core_regs[core_reg]);
    }
  }
  is_reading_core_reg = 0;
  pthread_mutex_unlock(&reopen_core);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: Dump core register done.\n", "register.c", 1255, (const char *)_FUNCTION___13410);
    fclose(pFile_0);
  }
}

//----- (00071294) --------------------------------------------------------
void __cdecl do_dump_asic_reg(int chain, uint8_t asic)
{
  reg_status_t status; // [sp+1Ch] [bp-38h] BYREF
  uint8_t asic_regs[31]; // [sp+24h] [bp-30h]
  FILE *pFile_0; // [sp+44h] [bp-10h]
  FILE *pFile; // [sp+48h] [bp-Ch]
  uint32_t i; // [sp+4Ch] [bp-8h]

  *(_DWORD *)asic_regs = 201851904;
  *(_DWORD *)&asic_regs[4] = 538448912;
  *(_DWORD *)&asic_regs[8] = 1279804472;
  *(_DWORD *)&asic_regs[12] = 1549292624;
  *(_DWORD *)&asic_regs[16] = 1818780768;
  *(_DWORD *)&asic_regs[20] = 2088268912;
  *(_DWORD *)&asic_regs[24] = -1802468224;
  *(_WORD *)&asic_regs[28] = -25448;
  asic_regs[30] = -96;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Dump asic register start. chain = %d, asic = %d\n",
        "register.c",
        1299,
        (const char *)_FUNCTION___13422,
        chain,
        asic);
    fclose(pFile);
  }
  pthread_mutex_lock(&reopen_core);
  if ( register_is_param_valid(chain, asic, 0) )
  {
    for ( i = 0; i <= 0x1E; ++i )
    {
      memset(&status, 0, sizeof(status));
      register_send_asic_cmd_read_one(chain, asic, asic_regs[i]);
      register_receive_asic_response(chain, asic, asic_regs[i], &status);
      register_dump_asic_reg(asic_regs[i], &status);
    }
  }
  pthread_mutex_unlock(&reopen_core);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: Dump asic register done.\n", "register.c", 1318, (const char *)_FUNCTION___13422);
    fclose(pFile_0);
  }
}

//----- (000714D8) --------------------------------------------------------
int __cdecl my_system(const unsigned __int8 *cmd)
{
  int *v2; // r0
  char *v3; // r0
  unsigned __int8 buf[1024]; // [sp+14h] [bp-420h] BYREF
  FILE *pFile; // [sp+414h] [bp-20h]
  FILE *pFile_0; // [sp+418h] [bp-1Ch]
  FILE *pFile_1; // [sp+41Ch] [bp-18h]
  FILE *pFile_2; // [sp+420h] [bp-14h]
  FILE *pFile_3; // [sp+424h] [bp-10h]
  int res; // [sp+428h] [bp-Ch]
  FILE *fp; // [sp+42Ch] [bp-8h]

  if ( cmd )
  {
    fp = popen((const char *)cmd, "r");
    if ( fp )
    {
      while ( fgets((char *)buf, 1024, fp) )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_1 = fopen((const char *)log_file, "a+");
          if ( pFile_1 )
            fprintf(pFile_1, "%s:%d:%s: %s", "log.c", 79, (const char *)_FUNCTION___8218, (const char *)buf);
          fclose(pFile_1);
        }
      }
      res = pclose(fp);
      if ( res == -1 )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_2 = fopen((const char *)log_file, "a+");
          if ( pFile_2 )
            fprintf(
              pFile_2,
              "%s:%d:%s: close popen file pointer fp error!\n",
              "log.c",
              83,
              (const char *)_FUNCTION___8218);
          fclose(pFile_2);
        }
        return res;
      }
      else if ( res )
      {
        if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_3 = fopen((const char *)log_file, "a+");
          if ( pFile_3 )
            fprintf(
              pFile_3,
              "%s:%d:%s: pclose res is :%d\n",
              "log.c",
              92,
              (const char *)_FUNCTION___8218,
              (res & 0x7F) == 0);
          fclose(pFile_3);
        }
        return BYTE1(res);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          v2 = _errno_location();
          v3 = strerror(*v2);
          fprintf(pFile_0, "%s:%d:%s: popen error: %s/n", "log.c", 72, (const char *)_FUNCTION___8218, v3);
        }
        fclose(pFile_0);
      }
      return -1;
    }
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: cmd is NULL!\n", "log.c", 67, (const char *)_FUNCTION___8218);
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00071888) --------------------------------------------------------
int __cdecl log_update_name(
        const _log_ctx *ctx,
        const unsigned __int8 *prefix,
        const unsigned __int8 *path,
        const unsigned __int8 *ts)
{
  unsigned __int8 cmd[4096]; // [sp+28h] [bp-1014h] BYREF
  FILE *pFile; // [sp+1028h] [bp-14h]
  FILE *pFile_1; // [sp+102Ch] [bp-10h]
  FILE *pFile_0; // [sp+1030h] [bp-Ch]
  int ret; // [sp+1034h] [bp-8h]

  ret = snprintf(
          (char *)cmd,
          0x1000u,
          "exec 2>&1; update_name () { log_tgt_dir=/$1; path=$2; ts=$3; prefix=\"$4\"_; new_path=$5; new_ts=$6; old_file="
          "$log_tgt_dir/$path/$prefix$ts.tar; new_file=$log_tgt_dir/$new_path/$prefix$new_ts.tar; echo \"old:$old_file ne"
          "w:$new_file\">/tmp/log_updatename.log;if [ ! -d $log_tgt_dir/$new_path ]; then mkdir -p $log_tgt_dir/$new_path"
          "; fi; if [ -f $old_file ]; then mv $old_file $new_file;fi; if [ \"`ls -A $log_tgt_dir/$path/ | wc -w`\" == \"0"
          "\" ];then rm -rf $log_tgt_dir/$path;fi; }; update_name %s %s %s %s %s %s",
          (const char *)ctx->tgt_dir,
          (const char *)ctx->path,
          (const char *)ctx->ts,
          (const char *)prefix,
          (const char *)path,
          (const char *)ts);
  if ( ret == -1 || (unsigned int)ret >= 0x1000 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: too large command LOGUPDATENAME\n", "log.c", 106, (const char *)_FUNCTION___8235);
      fclose(pFile);
    }
    return -1;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: _log_update_name\n", "log.c", 109, (const char *)_FUNCTION___8235);
      fclose(pFile_0);
    }
    ret = my_system(cmd);
    if ( ret && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: my_system returned failed %d on LOGUPDATENAME\n",
          "log.c",
          113,
          (const char *)_FUNCTION___8235,
          ret);
      fclose(pFile_1);
    }
    return ret;
  }
}

//----- (00071B48) --------------------------------------------------------
int __cdecl log_rotate(const _log_ctx *ctx)
{
  unsigned __int8 cmd[4096]; // [sp+20h] [bp-1024h] BYREF
  FILE *pFile; // [sp+1020h] [bp-24h]
  FILE *pFile_1; // [sp+1024h] [bp-20h]
  FILE *pFile_2; // [sp+1028h] [bp-1Ch]
  FILE *pFile_0; // [sp+102Ch] [bp-18h]
  int ret; // [sp+1030h] [bp-14h]
  int debug; // [sp+1034h] [bp-10h]

  debug = 0;
  ret = snprintf(
          (char *)cmd,
          0x1000u,
          "exec 2>&1; log_checksize () {     debug_mode=$1;     log_tgt_dir_name=$2;     log_tgt_dir=/$log_tgt_dir_name; "
          "    tmp_dir=/tmp/.tmp.$$;     selflog=/tmp/log_checknvdata.log;     echo \"start check /nvdata size: \" `date`"
          " > $selflog;     if [ $debug_mode -eq 0 ];     then         threshold1_percentage=75; threshold2_percentage=60"
          ";     else         threshold1_percentage=3; threshold2_percentage=3;     fi; nvdata_state=`df -k| grep $log_tg"
          "t_dir_name`; if [ \"$nvdata_state\" = \"\" ]; then     echo \"ERROR: can't find $log_tgt_dir\" >> $selflog; ex"
          "it -1; fi; used=`echo $nvdata_state| awk '{print $5}'|sed \"s/%%//g\"`; used_blocks=`echo $nvdata_state | awk "
          "'{print $3}'`; total_blocks=`echo $nvdata_state | awk '{print $2}'`; threshold1=$((total_blocks*threshold1_per"
          "centage/100)); threshold2=$((total_blocks*threshold2_percentage/100)); echo \"used_blocks   =$used_blocks\" >>"
          " $selflog; echo \"threshold1    =$threshold1\" >> $selflog; echo \"threshold2    =$threshold2\" >> $selflog; e"
          "cho \"total_blocks  =$total_blocks\" >> $selflog; mkdir $tmp_dir; cd $tmp_dir; if [ $used_blocks -gt $threshol"
          "d1 ]; then     if [ $debug_mode -eq 0 ];     then         filelist=`find $log_tgt_dir -type f -name \"cglog_*\""
          "| xargs ls -tr`;     else         filelist=`find $log_tgt_dir -type f -name \"test_log*\" | xargs ls -tr`;    "
          " fi;     echo $filelist >> $selflog;     if [ ! -z \"$filelist\" ];     then         for file in $filelist;   "
          "      do             used_blocks=`df -k | grep $log_tgt_dir_name | awk '{print $3}'`;             if [ $used_b"
          "locks -lt $threshold2 ];             then                 echo \"$used_blocks < $threshold2\" >> $selflog; bre"
          "ak;             else                 echo \"$used_blocks > $threshold2\" >> $selflog; cat /dev/null >$file;rm "
          "-f $file;           fi;         done;     else         echo \"ERROR: no log file found\" >> $selflog;     fi; "
          "else     echo \"enough free space ($((100-used))%% left). do nothing\" >> $selflog; fi; cd $log_tgt_dir; rm -r"
          "f $tmp_dir ; }; log_checksize %d %s",
          0,
          (const char *)ctx->tgt_dir);
  if ( ret == -1 || (unsigned int)ret >= 0x1000 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: too large command LOGCHECKSIZE\n", "log.c", 128, (const char *)_FUNCTION___8245);
      fclose(pFile);
    }
    return -1;
  }
  else
  {
    ret = my_system(cmd);
    if ( ret && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: my_system returned failed %d on LOGCHECKSIZE\n",
          "log.c",
          134,
          (const char *)_FUNCTION___8245,
          ret);
      fclose(pFile_0);
    }
    ret = snprintf(
            (char *)cmd,
            0x1000u,
            "exec 2>&1; log_rotate () {     debug_mode=$1;     need_clear=$2;     log_tgt_dir_name=$3;     log_src_dir=$4"
            ";     path=$5;     ts=$6;     prefix=\"$7\"_;     log_bak_dir=/tmp/var.log.bak;     log_tgt_dir=/$log_tgt_di"
            "r_name;     selflog=/tmp/log_rotate.log;     if [ $debug_mode -eq 0 ];     then         threshold1_percentag"
            "e=75; threshold2_percentage=60;     else         threshold1_percentage=15; threshold2_percentage=10;     fi;"
            " echo \"start bakcup logs: \" `date` > $selflog; cglog_archieve_file=$log_tgt_dir/$path/$prefix$ts.tar; rm -"
            "rf $log_bak_dir; mkdir -p $log_bak_dir; dmesg > $log_src_dir/dmesg.log; root_state=`df -k| grep root`; if [ "
            "\"$root_state\" = \"\" ]; then     echo \"ERROR: can't find root\" >> $selflog; exit -1; fi; used_blocks=`ec"
            "ho $root_state | awk '{print $3}'`; total_blocks=`echo $root_state | awk '{print $2}'`; threshold1=$((total_"
            "blocks*threshold1_percentage/100)); if [ $used_blocks -gt $threshold1 ] || [ $need_clear -eq 1 ]; then     e"
            "cho \"used_blocks=$used_blocks > threshold1=$threshold1, total_blocks=$total_blocks\" >> $selflog; echo \"cl"
            "ear $log_src_dir\" >> $selflog; cd $log_bak_dir; mv $log_src_dir/* ./;if [ $need_clear -ne 1 ]; then cglog_a"
            "rchieve_file=$log_tgt_dir/$path/$prefix$ts\"_clearAT_\"`date '+%%Y-%%m-%%d_%%H-%%M-%%S'`.tar;fi;echo \"backu"
            "p to $cglog_archieve_file\">>$selflog; else     echo \"used_blocks=$used_blocks <= threshold1=$threshold1, t"
            "otal_blocks=$total_blocks\" >> $selflog; echo \"only archieve logs to $cglog_archieve_file\" >> $selflog; cd"
            " $log_src_dir; fi; if [ ! -d $log_tgt_dir/$path ]; then     mkdir -p $log_tgt_dir/$path; fi; cat /dev/null >"
            " $cglog_archieve_file;tar cf $cglog_archieve_file * && rm $log_bak_dir/ -rf; }; log_rotate %d %d %s %s %s %s %s",
            debug,
            ctx->need_clear,
            (const char *)ctx->tgt_dir,
            (const char *)ctx->src_dir,
            (const char *)ctx->path,
            (const char *)ctx->ts,
            (const char *)ctx->prefix);
    if ( ret == -1 || (unsigned int)ret >= 0x1000 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "%s:%d:%s: too large command LOGROTATE\n", "log.c", 140, (const char *)_FUNCTION___8245);
        fclose(pFile_1);
      }
      return -1;
    }
    else
    {
      ret = my_system(cmd);
      if ( ret && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_2 = fopen((const char *)log_file, "a+");
        if ( pFile_2 )
          fprintf(
            pFile_2,
            "%s:%d:%s: my_system returned failed %d on LOGROTATE\n",
            "log.c",
            146,
            (const char *)_FUNCTION___8245,
            ret);
        fclose(pFile_2);
      }
      return ret;
    }
  }
}

//----- (00071F08) --------------------------------------------------------
int __cdecl log_generate_symbol_link(const _log_ctx *ctx, const unsigned __int8 *prefix, const unsigned __int8 *path)
{
  unsigned __int8 cmd[4096]; // [sp+24h] [bp-1010h] BYREF
  FILE *pFile; // [sp+1024h] [bp-10h]
  FILE *pFile_0; // [sp+1028h] [bp-Ch]
  int ret; // [sp+102Ch] [bp-8h]

  ret = snprintf(
          (char *)cmd,
          0x1000u,
          "exec 2>&1; gen_symbol_link () { selflog=/tmp/log_symbol_link.log; log_tgt_dir=/$1; path=$2; ts=$3; prefix=\"$4"
          "\"_; new_path=$5; old_file=$log_tgt_dir/$path/$prefix$ts.tar; new_file=$log_tgt_dir/$new_path/LINK_$prefix$ts."
          "tar; echo \"old:$old_file symbol link:$new_file\">$selflog;if [ ! -d $log_tgt_dir/$new_path ]; then mkdir -p $"
          "log_tgt_dir/$new_path; fi; if [ -f $old_file ]; then ln -sf $old_file $new_file;else echo \"old tarball not fo"
          "und\">>$selflog;fi; }; gen_symbol_link %s %s %s %s %s",
          (const char *)ctx->tgt_dir,
          (const char *)ctx->path,
          (const char *)ctx->ts,
          (const char *)prefix,
          (const char *)path);
  if ( ret == -1 || (unsigned int)ret >= 0x1000 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: too large command LOG_SYMBOL_LINK\n", "log.c", 160, (const char *)_FUNCTION___8257);
      fclose(pFile);
    }
    return -1;
  }
  else
  {
    ret = my_system(cmd);
    if ( ret && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: my_system returned failed %d on LOG_SYMBOL_LINK\n",
          "log.c",
          167,
          (const char *)_FUNCTION___8257,
          ret);
      fclose(pFile_0);
    }
    return ret;
  }
}

//----- (00072124) --------------------------------------------------------
int __cdecl log_remount(const _log_ctx *ctx)
{
  unsigned __int8 cmd[1024]; // [sp+10h] [bp-414h] BYREF
  FILE *pFile_0; // [sp+410h] [bp-14h]
  FILE *pFile_1; // [sp+414h] [bp-10h]
  int ret; // [sp+418h] [bp-Ch]
  FILE *pFile; // [sp+41Ch] [bp-8h]

  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: remount /nvdata\n", "log.c", 178, (const char *)_FUNCTION___8265);
    fclose(pFile);
  }
  ret = snprintf(
          (char *)cmd,
          0x400u,
          "exec 2>&1; remount () { mnt_point=/$1; umount -lf $mnt_point && mount -t jffs2 /dev/mtdblock5 $mnt_point; }; remount %s",
          (const char *)ctx->tgt_dir);
  if ( ret == -1 || (unsigned int)ret >= 0x400 )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(pFile_0, "%s:%d:%s: too large command LOG_REMOUNT\n", "log.c", 182, (const char *)_FUNCTION___8265);
      fclose(pFile_0);
    }
    return -1;
  }
  else
  {
    ret = my_system(cmd);
    if ( ret && log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(
          pFile_1,
          "%s:%d:%s: my_system returned failed %d on LOG_REMOUNT\n",
          "log.c",
          189,
          (const char *)_FUNCTION___8265,
          ret);
      fclose(pFile_1);
    }
    return ret;
  }
}

//----- (00072348) --------------------------------------------------------
void *__cdecl __noreturn log_thread_routine(void *arg)
{
  int updated; // r0
  size_t v2; // r0
  unsigned __int8 ts[20]; // [sp+Ch] [bp-58h] BYREF
  unsigned __int8 path[30]; // [sp+20h] [bp-44h] BYREF
  time_t tloc; // [sp+40h] [bp-24h] BYREF
  FILE *pFile; // [sp+44h] [bp-20h]
  int ret; // [sp+48h] [bp-1Ch]
  tm *tm_info; // [sp+4Ch] [bp-18h]
  _log_ctx *ctx; // [sp+50h] [bp-14h]
  uint32_t counter; // [sp+54h] [bp-10h]

  ctx = (_log_ctx *)arg;
  counter = 0;
  if ( !arg )
  {
    print_crt_time_to_file(log_file, 1u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "Assert fail!! %s:%d: input arg wrong\n", "log.c", 208);
    fclose(pFile);
    _assert_fail("0", "log.c", 0xD0u, (const char *)_PRETTY_FUNCTION___8280);
  }
  ctx->need_clear = 0;
  ctx->prefix = "cglog_sync";
  while ( 1 )
  {
    if ( !(++counter % 0x1E) )
    {
      time(&tloc);
      tm_info = localtime(&tloc);
      strftime((char *)path, 0xFu, "%Y-%m/%d", tm_info);
      strftime((char *)ts, 0xAu, "%H-%M-%S", tm_info);
      if ( !strncmp((const char *)ctx->path, "1970", 0x1Eu) )
      {
        if ( tloc > 30660000 )
        {
          ret = log_update_name(ctx, "cglog_init", path, ts);
          updated = log_update_name(ctx, "cglog_sync", path, ts);
          ret |= updated;
          if ( ret )
          {
            log_remount(ctx);
          }
          else
          {
            strncpy((char *)ctx->path, (const char *)path, 0x1Eu);
            strncpy((char *)ctx->ts, (const char *)ts, 0x14u);
          }
        }
      }
      else if ( ctx->last_path[0] )
      {
        v2 = strlen((const char *)path);
        if ( strncmp((const char *)ctx->last_path, (const char *)path, v2) )
        {
          ret = log_generate_symbol_link(ctx, "cglog_sync", path);
          if ( !ret )
            strncpy((char *)ctx->last_path, (const char *)path, 0x1Eu);
        }
      }
      else
      {
        strcpy((char *)ctx->last_path, (const char *)ctx->path);
      }
      if ( log_rotate(ctx) )
        log_remount(ctx);
    }
    sleep(1u);
  }
}

//----- (00072638) --------------------------------------------------------
void log_init()
{
  pthread_t log_thread; // [sp+4h] [bp-18h] BYREF
  time_t timer; // [sp+8h] [bp-14h] BYREF
  FILE *pFile; // [sp+Ch] [bp-10h]
  tm *tm_info; // [sp+10h] [bp-Ch]
  _log_ctx *ctx; // [sp+14h] [bp-8h]

  ctx = &log_ctx;
  if ( log_ctx.path[0] != 48 )
  {
    time(&timer);
    tm_info = localtime(&timer);
    strftime((char *)ctx->path, 0xFu, "%Y-%m/%d", tm_info);
    strftime((char *)ctx->ts, 0xAu, "%H-%M-%S", tm_info);
    ctx->need_clear = 1;
    ctx->src_dir = "/var/log";
    ctx->tgt_dir = "nvdata";
    ctx->prefix = "cglog_init";
    log_rotate(ctx);
    if ( pthread_create(&log_thread, 0, (void *(*)(void *))log_thread_routine, ctx) )
    {
      print_crt_time_to_file(log_file, 1u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "Assert fail!! %s:%d: Failed to create log thread", "log.c", 295);
      fclose(pFile);
      _assert_fail("0", "log.c", 0x127u, (const char *)_PRETTY_FUNCTION___8291);
    }
    pthread_detach(log_thread);
  }
}

//----- (000727C0) --------------------------------------------------------
void __cdecl set_log_level(unsigned int level)
{
  log_level = level;
}

//----- (000727F0) --------------------------------------------------------
void __cdecl clear_log(unsigned __int8 *file)
{
  FILE *fd; // [sp+Ch] [bp-8h]

  fd = fopen((const char *)file, "w");
  if ( fd )
    fclose(fd);
}

//----- (00072834) --------------------------------------------------------
void __cdecl copy_log_to_latest(unsigned __int8 *file)
{
  unsigned __int8 cmd[512]; // [sp+10h] [bp-204h] BYREF

  memset(cmd, 0, sizeof(cmd));
  sprintf(
    (char *)cmd,
    "if [ -f %s ];then cp %s %s_latest;fi;",
    (const char *)file,
    (const char *)file,
    (const char *)file);
  system((const char *)cmd);
}

//----- (00072890) --------------------------------------------------------
void __cdecl print_crt_time_to_file(const unsigned __int8 *file, unsigned int level)
{
  unsigned __int8 buffer[26]; // [sp+8h] [bp-2Ch] BYREF
  time_t timer; // [sp+24h] [bp-10h] BYREF
  FILE *pFile; // [sp+28h] [bp-Ch]
  tm *tm_info; // [sp+2Ch] [bp-8h]

  time(&timer);
  tm_info = localtime(&timer);
  strftime((char *)buffer, 0x1Au, "%Y-%m-%d %H:%M:%S", tm_info);
  if ( level < log_level )
  {
    pFile = fopen((const char *)file, "a+");
    if ( pFile )
      fprintf(pFile, "%s ", (const char *)buffer);
    fclose(pFile);
  }
}

//----- (0007293C) --------------------------------------------------------
void __cdecl dump_mem(unsigned __int8 *desc, void *addr, int len)
{
  int v3; // r3
  int v4; // r3
  int v5; // r3
  unsigned __int8 buff[17]; // [sp+14h] [bp-38h] BYREF
  FILE *pFile_2; // [sp+28h] [bp-24h]
  FILE *pFile_1; // [sp+2Ch] [bp-20h]
  FILE *pFile_0; // [sp+30h] [bp-1Ch]
  FILE *pFile_3; // [sp+34h] [bp-18h]
  FILE *pFile_4; // [sp+38h] [bp-14h]
  FILE *pFile; // [sp+3Ch] [bp-10h]
  unsigned __int8 *pc; // [sp+40h] [bp-Ch]
  int i; // [sp+44h] [bp-8h]

  pc = (unsigned __int8 *)addr;
  if ( desc && log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:\n", (const char *)desc);
    fclose(pFile);
  }
  for ( i = 0; i < len; ++i )
  {
    if ( (i & 0xF) == 0 )
    {
      if ( i && log_level > 3 )
      {
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(pFile_0, "  %s\n", (const char *)buff);
        fclose(pFile_0);
      }
      if ( log_level > 3 )
      {
        pFile_1 = fopen((const char *)log_file, "a+");
        if ( pFile_1 )
          fprintf(pFile_1, "  %04x ", i);
        fclose(pFile_1);
      }
    }
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fprintf(pFile_2, " %02x", pc[i]);
      fclose(pFile_2);
    }
    if ( pc[i] > 0x1Fu && pc[i] <= 0x7Eu )
    {
      v4 = i & 0xF;
      if ( i <= 0 )
        v4 = -(-i & 0xF);
      buff[v4] = pc[i];
    }
    else
    {
      v3 = i & 0xF;
      if ( i <= 0 )
        v3 = -(-i & 0xF);
      buff[v3] = 46;
    }
    v5 = i & 0xF;
    if ( i <= 0 )
      v5 = -(-i & 0xF);
    buff[v5 + 1] = 0;
  }
  while ( (i & 0xF) != 0 )
  {
    if ( log_level > 3 )
    {
      pFile_3 = fopen((const char *)log_file, "a+");
      if ( pFile_3 )
        fwrite("   ", 1u, 3u, pFile_3);
      fclose(pFile_3);
    }
    ++i;
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(pFile_4, "  %s\n", (const char *)buff);
    fclose(pFile_4);
  }
}

//----- (00072CCC) --------------------------------------------------------
uint8_t __cdecl eeprom_write_iic(uint8_t chain, uint8_t reg_addr, uint8_t data)
{
  return znyq_set_iic(chain & 7 | 0x50, 0, 0, 1, reg_addr, data);
}

//----- (00072D58) --------------------------------------------------------
uint8_t __cdecl eeprom_read_iic(uint8_t chain, uint8_t reg_addr)
{
  return znyq_set_iic(chain & 7 | 0x50, 0, 1, 1, reg_addr, 0);
}

//----- (00072DE0) --------------------------------------------------------
int __cdecl eeprom_write_iic_bytes(uint8_t chain, int reg_addr_start, int reg_count, uint8_t *buf)
{
  char reg_addr_starta; // [sp+10h] [bp-14h]
  FILE *pFile; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  reg_addr_starta = reg_addr_start;
  if ( reg_addr_start + reg_count <= 256 )
  {
    pthread_mutex_lock(&iic_mutex);
    for ( i = 0; i < reg_count; ++i )
      eeprom_write_iic(chain, reg_addr_starta + i, buf[i]);
    sleep(1u);
    pthread_mutex_unlock(&iic_mutex);
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: Over EEPROM size.\n", "eeprom.c", 63, (const char *)_FUNCTION___12462);
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00072F30) --------------------------------------------------------
int __cdecl eeprom_read_iic_bytes(uint8_t chain, int reg_addr_start, int reg_count, uint8_t *buf)
{
  char reg_addr_starta; // [sp+10h] [bp-1Ch]
  FILE *pFile; // [sp+18h] [bp-14h]
  int i; // [sp+1Ch] [bp-10h]

  reg_addr_starta = reg_addr_start;
  if ( reg_addr_start + reg_count <= 256 )
  {
    pthread_mutex_lock(&iic_mutex);
    for ( i = 0; i < reg_count; ++i )
      buf[i] = eeprom_read_iic(chain, reg_addr_starta + i);
    pthread_mutex_unlock(&iic_mutex);
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: Over EEPROM size.\n", "eeprom.c", 88, (const char *)_FUNCTION___12474);
      fclose(pFile);
    }
    return -1;
  }
}

//----- (0007307C) --------------------------------------------------------
void __cdecl eeprom_dump_raw(uint8_t *buf, int len)
{
  int v2; // r3
  int v3; // r3
  FILE *pFile_2; // [sp+Ch] [bp-18h]
  FILE *pFile_1; // [sp+10h] [bp-14h]
  FILE *pFile_0; // [sp+14h] [bp-10h]
  FILE *pFile; // [sp+18h] [bp-Ch]
  int i; // [sp+1Ch] [bp-8h]

  for ( i = 0; i < len; ++i )
  {
    if ( (i & 0xF) == 0 && log_level > 3 )
    {
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "0x%04X ", i);
      fclose(pFile);
    }
    v2 = i & 0xF;
    if ( i <= 0 )
      v2 = -(-i & 0xF);
    if ( v2 == 8 && log_level > 3 )
    {
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fwrite("  ", 1u, 2u, pFile_0);
      fclose(pFile_0);
    }
    if ( log_level > 3 )
    {
      pFile_1 = fopen((const char *)log_file, "a+");
      if ( pFile_1 )
        fprintf(pFile_1, "%02X ", buf[i]);
      fclose(pFile_1);
    }
    v3 = i & 0xF;
    if ( i <= 0 )
      v3 = -(-i & 0xF);
    if ( v3 == 15 && log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fputc(10, pFile_2);
      fclose(pFile_2);
    }
  }
}

//----- (00073288) --------------------------------------------------------
void __cdecl eeprom_dump_fileds(eeprom_layout_t *eeprom_buf)
{
  FILE *pFile_2; // [sp+8h] [bp-6Ch]
  FILE *pFile_18; // [sp+Ch] [bp-68h]
  FILE *pFile_17; // [sp+10h] [bp-64h]
  FILE *pFile_21; // [sp+14h] [bp-60h]
  FILE *pFile_20; // [sp+18h] [bp-5Ch]
  FILE *pFile_19; // [sp+1Ch] [bp-58h]
  FILE *pFile_16; // [sp+20h] [bp-54h]
  FILE *pFile_15; // [sp+28h] [bp-4Ch]
  FILE *pFile_14; // [sp+2Ch] [bp-48h]
  FILE *pFile_13; // [sp+30h] [bp-44h]
  FILE *pFile_6; // [sp+34h] [bp-40h]
  FILE *pFile_7; // [sp+38h] [bp-3Ch]
  FILE *pFile_8; // [sp+3Ch] [bp-38h]
  FILE *pFile_9; // [sp+40h] [bp-34h]
  FILE *pFile_10; // [sp+44h] [bp-30h]
  FILE *pFile_11; // [sp+48h] [bp-2Ch]
  FILE *pFile_12; // [sp+4Ch] [bp-28h]
  FILE *pFile_5; // [sp+50h] [bp-24h]
  FILE *pFile_4; // [sp+54h] [bp-20h]
  FILE *pFile_3; // [sp+58h] [bp-1Ch]
  FILE *pFile_1; // [sp+5Ch] [bp-18h]
  FILE *pFile_0; // [sp+60h] [bp-14h]
  FILE *pFile; // [sp+64h] [bp-10h]
  int mode; // [sp+68h] [bp-Ch]
  unsigned int i; // [sp+6Ch] [bp-8h]
  int ia; // [sp+6Ch] [bp-8h]

  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%-30s : 0x%04x\n", "fixture_header", eeprom_buf->fixture_header);
    fclose(pFile);
  }
  if ( log_level > 3 )
  {
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%-30s : 0x%04x\n", "fixture_version", eeprom_buf->fixture_version);
    fclose(pFile_0);
  }
  if ( log_level > 3 )
  {
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%-30s : ", "hash_board_sn");
    fclose(pFile_1);
  }
  for ( i = 0; i <= 0x13; ++i )
  {
    if ( log_level > 3 )
    {
      pFile_2 = fopen((const char *)log_file, "a+");
      if ( pFile_2 )
        fputc(eeprom_buf->hash_board_sn[i], pFile_2);
      fclose(pFile_2);
    }
  }
  if ( log_level > 3 )
  {
    pFile_3 = fopen((const char *)log_file, "a+");
    if ( pFile_3 )
      fputc(10, pFile_3);
    fclose(pFile_3);
  }
  if ( log_level > 3 )
  {
    pFile_4 = fopen((const char *)log_file, "a+");
    if ( pFile_4 )
      fprintf(pFile_4, "%-30s : 0x%04x\n", "pcb_version", eeprom_buf->pcb_version);
    fclose(pFile_4);
  }
  if ( log_level > 3 )
  {
    pFile_5 = fopen((const char *)log_file, "a+");
    if ( pFile_5 )
      fprintf(pFile_5, "%-30s : 0x%04x\n", "bom_version", eeprom_buf->bom_version);
    fclose(pFile_5);
  }
  switch ( eeprom_buf->temp_sensor_type )
  {
    case 1u:
      if ( log_level > 3 )
      {
        pFile_6 = fopen((const char *)log_file, "a+");
        if ( pFile_6 )
          fprintf(pFile_6, "%-30s : %s\n", "temp_sensor_type", "TMP451");
        fclose(pFile_6);
      }
      break;
    case 2u:
      if ( log_level > 3 )
      {
        pFile_7 = fopen((const char *)log_file, "a+");
        if ( pFile_7 )
          fprintf(pFile_7, "%-30s : %s\n", "temp_sensor_type", "TMP461");
        fclose(pFile_7);
      }
      break;
    case 3u:
      if ( log_level > 3 )
      {
        pFile_8 = fopen((const char *)log_file, "a+");
        if ( pFile_8 )
          fprintf(pFile_8, "%-30s : %s\n", "temp_sensor_type", "TMP421");
        fclose(pFile_8);
      }
      break;
    case 4u:
      if ( log_level > 3 )
      {
        pFile_9 = fopen((const char *)log_file, "a+");
        if ( pFile_9 )
          fprintf(pFile_9, "%-30s : %s\n", "temp_sensor_type", "TMP431");
        fclose(pFile_9);
      }
      break;
    case 5u:
      if ( log_level > 3 )
      {
        pFile_10 = fopen((const char *)log_file, "a+");
        if ( pFile_10 )
          fprintf(pFile_10, "%-30s : %s\n", "temp_sensor_type", "ECT218");
        fclose(pFile_10);
      }
      break;
    case 6u:
      if ( log_level > 3 )
      {
        pFile_11 = fopen((const char *)log_file, "a+");
        if ( pFile_11 )
          fprintf(pFile_11, "%-30s : %s\n", "temp_sensor_type", "TMP441B");
        fclose(pFile_11);
      }
      break;
    default:
      if ( eeprom_buf->temp_sensor_type == 7 && log_level > 3 )
      {
        pFile_12 = fopen((const char *)log_file, "a+");
        if ( pFile_12 )
          fprintf(pFile_12, "%-30s : %s\n", "temp_sensor_type", "TMP411C");
        fclose(pFile_12);
      }
      break;
  }
  if ( log_level > 3 )
  {
    pFile_13 = fopen((const char *)log_file, "a+");
    if ( pFile_13 )
      fprintf(pFile_13, "%-30s : 0x%02x\n", "product_id", eeprom_buf->product_id);
    fclose(pFile_13);
  }
  if ( log_level > 3 )
  {
    pFile_14 = fopen((const char *)log_file, "a+");
    if ( pFile_14 )
      fprintf(pFile_14, "%-30s : 0x%04x\n", "cgminer_header", eeprom_buf->cgminer_header);
    fclose(pFile_14);
  }
  if ( log_level > 3 )
  {
    pFile_15 = fopen((const char *)log_file, "a+");
    if ( pFile_15 )
      fputc(10, pFile_15);
    fclose(pFile_15);
  }
  for ( mode = 0; mode < 3; ++mode )
  {
    if ( log_level > 3 )
    {
      pFile_16 = fopen((const char *)log_file, "a+");
      if ( pFile_16 )
        fprintf(pFile_16, "[Tuning Result Mode %d]:\n", mode);
      fclose(pFile_16);
    }
    for ( ia = 0; ia <= 47; ++ia )
    {
      if ( log_level > 3 )
      {
        pFile_17 = fopen((const char *)log_file, "a+");
        if ( pFile_17 )
          fprintf(pFile_17, "IC[%02d]:%03d ", ia, 5 * eeprom_buf->tuning_ret[mode].freq[ia]);
        fclose(pFile_17);
      }
      if ( (((_BYTE)ia + 1) & 3) == 0 && log_level > 3 )
      {
        pFile_18 = fopen((const char *)log_file, "a+");
        if ( pFile_18 )
          fputc(10, pFile_18);
        fclose(pFile_18);
      }
    }
    if ( log_level > 3 )
    {
      pFile_19 = fopen((const char *)log_file, "a+");
      if ( pFile_19 )
        fprintf(pFile_19, "%s: %d\n", "voltage", eeprom_buf->tuning_ret[mode].voltage);
      fclose(pFile_19);
    }
    if ( log_level > 3 )
    {
      pFile_20 = fopen((const char *)log_file, "a+");
      if ( pFile_20 )
        fprintf(pFile_20, "%s: %d\n", "hash_rate", eeprom_buf->tuning_ret[mode].hash_rate);
      fclose(pFile_20);
    }
    if ( log_level > 3 )
    {
      pFile_21 = fopen((const char *)log_file, "a+");
      if ( pFile_21 )
        fputc(10, pFile_21);
      fclose(pFile_21);
    }
  }
}

//----- (00073D14) --------------------------------------------------------
void __cdecl eeprom_dump(eeprom_layout_t *eeprom_buf)
{
  FILE *pFile; // [sp+Ch] [bp-8h]

  eeprom_dump_raw((uint8_t *)eeprom_buf, 256);
  if ( log_level > 3 )
  {
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fputc(10, pFile);
    fclose(pFile);
  }
  eeprom_dump_fileds(eeprom_buf);
}

//----- (00073D98) --------------------------------------------------------
bool __cdecl eeprom_is_fixture_crc_pass(eeprom_layout_t *eeprom_buf)
{
  FILE *pFile; // [sp+14h] [bp-10h]

  if ( CRC16((const uint8_t *)eeprom_buf, 0x1Eu) == eeprom_buf->crc_fixture )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Fixture EEPROM CRC check fail.\n", "eeprom.c", 219, (const char *)_FUNCTION___12539);
    fclose(pFile);
  }
  return 0;
}

//----- (00073E88) --------------------------------------------------------
bool __cdecl eeprom_is_cgminer_crc_pass(eeprom_layout_t *eeprom_buf)
{
  FILE *pFile; // [sp+10h] [bp-14h]

  if ( CRC16((const uint8_t *)&eeprom_buf->cgminer_header, 0xA4u) == eeprom_buf->crc_cgminer )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Cgminer EEPROM CRC check fail.\n", "eeprom.c", 238, (const char *)_FUNCTION___12548);
    fclose(pFile);
  }
  return 0;
}

//----- (00073F90) --------------------------------------------------------
bool __cdecl eeprom_is_fixture_header_pass(eeprom_layout_t *eeprom_buf)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  if ( eeprom_buf->fixture_header == 5015 )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Fixture EEPROM header check fail. fixture_head = 0x%x\n",
        "eeprom.c",
        249,
        (const char *)_FUNCTION___12553,
        eeprom_buf->fixture_header);
    fclose(pFile);
  }
  return 0;
}

//----- (00074068) --------------------------------------------------------
bool __cdecl eeprom_is_cgminer_header_pass(eeprom_layout_t *eeprom_buf)
{
  FILE *pFile; // [sp+14h] [bp-8h]

  if ( eeprom_buf->cgminer_header == 5015 )
    return 1;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Cgminer EEPROM header check fail. cgminer-header = 0x%x\n",
        "eeprom.c",
        260,
        (const char *)_FUNCTION___12558,
        eeprom_buf->cgminer_header);
    fclose(pFile);
  }
  return 0;
}

//----- (00074140) --------------------------------------------------------
int __cdecl eeprom_load_one_chain(int chain, eeprom_layout_t *eeprom_buf)
{
  uint8_t chaina; // [sp+4h] [bp-108h]
  eeprom_layout_t eeprom_buf_tmp; // [sp+8h] [bp-104h] BYREF

  chaina = chain;
  memset(&eeprom_buf_tmp, 0, sizeof(eeprom_buf_tmp));
  if ( eeprom_read_iic_bytes(chaina, 0, 256, (uint8_t *)&eeprom_buf_tmp) )
    return -1;
  if ( !eeprom_is_fixture_crc_pass(&eeprom_buf_tmp) || !eeprom_is_fixture_header_pass(&eeprom_buf_tmp) )
    return -1;
  if ( eeprom_is_cgminer_crc_pass(&eeprom_buf_tmp) && !eeprom_is_cgminer_header_pass(&eeprom_buf_tmp) )
    return -1;
  memcpy(eeprom_buf, &eeprom_buf_tmp, sizeof(eeprom_layout_t));
  return 0;
}

//----- (00074244) --------------------------------------------------------
int __cdecl eeprom_flush_one_chain(int chain, eeprom_layout_t *eeprom_buf)
{
  uint8_t chaina; // [sp+Ch] [bp-120h]
  eeprom_layout_t eeprom_buf_tmp; // [sp+10h] [bp-11Ch] BYREF
  FILE *pFile; // [sp+110h] [bp-1Ch]
  int flush_len; // [sp+114h] [bp-18h]
  int crc_len; // [sp+118h] [bp-14h]
  int start; // [sp+11Ch] [bp-10h]
  uint8_t *p_buf_tmp; // [sp+120h] [bp-Ch]
  uint8_t *p_buf; // [sp+124h] [bp-8h]

  chaina = chain;
  p_buf = (uint8_t *)eeprom_buf;
  p_buf_tmp = (uint8_t *)&eeprom_buf_tmp;
  start = 40;
  crc_len = 164;
  flush_len = 166;
  eeprom_buf->cgminer_header = 5015;
  eeprom_buf->crc_cgminer = CRC16(&p_buf[start], crc_len);
  if ( eeprom_write_iic_bytes(chaina, start, flush_len, &p_buf[start]) )
    return -1;
  memset(&eeprom_buf_tmp, 255, sizeof(eeprom_buf_tmp));
  if ( eeprom_read_iic_bytes(chaina, start, flush_len, &p_buf_tmp[start]) )
    return -1;
  if ( !memcmp(&p_buf[start], &p_buf_tmp[start], flush_len) )
    return 0;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Read data is different of write data.\n",
        "eeprom.c",
        322,
        (const char *)_FUNCTION___12575);
    fclose(pFile);
  }
  return -1;
}

//----- (00074428) --------------------------------------------------------
void eeprom_load()
{
  FILE *pFile; // [sp+8h] [bp-14h]
  FILE *pFile_0; // [sp+Ch] [bp-10h]
  FILE *pFile_1; // [sp+10h] [bp-Ch]
  int chain; // [sp+14h] [bp-8h]

  if ( g_is_eeprom_loaded )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(pFile, "%s:%d:%s: EEPROM already loaded.\n", "eeprom.c", 341, (const char *)_FUNCTION___12581);
      fclose(pFile);
    }
  }
  else
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
      {
        memset(&g_eeprom_buf[chain], 255, sizeof(eeprom_layout_t));
        memcpy(g_eeprom_buf[chain].hash_board_sn, "deadbeefdeadbeefdead", sizeof(g_eeprom_buf[chain].hash_board_sn));
        if ( eeprom_load_one_chain(chain, &g_eeprom_buf[chain]) )
        {
          if ( log_level > 3 )
          {
            print_crt_time_to_file(log_file, 3u);
            pFile_1 = fopen((const char *)log_file, "a+");
            if ( pFile_1 )
              fprintf(
                pFile_1,
                "%s:%d:%s: Chain %d EEPROM data fail, power off the hash board.\n",
                "eeprom.c",
                362,
                (const char *)_FUNCTION___12581,
                chain);
            fclose(pFile_1);
          }
        }
        else if ( log_level > 3 )
        {
          print_crt_time_to_file(log_file, 3u);
          pFile_0 = fopen((const char *)log_file, "a+");
          if ( pFile_0 )
            fprintf(
              pFile_0,
              "%s:%d:%s: Chain %d EEPROM load success.\n",
              "eeprom.c",
              358,
              (const char *)_FUNCTION___12581,
              chain);
          fclose(pFile_0);
        }
      }
    }
    g_is_eeprom_loaded = 1;
  }
}

//----- (000746E0) --------------------------------------------------------
void eeprom_dump()
{
  FILE *pFile; // [sp+0h] [bp-Ch]
  int chain; // [sp+4h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
    {
      if ( log_level > 3 )
      {
        pFile = fopen((const char *)log_file, "a+");
        if ( pFile )
          fprintf(pFile, ">>>> EEPROM of Chain %d:\n", chain);
        fclose(pFile);
      }
      eeprom_dump(&g_eeprom_buf[chain]);
    }
  }
}

//----- (000747BC) --------------------------------------------------------
int eeprom_flush()
{
  FILE *pFile; // [sp+Ch] [bp-10h]
  int ret; // [sp+10h] [bp-Ch]
  int chain; // [sp+14h] [bp-8h]

  ret = 0;
  if ( !g_is_eeprom_loaded )
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Note: Can't flush EEPROM data without load.\n",
          "eeprom.c",
          395,
          (const char *)_FUNCTION___12604);
      fclose(pFile);
    }
    return -1;
  }
  else
  {
    for ( chain = 0; chain <= 15; ++chain )
    {
      if ( dev->chain_exist[chain] )
        ret |= eeprom_flush_one_chain(chain, &g_eeprom_buf[chain]);
    }
    return ret;
  }
}

//----- (00074908) --------------------------------------------------------
uint16_t __cdecl eeprom_get_pcb_version(int chain)
{
  const char *v1; // r3
  FILE *pFile; // [sp+1Ch] [bp-8h]

  if ( dev->chain_exist[chain] && g_is_eeprom_loaded )
    return g_eeprom_buf[chain].pcb_version;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( g_is_eeprom_loaded )
        v1 = "true";
      else
        v1 = "false";
      fprintf(
        pFile,
        "%s:%d:%s: Error: chain = %d, load_done = %s\n",
        "eeprom.c",
        427,
        (const char *)_FUNCTION___12618,
        chain,
        v1);
    }
    fclose(pFile);
  }
  return -1;
}

//----- (00074A40) --------------------------------------------------------
uint16_t __cdecl eeprom_get_bom_version(int chain)
{
  const char *v1; // r3
  FILE *pFile; // [sp+1Ch] [bp-8h]

  if ( dev->chain_exist[chain] && g_is_eeprom_loaded )
    return g_eeprom_buf[chain].bom_version;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
    {
      if ( g_is_eeprom_loaded )
        v1 = "true";
      else
        v1 = "false";
      fprintf(
        pFile,
        "%s:%d:%s: Error: chain = %d, load_done = %s\n",
        "eeprom.c",
        438,
        (const char *)_FUNCTION___12623,
        chain,
        v1);
    }
    fclose(pFile);
  }
  return -1;
}

//----- (00074B78) --------------------------------------------------------
int eeprom_get_freq_store_step()
{
  return 5;
}

//----- (00074B94) --------------------------------------------------------
int __cdecl eeprom_get_freq(int chain, int mode, uint32_t *buf, int len)
{
  const char *v4; // r3
  FILE *pFile; // [sp+28h] [bp-Ch]
  int i; // [sp+2Ch] [bp-8h]

  if ( dev->chain_exist[chain] && mode <= 2 && g_is_eeprom_loaded && len > 47 )
  {
    for ( i = 0; i <= 47; ++i )
      buf[i] = 5 * g_eeprom_buf[chain].tuning_ret[mode].freq[i];
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
      {
        if ( g_is_eeprom_loaded )
          v4 = "true";
        else
          v4 = "false";
        fprintf(
          pFile,
          "%s:%d:%s: Error: chain = %d, mode = %d, load_done = %s, len = %d.\n",
          "eeprom.c",
          478,
          (const char *)_FUNCTION___12645,
          chain,
          mode,
          v4,
          len);
      }
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00074D68) --------------------------------------------------------
int __cdecl eeprom_get_voltage(int chain, int mode, int *voltage)
{
  const char *v3; // r3
  FILE *pFile; // [sp+24h] [bp-8h]

  if ( dev->chain_exist[chain] && mode <= 2 && g_is_eeprom_loaded )
  {
    if ( voltage )
      *voltage = g_eeprom_buf[chain].tuning_ret[mode].voltage;
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
      {
        if ( g_is_eeprom_loaded )
          v3 = "true";
        else
          v3 = "false";
        fprintf(
          pFile,
          "%s:%d:%s: Error: chain = %d, mode = %d, load_done = %s.\n",
          "eeprom.c",
          494,
          (const char *)_FUNCTION___12655,
          chain,
          mode,
          v3);
      }
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00074EE8) --------------------------------------------------------
int __cdecl eeprom_get_hash_rate(int chain, int mode, uint32_t *hash_rate)
{
  const char *v3; // r3
  FILE *pFile; // [sp+24h] [bp-8h]

  if ( dev->chain_exist[chain] && mode <= 2 && g_is_eeprom_loaded )
  {
    if ( hash_rate )
      *hash_rate = g_eeprom_buf[chain].tuning_ret[mode].hash_rate;
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
      {
        if ( g_is_eeprom_loaded )
          v3 = "true";
        else
          v3 = "false";
        fprintf(
          pFile,
          "%s:%d:%s: Error: chain = %d, mode = %d, load_done = %s.\n",
          "eeprom.c",
          510,
          (const char *)_FUNCTION___12662,
          chain,
          mode,
          v3);
      }
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00075064) --------------------------------------------------------
int __cdecl eeprom_set_freq(int chain, int mode, int *buf, uint8_t len)
{
  const char *v4; // r3
  FILE *pFile; // [sp+2Ch] [bp-10h]
  FILE *pFile_0; // [sp+30h] [bp-Ch]
  int i; // [sp+34h] [bp-8h]

  if ( dev->chain_exist[chain] && g_is_eeprom_loaded && mode <= 2 && len > 0x2Fu )
  {
    for ( i = 0; i <= 47; ++i )
    {
      if ( buf[i] % 5 && log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
          fprintf(
            pFile_0,
            "%s:%d:%s: Note: buf[%d] = %d, which is not not multiple of %d\n",
            "eeprom.c",
            536,
            (const char *)_FUNCTION___12671,
            i,
            buf[i],
            5);
        fclose(pFile_0);
      }
      g_eeprom_buf[chain].tuning_ret[mode].freq[i] = (char)buf[i] / 5;
    }
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
      {
        if ( g_is_eeprom_loaded )
          v4 = "true";
        else
          v4 = "false";
        fprintf(
          pFile,
          "%s:%d:%s: Invalid parameter: chain = %d, load_done = %s, mode = %d, len = %d.\n",
          "eeprom.c",
          528,
          (const char *)_FUNCTION___12671,
          chain,
          v4,
          mode,
          len);
      }
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00075338) --------------------------------------------------------
int __cdecl eeprom_set_voltage(int chain, int mode, uint16_t voltage)
{
  const char *v3; // r3
  FILE *pFile; // [sp+24h] [bp-8h]

  if ( dev->chain_exist[chain] && g_is_eeprom_loaded && mode <= 2 )
  {
    g_eeprom_buf[chain].tuning_ret[mode].voltage = voltage;
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
      {
        if ( g_is_eeprom_loaded )
          v3 = "true";
        else
          v3 = "false";
        fprintf(
          pFile,
          "%s:%d:%s: Invalid parameter: chain = %d, load_done = %s, mode = %d.\n",
          "eeprom.c",
          549,
          (const char *)_FUNCTION___12682,
          chain,
          v3,
          mode);
      }
      fclose(pFile);
    }
    return -1;
  }
}

//----- (000754A8) --------------------------------------------------------
int __cdecl eeprom_set_hash_rate(int chain, int mode, uint32_t hash_rate)
{
  const char *v3; // r3
  FILE *pFile; // [sp+24h] [bp-8h]

  if ( dev->chain_exist[chain] && g_is_eeprom_loaded && mode <= 2 )
  {
    g_eeprom_buf[chain].tuning_ret[mode].hash_rate = hash_rate;
    return 0;
  }
  else
  {
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
      {
        if ( g_is_eeprom_loaded )
          v3 = "true";
        else
          v3 = "false";
        fprintf(
          pFile,
          "%s:%d:%s: Invalid parameter: chain = %d, load_done = %s, mode = %d.\n",
          "eeprom.c",
          561,
          (const char *)_FUNCTION___12689,
          chain,
          v3,
          mode);
      }
      fclose(pFile);
    }
    return -1;
  }
}

//----- (00075614) --------------------------------------------------------
uint8_t __cdecl write_pic_iic(uint8_t chain, uint8_t data)
{
  return znyq_set_iic(chain & 7 | 0x20, 0, 0, 0, 0, data);
}

//----- (000756A4) --------------------------------------------------------
uint8_t __cdecl read_pic_iic(uint8_t chain)
{
  return znyq_set_iic(chain & 7 | 0x20, 0, 1, 0, 0, 0);
}

//----- (00075728) --------------------------------------------------------
void __cdecl send_pic_cmd(uint8_t chain, uint8_t cmd, uint8_t len, uint8_t *crc, uint8_t *reply_buf, uint8_t reply_len)
{
  int i; // [sp+Ch] [bp-10h]

  pthread_mutex_lock(&iic_mutex);
  usleep(0x186A0u);
  write_pic_iic(chain, 0x55u);
  write_pic_iic(chain, 0xAAu);
  write_pic_iic(chain, len);
  write_pic_iic(chain, cmd);
  write_pic_iic(chain, *crc);
  write_pic_iic(chain, crc[1]);
  usleep(0x61A80u);
  for ( i = 0; i < reply_len; ++i )
    reply_buf[i] = read_pic_iic(chain);
  pthread_mutex_unlock(&iic_mutex);
}

//----- (00075858) --------------------------------------------------------
int __cdecl volt_clamp(uint8_t chain, uint8_t enable)
{
  int v3; // r3
  uint8_t read_back_data; // [sp+18h] [bp-1Ch]
  uint8_t read_back_data_1; // [sp+19h] [bp-1Bh]
  uint8_t crc_data; // [sp+1Ch] [bp-18h]
  uint8_t crc_data_1; // [sp+1Dh] [bp-17h]
  FILE *pFile; // [sp+20h] [bp-14h]
  FILE *pFile_0; // [sp+24h] [bp-10h]
  int retry_count; // [sp+2Ch] [bp-8h]

  retry_count = 0;
  crc_data = (unsigned __int16)(enable + 54) >> 8;
  crc_data_1 = enable + 54;
  while ( 1 )
  {
    v3 = retry_count++;
    if ( v3 > 2 )
      return 0;
    pthread_mutex_lock(&iic_mutex);
    usleep(0x186A0u);
    write_pic_iic(chain, 0x55u);
    write_pic_iic(chain, 0xAAu);
    write_pic_iic(chain, 5u);
    write_pic_iic(chain, 0x31u);
    write_pic_iic(chain, enable);
    write_pic_iic(chain, crc_data);
    write_pic_iic(chain, crc_data_1);
    usleep(0x7A120u);
    read_back_data = read_pic_iic(chain);
    read_back_data_1 = read_pic_iic(chain);
    pthread_mutex_unlock(&iic_mutex);
    if ( read_back_data == 49 && read_back_data_1 == 1 )
      break;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: failed on Chain[%d], b[0] = %d, b[2] = %d!\n",
          "dspic33ep16gs202.c",
          86,
          (const char *)_FUNCTION___11107,
          chain,
          read_back_data,
          read_back_data_1);
      fclose(pFile);
    }
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: Disable pic crab for chain %d success!\n",
        "dspic33ep16gs202.c",
        91,
        (const char *)_FUNCTION___11107,
        chain);
    fclose(pFile_0);
  }
  return 1;
}

//----- (00075B4C) --------------------------------------------------------
int __cdecl pic_voltage_clamp_disable(uint8_t chain)
{
  return volt_clamp(chain, 0);
}

//----- (00075B80) --------------------------------------------------------
int __cdecl hashboard_power_cntl(uint8_t chain, uint8_t enable)
{
  int v3; // r3
  uint8_t read_back_data; // [sp+18h] [bp-1Ch]
  uint8_t read_back_data_1; // [sp+19h] [bp-1Bh]
  uint8_t crc_data; // [sp+1Ch] [bp-18h]
  uint8_t crc_data_1; // [sp+1Dh] [bp-17h]
  FILE *pFile; // [sp+20h] [bp-14h]
  FILE *pFile_0; // [sp+24h] [bp-10h]
  int retry_count; // [sp+2Ch] [bp-8h]

  retry_count = 0;
  crc_data = (unsigned __int16)(enable + 26) >> 8;
  crc_data_1 = enable + 26;
  while ( 1 )
  {
    v3 = retry_count++;
    if ( v3 > 2 )
      return 0;
    pthread_mutex_lock(&iic_mutex);
    usleep(0x186A0u);
    write_pic_iic(chain, 0x55u);
    write_pic_iic(chain, 0xAAu);
    write_pic_iic(chain, 5u);
    write_pic_iic(chain, 0x15u);
    write_pic_iic(chain, enable);
    write_pic_iic(chain, crc_data);
    write_pic_iic(chain, crc_data_1);
    usleep(0x61A80u);
    read_back_data = read_pic_iic(chain);
    read_back_data_1 = read_pic_iic(chain);
    pthread_mutex_unlock(&iic_mutex);
    if ( read_back_data == 21 && read_back_data_1 == 1 )
      break;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: failed on Chain[%d]! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n",
          "dspic33ep16gs202.c",
          142,
          (const char *)_FUNCTION___11128,
          chain,
          read_back_data,
          read_back_data_1);
      fclose(pFile);
    }
    sleep(1u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: [%d] ok, i2c=%d!\n",
        "dspic33ep16gs202.c",
        149,
        (const char *)_FUNCTION___11128,
        enable,
        chain);
    fclose(pFile_0);
  }
  return 1;
}

//----- (00075E7C) --------------------------------------------------------
int __cdecl hashboard_power_on(uint8_t chain)
{
  return hashboard_power_cntl(chain, 1u);
}

//----- (00075EB0) --------------------------------------------------------
int __cdecl hashboard_power_off(uint8_t chain)
{
  return hashboard_power_cntl(chain, 0);
}

//----- (00075EE4) --------------------------------------------------------
int __cdecl pic_reset(uint8_t chain)
{
  int v2; // r3
  uint8_t read_back_data[2]; // [sp+18h] [bp-1Ch] BYREF
  uint8_t crc_data[2]; // [sp+1Ch] [bp-18h] BYREF
  FILE *pFile; // [sp+20h] [bp-14h]
  FILE *pFile_0; // [sp+24h] [bp-10h]
  unsigned __int16 crc; // [sp+28h] [bp-Ch]
  uint8_t length; // [sp+2Bh] [bp-9h]
  int retry_count; // [sp+2Ch] [bp-8h]

  length = 4;
  retry_count = 0;
  crc = 11;
  crc_data[0] = 0;
  crc_data[1] = 11;
  while ( 1 )
  {
    v2 = retry_count++;
    if ( v2 > 2 )
      return 0;
    send_pic_cmd(chain, 7u, length, crc_data, read_back_data, 2u);
    if ( read_back_data[0] == 7 && read_back_data[1] == 1 )
      break;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: failed on Chain[%d]! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n",
          "dspic33ep16gs202.c",
          240,
          (const char *)_FUNCTION___11169,
          chain,
          read_back_data[0],
          read_back_data[1]);
      fclose(pFile);
    }
    sleep(3u);
  }
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(pFile_0, "%s:%d:%s: chain[%d] ok\n", "dspic33ep16gs202.c", 246, (const char *)_FUNCTION___11169, chain);
    fclose(pFile_0);
  }
  sleep(3u);
  return 1;
}

//----- (000760EC) --------------------------------------------------------
int __cdecl pic_set_heart_beat(uint8_t chain)
{
  int v2; // r3
  uint8_t read_back_data[6]; // [sp+24h] [bp-20h] BYREF
  uint8_t crc_data[2]; // [sp+2Ch] [bp-18h] BYREF
  FILE *pFile; // [sp+30h] [bp-14h]
  FILE *pFile_0; // [sp+34h] [bp-10h]
  unsigned __int16 crc; // [sp+38h] [bp-Ch]
  uint8_t length; // [sp+3Bh] [bp-9h]
  int retry_count; // [sp+3Ch] [bp-8h]

  length = 4;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&read_back_data[4] = 0;
  retry_count = 0;
  crc = 26;
  crc_data[0] = 0;
  crc_data[1] = 26;
  while ( 1 )
  {
    v2 = retry_count++;
    if ( v2 > 2 )
      return 0;
    send_pic_cmd(chain, 0x16u, length, crc_data, read_back_data, 6u);
    if ( read_back_data[1] == 22 && read_back_data[2] == 1 )
      break;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: Heartbeat failed on Chain[%d], retry_count=%d! read_back_data[1] = 0x%x, read_back_data[2] = 0x%x\n",
          "dspic33ep16gs202.c",
          272,
          (const char *)_FUNCTION___11183,
          chain,
          retry_count,
          read_back_data[1],
          read_back_data[2]);
      fclose(pFile);
    }
    sleep(1u);
  }
  if ( log_level > 5 )
  {
    print_crt_time_to_file(log_file, 5u);
    pFile_0 = fopen((const char *)log_file, "a+");
    if ( pFile_0 )
      fprintf(
        pFile_0,
        "%s:%d:%s: success on chain[%d],ret = %d\n",
        "dspic33ep16gs202.c",
        277,
        (const char *)_FUNCTION___11183,
        chain,
        read_back_data[3]);
    fclose(pFile_0);
  }
  return 1;
}

//----- (0007632C) --------------------------------------------------------
int __cdecl jump_to_app_from_loader(uint32_t chain)
{
  int v2; // r3
  uint8_t read_back_data[2]; // [sp+1Ch] [bp-20h] BYREF
  uint8_t crc_data[2]; // [sp+20h] [bp-1Ch] BYREF
  FILE *pFile_0; // [sp+24h] [bp-18h]
  FILE *pFile; // [sp+28h] [bp-14h]
  FILE *pFile_1; // [sp+2Ch] [bp-10h]
  unsigned __int16 crc; // [sp+30h] [bp-Ch]
  uint8_t length; // [sp+33h] [bp-9h]
  int retry_count; // [sp+34h] [bp-8h]

  length = 4;
  read_back_data[1] = 0;
  read_back_data[0] = -1;
  retry_count = 0;
  crc = 10;
  crc_data[0] = 0;
  crc_data[1] = 10;
  while ( 1 )
  {
    v2 = retry_count++;
    if ( v2 > 2 )
      return 0;
    send_pic_cmd(chain, 6u, length, crc_data, read_back_data, 2u);
    if ( read_back_data[0] == 6 && read_back_data[1] == 1 )
      break;
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: failed on Chain[%d]! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x\n",
          "dspic33ep16gs202.c",
          508,
          (const char *)_FUNCTION___11197,
          chain,
          read_back_data[0],
          read_back_data[1]);
      fclose(pFile);
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile_0 = fopen((const char *)log_file, "a+");
      if ( pFile_0 )
        fprintf(
          pFile_0,
          "%s:%d:%s: Reset Chian[%d] PIC again!\n",
          "dspic33ep16gs202.c",
          509,
          (const char *)_FUNCTION___11197,
          chain);
      fclose(pFile_0);
    }
    pic_reset(chain);
    sleep(1u);
  }
  sleep(1u);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile_1 = fopen((const char *)log_file, "a+");
    if ( pFile_1 )
      fprintf(pFile_1, "%s:%d:%s: chain[%d] ok\n", "dspic33ep16gs202.c", 517, (const char *)_FUNCTION___11197, chain);
    fclose(pFile_1);
  }
  return 1;
}

//----- (000765FC) --------------------------------------------------------
int __cdecl pic_init(uint8_t chain)
{
  if ( pic_reset(chain) )
    return jump_to_app_from_loader(chain);
  else
    return 0;
}

//----- (0007665C) --------------------------------------------------------
void __cdecl sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  uint32_t wv[8]; // [sp+14h] [bp-138h]
  uint32_t w[64]; // [sp+34h] [bp-118h]
  uint32_t t2; // [sp+134h] [bp-18h]
  uint32_t t1; // [sp+138h] [bp-14h]
  const unsigned __int8 *sub_block; // [sp+13Ch] [bp-10h]
  int j; // [sp+140h] [bp-Ch]
  int i; // [sp+144h] [bp-8h]

  for ( i = 0; i < (int)block_nb; ++i )
  {
    sub_block = &message[64 * i];
    for ( j = 0; j <= 15; ++j )
      w[j] = sub_block[4 * j + 3] | (sub_block[4 * j + 2] << 8) | (sub_block[4 * j + 1] << 16) | (sub_block[4 * j] << 24);
    for ( j = 16; j <= 63; ++j )
      w[j] = (__ROR4__(w[j - 2], 17) ^ __ROR4__(w[j - 2], 19) ^ (w[j - 2] >> 10))
           + w[j - 7]
           + ((w[j - 15] >> 3) ^ __ROR4__(w[j - 15], 7) ^ __ROR4__(w[j - 15], 18))
           + w[j - 16];
    for ( j = 0; j <= 7; ++j )
      wv[j] = ctx->h[j];
    for ( j = 0; j <= 63; ++j )
    {
      t1 = wv[7]
         + (__ROR4__(wv[4], 25) ^ __ROR4__(wv[4], 6) ^ __ROR4__(wv[4], 11))
         + (wv[6] & ~wv[4] ^ wv[4] & wv[5])
         + sha256_k[j]
         + w[j];
      t2 = (__ROR4__(wv[0], 2) ^ __ROR4__(wv[0], 13) ^ __ROR4__(wv[0], 22)) + (wv[2] & wv[1] ^ wv[0] & (wv[2] ^ wv[1]));
      wv[7] = wv[6];
      wv[6] = wv[5];
      wv[5] = wv[4];
      wv[4] = wv[3] + t1;
      wv[3] = wv[2];
      wv[2] = wv[1];
      wv[1] = wv[0];
      wv[0] = t1 + t2;
    }
    for ( j = 0; j <= 7; ++j )
      ctx->h[j] += wv[j];
  }
}

//----- (00076A84) --------------------------------------------------------
void __cdecl sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  sha256_ctx ctx; // [sp+10h] [bp-ACh] BYREF

  sha256_init(&ctx);
  sha256_update(&ctx, message, len);
  sha256_final(&ctx, digest);
}

//----- (00076AD8) --------------------------------------------------------
void __cdecl sha256_init(sha256_ctx *ctx)
{
  int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i <= 7; ++i )
    ctx->h[i] = sha256_h0[i];
  ctx->len = 0;
  ctx->tot_len = 0;
}

//----- (00076B54) --------------------------------------------------------
void __cdecl sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v3; // r3
  const unsigned __int8 *shifted_message; // [sp+14h] [bp-18h]
  unsigned int block_nb; // [sp+18h] [bp-14h]
  unsigned int rem_len; // [sp+20h] [bp-Ch]
  int rem_lena; // [sp+20h] [bp-Ch]

  v3 = len;
  if ( 64 - ctx->len < len )
    v3 = 64 - ctx->len;
  rem_len = v3;
  memcpy(&ctx->block[ctx->len], message, v3);
  if ( ctx->len + len > 0x3F )
  {
    block_nb = (len - rem_len) >> 6;
    shifted_message = &message[rem_len];
    sha256_transf(ctx, ctx->block, 1u);
    sha256_transf(ctx, &message[rem_len], block_nb);
    rem_lena = ((_BYTE)len - (_BYTE)rem_len) & 0x3F;
    memcpy(ctx->block, &shifted_message[64 * block_nb], rem_lena);
    ctx->len = rem_lena;
    ctx->tot_len += (block_nb + 1) << 6;
  }
  else
  {
    ctx->len += len;
  }
}

//----- (00076CA4) --------------------------------------------------------
void __cdecl sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  int v2; // r3
  unsigned int pm_len; // [sp+8h] [bp-14h]
  unsigned int len_b; // [sp+Ch] [bp-10h]
  unsigned int block_nb; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  if ( (ctx->len & 0x3F) <= 0x37 )
    v2 = 1;
  else
    v2 = 2;
  block_nb = v2;
  len_b = 8 * (ctx->tot_len + ctx->len);
  pm_len = v2 << 6;
  memset(&ctx->block[ctx->len], 0, (v2 << 6) - ctx->len);
  ctx->block[ctx->len] = 0x80;
  ctx->block[pm_len - 1] = len_b;
  ctx->block[pm_len - 2] = BYTE1(len_b);
  ctx->block[pm_len - 3] = BYTE2(len_b);
  ctx->block[pm_len - 4] = HIBYTE(len_b);
  sha256_transf(ctx, ctx->block, block_nb);
  for ( i = 0; i <= 7; ++i )
  {
    digest[4 * i + 3] = ctx->h[i];
    digest[4 * i + 2] = BYTE1(ctx->h[i]);
    digest[4 * i + 1] = BYTE2(ctx->h[i]);
    digest[4 * i] = HIBYTE(ctx->h[i]);
  }
}

//----- (00076EDC) --------------------------------------------------------
void __cdecl mutex_init_1(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00076F7C) --------------------------------------------------------
void __cdecl rwlock_init_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0007701C) --------------------------------------------------------
void __cdecl cglock_init_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_init_1(&lock->mutex, file, func, line);
  rwlock_init_1(&lock->rwlock, file, func, line);
}

//----- (00077070) --------------------------------------------------------
void __cdecl k_alloc_items(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+34h] [bp-810h] BYREF
  int i; // [sp+834h] [bp-10h]
  int allocate; // [sp+838h] [bp-Ch]
  K_ITEM *item; // [sp+83Ch] [bp-8h]

  if ( list->is_store )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___10389,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___10389,
      20);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( list->limit <= 0 || list->total < list->limit )
  {
    allocate = list->allocate;
    if ( list->limit > 0 && list->total + allocate > list->limit )
      allocate = list->limit - list->total;
    ++list->item_mem_count;
    list->item_memory = (void **)realloc(list->item_memory, 4 * list->item_mem_count);
    if ( !list->item_memory )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s item_memory failed to realloc count=%d in %s %s():%d",
        (const char *)list->name,
        list->item_mem_count,
        "klist.c",
        (const char *)_func___10389,
        35);
      applog(3, tmp42, 1);
      quit(1);
    }
    item = (K_ITEM *)calloc(allocate, 0x10u);
    if ( !item )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
        (const char *)list->name,
        allocate,
        list->total,
        list->limit,
        "klist.c",
        (const char *)_func___10389,
        41);
      applog(3, tmp42, 1);
      quit(1);
    }
    DWORD1073741823(list->item_memory[list->item_mem_count]) = item;
    list->total += allocate;
    list->count = allocate;
    list->count_up = allocate;
    item->name = list->name;
    item->prev = 0;
    item->next = item + 1;
    for ( i = 1; i < allocate - 1; ++i )
    {
      item[i].name = list->name;
      item[i].prev = &item[i - 1];
      item[i].next = &item[i + 1];
    }
    item[allocate - 1].name = list->name;
    item[allocate - 1].prev = &item[allocate - 2];
    item[allocate - 1].next = 0;
    list->head = item;
    if ( list->do_tail )
      list->tail = &item[allocate - 1];
    for ( item = list->head; item; item = item->next )
    {
      ++list->data_mem_count;
      list->data_memory = (void **)realloc(list->data_memory, 4 * list->data_mem_count);
      if ( !list->data_memory )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "List %s data_memory failed to realloc count=%d in %s %s():%d",
          (const char *)list->name,
          list->data_mem_count,
          "klist.c",
          (const char *)_func___10389,
          75);
        applog(3, tmp42, 1);
        quit(1);
      }
      item->data = calloc(1u, list->siz);
      if ( !item->data )
      {
        snprintf(
          (char *)tmp42,
          0x800u,
          "List %s failed to calloc item data in %s %s():%d",
          (const char *)list->name,
          "klist.c",
          (const char *)_func___10389,
          79);
        applog(3, tmp42, 1);
        quit(1);
      }
      DWORD1073741823(list->data_memory[list->data_mem_count]) = item->data;
    }
  }
}

//----- (000776A0) --------------------------------------------------------
K_LIST *__cdecl k_new_list(
        const unsigned __int8 *name,
        size_t siz,
        int allocate,
        int limit,
        bool do_tail,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-808h] BYREF
  K_LIST *list; // [sp+824h] [bp-8h]

  if ( allocate <= 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      (const char *)name,
      allocate,
      "klist.c",
      (const char *)_func___10418,
      106);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( limit < 0 )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      (const char *)name,
      limit,
      "klist.c",
      (const char *)_func___10418,
      109);
    applog(3, tmp42, 1);
    quit(1);
  }
  list = (K_LIST *)calloc(1u, 0x40u);
  if ( !list )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___10418,
      113);
    applog(3, tmp42, 1);
    quit(1);
  }
  list->is_store = 0;
  list->lock = (cglock_t *)calloc(1u, 0x38u);
  if ( !list->lock )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to calloc lock for list %s in %s %s():%d",
      (const char *)name,
      "klist.c",
      (const char *)_func___10418,
      119);
    applog(3, tmp42, 1);
    quit(1);
  }
  cglock_init_1(list->lock, "klist.c", _func___10418, 121);
  list->name = name;
  list->siz = siz;
  list->allocate = allocate;
  list->limit = limit;
  list->do_tail = do_tail;
  k_alloc_items(list, file, func, line);
  return list;
}

//----- (00077950) --------------------------------------------------------
K_ITEM *__cdecl k_unlink_head(K_LIST *list, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  k_item *item; // [sp+14h] [bp-8h]

  if ( !list->head && !list->is_store )
    k_alloc_items(list, file, func, line);
  if ( !list->head )
    return 0;
  item = list->head;
  list->head = item->next;
  if ( list->head )
  {
    list->head->prev = 0;
  }
  else if ( list->do_tail )
  {
    list->tail = 0;
  }
  item->next = 0;
  item->prev = item->next;
  --list->count;
  return item;
}

//----- (00077A5C) --------------------------------------------------------
void __cdecl k_add_head(
        K_LIST *list,
        K_ITEM *item,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  unsigned __int8 tmp42[2048]; // [sp+30h] [bp-804h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      (char *)tmp42,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      (const char *)list->name,
      (const char *)_func___10453,
      (const char *)item->name,
      (const char *)file,
      (const char *)func,
      line,
      "klist.c",
      (const char *)_func___10453,
      214);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = 0;
  item->next = list->head;
  if ( list->head )
    list->head->prev = item;
  list->head = item;
  if ( list->do_tail && !list->tail )
    list->tail = item;
  ++list->count;
  ++list->count_up;
}

//----- (00077BCC) --------------------------------------------------------
int is_S15()
{
  return 0;
}

//----- (00077BE8) --------------------------------------------------------
int is_T15()
{
  return 0;
}

//----- (00077C04) --------------------------------------------------------
void __cdecl send_set_config_command(int chain, uint8_t mode, uint8_t chip_addr, uint8_t reg_addr, uint32_t reg_data)
{
  unsigned __int8 v5; // r0
  unsigned int bc_cmd[3]; // [sp+14h] [bp-28h] BYREF
  set_config_t set_cfg; // [sp+20h] [bp-1Ch] BYREF
  FILE *pFile; // [sp+2Ch] [bp-10h]
  unsigned int value; // [sp+30h] [bp-Ch]

  if ( dev->chain_exist[chain] )
  {
    memset(&set_cfg, 0, sizeof(set_cfg));
    set_cfg.v[0] = set_cfg.v[0] & 0xF0 | 1;
    set_cfg.v[0] = set_cfg.v[0] & 0xEF | (16 * (mode != 0));
    set_cfg.v[0] = set_cfg.v[0] & 0x1F | 0x40;
    set_cfg.u._Length = 9;
    set_cfg.u._ADDR = chip_addr;
    set_cfg.u._REGADDR = reg_addr;
    set_cfg.u._REGDATA[0] = HIBYTE(reg_data);
    set_cfg.u._REGDATA[1] = BYTE2(reg_data);
    set_cfg.u._REGDATA[2] = BYTE1(reg_data);
    set_cfg.u._REGDATA[3] = reg_data;
    v5 = CRC5((unsigned __int8 *)&set_cfg, 0x40u);
    set_cfg.v[8] = set_cfg.v[8] & 0xE0 | v5 & 0x1F;
    bc_cmd[0] = _byteswap_ulong(*(_DWORD *)&set_cfg.u);
    bc_cmd[1] = _byteswap_ulong(*(unsigned int *)&set_cfg.v[4]);
    bc_cmd[2] = set_cfg.v[8] << 24;
    set_BC_command_buffer(bc_cmd);
    value = (chain << 16) | get_BC_write_command() & 0xFFF0FFFF | 0x80800000;
    set_BC_write_command(value);
  }
  else if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(pFile, "%s:%d:%s: Chain %d not exist.\n", "chip1391.c", 42, (const char *)_FUNCTION___11489, chain);
    fclose(pFile);
  }
}

//----- (00077E88) --------------------------------------------------------
void __cdecl send_set_config_command_all_chain(uint8_t mode, uint8_t dev_addr, uint8_t reg_addr, uint32_t reg_data)
{
  int chain; // [sp+14h] [bp-8h]

  for ( chain = 0; chain <= 15; ++chain )
  {
    if ( dev->chain_exist[chain] )
      send_set_config_command(chain, mode, dev_addr, reg_addr, reg_data);
  }
}

//----- (00077F28) --------------------------------------------------------
void __cdecl chain_inactive(unsigned __int8 chain)
{
  unsigned int cmd_buf[3]; // [sp+20h] [bp-24h] BYREF
  unsigned __int8 buf[5]; // [sp+2Ch] [bp-18h] BYREF
  unsigned int value; // [sp+34h] [bp-10h]
  unsigned int ret; // [sp+38h] [bp-Ch]
  FILE *pFile; // [sp+3Ch] [bp-8h]

  buf[4] = 5;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  buf[0] = 83;
  buf[1] = 5;
  buf[2] = 0;
  buf[3] = 0;
  buf[4] = CRC5(buf, 0x20u);
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x\n",
        "chip1391.c",
        96,
        (const char *)_FUNCTION___11509,
        buf[0],
        buf[1],
        buf[2],
        buf[3],
        buf[4]);
    fclose(pFile);
  }
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = buf[4] << 24;
  while ( 1 )
  {
    ret = get_BC_write_command();
    if ( (ret & 0x80000000) == 0 )
      break;
    cgsleep_ms(1);
  }
  set_BC_command_buffer(cmd_buf);
  value = (chain << 16) | ret & 0xFFF0FFFF | 0x80800000;
  set_BC_write_command(value);
}

//----- (00078108) --------------------------------------------------------
void __cdecl set_address(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 address)
{
  unsigned int cmd_buf[3]; // [sp+8h] [bp-24h] BYREF
  unsigned __int8 buf[9]; // [sp+14h] [bp-18h] BYREF
  unsigned int value; // [sp+20h] [bp-Ch]
  unsigned int ret; // [sp+24h] [bp-8h]

  *(_DWORD *)buf = 1344;
  *(_DWORD *)&buf[4] = 0;
  buf[8] = 0;
  cmd_buf[2] = 0;
  buf[2] = address;
  buf[4] = CRC5(buf, 0x20u);
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = buf[4] << 24;
  while ( 1 )
  {
    ret = get_BC_write_command();
    if ( (ret & 0x80000000) == 0 )
      break;
    cgsleep_ms(1);
  }
  set_BC_command_buffer(cmd_buf);
  value = (chain << 16) | ret & 0xFFF0FFFF | 0x80800000;
  set_BC_write_command(value);
}

//----- (00078234) --------------------------------------------------------
void __cdecl set_asic_ticket_mask(unsigned int ticket_mask)
{
  int ticket_mask_bit_swap; // [sp+10h] [bp-Ch]
  unsigned int i; // [sp+14h] [bp-8h]

  ticket_mask_bit_swap = 0;
  for ( i = 0; i <= 3; ++i )
  {
    ticket_mask_bit_swap |= bit_swap_table[(unsigned __int8)ticket_mask] << (8 * i);
    ticket_mask >>= 8;
  }
  send_set_config_command_all_chain(1u, 0, 0x14u, ticket_mask_bit_swap);
}

//----- (000782D0) --------------------------------------------------------
void __cdecl set_baud_ext(int chain)
{
  send_set_config_command(chain, 1u, 0, 0x68u, 0xC0700111);
  send_set_config_command(chain, 1u, 0, 0x68u, 0xC0700111);
  send_set_config_command(chain, 1u, 0, 0x28u, 0x600000Fu);
}

//----- (00078388) --------------------------------------------------------
int __cdecl get_bt8d_chip_divider(int baud)
{
  int base_clk; // [sp+Ch] [bp-8h]

  base_clk = 25000000;
  if ( baud > (int)&nonce_num[1][124][55] )
    base_clk = 400000000;
  return base_clk / (8 * baud) - 1;
}

//----- (000783F0) --------------------------------------------------------
int __cdecl get_bt8d_fpga_divider(int baud)
{
  FILE *pFile; // [sp+10h] [bp-Ch]
  int divider; // [sp+14h] [bp-8h]

  divider = 26;
  if ( baud == 115200 )
    return 26;
  if ( (double)baud == 1500000.0 )
    return 1;
  if ( (uint64_t *)baud == &nonce_num[1][124][55] )
    return 0;
  if ( (int *)baud == &asic_core_nonce_num[2][101][208] )
    return 3;
  if ( (int *)baud == &asic_core_nonce_num[14][30][48] )
    return 4;
  if ( baud == 25000000 )
    return 5;
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: Error divider for fpage, baud = %d\n",
        "chip1391.c",
        248,
        (const char *)_FUNCTION___11559,
        baud);
    fclose(pFile);
  }
  return divider;
}

//----- (00078578) --------------------------------------------------------
void __cdecl set_baud_fpga(int baud)
{
  unsigned int fpga_bt8d; // [sp+1Ch] [bp-10h]
  FILE *pFile; // [sp+20h] [bp-Ch]
  int fpga_divider; // [sp+24h] [bp-8h]

  fpga_divider = get_bt8d_fpga_divider(baud);
  if ( log_level > 3 )
  {
    print_crt_time_to_file(log_file, 3u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: set fpga_baud = %d, fpga_divider = %d\n",
        "chip1391.c",
        260,
        (const char *)_FUNCTION___11566,
        baud,
        fpga_divider);
    fclose(pFile);
  }
  fpga_bt8d = get_bt8d_control();
  BYTE2(fpga_bt8d) = BYTE2(fpga_bt8d) & 0xC0 | fpga_divider & 0x3F;
  set_bt8d_control(fpga_bt8d);
}

//----- (00078668) --------------------------------------------------------
void __cdecl set_baud_one_chain(int baud, int change_fpga_baud, const unsigned __int8 chain)
{
  uint32_t misc_reg; // [sp+24h] [bp-10h]
  FILE *pFile; // [sp+28h] [bp-Ch]
  int chip_divider; // [sp+2Ch] [bp-8h]

  if ( dev->chain_exist[chain] )
  {
    chip_divider = get_bt8d_chip_divider(baud);
    misc_reg = gBM1391_MISC_CONTROL_reg;
    BYTE1(misc_reg) = BYTE1(gBM1391_MISC_CONTROL_reg) & 0xE0 | chip_divider & 0x1F;
    HIBYTE(misc_reg) = HIBYTE(gBM1391_MISC_CONTROL_reg) & 0xF0 | (chip_divider >> 5) & 0xF;
    if ( baud > (int)&nonce_num[1][124][55] )
    {
      set_baud_ext(chain);
      BYTE2(misc_reg) |= 1u;
    }
    gBM1391_MISC_CONTROL_reg = misc_reg;
    send_set_config_command(chain, 1u, 0, 0x18u, misc_reg);
    if ( change_fpga_baud )
    {
      cgsleep_us(50000LL);
      set_baud_fpga(baud);
      dev->baud = baud;
    }
    if ( log_level > 3 )
    {
      print_crt_time_to_file(log_file, 3u);
      pFile = fopen((const char *)log_file, "a+");
      if ( pFile )
        fprintf(
          pFile,
          "%s:%d:%s: chain[%d]: chip baud = %d, chip_divider = %d\n",
          "chip1391.c",
          303,
          (const char *)_FUNCTION___11575,
          chain,
          baud,
          chip_divider);
      fclose(pFile);
    }
  }
}

//----- (0007883C) --------------------------------------------------------
void __cdecl enable_core_clock_BM1391(unsigned int core_id, unsigned __int8 mode, unsigned __int8 chain)
{
  __int16 core_ida; // [sp+Ch] [bp-10h]
  core_command_t core_cmd; // [sp+14h] [bp-8h] BYREF

  core_ida = core_id;
  memset(&core_cmd, 0, sizeof(core_cmd));
  core_cmd.v[0] = -86;
  core_cmd.v[1] = core_cmd.v[1] & 0xF0 | 4;
  core_cmd.v[1] &= ~0x40u;
  core_cmd.v[1] |= 0x80u;
  *(_WORD *)&core_cmd.v[2] = *(_WORD *)&core_cmd.v[2] & 0xFE00 | core_ida & 0x1FF;
  core_cmd.v[3] &= ~0x80u;
  send_set_config_command(chain, mode, 0, 0x3Cu, core_cmd.v_32);
}

//----- (000788EC) --------------------------------------------------------
void __cdecl set_core_cmd_BM1391(core_cmd *core)
{
  core_command_t core_cmd; // [sp+14h] [bp-8h] BYREF

  memset(&core_cmd, 0, sizeof(core_cmd));
  core_cmd.v[0] = core->reg_data;
  core_cmd.v[1] = core_cmd.v[1] & 0xF0 | core->cmd_type & 0xF;
  core_cmd.v[1] &= ~0x40u;
  core_cmd.v[1] = core_cmd.v[1] & 0x7F | ((core->rw_falg & 1) << 7);
  *(_WORD *)&core_cmd.v[2] = *(_WORD *)&core_cmd.v[2] & 0xFE00 | core->core_id & 0x1FF;
  core_cmd.v[3] = core_cmd.v[3] & 0x7F | ((core->mode != 0) << 7);
  send_set_config_command(core->chain, core->mode, core->chip_addr, 0x3Cu, core_cmd.v_32);
}

//----- (000789DC) --------------------------------------------------------
void __cdecl set_config_BM1391_t(
        unsigned __int8 which_chain,
        unsigned __int8 chip_addr,
        unsigned __int8 mode,
        unsigned __int8 reg,
        unsigned int reg_data)
{
  send_set_config_command(which_chain, mode, chip_addr, reg, reg_data);
}

//----- (00078A44) --------------------------------------------------------
void __cdecl read_asic_register(
        unsigned __int8 chain,
        unsigned __int8 mode,
        unsigned __int8 chip_addr,
        unsigned __int8 reg_addr)
{
  int hash_on_plug; // r0
  unsigned int cmd_buf[3]; // [sp+20h] [bp-2Ch] BYREF
  unsigned __int8 buf[5]; // [sp+2Ch] [bp-20h] BYREF
  unsigned int value; // [sp+34h] [bp-18h]
  FILE *pFile_0; // [sp+38h] [bp-14h]
  unsigned int ret; // [sp+3Ch] [bp-10h]
  FILE *pFile; // [sp+40h] [bp-Ch]
  int wait_count; // [sp+44h] [bp-8h]

  *(_DWORD *)buf = 66;
  buf[4] = 0;
  memset(cmd_buf, 0, sizeof(cmd_buf));
  wait_count = 0;
  if ( mode )
    buf[0] |= 0x10u;
  buf[1] = 5;
  buf[2] = chip_addr;
  buf[3] = reg_addr;
  buf[4] = CRC5(buf, 0x20u);
  if ( log_level > 4 )
  {
    print_crt_time_to_file(log_file, 4u);
    pFile = fopen((const char *)log_file, "a+");
    if ( pFile )
      fprintf(
        pFile,
        "%s:%d:%s: VIL buf[0]=0x%x, buf[1]=0x%x, buf[2]=0x%x, buf[3]=0x%x, buf[4]=0x%x\n",
        "chip1391.c",
        378,
        (const char *)_FUNCTION___11619,
        buf[0],
        buf[1],
        buf[2],
        buf[3],
        buf[4]);
    fclose(pFile);
  }
  cmd_buf[0] = _byteswap_ulong(*(unsigned int *)buf);
  cmd_buf[1] = buf[4] << 24;
  while ( 1 )
  {
    ret = get_BC_write_command();
    if ( (ret & 0x80000000) == 0 )
      break;
    cgsleep_ms(1);
    if ( ++wait_count > 3000 )
    {
      if ( log_level > 3 )
      {
        print_crt_time_to_file(log_file, 3u);
        pFile_0 = fopen((const char *)log_file, "a+");
        if ( pFile_0 )
        {
          hash_on_plug = get_hash_on_plug();
          fprintf(
            pFile_0,
            "%s:%d:%s: Error: clement debug: wait BC ready timeout, PLUG ON=0x%08x..\n",
            "chip1391.c",
            396,
            (const char *)_FUNCTION___11619,
            hash_on_plug);
        }
        fclose(pFile_0);
      }
      break;
    }
  }
  set_BC_command_buffer(cmd_buf);
  value = (chain << 16) | get_BC_write_command() & 0xFFF0FFFF | 0x80800000;
  set_BC_write_command(value);
}

//----- (00078D1C) --------------------------------------------------------
void __cdecl read_temp(
        unsigned __int8 device,
        unsigned int reg,
        unsigned __int8 data,
        unsigned __int8 write,
        unsigned __int8 chip_addr,
        int chain)
{
  char rega; // [sp+8h] [bp-14h]
  general_i2c_command_t i2c_cmd; // [sp+14h] [bp-8h] BYREF

  rega = reg;
  memset(&i2c_cmd, 0, sizeof(i2c_cmd));
  *(_BYTE *)&i2c_cmd.u = data;
  *((_BYTE *)&i2c_cmd.u + 1) = rega;
  BYTE2(i2c_cmd.v) = BYTE2(i2c_cmd.v) & 0xFE | write & 1;
  BYTE2(i2c_cmd.v) = BYTE2(i2c_cmd.v) & 1 | (2 * (device >> 1));
  HIBYTE(i2c_cmd.v) = HIBYTE(i2c_cmd.v) & 0x38 | 1;
  send_set_config_command(chain, 0, chip_addr, 0x1Cu, i2c_cmd.v);
}

//----- (00078E10) --------------------------------------------------------
void __cdecl set_misc_control(unsigned __int8 chain, unsigned __int8 mode, unsigned __int8 addr, int i2c)
{
  misc_ctrl_t misc_reg; // [sp+14h] [bp-8h]

  if ( i2c )
  {
    HIWORD(misc_reg.v) = HIWORD(gBM1391_MISC_CONTROL_reg);
    *((_BYTE *)&misc_reg.u + 1) = BYTE1(gBM1391_MISC_CONTROL_reg) | 0x40;
    *(_BYTE *)&misc_reg.u = gBM1391_MISC_CONTROL_reg & 0x8F | 0x30;
    gBM1391_MISC_CONTROL_reg = misc_reg.v;
  }
  send_set_config_command(chain, mode, addr, 0x18u, gBM1391_MISC_CONTROL_reg);
}

//----- (00078EB0) --------------------------------------------------------
void __cdecl mutex_lock_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00078F4C) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00078FE8) --------------------------------------------------------
void __cdecl mutex_unlock_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_2(lock, file, func, line);
  selective_yield();
}

//----- (00079034) --------------------------------------------------------
int __cdecl mutex_trylock_0(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  return pthread_mutex_trylock(lock);
}

//----- (0007906C) --------------------------------------------------------
void __cdecl my_log_curses(int prio, const unsigned __int8 *datetime, const unsigned __int8 *str, bool force)
{
  if ( !opt_quiet || prio == 3 )
  {
    if ( force )
    {
      mutex_trylock_0(&console_lock, "logging.c", _func___10962, 40);
      mutex_unlock_2(&console_lock, "logging.c", _func___10962, 41);
    }
    mutex_lock_2(&console_lock, "logging.c", _func___10962, 52);
    printf("%s%s%s", (const char *)datetime, (const char *)str, "                    \n");
    mutex_unlock_2(&console_lock, "logging.c", _func___10962, 54);
  }
}

//----- (00079160) --------------------------------------------------------
void __cdecl applog(int prio, const unsigned __int8 *str, bool force)
{
  int v3; // r0
  size_t v4; // r0
  size_t v5; // r0
  unsigned __int8 datetime[64]; // [sp+2Ch] [bp-60h] BYREF
  time_t tmp_time; // [sp+6Ch] [bp-20h] BYREF
  timeval tv; // [sp+70h] [bp-1Ch] BYREF
  tm *tm; // [sp+78h] [bp-14h]
  int ms; // [sp+7Ch] [bp-10h]

  if ( use_syslog )
  {
    syslog(prio | 0x80, (const char *)&off_ACB98, str);
  }
  else
  {
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    cgtime(&tv);
    tmp_time = tv.tv_sec;
    ms = tv.tv_usec / 1000;
    tm = localtime(&tmp_time);
    snprintf(
      (char *)datetime,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      tm->tm_year + 1900,
      tm->tm_mon + 1,
      tm->tm_mday,
      tm->tm_hour,
      tm->tm_min,
      tm->tm_sec,
      ms);
    v3 = fileno((FILE *)stderr);
    if ( !isatty(v3) )
    {
      fprintf((FILE *)stderr, "%s%s\n", (const char *)datetime, (const char *)str);
      fflush((FILE *)stderr);
    }
    if ( g_logfile_enable )
    {
      if ( !g_log_file )
        g_log_file = fopen((const char *)g_logfile_path, (const char *)g_logfile_openflag);
      if ( g_log_file )
      {
        v4 = strlen((const char *)datetime);
        fwrite(datetime, v4, 1u, g_log_file);
        v5 = strlen((const char *)str);
        fwrite(str, v5, 1u, g_log_file);
        fwrite("\n", 1u, 1u, g_log_file);
        fflush(g_log_file);
      }
    }
    my_log_curses(prio, datetime, str, force);
  }
}
// ACB98: using guessed type void *off_ACB98;
// C4478: using guessed type int stderr;

//----- (000793D4) --------------------------------------------------------
void *__cdecl statusServiceThread(void *param)
{
  int ideal_hash_rate_fixed; // r0
  int v3; // r0
  int ideal_hash_rate; // r0
  int v5; // r0
  int ideal_hash_rate_max; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  size_t v15; // r0
  unsigned __int8 tmp42[2048]; // [sp+10h] [bp-685Ch] BYREF
  unsigned __int8 endofrequest[5]; // [sp+810h] [bp-605Ch] BYREF
  int test_value; // [sp+818h] [bp-6054h] BYREF
  int testID; // [sp+81Ch] [bp-6050h] BYREF
  unsigned __int8 sendbuf[3]; // [sp+820h] [bp-604Ch] BYREF
  int recvlen; // [sp+824h] [bp-6048h] BYREF
  unsigned __int8 strSendbuf[10240]; // [sp+828h] [bp-6044h] BYREF
  unsigned __int8 buf[4096]; // [sp+3028h] [bp-3844h] BYREF
  sockaddr_in from; // [sp+4028h] [bp-2844h] BYREF
  unsigned __int8 recvbuf[10240]; // [sp+4038h] [bp-2834h] BYREF
  timeval timeout; // [sp+6838h] [bp-34h] BYREF
  int bError; // [sp+6840h] [bp-2Ch]
  int len; // [sp+6844h] [bp-28h]
  int ret; // [sp+6848h] [bp-24h]
  int s1; // [sp+684Ch] [bp-20h]
  int res_mode; // [sp+6850h] [bp-1Ch]
  int sentlen; // [sp+6854h] [bp-18h]
  int buflen; // [sp+6858h] [bp-14h]
  unsigned __int8 *precvbuf; // [sp+685Ch] [bp-10h]

  s1 = (int)param;
  timeout.tv_sec = 3;
  timeout.tv_usec = 0;
  precvbuf = recvbuf;
  ret = -1;
  len = 0;
  bError = 0;
  buflen = 0;
  recvlen = 0;
  sentlen = 0;
  strcpy((char *)sendbuf, "\r\n");
  testID = -1;
  test_value = -1;
  res_mode = 0;
  strcpy((char *)endofrequest, "\r\n\r\n");
  memset(recvbuf, 0, sizeof(recvbuf));
  while ( !ExitServer )
  {
    ret = recvfrom(s1, precvbuf, 10239 - buflen, 0, (struct sockaddr *)&from, (socklen_t *)&recvlen);
    if ( ret <= 0 )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, ":statusServiceThread recvfrom<=0");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    buflen = ret;
    if ( ret == 10239 )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "BUFSIZE is too small!");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    precvbuf = &recvbuf[buflen];
    if ( strstr((const char *)recvbuf, (const char *)endofrequest) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "find http request end flag!");
        applog(7, tmp42, 0);
      }
      break;
    }
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)tmp42, 0x800u, "get http=%s", (const char *)recvbuf);
    applog(7, tmp42, 0);
  }
  if ( recvbuf[0] != 71 || recvbuf[1] != 69 || recvbuf[2] != 84 || recvbuf[3] != 32 )
  {
    close(s1);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "statusServiceThread not support http command");
      applog(7, tmp42, 0);
    }
    return 0;
  }
  if ( strstr((const char *)&recvbuf[4], "/rate") )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "cmd : get rate");
      applog(7, tmp42, 0);
    }
    res_mode = 0;
  }
  else if ( strstr((const char *)&recvbuf[4], "/test") )
  {
    _isoc99_sscanf(&recvbuf[4], "/test.%d.%d", &testID, &test_value);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "cmd : get test = %d", testID);
      applog(7, tmp42, 0);
    }
    res_mode = 1;
  }
  else if ( strstr((const char *)&recvbuf[4], "/ideal_rate") )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "cmd : get ideal rate");
      applog(7, tmp42, 0);
    }
    res_mode = 2;
  }
  else
  {
    if ( !strstr((const char *)&recvbuf[4], "/max_rate") )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "statusServiceThread exit for Error cmd!");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "cmd : get max rate");
      applog(7, tmp42, 0);
    }
    res_mode = 3;
  }
  ret = setsockopt(s1, 1, 21, &timeout, 8u);
  if ( ret )
  {
    close(s1);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)tmp42, "setsockopt SO_SNDTIMEO failed");
      applog(7, tmp42, 0);
    }
    return 0;
  }
  else
  {
    ret = setsockopt(s1, 1, 20, &timeout, 8u);
    if ( ret )
    {
      close(s1);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "setsockopt SO_RCVTIMEO failed");
        applog(7, tmp42, 0);
      }
      return 0;
    }
    else
    {
      if ( res_mode == 1 )
      {
        if ( testID == 523 )
          get_miner_info(buf);
        else
          sprintf((char *)buf, "OK get test=%d", testID);
      }
      if ( !res_mode )
      {
        if ( freq_scan_status == 1 )
        {
          ideal_hash_rate_fixed = get_ideal_hash_rate_fixed();
          v3 = convirt_total_rate(ideal_hash_rate_fixed);
          sprintf((char *)buf, "%d", v3);
        }
        else if ( freq_scan_status == 2 )
        {
          sprintf((char *)buf, "searchfailed:%s", (const char *)search_failed_info);
        }
        else
        {
          strcpy((char *)buf, "searching");
        }
      }
      if ( res_mode == 2 )
      {
        if ( freq_scan_status == 1 )
        {
          ideal_hash_rate = get_ideal_hash_rate();
          v5 = convirt_total_rate(ideal_hash_rate);
          sprintf((char *)buf, "%d", v5);
        }
        else if ( freq_scan_status == 2 )
        {
          sprintf((char *)buf, "searchfailed:%s", (const char *)search_failed_info);
        }
        else
        {
          strcpy((char *)buf, "searching");
        }
      }
      if ( res_mode == 3 )
      {
        if ( freq_scan_status == 1 )
        {
          ideal_hash_rate_max = get_ideal_hash_rate_max();
          v7 = convirt_total_rate(ideal_hash_rate_max);
          sprintf((char *)buf, "%d", v7);
        }
        else if ( freq_scan_status == 2 )
        {
          sprintf((char *)buf, "searchfailed:%s", (const char *)search_failed_info);
        }
        else
        {
          strcpy((char *)buf, "searching");
        }
      }
      len = strlen((const char *)buf);
      ret = 0;
      v8 = sprintf((char *)strSendbuf, "HTTP/1.0  200  OK%s", (const char *)sendbuf);
      ret += v8;
      v9 = sprintf((char *)&strSendbuf[ret], "Server: SearchFreqServer%s", (const char *)sendbuf);
      ret += v9;
      v10 = sprintf((char *)&strSendbuf[ret], "Cache-Control: no-cache%s", (const char *)sendbuf);
      ret += v10;
      v11 = sprintf((char *)&strSendbuf[ret], "Pragma: no-cache%s", (const char *)sendbuf);
      ret += v11;
      v12 = sprintf((char *)&strSendbuf[ret], "Content-Type: text/plain%s", (const char *)sendbuf);
      ret += v12;
      v13 = sprintf((char *)&strSendbuf[ret], "Content-Length: %d%s", len, (const char *)sendbuf);
      ret += v13;
      v14 = sprintf((char *)&strSendbuf[ret], "Connection: Keep-Alive%s", (const char *)endofrequest);
      ret += v14;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "send http response...\n");
        applog(7, tmp42, 0);
      }
      while ( !ExitServer )
      {
        sentlen = 0;
        do
        {
          v15 = strlen((const char *)strSendbuf);
          ret = send(s1, &strSendbuf[sentlen], v15 - sentlen, 0);
          if ( ret == -1 && *_errno_location() == 11 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy((char *)tmp42, "statusServiceThread send http timeout, try again...");
              applog(7, tmp42, 0);
            }
            usleep(0x186A0u);
          }
          else
          {
            if ( ret <= 0 )
            {
              close(s1);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                strcpy((char *)tmp42, "statusServiceThread send http response error");
                applog(7, tmp42, 0);
              }
              return 0;
            }
            sentlen += ret;
          }
        }
        while ( strlen((const char *)strSendbuf) > sentlen && !ExitServer );
        if ( strlen((const char *)strSendbuf) <= sentlen || ExitServer )
          break;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "send http data...");
        applog(7, tmp42, 0);
      }
      sentlen = 0;
      while ( 1 )
      {
        ret = send(s1, &buf[sentlen], len - sentlen, 0);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "send http data ret=%d", ret);
          applog(7, tmp42, 0);
        }
        if ( ret <= 0 )
          break;
        sentlen += ret;
        if ( sentlen >= len || bError || ExitServer )
          goto LABEL_155;
      }
      bError = 1;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "statusServiceThread send http data error");
        applog(7, tmp42, 0);
      }
LABEL_155:
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)tmp42, "one client disconnected!");
        applog(7, tmp42, 0);
      }
      close(s1);
      return (void *)sentlen;
    }
  }
}
// 123FC: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0007AAE4) --------------------------------------------------------
void *__cdecl httpListenThread(void *param)
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-830h] BYREF
  int addr_len; // [sp+80Ch] [bp-30h] BYREF
  sockaddr_in client_addr; // [sp+810h] [bp-2Ch] BYREF
  sockaddr_in service; // [sp+820h] [bp-1Ch] BYREF
  int ret; // [sp+830h] [bp-Ch]
  int AcceptSocket; // [sp+834h] [bp-8h]

  ret = 0;
  AcceptSocket = -1;
  sleep(0x1Eu);
  do
  {
    listen_sockfd = socket(2, 1, 6);
    if ( listen_sockfd >= 0 )
    {
      memset(&service, 0, sizeof(service));
      service.sin_family = 2;
      service.sin_addr.s_addr = htonl(0);
      service.sin_port = htons(0x17ACu);
      if ( bind(listen_sockfd, (const struct sockaddr *)&service, 0x10u) >= 0 )
      {
        if ( listen(listen_sockfd, 100) >= 0 )
          break;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy((char *)tmp42, "http listen failed! try again after 10s...");
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "http port bind failed! try again after 10s...");
        applog(5, tmp42, 0);
      }
      close(listen_sockfd);
      listen_sockfd = -1;
      sleep(0xAu);
    }
    else
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "socket creating failed, try again after 10s...");
        applog(5, tmp42, 0);
      }
      sleep(0xAu);
    }
  }
  while ( !ExitServer );
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "start listen on 6060 ...");
    applog(5, tmp42, 0);
  }
  while ( !ExitServer )
  {
    for ( AcceptSocket = -1;
          AcceptSocket == -1 && !ExitServer;
          AcceptSocket = accept(listen_sockfd, (struct sockaddr *)&client_addr, (socklen_t *)&addr_len) )
    {
      usleep(0x2710u);
      addr_len = 16;
    }
    if ( ExitServer )
    {
      if ( AcceptSocket != -1 )
      {
        close(AcceptSocket);
        AcceptSocket = -1;
      }
      break;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "one client connected sock=%d", AcceptSocket);
      applog(7, tmp42, 0);
    }
    statusServiceThread((void *)AcceptSocket);
  }
  close(listen_sockfd);
  listen_sockfd = -1;
  return (void *)ret;
}

//----- (0007B038) --------------------------------------------------------
void start_http_thread()
{
  unsigned __int8 tmp42[2048]; // [sp+0h] [bp-834h] BYREF
  pthread_attr_t_0 tattr_ctrl; // [sp+800h] [bp-34h] BYREF
  pthread_t tid_ctrl; // [sp+824h] [bp-10h] BYREF
  int stacksize_ctrl; // [sp+828h] [bp-Ch]
  int ret; // [sp+82Ch] [bp-8h]

  ret = pthread_attr_init(&tattr_ctrl);
  stacksize_ctrl = 0x200000;
  ret = pthread_attr_setstacksize(&tattr_ctrl, 0x200000u);
  ret = pthread_create(&tid_ctrl, &tattr_ctrl, (void *(*)(void *))httpListenThread, 0);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf((char *)tmp42, 0x800u, "httpListenThread start ret=%d", ret);
    applog(5, tmp42, 0);
  }
}

//----- (0007B10C) --------------------------------------------------------
void __cdecl json_decref_1(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (0007B170) --------------------------------------------------------
int sock_blocks_0()
{
  return *_errno_location() == 11 || *_errno_location() == 11;
}

//----- (0007B1BC) --------------------------------------------------------
void __cdecl mutex_lock_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_lock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0007B258) --------------------------------------------------------
void __cdecl mutex_unlock_noyield_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0007B2F4) --------------------------------------------------------
void __cdecl mutex_unlock_3(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  mutex_unlock_noyield_3(lock, file, func, line);
  selective_yield();
}

//----- (0007B340) --------------------------------------------------------
void __cdecl wr_lock_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_wrlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0007B3DC) --------------------------------------------------------
void __cdecl rd_lock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0007B478) --------------------------------------------------------
void __cdecl rw_unlock_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_rwlock_unlock(lock) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0007B514) --------------------------------------------------------
void __cdecl wr_unlock_noyield_2(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_2(lock, file, func, line);
}

//----- (0007B550) --------------------------------------------------------
void __cdecl rd_unlock_1(
        pthread_rwlock_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  rw_unlock_2(lock, file, func, line);
  selective_yield();
}

//----- (0007B59C) --------------------------------------------------------
void __cdecl mutex_init_2(
        pthread_mutex_t *lock,
        const unsigned __int8 *file,
        const unsigned __int8 *func,
        const int line)
{
  int *v4; // r0
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-804h] BYREF

  if ( pthread_mutex_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      (const char *)file,
      (const char *)func,
      line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0007B63C) --------------------------------------------------------
void __cdecl cg_rlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_3(&lock->mutex, file, func, line);
  rd_lock_1(&lock->rwlock, file, func, line);
  mutex_unlock_noyield_3(&lock->mutex, file, func, line);
}

//----- (0007B6A4) --------------------------------------------------------
void __cdecl cg_wlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  mutex_lock_3(&lock->mutex, file, func, line);
  wr_lock_2(&lock->rwlock, file, func, line);
}

//----- (0007B6F8) --------------------------------------------------------
void __cdecl cg_runlock_1(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  rd_unlock_1(&lock->rwlock, file, func, line);
}

//----- (0007B738) --------------------------------------------------------
void __cdecl cg_wunlock_2(cglock_t *lock, const unsigned __int8 *file, const unsigned __int8 *func, const int line)
{
  wr_unlock_noyield_2(&lock->rwlock, file, func, line);
  mutex_unlock_3(&lock->mutex, file, func, line);
}

//----- (0007B78C) --------------------------------------------------------
void __cdecl io_reinit(io_data *io_data)
{
  io_data->cur = io_data->ptr;
  *io_data->ptr = 0;
  io_data->close = 0;
}

//----- (0007B7D8) --------------------------------------------------------
io_data *__cdecl io_new(size_t initial, bool socket_buf)
{
  io_list *io_list; // [sp+8h] [bp-Ch]
  io_data *io_data; // [sp+Ch] [bp-8h]

  io_data = (io_data *)cgmalloc(0x10u, "api-btm.c", _func___11256, 723);
  io_data->ptr = (unsigned __int8 *)cgmalloc(initial, "api-btm.c", _func___11256, 724);
  io_data->siz = initial;
  io_data->sock = socket_buf;
  io_reinit(io_data);
  io_list = (io_list *)cgmalloc(0xCu, "api-btm.c", _func___11256, 729);
  io_list->io_data = io_data;
  if ( io_head )
  {
    io_list->next = io_head;
    io_list->prev = io_head->prev;
    io_list->next->prev = io_list;
    io_list->prev->next = io_list;
  }
  else
  {
    io_list->prev = io_list;
    io_list->next = io_list;
    io_head = io_list;
  }
  return io_data;
}

//----- (0007B920) --------------------------------------------------------
bool __cdecl io_add(io_data *io_data, unsigned __int8 *buf)
{
  unsigned int tot; // [sp+10h] [bp-14h]
  size_t dif; // [sp+14h] [bp-10h]
  size_t len; // [sp+18h] [bp-Ch]
  unsigned int newa; // [sp+1Ch] [bp-8h]

  len = strlen((const char *)buf);
  dif = io_data->cur - io_data->ptr;
  tot = len + dif + 12;
  if ( tot > io_data->siz )
  {
    newa = io_data->siz + 0x20000;
    if ( newa < tot )
      newa = ((unsigned int)(float)((float)tot / 65536.0) + 2) << 16;
    io_data->ptr = (unsigned __int8 *)cgrealloc(io_data->ptr, newa, "api-btm.c", _func___11265, 766);
    io_data->cur = &io_data->ptr[dif];
    io_data->siz = newa;
  }
  memcpy(io_data->cur, buf, len + 1);
  io_data->cur += len;
  return 1;
}

//----- (0007BA6C) --------------------------------------------------------
bool __cdecl io_put(io_data *io_data, unsigned __int8 *buf)
{
  io_reinit(io_data);
  return io_add(io_data, buf);
}

//----- (0007BAA4) --------------------------------------------------------
void __cdecl io_close(io_data *io_data)
{
  io_data->close = 1;
}

//----- (0007BAD0) --------------------------------------------------------
void io_free()
{
  io_list *io_next; // [sp+0h] [bp-Ch]
  io_list *io_list; // [sp+4h] [bp-8h]

  if ( io_head )
  {
    io_list = io_head;
    do
    {
      io_next = io_list->next;
      free(io_list->io_data->ptr);
      free(io_list->io_data);
      free(io_list);
      io_list = io_next;
    }
    while ( io_next != io_head );
    io_head = 0;
  }
}

//----- (0007BB74) --------------------------------------------------------
unsigned __int8 *__cdecl escape_string(unsigned __int8 *str, bool isjson)
{
  int v2; // r3
  size_t v4; // r0
  int v5; // r3
  unsigned __int8 *v6; // r3
  unsigned __int8 *v7; // r2
  unsigned __int8 *v8; // r3
  unsigned __int8 *v9; // r3
  unsigned __int8 *v10; // r2
  unsigned __int8 *v11; // r3
  unsigned __int8 *v12; // r2
  unsigned __int8 *v13; // r3
  unsigned __int8 *v14; // r2
  unsigned __int8 *v15; // r3
  unsigned __int8 *stra; // [sp+4h] [bp-18h]
  unsigned __int8 *buf; // [sp+Ch] [bp-10h]
  int count; // [sp+10h] [bp-Ch]
  unsigned __int8 *ptr; // [sp+14h] [bp-8h]
  unsigned __int8 *ptra; // [sp+14h] [bp-8h]

  stra = str;
  count = 0;
  for ( ptr = str; *ptr; ++ptr )
  {
    v2 = *ptr;
    if ( v2 == 61 )
      goto LABEL_9;
    if ( *ptr > 0x3Du )
    {
      if ( v2 == 92 )
      {
        ++count;
        continue;
      }
      if ( v2 != 124 )
        continue;
LABEL_9:
      if ( !isjson )
        ++count;
      continue;
    }
    if ( v2 != 34 )
    {
      if ( v2 != 44 )
        continue;
      goto LABEL_9;
    }
    if ( isjson )
      ++count;
  }
  if ( count )
  {
    v4 = strlen((const char *)str);
    buf = (unsigned __int8 *)cgmalloc(v4 + count + 1, "api-btm.c", _func___11295, 842);
    ptra = buf;
    while ( 1 )
    {
      if ( !*stra )
      {
        *ptra = 0;
        return buf;
      }
      v5 = *stra;
      if ( v5 == 61 )
        goto LABEL_26;
      if ( *stra > 0x3Du )
      {
        if ( v5 == 92 )
        {
          *ptra = 92;
          v12 = stra++;
          v13 = ptra + 1;
          ptra += 2;
          *v13 = *v12;
        }
        else
        {
          if ( v5 != 124 )
            goto LABEL_33;
LABEL_26:
          if ( !isjson )
          {
            v6 = ptra++;
            *v6 = 92;
          }
          v7 = stra++;
          v8 = ptra++;
          *v8 = *v7;
        }
      }
      else if ( v5 == 34 )
      {
        if ( isjson )
        {
          v9 = ptra++;
          *v9 = 92;
        }
        v10 = stra++;
        v11 = ptra++;
        *v11 = *v10;
      }
      else
      {
        if ( v5 == 44 )
          goto LABEL_26;
LABEL_33:
        v14 = stra++;
        v15 = ptra++;
        *v15 = *v14;
      }
    }
  }
  return str;
}

//----- (0007BDFC) --------------------------------------------------------
api_data *__cdecl api_add_extra(api_data *root, api_data *extra)
{
  api_data *roota; // [sp+4h] [bp-10h]
  api_data *tmp; // [sp+Ch] [bp-8h]

  roota = root;
  if ( !root )
    return extra;
  if ( extra )
  {
    tmp = extra->prev;
    extra->prev = root->prev;
    root->prev->next = extra;
    tmp->next = root;
    root->prev = tmp;
  }
  return roota;
}

//----- (0007BE8C) --------------------------------------------------------
api_data *__cdecl api_add_data_full(
        api_data *root,
        unsigned __int8 *name,
        api_data_type type,
        void *data,
        bool copy_data)
{
  size_t v5; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-808h] BYREF
  api_data *api_data; // [sp+814h] [bp-8h]

  api_data = (api_data *)cgmalloc(0x18u, "api-btm.c", _func___11319, 908);
  api_data->name = (unsigned __int8 *)strdup((const char *)name);
  api_data->type = type;
  if ( root )
  {
    api_data->prev = root->prev;
    root->prev = api_data;
    api_data->next = root;
    api_data->prev->next = api_data;
  }
  else
  {
    root = api_data;
    api_data->prev = api_data;
    root->next = root;
  }
  api_data->data_was_malloc = copy_data;
  if ( !data )
  {
    type = API_CONST;
    api_data->type = API_CONST;
    data = (void *)NULLSTR;
    copy_data = 0;
    api_data->data_was_malloc = 0;
  }
  if ( !copy_data )
  {
    api_data->data = data;
  }
  else
  {
    switch ( type )
    {
      case API_ESCAPE:
      case API_STRING:
      case API_CONST:
        v5 = strlen((const char *)data);
        api_data->data = cgmalloc(v5 + 1, "api-btm.c", _func___11319, 945);
        strcpy((char *)api_data->data, (const char *)data);
        break;
      case API_UINT8:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 950);
        *(_BYTE *)api_data->data = *(_BYTE *)data;
        break;
      case API_INT16:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 955);
        *(_WORD *)api_data->data = *(_WORD *)data;
        break;
      case API_UINT16:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 960);
        *(_WORD *)api_data->data = *(_WORD *)data;
        break;
      case API_INT:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 964);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 968);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT32:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 972);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_HEX32:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 976);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_UINT64:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11319, 980);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_INT64:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11319, 984);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_DOUBLE:
      case API_ELAPSED:
      case API_MHS:
      case API_MHTOTAL:
      case API_UTILITY:
      case API_FREQ:
      case API_HS:
      case API_DIFF:
      case API_PERCENT:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11319, 996);
        *(_QWORD *)api_data->data = *(_QWORD *)data;
        break;
      case API_BOOL:
        api_data->data = cgmalloc(1u, "api-btm.c", _func___11319, 1000);
        *(_BYTE *)api_data->data = *(_BYTE *)data;
        break;
      case API_TIMEVAL:
        api_data->data = cgmalloc(8u, "api-btm.c", _func___11319, 1004);
        memcpy(api_data->data, data, 8u);
        break;
      case API_TIME:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 1008);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      case API_TEMP:
      case API_VOLTS:
      case API_AVG:
        api_data->data = cgmalloc(4u, "api-btm.c", _func___11319, 1014);
        *(_DWORD *)api_data->data = *(_DWORD *)data;
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: unknown1 data type %d ignored", type);
          applog(3, tmp42, 0);
        }
        api_data->type = API_STRING;
        api_data->data_was_malloc = 0;
        api_data->data = (void *)UNKNOWN;
        break;
    }
  }
  return root;
}
// 7BFD8: control flows out of bounds to 7BFDC

//----- (0007C4D0) --------------------------------------------------------
api_data *__cdecl api_add_escape(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ESCAPE, data, copy_data);
}

//----- (0007C518) --------------------------------------------------------
api_data *__cdecl api_add_string(api_data *root, unsigned __int8 *name, unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_STRING, data, copy_data);
}

//----- (0007C560) --------------------------------------------------------
api_data *__cdecl api_add_const(api_data *root, unsigned __int8 *name, const unsigned __int8 *data, bool copy_data)
{
  return api_add_data_full(root, name, API_CONST, (void *)data, copy_data);
}

//----- (0007C5A8) --------------------------------------------------------
api_data *__cdecl api_add_uint8(api_data *root, unsigned __int8 *name, uint8_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT8, data, copy_data);
}

//----- (0007C5F0) --------------------------------------------------------
api_data *__cdecl api_add_int16(api_data *root, unsigned __int8 *name, uint16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT16, data, copy_data);
}

//----- (0007C638) --------------------------------------------------------
api_data *__cdecl api_add_int(api_data *root, unsigned __int8 *name, int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT, data, copy_data);
}

//----- (0007C680) --------------------------------------------------------
api_data *__cdecl api_add_uint(api_data *root, unsigned __int8 *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT, data, copy_data);
}

//----- (0007C6C8) --------------------------------------------------------
api_data *__cdecl api_add_uint32(api_data *root, unsigned __int8 *name, uint32_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT32, data, copy_data);
}

//----- (0007C710) --------------------------------------------------------
api_data *__cdecl api_add_uint64(api_data *root, unsigned __int8 *name, uint64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UINT64, data, copy_data);
}

//----- (0007C758) --------------------------------------------------------
api_data *__cdecl api_add_int64(api_data *root, unsigned __int8 *name, int64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_INT64, data, copy_data);
}

//----- (0007C7A0) --------------------------------------------------------
api_data *__cdecl api_add_elapsed(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_ELAPSED, data, copy_data);
}

//----- (0007C7E8) --------------------------------------------------------
api_data *__cdecl api_add_bool(api_data *root, unsigned __int8 *name, bool *data, bool copy_data)
{
  return api_add_data_full(root, name, API_BOOL, data, copy_data);
}

//----- (0007C830) --------------------------------------------------------
api_data *__cdecl api_add_timeval(api_data *root, unsigned __int8 *name, timeval *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIMEVAL, data, copy_data);
}

//----- (0007C878) --------------------------------------------------------
api_data *__cdecl api_add_time(api_data *root, unsigned __int8 *name, time_t *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TIME, data, copy_data);
}

//----- (0007C8C0) --------------------------------------------------------
api_data *__cdecl api_add_mhs(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHS, data, copy_data);
}

//----- (0007C908) --------------------------------------------------------
api_data *__cdecl api_add_mhtotal(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_MHTOTAL, data, copy_data);
}

//----- (0007C950) --------------------------------------------------------
api_data *__cdecl api_add_temp(api_data *root, unsigned __int8 *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, API_TEMP, data, copy_data);
}

//----- (0007C998) --------------------------------------------------------
api_data *__cdecl api_add_utility(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_UTILITY, data, copy_data);
}

//----- (0007C9E0) --------------------------------------------------------
api_data *__cdecl api_add_diff(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_DIFF, data, copy_data);
}

//----- (0007CA28) --------------------------------------------------------
api_data *__cdecl api_add_percent(api_data *root, unsigned __int8 *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, API_PERCENT, data, copy_data);
}

//----- (0007CA70) --------------------------------------------------------
void __cdecl add_item_buf(K_ITEM *item, const unsigned __int8 *str)
{
  size_t old_siz; // [sp+1Ch] [bp-10h]
  size_t siz; // [sp+20h] [bp-Ch]
  unsigned __int8 *buf; // [sp+24h] [bp-8h]

  buf = *(unsigned __int8 **)item->data;
  siz = strlen((const char *)str);
  old_siz = *((_DWORD *)item->data + 1);
  if ( old_siz + siz + 1 > *((_DWORD *)item->data + 2) )
  {
    buf = (unsigned __int8 *)cgrealloc(
                               *(void **)item->data,
                               *((_DWORD *)item->data + 2) + siz - (((_WORD)siz + 1) & 0xFFF) + 4097,
                               "api-btm.c",
                               _func___11521,
                               1176);
    *(_DWORD *)item->data = buf;
    *((_DWORD *)item->data + 2) += siz - (((_WORD)siz + 1) & 0xFFF) + 4097;
  }
  memcpy(&buf[old_siz], str, siz + 1);
  *((_DWORD *)item->data + 1) += siz;
}

//----- (0007CBB8) --------------------------------------------------------
api_data *__cdecl print_data(io_data *io_data, api_data *root, bool isjson, bool precom)
{
  const unsigned __int8 *v4; // r3
  unsigned __int8 tmp42[2048]; // [sp+1Ch] [bp-858h] BYREF
  unsigned __int8 buf[64]; // [sp+81Ch] [bp-58h] BYREF
  api_data *tmp; // [sp+85Ch] [bp-18h]
  unsigned __int8 *escape; // [sp+860h] [bp-14h]
  unsigned __int8 *original; // [sp+864h] [bp-10h]
  K_ITEM *item; // [sp+868h] [bp-Ch]
  bool first; // [sp+86Eh] [bp-6h]
  bool done; // [sp+86Fh] [bp-5h]

  first = 1;
  cg_wlock_2(strbufs->lock, "api-btm.c", _func___11535, 1192);
  item = k_unlink_head(strbufs, "api-btm.c", _func___11535, 1193);
  cg_wunlock_2(strbufs->lock, "api-btm.c", _func___11535, 1194);
  *((_DWORD *)item->data + 1) = 0;
  if ( precom )
    add_item_buf(item, COMMA);
  if ( isjson )
    add_item_buf(item, "{");
  while ( root )
  {
    if ( !first )
      add_item_buf(item, COMMA);
    else
      first = 0;
    if ( isjson )
      add_item_buf(item, "\"");
    add_item_buf(item, root->name);
    if ( isjson )
      add_item_buf(item, "\"");
    if ( isjson )
      add_item_buf(item, ":");
    else
      add_item_buf(item, "=");
    first = 0;
    done = 0;
    switch ( root->type )
    {
      case API_ESCAPE:
        original = (unsigned __int8 *)root->data;
        escape = escape_string((unsigned __int8 *)root->data, isjson);
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, escape);
        if ( isjson )
          add_item_buf(item, "\"");
        if ( escape != original )
          free(escape);
        done = 1;
        break;
      case API_STRING:
      case API_CONST:
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, (const unsigned __int8 *)root->data);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
      case API_UINT8:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int8 *)root->data);
        break;
      case API_INT16:
        snprintf((char *)buf, 0x40u, "%d", *(__int16 *)root->data);
        break;
      case API_UINT16:
        snprintf((char *)buf, 0x40u, "%u", *(unsigned __int16 *)root->data);
        break;
      case API_INT:
        snprintf((char *)buf, 0x40u, "%d", *(_DWORD *)root->data);
        break;
      case API_UINT:
      case API_UINT32:
        snprintf((char *)buf, 0x40u, "%u", *(_DWORD *)root->data);
        break;
      case API_HEX32:
        if ( isjson )
          add_item_buf(item, "\"");
        snprintf((char *)buf, 0x40u, "0x%08x", *(_DWORD *)root->data);
        add_item_buf(item, buf);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
      case API_UINT64:
        snprintf((char *)buf, 0x40u, "%llu", *(_QWORD *)root->data);
        break;
      case API_INT64:
        snprintf((char *)buf, 0x40u, "%lld", *(_QWORD *)root->data);
        break;
      case API_DOUBLE:
        snprintf((char *)buf, 0x40u, "%f", *(double *)root->data);
        break;
      case API_ELAPSED:
        snprintf((char *)buf, 0x40u, "%.0f", *(double *)root->data);
        break;
      case API_BOOL:
        if ( *(_BYTE *)root->data )
          v4 = TRUESTR;
        else
          v4 = FALSESTR;
        snprintf((char *)buf, 0x40u, "%s", (const char *)v4);
        break;
      case API_TIMEVAL:
        snprintf((char *)buf, 0x40u, "%ld.%06ld", *(_DWORD *)root->data, *((_DWORD *)root->data + 1));
        break;
      case API_TIME:
        snprintf((char *)buf, 0x40u, "%lu", *(_DWORD *)root->data);
        break;
      case API_MHS:
      case API_UTILITY:
      case API_FREQ:
        snprintf((char *)buf, 0x40u, "%.2f", *(double *)root->data);
        break;
      case API_MHTOTAL:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data);
        break;
      case API_TEMP:
        snprintf((char *)buf, 0x40u, "%.2f", *(float *)root->data);
        break;
      case API_VOLTS:
      case API_AVG:
        snprintf((char *)buf, 0x40u, "%.3f", *(float *)root->data);
        break;
      case API_HS:
        snprintf((char *)buf, 0x40u, "%.15f", *(double *)root->data);
        break;
      case API_DIFF:
        snprintf((char *)buf, 0x40u, "%.8f", *(double *)root->data);
        break;
      case API_PERCENT:
        snprintf((char *)buf, 0x40u, "%.4f", *(double *)root->data * 100.0);
        break;
      default:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: unknown2 data type %d ignored", root->type);
          applog(3, tmp42, 0);
        }
        if ( isjson )
          add_item_buf(item, "\"");
        add_item_buf(item, UNKNOWN);
        if ( isjson )
          add_item_buf(item, "\"");
        done = 1;
        break;
    }
    if ( !done )
      add_item_buf(item, buf);
    free(root->name);
    if ( root->data_was_malloc )
      free(root->data);
    if ( root == root->next )
    {
      free(root);
      root = 0;
    }
    else
    {
      tmp = root;
      root = root->next;
      root->prev = tmp->prev;
      root->prev->next = root;
      free(tmp);
    }
  }
  if ( isjson )
    add_item_buf(item, "}");
  else
    add_item_buf(item, "|");
  io_add(io_data, *(unsigned __int8 **)item->data);
  cg_wlock_2(strbufs->lock, "api-btm.c", _func___11535, 1364);
  k_add_head(strbufs, item, "api-btm.c", _func___11535, 1365);
  cg_wunlock_2(strbufs->lock, "api-btm.c", _func___11535, 1366);
  return 0;
}
// 7CD8C: control flows out of bounds to 7CD90

//----- (0007D520) --------------------------------------------------------
int numascs()
{
  int i; // [sp+0h] [bp-Ch]
  int count; // [sp+4h] [bp-8h]

  count = 0;
  rd_lock_1(&devices_lock, "api-btm.c", _func___11574, 1380);
  for ( i = 0; i < total_devices; ++i )
  {
    if ( devices[i]->drv->drv_id == DRIVER_bitmain )
      ++count;
    if ( devices[i]->drv->drv_id == DRIVER_bitmain_soc )
      ++count;
  }
  rd_unlock_1(&devices_lock, "api-btm.c", _func___11574, 1385);
  return count;
}

//----- (0007D624) --------------------------------------------------------
int __cdecl ascdevice(int ascid)
{
  int i; // [sp+8h] [bp-Ch]
  int count; // [sp+Ch] [bp-8h]

  count = 0;
  rd_lock_1(&devices_lock, "api-btm.c", _func___11583, 1394);
  for ( i = 0; ; ++i )
  {
    if ( i >= total_devices )
    {
      rd_unlock_1(&devices_lock, "api-btm.c", _func___11583, 1402);
      return -1;
    }
    if ( devices[i]->drv->drv_id == DRIVER_bitmain )
      ++count;
    if ( devices[i]->drv->drv_id == DRIVER_bitmain_soc )
      ++count;
    if ( count == ascid + 1 )
      break;
  }
  rd_unlock_1(&devices_lock, "api-btm.c", _func___11583, 1407);
  return i;
}

//----- (0007D76C) --------------------------------------------------------
void __cdecl message(io_data *io_data, int messageid, int paramid, unsigned __int8 *param2, bool isjson)
{
  code_severity v5; // r3
  const unsigned __int8 *v6; // r2
  api_data *v7; // r0
  int messageida; // [sp+8h] [bp-2024h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp-2020h]
  int id; // [sp+14h] [bp-2018h] BYREF
  unsigned __int8 severity[2]; // [sp+18h] [bp-2014h] BYREF
  unsigned __int8 buf[8192]; // [sp+1Ch] [bp-2010h] BYREF
  int asc; // [sp+201Ch] [bp-10h]
  api_data *root; // [sp+2020h] [bp-Ch]
  int i; // [sp+2024h] [bp-8h]

  io_dataa = io_data;
  messageida = messageid;
  root = 0;
  if ( isjson )
    io_add(io_dataa, "{\"STATUS\":[");
  for ( i = 0; ; ++i )
  {
    if ( codes[i].severity == SEVERITY_FAIL )
    {
      v7 = api_add_string(root, "STATUS", "F", 0);
      root = api_add_time(v7, "When", &when, 0);
      id = -1;
      root = api_add_int(root, "Code", &id, 0);
      sprintf((char *)buf, "%d", messageida);
      root = api_add_escape(root, "Msg", buf, 0);
      root = api_add_escape(root, "Description", opt_api_description, 0);
      root = print_data(io_dataa, root, isjson, 0);
      if ( isjson )
        io_add(io_dataa, "]");
      return;
    }
    if ( codes[i].code == messageida )
      break;
  }
  v5 = codes[i].severity;
  switch ( v5 )
  {
    case SEVERITY_INFO:
      severity[0] = 73;
      break;
    case SEVERITY_SUCC:
      severity[0] = 83;
      break;
    case SEVERITY_WARN:
      severity[0] = 87;
      break;
    default:
      severity[0] = 69;
      break;
  }
  severity[1] = 0;
  switch ( codes[i].params )
  {
    case PARAM_PGA:
    case PARAM_ASC:
    case PARAM_PID:
    case PARAM_INT:
      sprintf((char *)buf, (const char *)codes[i].description, paramid);
      break;
    case PARAM_ASCMAX:
      asc = numascs();
      sprintf((char *)buf, (const char *)codes[i].description, paramid, asc - 1);
      break;
    case PARAM_PMAX:
      sprintf((char *)buf, (const char *)codes[i].description, total_pools);
      break;
    case PARAM_POOLMAX:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, total_pools - 1);
      break;
    case PARAM_DMAX:
      asc = numascs();
      sprintf((char *)buf, (const char *)codes[i].description, asc);
      break;
    case PARAM_CMD:
      sprintf((char *)buf, (const char *)codes[i].description, JSON_COMMAND);
      break;
    case PARAM_POOL:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, pools[paramid]->rpc_url);
      break;
    case PARAM_STR:
      sprintf((char *)buf, (const char *)codes[i].description, param2);
      break;
    case PARAM_BOTH:
      sprintf((char *)buf, (const char *)codes[i].description, paramid, param2);
      break;
    case PARAM_BOOL:
      if ( paramid )
        v6 = TRUESTR;
      else
        v6 = FALSESTR;
      sprintf((char *)buf, (const char *)codes[i].description, v6);
      break;
    case PARAM_SET:
      sprintf((char *)buf, (const char *)codes[i].description, param2, paramid);
      break;
    default:
      strcpy((char *)buf, (const char *)codes[i].description);
      break;
  }
  root = api_add_string(root, "STATUS", severity, 0);
  root = api_add_time(root, "When", &when, 0);
  root = api_add_int(root, "Code", &messageida, 0);
  root = api_add_escape(root, "Msg", buf, 0);
  root = api_add_escape(root, "Description", opt_api_description, 0);
  root = print_data(io_dataa, root, isjson, 0);
  if ( isjson )
    io_add(io_dataa, "]");
}
// 7D8B8: control flows out of bounds to 7D8BC

//----- (0007DE94) --------------------------------------------------------
void __cdecl lockstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 124, 0, 0, isjson);
}

//----- (0007DED8) --------------------------------------------------------
void __cdecl apiversion(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  bool io_open; // [sp+1Bh] [bp-9h]

  message(io_data, 22, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"VERSION\":[";
  else
    v5 = "VERSION,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_string(0, "CGMiner", "2.0.0", 0);
  v7 = api_add_const(v6, "API", APIVERSION, 0);
  v8 = api_add_string(v7, "Miner", g_miner_version, 0);
  v9 = api_add_string(v8, "CompileTime", g_miner_compiletime, 0);
  v10 = api_add_string(v9, "Type", g_miner_type, 0);
  print_data(io_data, v10, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0007E034) --------------------------------------------------------
void __cdecl minerconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int pgacount; // [sp+18h] [bp-14h] BYREF
  int asccount; // [sp+1Ch] [bp-10h] BYREF
  bool io_open; // [sp+23h] [bp-9h]
  api_data *root; // [sp+24h] [bp-8h]

  root = 0;
  pgacount = 0;
  asccount = numascs();
  message(io_data, 33, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"CONFIG\":[";
  else
    v5 = "CONFIG,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "ASC Count", &asccount, 0);
  root = api_add_int(root, "PGA Count", &pgacount, 0);
  root = api_add_int(root, "Pool Count", &total_pools, 0);
  root = api_add_const(root, "Strategy", strategies_0[pool_strategy_0].s, 0);
  root = api_add_int(root, "Log Interval", &opt_log_interval, 0);
  root = api_add_const(root, "Device Code", DEVICECODE, 0);
  root = api_add_const(root, "OS", OSINFO, 0);
  root = api_add_const(root, "Hotplug", NONE, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0007E21C) --------------------------------------------------------
const unsigned __int8 *__cdecl status2str(alive status)
{
  const unsigned __int8 *v1; // r3

  switch ( status )
  {
    case LIFE_WELL:
      v1 = ALIVE;
      break;
    case LIFE_SICK:
      v1 = SICK;
      break;
    case LIFE_DEAD:
      v1 = DEAD;
      break;
    case LIFE_NOSTART:
      v1 = NOSTART;
      break;
    case LIFE_INIT:
      v1 = INIT;
      break;
    default:
      v1 = UNKNOWN;
      break;
  }
  return v1;
}
// 7E238: control flows out of bounds to 7E23C

//----- (0007E2C0) --------------------------------------------------------
void __cdecl ascstatus(io_data *io_data, int asc, bool isjson, bool precom)
{
  double v4; // d0
  float v5; // s15
  int v6; // r3
  double v7; // d7
  double v8; // d7
  int asca; // [sp+8h] [bp-88h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp-84h]
  double rejp; // [sp+10h] [bp-80h] BYREF
  double hwp; // [sp+18h] [bp-78h] BYREF
  int last_share_pool; // [sp+20h] [bp-70h] BYREF
  unsigned __int8 mhsname[27]; // [sp+24h] [bp-6Ch] BYREF
  double mhs; // [sp+40h] [bp-50h] BYREF
  double dev_runtime; // [sp+48h] [bp-48h] BYREF
  float temp; // [sp+54h] [bp-3Ch] BYREF
  unsigned __int8 *status; // [sp+58h] [bp-38h]
  cgpu_info *cgpu; // [sp+5Ch] [bp-34h]
  int dev; // [sp+60h] [bp-30h]
  int numasc; // [sp+64h] [bp-2Ch]
  api_data *root; // [sp+68h] [bp-28h]
  unsigned __int8 *enabled; // [sp+6Ch] [bp-24h]

  io_dataa = io_data;
  asca = asc;
  root = 0;
  numasc = numascs();
  if ( numasc > 0 && asca >= 0 && numasc > asca )
  {
    dev = ascdevice(asca);
    if ( dev >= 0 )
    {
      cgpu = get_devices(dev);
      v5 = cgpu->temp;
      temp = v5;
      cgpu_runtime(cgpu);
      dev_runtime = v4;
      cgpu->utility = (double)cgpu->accepted / v4 * 60.0;
      if ( cgpu->deven == DEV_DISABLED )
        enabled = (unsigned __int8 *)NO;
      else
        enabled = (unsigned __int8 *)YES;
      status = (unsigned __int8 *)status2str(cgpu->status);
      root = api_add_int(root, "ASC", &asca, 0);
      root = api_add_string(root, "Name", cgpu->drv->name, 0);
      root = api_add_int(root, "ID", &cgpu->device_id, 0);
      root = api_add_string(root, "Enabled", enabled, 0);
      root = api_add_string(root, "Status", status, 0);
      root = api_add_temp(root, "Temperature", &temp, 0);
      mhs = cgpu->total_mhashes / dev_runtime;
      root = api_add_mhs(root, "MHS av", &mhs, 0);
      sprintf((char *)mhsname, "MHS %ds", opt_log_interval);
      root = api_add_mhs(root, mhsname, &cgpu->rolling, 0);
      root = api_add_int(root, "Accepted", &cgpu->accepted, 0);
      root = api_add_int(root, "Rejected", &cgpu->rejected, 0);
      root = api_add_int(root, "Hardware Errors", &cgpu->hw_errors, 0);
      root = api_add_utility(root, "Utility", &cgpu->utility, 0);
      if ( cgpu->last_share_pool_time <= 0 )
        v6 = -1;
      else
        v6 = cgpu->last_share_pool;
      last_share_pool = v6;
      root = api_add_int(root, "Last Share Pool", &last_share_pool, 0);
      root = api_add_time(root, "Last Share Time", &cgpu->last_share_pool_time, 0);
      root = api_add_mhtotal(root, "Total MH", &cgpu->total_mhashes, 0);
      root = api_add_int64(root, "Diff1 Work", &cgpu->diff1, 0);
      root = api_add_diff(root, "Difficulty Accepted", &cgpu->diff_accepted, 0);
      root = api_add_diff(root, "Difficulty Rejected", &cgpu->diff_rejected, 0);
      root = api_add_diff(root, "Last Share Difficulty", &cgpu->last_share_diff, 0);
      root = api_add_time(root, "Last Valid Work", &cgpu->last_device_valid_work, 0);
      if ( cgpu->hw_errors + cgpu->diff1 )
        v7 = (double)cgpu->hw_errors / (double)(cgpu->hw_errors + cgpu->diff1);
      else
        v7 = 0.0;
      hwp = v7;
      root = api_add_percent(root, "Device Hardware%", &hwp, 0);
      if ( cgpu->diff1 )
        v8 = cgpu->diff_rejected / (double)cgpu->diff1;
      else
        v8 = 0.0;
      rejp = v8;
      root = api_add_percent(root, "Device Rejected%", &rejp, 0);
      root = api_add_elapsed(root, "Device Elapsed", &dev_runtime, 0);
      print_data(io_dataa, root, isjson, precom);
    }
  }
}
// 7E36C: variable 'v4' is possibly undefined

//----- (0007E7EC) --------------------------------------------------------
void __cdecl devstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int numasc; // [sp+20h] [bp-14h]
  int i; // [sp+24h] [bp-10h]
  int devcount; // [sp+28h] [bp-Ch]
  bool io_open; // [sp+2Fh] [bp-5h]

  io_open = 0;
  devcount = 0;
  numasc = numascs();
  if ( numasc )
  {
    message(io_data, 9, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVS\":[");
    if ( numasc > 0 )
    {
      for ( i = 0; i < numasc; ++i )
      {
        v5 = isjson && devcount > 0;
        ascstatus(io_data, i, isjson, v5);
        ++devcount;
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}
// 7E838: conditional instruction was optimized away because %numpga.4==0

//----- (0007E94C) --------------------------------------------------------
void __cdecl edevstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int numasc; // [sp+20h] [bp-14h]
  int i; // [sp+24h] [bp-10h]
  int devcount; // [sp+28h] [bp-Ch]
  bool io_open; // [sp+2Fh] [bp-5h]

  io_open = 0;
  devcount = 0;
  numasc = numascs();
  if ( numasc )
  {
    message(io_data, 9, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVS\":[");
    if ( numasc > 0 )
    {
      for ( i = 0; i < numasc; ++i )
      {
        v5 = isjson && devcount > 0;
        ascstatus(io_data, i, isjson, v5);
        ++devcount;
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}
// 7E998: conditional instruction was optimized away because %numpga.4==0

//----- (0007EAB0) --------------------------------------------------------
void __cdecl poolstatus(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool_enable enabled; // r3
  const unsigned __int8 *v6; // r0
  double v7; // d7
  double v8; // d7
  bool v9; // r3
  double stalep; // [sp+18h] [bp-13Ch] BYREF
  double rejp; // [sp+20h] [bp-134h] BYREF
  unsigned __int8 lasttime[256]; // [sp+28h] [bp-12Ch] BYREF
  int i; // [sp+128h] [bp-2Ch] BYREF
  pool *pool; // [sp+12Ch] [bp-28h]
  int second; // [sp+130h] [bp-24h]
  int minute; // [sp+134h] [bp-20h]
  int hour; // [sp+138h] [bp-1Ch]
  int timediff; // [sp+13Ch] [bp-18h]
  unsigned __int8 *lp; // [sp+140h] [bp-14h]
  unsigned __int8 *status; // [sp+144h] [bp-10h]
  bool io_open; // [sp+14Bh] [bp-9h]
  api_data *root; // [sp+14Ch] [bp-8h]

  root = 0;
  io_open = 0;
  hour = 0;
  minute = 0;
  second = 0;
  memset(lasttime, 0, sizeof(lasttime));
  timediff = 0;
  if ( total_pools )
  {
    message(io_data, 7, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"POOLS\":[");
    for ( i = 0; i < total_pools; ++i )
    {
      pool = pools[i];
      if ( !pool->removed )
      {
        enabled = pool->enabled;
        if ( enabled == POOL_ENABLED )
        {
          if ( pool->idle )
            status = (unsigned __int8 *)DEAD;
          else
            status = (unsigned __int8 *)ALIVE;
        }
        else if ( enabled )
        {
          if ( enabled == POOL_REJECTING )
            status = (unsigned __int8 *)REJECTING;
          else
            status = (unsigned __int8 *)UNKNOWN;
        }
        else
        {
          status = (unsigned __int8 *)DISABLED;
        }
        if ( pool->hdr_path )
          lp = (unsigned __int8 *)YES;
        else
          lp = (unsigned __int8 *)NO;
        if ( pool->last_share_time > 0 )
        {
          timediff = time(0) - pool->last_share_time;
          if ( timediff < 0 )
            timediff = 0;
          hour = timediff / 3600;
          minute = timediff % 3600 / 60;
          second = timediff % 3600 % 60;
          sprintf((char *)lasttime, "%d:%02d:%02d", timediff / 3600, minute, second);
        }
        else
        {
          strcpy((char *)lasttime, "0");
        }
        root = api_add_int(root, "POOL", &i, 0);
        root = api_add_escape(root, "URL", pool->rpc_url, 0);
        root = api_add_string(root, "Status", status, 0);
        root = api_add_int(root, "Priority", &pool->prio, 0);
        root = api_add_int(root, "Quota", &pool->quota, 0);
        root = api_add_string(root, "Long Poll", lp, 0);
        root = api_add_uint(root, "Getworks", &pool->getwork_requested, 0);
        root = api_add_int64(root, "Accepted", &pool->accepted, 0);
        root = api_add_int64(root, "Rejected", &pool->rejected, 0);
        root = api_add_uint(root, "Discarded", &pool->discarded_work, 0);
        root = api_add_uint(root, "Stale", &pool->stale_shares, 0);
        root = api_add_uint(root, "Get Failures", &pool->getfail_occasions, 0);
        root = api_add_uint(root, "Remote Failures", &pool->remotefail_occasions, 0);
        root = api_add_escape(root, "User", pool->rpc_user, 0);
        root = api_add_string(root, "Last Share Time", lasttime, 0);
        root = api_add_string(root, "Diff", pool->diff, 0);
        root = api_add_int64(root, "Diff1 Shares", &pool->diff1, 0);
        if ( pool->rpc_proxy )
        {
          v6 = proxytype(pool->rpc_proxytype);
          root = api_add_const(root, "Proxy Type", v6, 0);
          root = api_add_escape(root, "Proxy", pool->rpc_proxy, 0);
        }
        else
        {
          root = api_add_const(root, "Proxy Type", BLANK, 0);
          root = api_add_const(root, "Proxy", BLANK, 0);
        }
        root = api_add_diff(root, "Difficulty Accepted", &pool->diff_accepted, 0);
        root = api_add_diff(root, "Difficulty Rejected", &pool->diff_rejected, 0);
        root = api_add_diff(root, "Difficulty Stale", &pool->diff_stale, 0);
        root = api_add_diff(root, "Last Share Difficulty", &pool->last_share_diff, 0);
        root = api_add_bool(root, "Has Stratum", &pool->has_stratum, 0);
        root = api_add_bool(root, "Stratum Active", &pool->stratum_active, 0);
        if ( pool->stratum_active )
          root = api_add_escape(root, "Stratum URL", pool->stratum_url, 0);
        else
          root = api_add_const(root, "Stratum URL", BLANK, 0);
        root = api_add_bool(root, "Has GBT", &pool->has_gbt, 0);
        root = api_add_uint64(root, "Best Share", &pool->best_diff, 1);
        if ( pool->diff_accepted + pool->diff_rejected + pool->diff_stale == 0.0 )
          v7 = 0.0;
        else
          v7 = pool->diff_rejected / (pool->diff_accepted + pool->diff_rejected + pool->diff_stale);
        rejp = v7;
        root = api_add_percent(root, "Pool Rejected%", &rejp, 0);
        if ( pool->diff_accepted + pool->diff_rejected + pool->diff_stale == 0.0 )
          v8 = 0.0;
        else
          v8 = pool->diff_stale / (pool->diff_accepted + pool->diff_rejected + pool->diff_stale);
        stalep = v8;
        root = api_add_percent(root, "Pool Stale%", &stalep, 0);
        v9 = isjson && i > 0;
        root = print_data(io_data, root, isjson, v9);
      }
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (0007F380) --------------------------------------------------------
void get_AVG_hashrate()
{
  ;
}

//----- (0007F3E8) --------------------------------------------------------
void get_total_hashs()
{
  ;
}

//----- (0007F410) --------------------------------------------------------
void get_total_secs()
{
  ;
}

//----- (0007F438) --------------------------------------------------------
void __cdecl lcddisplay(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  double v5; // d0
  unsigned __int8 szuser[32]; // [sp+18h] [bp-7Ch] BYREF
  unsigned __int8 szpool[32]; // [sp+38h] [bp-5Ch] BYREF
  unsigned __int8 szindex[32]; // [sp+58h] [bp-3Ch] BYREF
  double ghs; // [sp+78h] [bp-1Ch] BYREF
  pool *pool; // [sp+84h] [bp-10h]
  bool io_open; // [sp+8Bh] [bp-9h]
  api_data *root; // [sp+8Ch] [bp-8h]

  root = 0;
  io_open = 0;
  memset(szindex, 0, sizeof(szindex));
  memset(szpool, 0, sizeof(szpool));
  memset(szuser, 0, sizeof(szuser));
  pool = current_pool();
  message(io_data, 7, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"POOLS\":[");
  get_AVG_hashrate();
  ghs = v5;
  strcpy((char *)szindex, "0");
  root = api_add_string(root, "LCD", szindex, 0);
  root = api_add_string(root, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHSavg", &ghs, 0);
  if ( pool )
  {
    root = api_add_string(root, "pool", pool->rpc_url, 0);
    root = api_add_string(root, "user", pool->rpc_user, 0);
  }
  else
  {
    strcpy((char *)szpool, "no");
    strcpy((char *)szuser, "no");
    root = api_add_string(root, "pool", szpool, 0);
    root = api_add_string(root, "user", szuser, 0);
  }
  root = print_data(io_data, root, isjson, isjson);
  if ( isjson && io_open )
    io_close(io_data);
}
// 7F4F0: variable 'v5' is possibly undefined

//----- (0007F668) --------------------------------------------------------
void __cdecl summary(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  double v5; // d0
  char *v6; // r3
  double v7; // d7
  double v8; // d7
  api_data *v9; // r0
  double v10; // d7
  double v11; // d7
  double v12; // d7
  double v13; // d7
  double stalep; // [sp+18h] [bp-60h] BYREF
  double prejp; // [sp+20h] [bp-58h] BYREF
  double rejp; // [sp+28h] [bp-50h] BYREF
  double hwp; // [sp+30h] [bp-48h] BYREF
  double work_utility; // [sp+38h] [bp-40h] BYREF
  double ghs; // [sp+40h] [bp-38h] BYREF
  double utility; // [sp+48h] [bp-30h] BYREF
  bool io_open; // [sp+53h] [bp-25h]
  api_data *root; // [sp+54h] [bp-24h]

  root = 0;
  message(io_data, 11, 0, 0, isjson);
  if ( isjson )
    v6 = ",\"SUMMARY\":[";
  else
    v6 = "SUMMARY,";
  io_open = io_add(io_data, (unsigned __int8 *)v6);
  mutex_lock_3(&hash_lock, "api-btm.c", _func___11773, 2788);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  if ( total_secs == 0.0 )
    v7 = 1.0;
  else
    v7 = total_secs;
  utility = (double)total_accepted / v7 * 60.0;
  get_AVG_hashrate();
  ghs = v5;
  if ( total_secs == 0.0 )
    v8 = 1.0;
  else
    v8 = total_secs;
  work_utility = (double)total_diff1 / v8 * 60.0;
  v9 = api_add_elapsed(root, "Elapsed", &total_secs, 1);
  root = api_add_string(v9, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHS av", &ghs, 0);
  root = api_add_uint(root, "Found Blocks", &found_blocks, 1);
  root = api_add_int64(root, "Getworks", &total_getworks, 1);
  root = api_add_int64(root, "Accepted", &total_accepted, 1);
  root = api_add_int64(root, "Rejected", &total_rejected, 1);
  root = api_add_int(root, "Hardware Errors", &hw_errors, 1);
  root = api_add_utility(root, "Utility", &utility, 0);
  root = api_add_int64(root, "Discarded", &total_discarded, 1);
  root = api_add_int64(root, "Stale", &total_stale, 1);
  root = api_add_uint(root, "Get Failures", &total_go, 1);
  root = api_add_uint(root, "Local Work", &local_work, 1);
  root = api_add_uint(root, "Remote Failures", &total_ro, 1);
  root = api_add_uint(root, "Network Blocks", &new_blocks, 1);
  root = api_add_mhtotal(root, "Total MH", &total_mhashes_done, 1);
  root = api_add_utility(root, "Work Utility", &work_utility, 0);
  root = api_add_diff(root, "Difficulty Accepted", &total_diff_accepted, 1);
  root = api_add_diff(root, "Difficulty Rejected", &total_diff_rejected, 1);
  root = api_add_diff(root, "Difficulty Stale", &total_diff_stale, 1);
  root = api_add_uint64(root, "Best Share", &best_diff, 1);
  if ( hw_errors + total_diff1 )
    v10 = (double)hw_errors / (double)(hw_errors + total_diff1);
  else
    v10 = 0.0;
  hwp = v10;
  root = api_add_percent(root, "Device Hardware%", &hwp, 0);
  if ( total_diff1 )
    v11 = total_diff_rejected / (double)total_diff1;
  else
    v11 = 0.0;
  rejp = v11;
  root = api_add_percent(root, "Device Rejected%", &rejp, 0);
  if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
    v12 = 0.0;
  else
    v12 = total_diff_rejected / (total_diff_accepted + total_diff_rejected + total_diff_stale);
  prejp = v12;
  root = api_add_percent(root, "Pool Rejected%", &prejp, 0);
  if ( total_diff_accepted + total_diff_rejected + total_diff_stale == 0.0 )
    v13 = 0.0;
  else
    v13 = total_diff_stale / (total_diff_accepted + total_diff_rejected + total_diff_stale);
  stalep = v13;
  root = api_add_percent(root, "Pool Stale%", &stalep, 0);
  root = api_add_time(root, "Last getwork", &last_getwork, 0);
  mutex_unlock_3(&hash_lock, "api-btm.c", _func___11773, 2833);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}
// 7F7A0: variable 'v5' is possibly undefined

//----- (0007FD74) --------------------------------------------------------
void __cdecl noncenum(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  bool io_open; // [sp+1Bh] [bp-9h]

  message(io_data, 16, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"NONCENUM\":[";
  else
    v5 = "NONCENUM,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_string(0, "10min nonce", nonce_num10_string, 0);
  v7 = api_add_string(v6, "30min nonce", nonce_num30_string, 0);
  v8 = api_add_string(v7, "60min nonce", nonce_num60_string, 0);
  print_data(io_data, v8, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0007FE8C) --------------------------------------------------------
void __cdecl pgacount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int count; // [sp+1Ch] [bp-10h] BYREF
  bool io_open; // [sp+23h] [bp-9h]
  api_data *root; // [sp+24h] [bp-8h]

  root = 0;
  count = 0;
  message(io_data, 59, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"PGAS\":[";
  else
    v5 = "PGAS,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "Count", &count, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (0007FF68) --------------------------------------------------------
void __cdecl switchpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool *pool; // [sp+18h] [bp-Ch]
  int id; // [sp+1Ch] [bp-8h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      cg_rlock_1(&control_lock, "api-btm.c", _func___11806, 2896);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        pool->enabled = POOL_ENABLED;
        cg_runlock_1(&control_lock, "api-btm.c", _func___11806, 2906);
        switch_pools(pool);
        message(io_data, 27, id, 0, isjson);
      }
      else
      {
        cg_runlock_1(&control_lock, "api-btm.c", _func___11806, 2899);
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (000800FC) --------------------------------------------------------
void __cdecl copyadvanceafter(unsigned __int8 ch, unsigned __int8 **param, unsigned __int8 **buf)
{
  unsigned __int8 *v3; // r2
  unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // r3

  while ( **param && ch != **param )
  {
    if ( **param == 92 && (*param)[1] )
      ++*param;
    v3 = (*param)++;
    v4 = (*buf)++;
    *v4 = *v3;
  }
  if ( **param )
    ++*param;
  v5 = (*buf)++;
  *v5 = 0;
}

//----- (0008020C) --------------------------------------------------------
bool __cdecl pooldetails(unsigned __int8 *param, unsigned __int8 **url, unsigned __int8 **user, unsigned __int8 **pass)
{
  size_t v4; // r0
  unsigned __int8 *parama; // [sp+Ch] [bp-10h] BYREF
  unsigned __int8 *buf; // [sp+10h] [bp-Ch] BYREF
  unsigned __int8 *ptr; // [sp+14h] [bp-8h]

  parama = param;
  v4 = strlen((const char *)param);
  buf = (unsigned __int8 *)cgmalloc(v4 + 1, "api-btm.c", _func___11823, 2934);
  ptr = buf;
  *url = buf;
  copyadvanceafter(0x2Cu, &parama, &buf);
  if ( *parama && (*user = buf, copyadvanceafter(0x2Cu, &parama, &buf), *parama) )
  {
    *pass = buf;
    copyadvanceafter(0x2Cu, &parama, &buf);
    return 1;
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (00080310) --------------------------------------------------------
void __cdecl addpool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *pass; // [sp+1Ch] [bp-18h] BYREF
  unsigned __int8 *user; // [sp+20h] [bp-14h] BYREF
  unsigned __int8 *url; // [sp+24h] [bp-10h] BYREF
  unsigned __int8 *ptr; // [sp+28h] [bp-Ch]
  pool *pool; // [sp+2Ch] [bp-8h]

  if ( param && *param )
  {
    if ( !pooldetails(param, &url, &user, &pass) )
    {
      ptr = escape_string(param, isjson);
      message(io_data, 53, 0, ptr, isjson);
      if ( ptr != param )
        free(ptr);
      ptr = 0;
    }
    else
    {
      pool = add_pool();
      detect_stratum(pool, url);
      add_pool_details(pool, 1, url, user, pass);
      ptr = escape_string(url, isjson);
      message(io_data, 55, pool->pool_no, ptr, isjson);
      if ( ptr != url )
        free(ptr);
    }
  }
  else
  {
    message(io_data, 52, 0, 0, isjson);
  }
}

//----- (0008047C) --------------------------------------------------------
void __cdecl enablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int prio; // r4
  pool *pool; // [sp+18h] [bp-14h]
  int id; // [sp+1Ch] [bp-10h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        if ( pool->enabled == POOL_ENABLED )
        {
          message(io_data, 49, id, 0, isjson);
        }
        else
        {
          pool->enabled = POOL_ENABLED;
          prio = pool->prio;
          if ( prio < current_pool()->prio )
            switch_pools(pool);
          message(io_data, 47, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (000805FC) --------------------------------------------------------
void __cdecl poolpriority(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  int v6; // r3
  int v7; // r2
  char v8[3]; // [sp+8h] [bp-44h] BYREF
  bool isjsona; // [sp+Bh] [bp-41h]
  unsigned __int8 *parama; // [sp+Ch] [bp-40h]
  int ca; // [sp+10h] [bp-3Ch]
  io_data *io_dataa; // [sp+14h] [bp-38h]
  unsigned __int8 *ptr; // [sp+1Ch] [bp-30h]
  int (*p_new_prio)[]; // [sp+20h] [bp-2Ch]
  int v15; // [sp+24h] [bp-28h]
  bool (*p_pools_changed)[]; // [sp+28h] [bp-24h]
  int v17; // [sp+2Ch] [bp-20h]
  unsigned __int8 *next; // [sp+30h] [bp-1Ch]
  int i; // [sp+34h] [bp-18h]
  int pr; // [sp+38h] [bp-14h]
  int prio; // [sp+3Ch] [bp-10h]

  io_dataa = io_data;
  ca = c;
  parama = param;
  isjsona = isjson;
  prio = 0;
  if ( total_pools )
  {
    if ( parama && *parama )
    {
      v17 = total_pools - 1;
      p_pools_changed = (bool (*)[])v8;
      v15 = total_pools - 1;
      p_new_prio = (int (*)[])v8;
      for ( i = 0; i < total_pools; ++i )
        *((_BYTE *)p_pools_changed + i) = 0;
      next = parama;
      while ( next && *next )
      {
        ptr = next;
        next = (unsigned __int8 *)strchr((const char *)next, 44);
        if ( next )
        {
          v5 = next++;
          *v5 = 0;
        }
        i = atoi((const char *)ptr);
        if ( i < 0 || i >= total_pools )
        {
          message(io_dataa, 26, i, 0, isjsona);
          return;
        }
        if ( *((_BYTE *)p_pools_changed + i) )
        {
          message(io_dataa, 74, i, 0, isjsona);
          return;
        }
        *((_BYTE *)p_pools_changed + i) = 1;
        v6 = prio++;
        *((_DWORD *)p_new_prio + i) = v6;
      }
      for ( i = 0; i < total_pools; ++i )
      {
        if ( *((_BYTE *)p_pools_changed + i) )
          pools[i]->prio = *((_DWORD *)p_new_prio + i);
      }
      for ( pr = 0; pr < total_pools; ++pr )
      {
        for ( i = 0; i < total_pools; ++i )
        {
          if ( *((_BYTE *)p_pools_changed + i) != 1 && pr == pools[i]->prio )
          {
            v7 = prio++;
            pools[i]->prio = v7;
            *((_BYTE *)p_pools_changed + i) = 1;
            break;
          }
        }
      }
      if ( current_pool()->prio )
        switch_pools(0);
      message(io_dataa, 73, 0, 0, isjsona);
    }
    else
    {
      message(io_dataa, 25, 0, 0, isjsona);
    }
  }
  else
  {
    message(io_dataa, 8, 0, 0, isjsona);
  }
}

//----- (00080A98) --------------------------------------------------------
void __cdecl poolquota(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  int quota; // [sp+18h] [bp-14h]
  pool *pool; // [sp+1Ch] [bp-10h]
  int id; // [sp+20h] [bp-Ch]
  unsigned __int8 *comma; // [sp+24h] [bp-8h]
  unsigned __int8 *commaa; // [sp+24h] [bp-8h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      comma = (unsigned __int8 *)strchr((const char *)param, 44);
      if ( comma )
      {
        v5 = comma;
        commaa = comma + 1;
        *v5 = 0;
        id = atoi((const char *)param);
        if ( id >= 0 && id < total_pools )
        {
          pool = pools[id];
          quota = atoi((const char *)commaa);
          if ( quota >= 0 )
          {
            pool->quota = quota;
            adjust_quota_gcd();
            message(io_data, 122, quota, pool->rpc_url, isjson);
          }
          else
          {
            message(io_data, 121, quota, pool->rpc_url, isjson);
          }
        }
        else
        {
          message(io_data, 26, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 86, 0, param, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (00080C60) --------------------------------------------------------
void __cdecl disablepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  pool *pool; // [sp+18h] [bp-Ch]
  int id; // [sp+1Ch] [bp-8h]

  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        pool = pools[id];
        if ( pool->enabled )
        {
          if ( enabled_pools > 1 )
          {
            pool->enabled = POOL_DISABLED;
            if ( pool == current_pool() )
              switch_pools(0);
            message(io_data, 48, id, 0, isjson);
          }
          else
          {
            message(io_data, 51, id, 0, isjson);
          }
        }
        else
        {
          message(io_data, 50, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (00080E0C) --------------------------------------------------------
void __cdecl removepool(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *rpc_url; // [sp+18h] [bp-14h]
  pool *pool; // [sp+1Ch] [bp-10h]
  int id; // [sp+20h] [bp-Ch]
  bool dofree; // [sp+27h] [bp-5h]

  dofree = 0;
  if ( total_pools )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < total_pools )
      {
        if ( total_pools > 1 )
        {
          pool = pools[id];
          if ( pool == current_pool() )
            switch_pools(0);
          if ( pool == current_pool() )
          {
            message(io_data, 67, id, 0, isjson);
          }
          else
          {
            pool->enabled = POOL_DISABLED;
            rpc_url = escape_string(pool->rpc_url, isjson);
            if ( rpc_url != pool->rpc_url )
              dofree = 1;
            remove_pool(pool);
            message(io_data, 68, id, rpc_url, isjson);
            if ( dofree )
              free(rpc_url);
          }
        }
        else
        {
          message(io_data, 66, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 26, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 25, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 8, 0, 0, isjson);
  }
}

//----- (00081020) --------------------------------------------------------
void __cdecl doquit(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"BYE\"");
  else
    io_put(io_data, "BYE");
  bye = 1;
  do_a_quit = 1;
}

//----- (00081098) --------------------------------------------------------
void __cdecl dorestart(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( isjson )
    io_put(io_data, "{\"STATUS\":\"RESTART\"");
  else
    io_put(io_data, "RESTART");
  bye = 1;
  do_a_restart = 1;
}

//----- (00081110) --------------------------------------------------------
void __cdecl privileged(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 46, 0, 0, isjson);
}

//----- (00081154) --------------------------------------------------------
void __cdecl notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, unsigned __int8 group)
{
  bool v5; // r3
  int devicea; // [sp+8h] [bp-14h] BYREF
  io_data *io_dataa; // [sp+Ch] [bp-10h]
  api_data *root; // [sp+10h] [bp-Ch]
  unsigned __int8 *reason; // [sp+14h] [bp-8h]

  io_dataa = io_data;
  devicea = device;
  root = 0;
  if ( cgpu->device_last_not_well )
  {
    switch ( cgpu->device_not_well_reason )
    {
      case REASON_THREAD_FAIL_INIT:
        reason = "Thread failed to init";
        break;
      case REASON_THREAD_ZERO_HASH:
        reason = "Thread got zero hashes";
        break;
      case REASON_THREAD_FAIL_QUEUE:
        reason = "Thread failed to queue work";
        break;
      case REASON_DEV_SICK_IDLE_60:
        reason = "Device idle for 60s";
        break;
      case REASON_DEV_DEAD_IDLE_600:
        reason = "Device dead - idle for 600s";
        break;
      case REASON_DEV_NOSTART:
        reason = "Device failed to start";
        break;
      case REASON_DEV_OVER_HEAT:
        reason = "Device over heated";
        break;
      case REASON_DEV_THERMAL_CUTOFF:
        reason = "Device reached thermal cutoff";
        break;
      case REASON_DEV_COMMS_ERROR:
        reason = "Device comms error";
        break;
      default:
        reason = "Unknown reason - code bug";
        break;
    }
  }
  else
  {
    reason = "None";
  }
  root = api_add_int(root, "NOTIFY", &devicea, 0);
  root = api_add_string(root, "Name", cgpu->drv->name, 0);
  root = api_add_int(root, "ID", &cgpu->device_id, 0);
  root = api_add_time(root, "Last Well", &cgpu->device_last_well, 0);
  root = api_add_time(root, "Last Not Well", &cgpu->device_last_not_well, 0);
  root = api_add_string(root, "Reason Not Well", reason, 0);
  root = api_add_int(root, "*Thread Fail Init", &cgpu->thread_fail_init_count, 0);
  root = api_add_int(root, "*Thread Zero Hash", &cgpu->thread_zero_hash_count, 0);
  root = api_add_int(root, "*Thread Fail Queue", &cgpu->thread_fail_queue_count, 0);
  root = api_add_int(root, "*Dev Sick Idle 60s", &cgpu->dev_sick_idle_60_count, 0);
  root = api_add_int(root, "*Dev Dead Idle 600s", &cgpu->dev_dead_idle_600_count, 0);
  root = api_add_int(root, "*Dev Nostart", &cgpu->dev_nostart_count, 0);
  root = api_add_int(root, "*Dev Over Heat", &cgpu->dev_over_heat_count, 0);
  root = api_add_int(root, "*Dev Thermal Cutoff", &cgpu->dev_thermal_cutoff_count, 0);
  root = api_add_int(root, "*Dev Comms Error", &cgpu->dev_comms_error_count, 0);
  root = api_add_int(root, "*Dev Throttle", &cgpu->dev_throttle_count, 0);
  v5 = isjson && devicea > 0;
  print_data(io_dataa, root, isjson, v5);
}
// 811A8: control flows out of bounds to 811AC

//----- (000814B8) --------------------------------------------------------
void __cdecl notify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  cgpu_info *cgpu; // [sp+1Ch] [bp-10h]
  int i; // [sp+20h] [bp-Ch]
  bool io_open; // [sp+27h] [bp-5h]

  io_open = 0;
  if ( total_devices )
  {
    message(io_data, 60, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"NOTIFY\":[");
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = get_devices(i);
      notifystatus(io_data, i, cgpu, isjson, group);
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}

//----- (000815D4) --------------------------------------------------------
void __cdecl devdetails(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  const unsigned __int8 *kname; // r2
  unsigned __int8 *name; // r2
  unsigned __int8 *device_path; // r2
  bool v8; // r3
  int i; // [sp+18h] [bp-14h] BYREF
  cgpu_info *cgpu; // [sp+1Ch] [bp-10h]
  bool io_open; // [sp+23h] [bp-9h]
  api_data *root; // [sp+24h] [bp-8h]

  root = 0;
  io_open = 0;
  if ( total_devices )
  {
    message(io_data, 69, 0, 0, isjson);
    if ( isjson )
      io_open = io_add(io_data, ",\"DEVDETAILS\":[");
    for ( i = 0; i < total_devices; ++i )
    {
      cgpu = get_devices(i);
      root = api_add_int(root, "DEVDETAILS", &i, 0);
      root = api_add_string(root, "Name", cgpu->drv->name, 0);
      root = api_add_int(root, "ID", &cgpu->device_id, 0);
      root = api_add_string(root, "Driver", cgpu->drv->dname, 0);
      kname = cgpu->kname;
      if ( !kname )
        kname = BLANK;
      root = api_add_const(root, "Kernel", kname, 0);
      if ( cgpu->name )
        name = cgpu->name;
      else
        name = (unsigned __int8 *)BLANK;
      root = api_add_const(root, "Model", name, 0);
      if ( cgpu->device_path )
        device_path = cgpu->device_path;
      else
        device_path = (unsigned __int8 *)BLANK;
      root = api_add_const(root, "Device Path", device_path, 0);
      v8 = isjson && i > 0;
      root = print_data(io_data, root, isjson, v8);
    }
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 10, 0, 0, isjson);
  }
}

//----- (0008184C) --------------------------------------------------------
void __cdecl dosave(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *parama; // [sp+Ch] [bp-1018h]
  unsigned __int8 filename[4096]; // [sp+18h] [bp-100Ch] BYREF
  unsigned __int8 *ptr; // [sp+1018h] [bp-Ch]
  FILE *fcfg; // [sp+101Ch] [bp-8h]

  parama = param;
  if ( !param || !*param )
  {
    default_save_file(filename);
    parama = filename;
  }
  fcfg = fopen((const char *)parama, "w");
  if ( fcfg )
  {
    write_config(fcfg);
    fclose(fcfg);
    ptr = escape_string(parama, isjson);
    message(io_data, 44, 0, ptr, isjson);
    if ( ptr != parama )
      free(ptr);
  }
  else
  {
    ptr = escape_string(parama, isjson);
    message(io_data, 43, 0, ptr, isjson);
    if ( ptr != parama )
      free(ptr);
    ptr = 0;
  }
}

//----- (00081A28) --------------------------------------------------------
int __cdecl itemstats(
        io_data *io_data,
        int i,
        unsigned __int8 *id,
        cgminer_stats *stats,
        cgminer_pool_stats *pool_stats,
        api_data *extra,
        cgpu_info *cgpu,
        bool isjson)
{
  double v8; // d0
  int ia; // [sp+8h] [bp-1Ch] BYREF
  io_data *io_dataa; // [sp+Ch] [bp-18h]
  double ghs; // [sp+10h] [bp-14h] BYREF
  api_data *root; // [sp+1Ch] [bp-8h]

  io_dataa = io_data;
  ia = i;
  root = 0;
  get_AVG_hashrate();
  ghs = v8;
  root = api_add_int(0, "STATS", &ia, 0);
  root = api_add_string(root, "ID", id, 0);
  root = api_add_elapsed(root, "Elapsed", &total_secs, 0);
  root = api_add_uint32(root, "Calls", &stats->getwork_calls, 0);
  root = api_add_timeval(root, "Wait", &stats->getwork_wait, 0);
  root = api_add_timeval(root, "Max", &stats->getwork_wait_max, 0);
  root = api_add_timeval(root, "Min", &stats->getwork_wait_min, 0);
  root = api_add_string(root, "GHS 5s", displayed_hash_rate, 0);
  root = api_add_mhs(root, "GHS av", &ghs, 0);
  root = api_add_string(root, "Voltage", displayed_working_voltage, 0);
  root = api_add_string(root, "Mode", displayed_mode, 0);
  if ( extra )
    root = api_add_extra(root, extra);
  print_data(io_dataa, root, isjson, 1);
  return ia + 1;
}
// 81A54: variable 'v8' is possibly undefined

//----- (00081BF8) --------------------------------------------------------
void __cdecl minerstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  api_data *v5; // r0
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  unsigned __int8 id[20]; // [sp+24h] [bp-30h] BYREF
  cgpu_info *cgpu; // [sp+38h] [bp-1Ch]
  api_data *root; // [sp+3Ch] [bp-18h]
  int j; // [sp+40h] [bp-14h]
  int i; // [sp+44h] [bp-10h]
  api_data *extra; // [sp+48h] [bp-Ch]
  bool io_open; // [sp+4Fh] [bp-5h]

  root = 0;
  io_open = 0;
  message(io_data, 70, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"STATS\":[");
  v5 = api_add_string(root, "BMMiner", "2.0.0", 0);
  v6 = api_add_string(v5, "Miner", g_miner_version, 0);
  v7 = api_add_string(v6, "CompileTime", g_miner_compiletime, 0);
  v8 = api_add_string(v7, "Type", g_miner_type, 0);
  root = print_data(io_data, v8, isjson, 0);
  i = 0;
  for ( j = 0; j < total_devices; ++j )
  {
    cgpu = get_devices(j);
    if ( cgpu && cgpu->drv )
    {
      if ( cgpu->drv->get_api_stats )
        extra = cgpu->drv->get_api_stats(cgpu);
      else
        extra = 0;
      sprintf((char *)id, "%s%d", (const char *)cgpu->drv->name, cgpu->device_id);
      i = itemstats(io_data, i, id, &cgpu->cgminer_stats, 0, extra, cgpu, isjson);
    }
  }
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00081E24) --------------------------------------------------------
void __cdecl minerestats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 id[20]; // [sp+20h] [bp-2Ch] BYREF
  cgpu_info *cgpu; // [sp+34h] [bp-18h]
  int j; // [sp+38h] [bp-14h]
  int i; // [sp+3Ch] [bp-10h]
  api_data *extra; // [sp+40h] [bp-Ch]
  bool io_open; // [sp+47h] [bp-5h]

  io_open = 0;
  message(io_data, 70, 0, 0, isjson);
  if ( isjson )
    io_open = io_add(io_data, ",\"STATS\":[");
  i = 0;
  for ( j = 0; j < total_devices; ++j )
  {
    cgpu = get_devices(j);
    if ( cgpu && cgpu->drv )
    {
      if ( cgpu->drv->get_api_stats )
        extra = cgpu->drv->get_api_stats(cgpu);
      else
        extra = 0;
      sprintf((char *)id, "%s%d", (const char *)cgpu->drv->name, cgpu->device_id);
      i = itemstats(io_data, i, id, &cgpu->cgminer_stats, 0, extra, cgpu, isjson);
    }
  }
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00081FB8) --------------------------------------------------------
void __cdecl failoveronly(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 126, 0, param, isjson);
}

//----- (00081FFC) --------------------------------------------------------
void __cdecl minecoin(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  bool io_open; // [sp+1Bh] [bp-9h]
  api_data *root; // [sp+1Ch] [bp-8h]
  api_data *roota; // [sp+1Ch] [bp-8h]

  message(io_data, 78, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"COIN\":[";
  else
    v5 = "COIN,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_const(0, "Hash Method", SHA256STR, 0);
  cg_rlock_1(&ch_lock, "api-btm.c", _func___12046, 3673);
  v6 = api_add_timeval(root, "Current Block Time", &block_timeval, 1);
  roota = api_add_string(v6, "Current Block Hash", current_hash, 1);
  cg_runlock_1(&ch_lock, "api-btm.c", _func___12046, 3676);
  v7 = api_add_bool(roota, "LP", &have_longpoll, 0);
  v8 = api_add_diff(v7, "Network Difficulty", &current_diff, 1);
  print_data(io_data, v8, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00082198) --------------------------------------------------------
void __cdecl debugstate(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  api_data *v6; // r0
  api_data *v7; // r0
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  const unsigned __int8 *parama; // [sp+Ch] [bp-18h]
  bool io_open; // [sp+1Bh] [bp-9h]

  parama = param;
  if ( param )
    *param = tolower(*param);
  else
    parama = BLANK;
  switch ( *parama )
  {
    case 'd':
      opt_debug = !opt_debug;
      opt_log_output = opt_debug;
      if ( opt_debug )
        opt_quiet = 0;
      break;
    case 'n':
      opt_log_output = 0;
      opt_debug = 0;
      opt_quiet = 0;
      opt_protocol = 0;
      want_per_device_stats = 0;
      opt_worktime = 0;
      break;
    case 'p':
      want_per_device_stats = !want_per_device_stats;
      opt_log_output = want_per_device_stats;
      break;
    case 'q':
      opt_quiet = !opt_quiet;
      break;
    case 'r':
      opt_protocol = !opt_protocol;
      if ( opt_protocol )
        opt_quiet = 0;
      break;
    case 's':
      opt_realquiet = 1;
      break;
    case 'v':
      opt_log_output = !opt_log_output;
      if ( opt_log_output )
        opt_quiet = 0;
      break;
    case 'w':
      opt_worktime = !opt_worktime;
      break;
    default:
      break;
  }
  message(io_data, 79, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"DEBUG\":[";
  else
    v5 = "DEBUG,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  v6 = api_add_bool(0, "Silent", &opt_realquiet, 0);
  v7 = api_add_bool(v6, "Quiet", &opt_quiet, 0);
  v8 = api_add_bool(v7, "Verbose", &opt_log_output, 0);
  v9 = api_add_bool(v8, "Debug", &opt_debug, 0);
  v10 = api_add_bool(v9, "RPCProto", &opt_protocol, 0);
  v11 = api_add_bool(v10, "PerDevice", &want_per_device_stats, 0);
  v12 = api_add_bool(v11, "WorkTime", &opt_worktime, 0);
  print_data(io_data, v12, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}
// 82210: control flows out of bounds to 82214

//----- (00082640) --------------------------------------------------------
void __cdecl setconfig(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  if ( !strcasecmp((const char *)param, "queue")
    || !strcasecmp((const char *)param, "scantime")
    || !strcasecmp((const char *)param, "expiry") )
  {
    message(io_data, 126, 0, param, isjson);
  }
  message(io_data, 83, 0, param, isjson);
}

//----- (000826F4) --------------------------------------------------------
void __cdecl usbstats(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 88, 0, 0, isjson);
}

//----- (0008274C) --------------------------------------------------------
void __cdecl dozero(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  char *v6; // r3
  char *v7; // r3
  bool dosum; // [sp+19h] [bp-Bh]
  bool bs; // [sp+1Ah] [bp-Ah]
  bool all; // [sp+1Bh] [bp-9h]
  unsigned __int8 *sum; // [sp+1Ch] [bp-8h]

  if ( param && *param )
  {
    sum = (unsigned __int8 *)strchr((const char *)param, 44);
    if ( sum )
    {
      v5 = sum++;
      *v5 = 0;
    }
    if ( sum && *sum )
    {
      all = 0;
      bs = 0;
      if ( !strcasecmp((const char *)param, "all") )
      {
        all = 1;
      }
      else if ( !strcasecmp((const char *)param, "bestshare") )
      {
        bs = 1;
      }
      if ( !all && !bs )
      {
        message(io_data, 95, 0, param, isjson);
      }
      else
      {
        *sum = tolower(*sum);
        if ( *sum == 116 || *sum == 102 )
        {
          dosum = *sum == 116;
          if ( *sum == 116 )
            print_summary();
          if ( all )
            zero_stats();
          if ( bs )
            zero_bestshare();
          if ( dosum )
          {
            if ( all )
              v6 = "All";
            else
              v6 = "BestShare";
            message(io_data, 96, 0, (unsigned __int8 *)v6, isjson);
          }
          else
          {
            if ( all )
              v7 = "All";
            else
              v7 = "BestShare";
            message(io_data, 97, 0, (unsigned __int8 *)v7, isjson);
          }
        }
        else
        {
          message(io_data, 76, 0, 0, isjson);
        }
      }
    }
    else
    {
      message(io_data, 75, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 94, 0, 0, isjson);
  }
}

//----- (000829E4) --------------------------------------------------------
void __cdecl dohotplug(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  message(io_data, 102, 0, 0, isjson);
}

//----- (00082A28) --------------------------------------------------------
void __cdecl ascdev(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int id; // [sp+1Ch] [bp-10h]
  int numasc; // [sp+20h] [bp-Ch]
  bool io_open; // [sp+27h] [bp-5h]

  io_open = 0;
  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc )
      {
        message(io_data, 106, id, 0, isjson);
        if ( isjson )
          io_open = io_add(io_data, ",\"ASC\":[");
        ascstatus(io_data, id, isjson, 0);
        if ( isjson && io_open )
          io_close(io_data);
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (00082B80) --------------------------------------------------------
void __cdecl ascenable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 tmp42[2048]; // [sp+24h] [bp-820h] BYREF
  int asc; // [sp+824h] [bp-20h]
  thr_info *thr; // [sp+828h] [bp-1Ch]
  cgpu_info *cgpu; // [sp+82Ch] [bp-18h]
  int dev; // [sp+830h] [bp-14h]
  int id; // [sp+834h] [bp-10h]
  int numasc; // [sp+838h] [bp-Ch]
  int i; // [sp+83Ch] [bp-8h]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: request to ascenable ascid %d device %d %s%u",
            id,
            dev,
            (const char *)cgpu->drv->name,
            cgpu->device_id);
          applog(7, tmp42, 0);
        }
        if ( cgpu->deven == DEV_DISABLED )
        {
          for ( i = 0; i < mining_threads; ++i )
          {
            thr = get_thread(i);
            asc = thr->cgpu->cgminer_id;
            if ( asc == dev )
            {
              cgpu->deven = DEV_ENABLED;
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf((char *)tmp42, 0x800u, "API: Pushing sem post to thread %d", thr->id);
                applog(7, tmp42, 0);
              }
              cgsem_post(&thr->sem, "api-btm.c", _func___12125, 4071);
            }
          }
          message(io_data, 110, id, 0, isjson);
        }
        else
        {
          message(io_data, 108, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (00082EB4) --------------------------------------------------------
void __cdecl ascdisable(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 tmp42[2048]; // [sp+20h] [bp-814h] BYREF
  cgpu_info *cgpu; // [sp+820h] [bp-14h]
  int dev; // [sp+824h] [bp-10h]
  int id; // [sp+828h] [bp-Ch]
  int numasc; // [sp+82Ch] [bp-8h]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: request to ascdisable ascid %d device %d %s%u",
            id,
            dev,
            (const char *)cgpu->drv->name,
            cgpu->device_id);
          applog(7, tmp42, 0);
        }
        if ( cgpu->deven == DEV_DISABLED )
        {
          message(io_data, 109, id, 0, isjson);
        }
        else
        {
          cgpu->deven = DEV_DISABLED;
          message(io_data, 111, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (000830D4) --------------------------------------------------------
void __cdecl ascidentify(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  device_drv *drv; // [sp+1Ch] [bp-18h]
  cgpu_info *cgpu; // [sp+20h] [bp-14h]
  int dev; // [sp+24h] [bp-10h]
  int id; // [sp+28h] [bp-Ch]
  int numasc; // [sp+2Ch] [bp-8h]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      id = atoi((const char *)param);
      if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
      {
        cgpu = get_devices(dev);
        drv = cgpu->drv;
        if ( drv->identify_device )
        {
          drv->identify_device(cgpu);
          message(io_data, 113, id, 0, isjson);
        }
        else
        {
          message(io_data, 114, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 107, id, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (0008325C) --------------------------------------------------------
void __cdecl asccount(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  char *v5; // r3
  int count; // [sp+1Ch] [bp-10h] BYREF
  bool io_open; // [sp+23h] [bp-9h]
  api_data *root; // [sp+24h] [bp-8h]

  root = 0;
  count = numascs();
  message(io_data, 104, 0, 0, isjson);
  if ( isjson )
    v5 = ",\"ASCS\":[";
  else
    v5 = "ASCS,";
  io_open = io_add(io_data, (unsigned __int8 *)v5);
  root = api_add_int(root, "Count", &count, 0);
  root = print_data(io_data, root, isjson, 0);
  if ( isjson && io_open )
    io_close(io_data);
}

//----- (00083344) --------------------------------------------------------
void __cdecl ascset(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  unsigned __int8 *v5; // r3
  unsigned __int8 *v6; // r3
  unsigned __int8 buf[8192]; // [sp+18h] [bp-202Ch] BYREF
  unsigned __int8 *ret; // [sp+2018h] [bp-2Ch]
  device_drv *drv; // [sp+201Ch] [bp-28h]
  cgpu_info *cgpu; // [sp+2020h] [bp-24h]
  int dev; // [sp+2024h] [bp-20h]
  int id; // [sp+2028h] [bp-1Ch]
  int numasc; // [sp+202Ch] [bp-18h]
  unsigned __int8 *set; // [sp+2030h] [bp-14h]
  unsigned __int8 *opt; // [sp+2034h] [bp-10h]

  numasc = numascs();
  if ( numasc )
  {
    if ( param && *param )
    {
      opt = (unsigned __int8 *)strchr((const char *)param, 44);
      if ( opt )
      {
        v5 = opt++;
        *v5 = 0;
      }
      if ( opt && *opt )
      {
        id = atoi((const char *)param);
        if ( id >= 0 && id < numasc && (dev = ascdevice(id), dev >= 0) )
        {
          cgpu = get_devices(dev);
          drv = cgpu->drv;
          set = (unsigned __int8 *)strchr((const char *)opt, 44);
          if ( set )
          {
            v6 = set++;
            *v6 = 0;
          }
          if ( drv->set_device )
          {
            ret = drv->set_device(cgpu, opt, set, buf);
            if ( ret )
            {
              if ( !strcasecmp((const char *)opt, "help") )
                message(io_data, 118, id, ret, isjson);
              else
                message(io_data, 120, id, ret, isjson);
            }
            else
            {
              message(io_data, 119, id, 0, isjson);
            }
          }
          else
          {
            message(io_data, 117, id, 0, isjson);
          }
        }
        else
        {
          message(io_data, 107, id, 0, isjson);
        }
      }
      else
      {
        message(io_data, 116, 0, 0, isjson);
      }
    }
    else
    {
      message(io_data, 15, 0, 0, isjson);
    }
  }
  else
  {
    message(io_data, 105, 0, 0, isjson);
  }
}

//----- (000836E4) --------------------------------------------------------
void __cdecl checkcommand(io_data *io_data, int c, unsigned __int8 *param, bool isjson, unsigned __int8 group)
{
  int v5; // r4
  int v6; // r4
  int v7; // r0
  char *v8; // r3
  const unsigned __int8 *v9; // r2
  const unsigned __int8 *v10; // r2
  unsigned __int8 cmdbuf[100]; // [sp+1Ch] [bp-80h] BYREF
  bool io_open; // [sp+83h] [bp-19h]
  api_data *root; // [sp+84h] [bp-18h]
  int i; // [sp+88h] [bp-14h]
  bool access; // [sp+8Eh] [bp-Eh]
  bool found; // [sp+8Fh] [bp-Dh]

  root = 0;
  if ( param && *param )
  {
    found = 0;
    access = 0;
    for ( i = 0; cmds[i].name; ++i )
    {
      if ( !strcmp((const char *)cmds[i].name, (const char *)param) )
      {
        found = 1;
        sprintf((char *)cmdbuf, "|%s|", (const char *)param);
        v5 = toupper(group);
        if ( v5 == toupper(87)
          || (v6 = toupper(group),
              v7 = toupper(65),
              strstr((const char *)apigroups[v6 - v7].commands, (const char *)cmdbuf)) )
        {
          access = 1;
        }
        break;
      }
    }
    message(io_data, 72, 0, 0, isjson);
    if ( isjson )
      v8 = ",\"CHECK\":[";
    else
      v8 = "CHECK,";
    io_open = io_add(io_data, (unsigned __int8 *)v8);
    if ( found )
      v9 = YES;
    else
      v9 = NO;
    root = api_add_const(root, "Exists", v9, 0);
    if ( access )
      v10 = YES;
    else
      v10 = NO;
    root = api_add_const(root, "Access", v10, 0);
    root = print_data(io_data, root, isjson, 0);
    if ( isjson && io_open )
      io_close(io_data);
  }
  else
  {
    message(io_data, 71, 0, 0, isjson);
  }
}

//----- (00083984) --------------------------------------------------------
void __cdecl head_join(io_data *io_data, unsigned __int8 *cmdptr, bool isjson, bool *firstjoin)
{
  unsigned __int8 *ptr; // [sp+14h] [bp-8h]

  if ( *firstjoin )
  {
    if ( isjson )
      io_add(io_data, "{");
    *firstjoin = 0;
  }
  else if ( isjson )
  {
    io_add(io_data, ",");
  }
  ptr = escape_string(cmdptr, isjson);
  if ( isjson )
  {
    io_add(io_data, "\"");
    io_add(io_data, ptr);
    io_add(io_data, "\":[");
  }
  else
  {
    io_add(io_data, "CMD=");
    io_add(io_data, ptr);
    io_add(io_data, "|");
  }
  if ( ptr != cmdptr )
    free(ptr);
}

//----- (00083A9C) --------------------------------------------------------
void __cdecl tail_join(io_data *io_data, bool isjson)
{
  if ( io_data->close )
  {
    io_add(io_data, "]");
    io_data->close = 0;
  }
  if ( isjson )
  {
    io_add(io_data, ",\"id\":1}");
    io_add(io_data, "]");
  }
}

//----- (00083B18) --------------------------------------------------------
void __cdecl send_result(io_data *io_data, int c, bool isjson)
{
  const char *v3; // r3
  int v4; // r3
  int v5; // r5
  int v6; // r4
  int *v7; // r0
  char *v8; // r0
  fd_set wd; // [sp+1Ch] [bp-8B8h] BYREF
  unsigned __int8 tmp42[2048]; // [sp+9Ch] [bp-838h] BYREF
  timeval timeout; // [sp+89Ch] [bp-38h] BYREF
  int n; // [sp+8A4h] [bp-30h]
  int res; // [sp+8A8h] [bp-2Ch]
  fd_set *__arr; // [sp+8ACh] [bp-28h]
  int len; // [sp+8B0h] [bp-24h]
  unsigned int __i; // [sp+8B4h] [bp-20h]
  unsigned __int8 *buf; // [sp+8B8h] [bp-1Ch]
  int tosend; // [sp+8BCh] [bp-18h]
  int sendc; // [sp+8C0h] [bp-14h]
  int count; // [sp+8C4h] [bp-10h]

  buf = io_data->ptr;
  strcpy((char *)buf, (const char *)io_data->ptr);
  if ( io_data->close )
    strcat((char *)buf, "]");
  if ( isjson )
    strcat((char *)buf, ",\"id\":1}");
  len = strlen((const char *)buf);
  tosend = len + 1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( len > 10 )
      v3 = "...";
    else
      v3 = (const char *)BLANK;
    snprintf((char *)tmp42, 0x800u, "API: send reply: (%d) '%.10s%s'", tosend, (const char *)buf, v3);
    applog(7, tmp42, 0);
  }
  sendc = 0;
  count = 0;
  while ( count <= 4 && tosend > 0 )
  {
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    __arr = &wd;
    for ( __i = 0; __i <= 0x1F; ++__i )
      __arr->fds_bits[__i] = 0;
    LOBYTE(v4) = c & 0x1F;
    if ( c <= 0 )
      v4 = -(-c & 0x1F);
    wd.fds_bits[c / 32] |= 1 << v4;
    res = select(c + 1, 0, &wd, 0, &timeout);
    if ( res <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42, 0x800u, "API: send select failed (%d)", res);
        applog(4, tmp42, 0);
      }
      return;
    }
    n = send(c, buf, tosend, 0);
    ++sendc;
    if ( n >= 0 )
    {
      if ( sendc > 1 )
      {
        if ( n == tosend )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf((char *)tmp42, 0x800u, "API: sent all of remaining %d (sendc=%d)", tosend, sendc);
            applog(7, tmp42, 0);
          }
        }
        else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent %d of remaining %d (sendc=%d)", n, tosend, sendc);
          applog(7, tmp42, 0);
        }
      }
      else if ( n == tosend )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)tmp42, 0x800u, "API: sent all of %d first go", tosend);
          applog(7, tmp42, 0);
        }
      }
      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x800u, "API: sent %d of %d first go", n, tosend);
        applog(7, tmp42, 0);
      }
      tosend -= n;
      buf += n;
      if ( !n )
        ++count;
    }
    else
    {
      ++count;
      if ( !sock_blocks_0() )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          v5 = len + 1;
          v6 = len + 1 - tosend;
          v7 = _errno_location();
          v8 = strerror(*v7);
          snprintf((char *)tmp42, 0x800u, "API: send (%d:%d) failed: %s", v5, v6, v8);
          applog(4, tmp42, 0);
        }
        return;
      }
    }
  }
}

//----- (00084218) --------------------------------------------------------
void __cdecl tidyup(void *arg)
{
  mutex_lock_3(&quit_restart_lock, "api-btm.c", _func___12255, 4569);
  bye = 1;
  if ( *(_DWORD *)arg != -1 )
  {
    shutdown(*(_DWORD *)arg, 2);
    close(*(_DWORD *)arg);
    *(_DWORD *)arg = -1;
  }
  if ( ipaccess )
  {
    free(ipaccess);
    ipaccess = 0;
  }
  io_free();
  mutex_unlock_3(&quit_restart_lock, "api-btm.c", _func___12255, 4590);
}

//----- (00084308) --------------------------------------------------------
void setup_groups()
{
  unsigned __int8 *v0; // r3
  size_t v1; // r0
  unsigned __int8 *v2; // r3
  int v3; // r4
  int v4; // r4
  int v5; // r4
  int v6; // r0
  int v7; // r4
  int v8; // r0
  int v9; // r4
  unsigned __int8 *v10; // r3
  unsigned __int8 *v11; // r3
  unsigned __int8 *v12; // r3
  uint32_t v13; // r5
  int v14; // r4
  int v15; // r4
  unsigned __int8 *v16; // r3
  uint32_t v17; // r5
  int v18; // r0
  int v19; // r4
  int v20; // r4
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-2894h] BYREF
  unsigned __int8 cmdbuf[100]; // [sp+808h] [bp-2094h] BYREF
  unsigned __int8 commands[8192]; // [sp+86Ch] [bp-2030h] BYREF
  unsigned __int8 group; // [sp+286Fh] [bp-2Dh]
  unsigned __int8 *buf; // [sp+2870h] [bp-2Ch]
  unsigned __int8 *api_groups; // [sp+2874h] [bp-28h]
  int i; // [sp+2878h] [bp-24h]
  bool did; // [sp+287Eh] [bp-1Eh]
  bool addstar; // [sp+287Fh] [bp-1Dh]
  unsigned __int8 *cmd; // [sp+2880h] [bp-1Ch]
  unsigned __int8 *colon; // [sp+2884h] [bp-18h]
  unsigned __int8 *next; // [sp+2888h] [bp-14h]
  unsigned __int8 *ptr; // [sp+288Ch] [bp-10h]

  if ( opt_api_groups )
    v0 = opt_api_groups;
  else
    v0 = (unsigned __int8 *)BLANK;
  api_groups = v0;
  v1 = strlen((const char *)v0);
  buf = (unsigned __int8 *)cgmalloc(v1 + 1, "api-btm.c", _func___12271, 4607);
  strcpy((char *)buf, (const char *)api_groups);
  next = buf;
  while ( next && *next )
  {
    ptr = next;
    next = (unsigned __int8 *)strchr((const char *)next, 44);
    if ( next )
    {
      v2 = next++;
      *v2 = 0;
    }
    if ( ptr[1] != 58 )
    {
      colon = (unsigned __int8 *)strchr((const char *)ptr, 58);
      if ( colon )
        *colon = 0;
      snprintf((char *)tmp42, 0x800u, "API invalid group name '%s'", (const char *)ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    group = toupper(*ptr);
    v3 = toupper(group);
    if ( v3 < toupper(65) || (v4 = toupper(group), v4 > toupper(90)) )
    {
      snprintf((char *)tmp42, 0x800u, "API invalid group name '%c'", *ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    v5 = group;
    if ( v5 == toupper(87) )
    {
      v6 = toupper(87);
      snprintf((char *)tmp42, 0x800u, "API group name can't be '%c'", v6);
      applog(3, tmp42, 1);
      quit(1);
    }
    v7 = group;
    if ( v7 == toupper(82) )
    {
      v8 = toupper(82);
      snprintf((char *)tmp42, 0x800u, "API group name can't be '%c'", v8);
      applog(3, tmp42, 1);
      quit(1);
    }
    v9 = toupper(group);
    if ( apigroups[v9 - toupper(65)].commands )
    {
      snprintf((char *)tmp42, 0x800u, "API duplicate group name '%c'", *ptr);
      applog(3, tmp42, 1);
      quit(1);
    }
    ptr += 2;
    cmd = &commands[1];
    strcpy((char *)commands, "|");
    addstar = 0;
    while ( ptr && *ptr )
    {
      colon = (unsigned __int8 *)strchr((const char *)ptr, 58);
      if ( colon )
      {
        v10 = colon++;
        *v10 = 0;
      }
      if ( !strcmp((const char *)ptr, "*") )
      {
        addstar = 1;
      }
      else
      {
        did = 0;
        for ( i = 0; cmds[i].name; ++i )
        {
          if ( !strcasecmp((const char *)ptr, (const char *)cmds[i].name) )
          {
            did = 1;
            break;
          }
        }
        if ( !did )
        {
          snprintf((char *)tmp42, 0x800u, "API unknown command '%s' in group '%c'", (const char *)ptr, group);
          applog(3, tmp42, 1);
          quit(1);
        }
        sprintf((char *)cmdbuf, "|%s|", (const char *)cmds[i].name);
        if ( !strstr((const char *)commands, (const char *)cmdbuf) )
        {
          strcpy((char *)cmd, (const char *)cmds[i].name);
          cmd += strlen((const char *)cmds[i].name);
          v11 = cmd++;
          *v11 = 124;
          *cmd = 0;
        }
      }
      ptr = colon;
    }
    if ( addstar )
    {
      for ( i = 0; cmds[i].name; ++i )
      {
        if ( !cmds[i].iswritemode )
        {
          sprintf((char *)cmdbuf, "|%s|", (const char *)cmds[i].name);
          if ( !strstr((const char *)commands, (const char *)cmdbuf) )
          {
            strcpy((char *)cmd, (const char *)cmds[i].name);
            cmd += strlen((const char *)cmds[i].name);
            v12 = cmd++;
            *v12 = 124;
            *cmd = 0;
          }
        }
      }
    }
    v13 = strlen((const char *)commands) + 1;
    v14 = toupper(group);
    v15 = v14 - toupper(65);
    apigroups[v15].commands = (unsigned __int8 *)cgmalloc(v13, "api-btm.c", _func___12271, 4709);
    ptr = apigroups[v15].commands;
    strcpy((char *)ptr, (const char *)commands);
  }
  cmd = &commands[1];
  strcpy((char *)commands, "|");
  for ( i = 0; cmds[i].name; ++i )
  {
    if ( !cmds[i].iswritemode )
    {
      strcpy((char *)cmd, (const char *)cmds[i].name);
      cmd += strlen((const char *)cmds[i].name);
      v16 = cmd++;
      *v16 = 124;
      *cmd = 0;
    }
  }
  v17 = strlen((const char *)commands) + 1;
  v18 = toupper(82);
  v19 = toupper(v18);
  v20 = v19 - toupper(65);
  apigroups[v20].commands = (unsigned __int8 *)cgmalloc(v17, "api-btm.c", _func___12271, 4729);
  ptr = apigroups[v20].commands;
  strcpy((char *)ptr, (const char *)commands);
  free(buf);
}

//----- (00084CF8) --------------------------------------------------------
void setup_ipaccess()
{
  size_t v0; // r0
  unsigned __int8 *v1; // r3
  unsigned __int8 *v2; // r3
  int v3; // r4
  int v4; // r4
  unsigned __int8 *v5; // r3
  unsigned __int8 *v6; // r3
  unsigned __int8 *v7; // r3
  unsigned __int8 *v8; // r3
  int v9; // r3
  int v11; // r3
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-8B8h] BYREF
  unsigned __int8 original[64]; // [sp+80Ch] [bp-B8h] BYREF
  unsigned __int8 tmp[64]; // [sp+84Ch] [bp-78h] BYREF
  unsigned __int8 *dot; // [sp+88Ch] [bp-38h]
  unsigned __int8 *slash; // [sp+890h] [bp-34h]
  unsigned __int8 *buf; // [sp+894h] [bp-30h]
  unsigned __int8 group; // [sp+89Ah] [bp-2Ah]
  bool ipv6; // [sp+89Bh] [bp-29h]
  int shift; // [sp+89Ch] [bp-28h]
  int i; // [sp+8A0h] [bp-24h]
  int mask; // [sp+8A4h] [bp-20h]
  int ipcount; // [sp+8A8h] [bp-1Ch]
  unsigned __int8 *end; // [sp+8ACh] [bp-18h]
  unsigned __int8 *comma; // [sp+8B0h] [bp-14h]
  unsigned __int8 *ptr; // [sp+8B4h] [bp-10h]

  ipv6 = 0;
  v0 = strlen((const char *)opt_api_allow);
  buf = (unsigned __int8 *)cgmalloc(v0 + 1, "api-btm.c", _func___12309, 4756);
  strcpy((char *)buf, (const char *)opt_api_allow);
  ipcount = 1;
  ptr = buf;
  while ( *ptr )
  {
    v1 = ptr++;
    if ( *v1 == 44 )
      ++ipcount;
  }
  ipaccess = (IPACCESS *)cgcalloc(ipcount, 0x24u, "api-btm.c", _func___12309, 4767);
  ips = 0;
  ptr = buf;
  while ( ptr && *ptr )
  {
    while ( *ptr == 32 || *ptr == 9 )
      ++ptr;
    if ( *ptr == 44 )
    {
      ++ptr;
    }
    else
    {
      comma = (unsigned __int8 *)strchr((const char *)ptr, 44);
      if ( comma )
      {
        v2 = comma++;
        *v2 = 0;
      }
      strncpy((char *)original, (const char *)ptr, 0x40u);
      original[63] = 0;
      group = toupper(82);
      if ( ((*_ctype_b_loc())[*ptr] & 0x400) != 0 && ptr[1] == 58 )
      {
        v3 = toupper(*ptr);
        if ( v3 == toupper(87) || (v4 = toupper(*ptr), apigroups[v4 - toupper(65)].commands) )
          group = toupper(*ptr);
        ptr += 2;
      }
      ipaccess[ips].group = group;
      if ( !strcmp((const char *)ptr, "0/0") )
      {
        for ( i = 0; i <= 15; ++i )
        {
          ipaccess[ips].ip.__u6_addr8[i] = 0;
          ipaccess[ips].mask.__u6_addr8[i] = 0;
        }
LABEL_74:
        ++ips;
        goto popipo;
      }
      end = (unsigned __int8 *)strchr((const char *)ptr, 47);
      if ( !end )
      {
        for ( i = 0; i <= 15; ++i )
          ipaccess[ips].mask.__u6_addr8[i] = -1;
        end = &ptr[strlen((const char *)ptr)];
      }
      v5 = end--;
      slash = v5;
      if ( *ptr == 91 && *end == 93 )
      {
        v6 = ptr++;
        *v6 = 0;
        v7 = end--;
        *v7 = 0;
        ipv6 = 1;
      }
      else
      {
        ipv6 = 0;
      }
      if ( *slash )
      {
        v8 = slash++;
        *v8 = 0;
        mask = atoi((const char *)slash);
        if ( mask <= 0 || (!ipv6 ? (v9 = 96) : (v9 = 0), mask += v9, mask > 128) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "API: ignored address with invalid mask (%d) '%s'",
              mask,
              (const char *)original);
            applog(3, tmp42, 0);
          }
          goto popipo;
        }
        for ( i = 0; i <= 15; ++i )
          ipaccess[ips].mask.__u6_addr8[i] = 0;
        i = 0;
        shift = 7;
        while ( 1 )
        {
          v11 = mask--;
          if ( v11 <= 0 )
            break;
          ipaccess[ips].mask.__u6_addr8[i] |= 1 << shift;
          if ( !shift-- )
          {
            ++i;
            shift = 7;
          }
        }
      }
      for ( i = 0; i <= 15; ++i )
        ipaccess[ips].ip.__u6_addr8[i] = 0;
      if ( ipv6 )
      {
        if ( inet_pton(10, (const char *)ptr, &ipaccess[ips]) == 1 )
          goto LABEL_71;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x800u, "API: ignored invalid IPv6 address '%s'", (const char *)original);
          applog(3, tmp42, 0);
        }
      }
      else
      {
        dot = (unsigned __int8 *)strchr((const char *)ptr, 46);
        if ( dot )
        {
          dot = (unsigned __int8 *)strchr((const char *)dot + 1, 46);
          if ( dot )
          {
            dot = (unsigned __int8 *)strchr((const char *)dot + 1, 46);
            if ( dot )
              snprintf((char *)tmp, 0x40u, "::ffff:%s", (const char *)ptr);
            else
              snprintf((char *)tmp, 0x40u, "::ffff:%s.0", (const char *)ptr);
          }
          else
          {
            snprintf((char *)tmp, 0x40u, "::ffff:%s.0.0", (const char *)ptr);
          }
        }
        else
        {
          snprintf((char *)tmp, 0x40u, "::ffff:%s.0.0.0", (const char *)ptr);
        }
        if ( inet_pton(10, (const char *)tmp, &ipaccess[ips]) == 1 )
        {
LABEL_71:
          for ( i = 0; i <= 15; ++i )
            ipaccess[ips].ip.__u6_addr8[i] &= ipaccess[ips].mask.__u6_addr8[i];
          goto LABEL_74;
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API: ignored invalid IPv4 address '%s' (as %s)",
            (const char *)original,
            (const char *)tmp);
          applog(3, tmp42, 0);
        }
      }
popipo:
      ptr = comma;
    }
  }
  free(buf);
}

//----- (000857EC) --------------------------------------------------------
void *__cdecl __noreturn quit_thread(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-804h] BYREF

  mutex_lock_3(&quit_restart_lock, "api-btm.c", _func___12344, 4925);
  mutex_unlock_3(&quit_restart_lock, "api-btm.c", _func___12344, 4926);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "API: killing cgminer");
    applog(7, tmp42, 0);
  }
  kill_work();
}

//----- (000858F0) --------------------------------------------------------
void __fastcall sub_858F0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R11,PC} }
}
// 858FC: unbalanced stack, ignored a potential tail call

//----- (00085900) --------------------------------------------------------
void *__cdecl restart_thread_0(void *userdata)
{
  unsigned __int8 tmp42[2048]; // [sp+8h] [bp-804h] BYREF

  mutex_lock_3(&quit_restart_lock, "api-btm.c", _func___12349, 4939);
  mutex_unlock_3(&quit_restart_lock, "api-btm.c", _func___12349, 4940);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy((char *)tmp42, "API: restarting cgminer");
    applog(7, tmp42, 0);
  }
  app_restart();
  return 0;
}

//----- (00085A0C) --------------------------------------------------------
bool __cdecl check_connect(sockaddr_storage *cli, unsigned __int8 **connectaddr, unsigned __int8 *group)
{
  uint32_t v3; // r4
  bool v5; // r3
  in6_addr client_ip; // [sp+24h] [bp-50h] BYREF
  unsigned __int8 tmp[30]; // [sp+34h] [bp-40h] BYREF
  const in6_addr *__a; // [sp+54h] [bp-20h]
  bool match; // [sp+5Bh] [bp-19h]
  int j; // [sp+5Ch] [bp-18h]
  int i; // [sp+60h] [bp-14h]
  bool addrok; // [sp+67h] [bp-Dh]

  addrok = 0;
  *connectaddr = (unsigned __int8 *)cgmalloc(0x2Eu, "api-btm.c", _func___12362, 4958);
  getnameinfo((const struct sockaddr *)cli, 0x80u, (char *)*connectaddr, 0x2Eu, 0, 0, 1u);
  if ( cli->ss_family == 2 )
  {
    sprintf((char *)tmp, "::ffff:%s", (const char *)*connectaddr);
    inet_pton(10, (const char *)tmp, &client_ip);
  }
  else
  {
    inet_pton(10, (const char *)*connectaddr, &client_ip);
  }
  *group = toupper(82);
  if ( opt_api_allow )
  {
    for ( i = 0; i < ips; ++i )
    {
      match = 1;
      for ( j = 0; j <= 15; ++j )
      {
        if ( (unsigned __int8)(ipaccess[i].mask.__u6_addr8[j] & client_ip.__u6_addr8[j]) != ipaccess[i].ip.__u6_addr8[j] )
        {
          match = 0;
          break;
        }
      }
      if ( match )
      {
        addrok = 1;
        *group = ipaccess[i].group;
        return addrok;
      }
    }
  }
  else if ( opt_api_network )
  {
    return 1;
  }
  else
  {
    v5 = 1;
    if ( strcmp((const char *)*connectaddr, (const char *)localaddr) )
    {
      __a = &client_ip;
      if ( client_ip.__u6_addr32[0] )
        return 0;
      if ( __a->__u6_addr32[1] )
        return 0;
      if ( __a->__u6_addr32[2] )
        return 0;
      v3 = __a->__u6_addr32[3];
      if ( v3 != htonl(1u) )
        return 0;
    }
    return v5;
  }
  return addrok;
}
// 85D10: masking with 0x1 was optimized away because r3.1 <= 0x1

//----- (00085D24) --------------------------------------------------------
void mcast()
{
  int *v0; // r0
  char *v1; // r0
  int *v2; // r0
  int ai_family; // r3
  int *v4; // r0
  char *v5; // r0
  int *v6; // r0
  char *v7; // r0
  size_t v8; // r0
  int *v9; // r0
  char *v10; // r0
  const char *v11; // r3
  size_t v12; // r0
  int *v13; // r0
  char *v14; // r0
  unsigned __int8 tmp42[2048]; // [sp+14h] [bp-1128h] BYREF
  ipv6_mreq grp_0; // [sp+814h] [bp-928h] BYREF
  ip_mreq grp; // [sp+828h] [bp-914h] BYREF
  int optval; // [sp+830h] [bp-90Ch] BYREF
  unsigned __int8 replybuf[1024]; // [sp+834h] [bp-908h] BYREF
  unsigned __int8 buf[1024]; // [sp+C34h] [bp-508h] BYREF
  unsigned __int8 expect[9]; // [sp+1034h] [bp-108h] BYREF
  addrinfo *res; // [sp+1040h] [bp-FCh] BYREF
  addrinfo hints; // [sp+1044h] [bp-F8h] BYREF
  unsigned __int8 came_from_port[10]; // [sp+1064h] [bp-D8h] BYREF
  unsigned __int8 port_s[10]; // [sp+1070h] [bp-CCh] BYREF
  unsigned __int8 group; // [sp+107Bh] [bp-C1h] BYREF
  unsigned __int8 *connectaddr; // [sp+107Ch] [bp-C0h] BYREF
  socklen_t came_from_siz; // [sp+1080h] [bp-BCh] BYREF
  sockaddr_storage came_from; // [sp+1084h] [bp-B8h] BYREF
  int reply_port; // [sp+1104h] [bp-38h]
  bool addrok; // [sp+110Bh] [bp-31h]
  unsigned __int8 *expect_code; // [sp+110Ch] [bp-30h]
  size_t expect_code_len; // [sp+1110h] [bp-2Ch]
  time_t bindstart; // [sp+1114h] [bp-28h]
  addrinfo *client; // [sp+1118h] [bp-24h]
  addrinfo *host; // [sp+111Ch] [bp-20h]
  int count; // [sp+1120h] [bp-1Ch]
  int bound; // [sp+1124h] [bp-18h]
  ssize_t rep; // [sp+1128h] [bp-14h]
  int reply_sock; // [sp+112Ch] [bp-10h]
  int mcast_sock; // [sp+1130h] [bp-Ch]
  unsigned __int8 *binderror; // [sp+1134h] [bp-8h]

  mcast_sock = -1;
  reply_sock = -1;
  strcpy((char *)expect, "cgminer-");
  sprintf((char *)port_s, "%d", opt_api_mcast_port);
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  if ( getaddrinfo((const char *)opt_api_mcast_addr, (const char *)port_s, &hints, &res) )
  {
    strcpy((char *)tmp42, "Invalid API Multicast Address");
    applog(3, tmp42, 1);
    quit(1);
  }
  for ( host = res; host; host = host->ai_next )
  {
    mcast_sock = socket(res->ai_family, 2, 0);
    if ( mcast_sock > 0 )
      break;
  }
  if ( mcast_sock == -1 )
  {
    freeaddrinfo(res);
    strcpy((char *)tmp42, "API mcast could not open socket");
    applog(3, tmp42, 1);
    quit(1);
  }
  optval = 1;
  if ( setsockopt(mcast_sock, 1, 2, &optval, 4u) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v0 = _errno_location();
      v1 = strerror(*v0);
      snprintf((char *)tmp42, 0x800u, "API mcast setsockopt SO_REUSEADDR failed (%s)%s", v1, (const char *)MUNAVAILABLE);
      applog(3, tmp42, 0);
    }
    goto die;
  }
  bound = 0;
  bindstart = time(0);
  while ( !bound )
  {
    if ( bind(mcast_sock, host->ai_addr, host->ai_addrlen) >= 0 )
    {
      bound = 1;
    }
    else
    {
      v2 = _errno_location();
      binderror = (unsigned __int8 *)strerror(*v2);
      if ( time(0) - bindstart > 61 )
        break;
      cgsleep_ms(30000);
    }
  }
  if ( !bound )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42,
        0x800u,
        "API mcast bind to port %d failed (%s)%s",
        opt_api_mcast_port,
        (const char *)binderror,
        (const char *)MUNAVAILABLE);
      applog(3, tmp42, 0);
    }
    goto die;
  }
  ai_family = host->ai_family;
  if ( ai_family != 2 )
  {
    if ( ai_family == 10 )
    {
      memcpy(&grp_0, &host->ai_addr->sa_data[6], 0x10u);
      grp_0.ipv6mr_interface = 0;
      if ( setsockopt(mcast_sock, 41, 20, &grp_0, 0x14u) < 0 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          v6 = _errno_location();
          v7 = strerror(*v6);
          snprintf((char *)tmp42, 0x800u, "API mcast join failed (%s)%s", v7, (const char *)MUNAVAILABLE);
          applog(3, tmp42, 0);
        }
        goto die;
      }
    }
LABEL_38:
    freeaddrinfo(res);
    v8 = strlen((const char *)opt_api_mcast_code);
    expect_code_len = v8 + 9;
    expect_code = (unsigned __int8 *)cgmalloc(v8 + 10, "api-btm.c", _func___12417, 5118);
    snprintf((char *)expect_code, expect_code_len + 1, "%s%s-", (const char *)expect, (const char *)opt_api_mcast_code);
    count = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        cgsleep_ms(1000);
        ++count;
        came_from_siz = 128;
        rep = recvfrom(mcast_sock, buf, 0x3FFu, 0, (struct sockaddr *)&came_from, &came_from_siz);
        if ( rep >= 0 )
          break;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          v9 = _errno_location();
          v10 = strerror(*v9);
          snprintf((char *)tmp42, 0x800u, "API mcast failed count=%d (%s) (%d)", count, v10, mcast_sock);
          applog(7, tmp42, 0);
        }
      }
      addrok = check_connect(&came_from, &connectaddr, &group);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        if ( addrok )
          v11 = "Accepted";
        else
          v11 = "Ignored";
        snprintf((char *)tmp42, 0x800u, "API mcast from %s - %s", (const char *)connectaddr, v11);
        applog(7, tmp42, 0);
      }
      if ( addrok )
      {
        buf[rep] = 0;
        if ( rep > 0 && buf[rep - 1] == 10 )
          buf[--rep] = 0;
        getnameinfo((const struct sockaddr *)&came_from, came_from_siz, 0, 0, (char *)came_from_port, 0xAu, 1u);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            (char *)tmp42,
            0x800u,
            "API mcast request rep=%d (%s) from [%s]:%s",
            rep,
            (const char *)buf,
            (const char *)connectaddr,
            (const char *)came_from_port);
          applog(7, tmp42, 0);
        }
        if ( expect_code_len < rep && !memcmp(buf, expect_code, expect_code_len) )
        {
          reply_port = atoi((const char *)&buf[expect_code_len]);
          if ( reply_port > 0 && reply_port < 0x10000 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                (char *)tmp42,
                0x800u,
                "API mcast request OK port %s=%d",
                (const char *)&buf[expect_code_len],
                reply_port);
              applog(7, tmp42, 0);
            }
            if ( getaddrinfo((const char *)connectaddr, (const char *)&buf[expect_code_len], &hints, &res) )
            {
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf((char *)tmp42, 0x800u, "Invalid client address %s", (const char *)connectaddr);
                applog(3, tmp42, 0);
              }
            }
            else
            {
              for ( client = res; client; client = client->ai_next )
              {
                reply_sock = socket(res->ai_family, 2, 0);
                if ( mcast_sock > 0 )
                  break;
              }
              if ( reply_sock == -1 )
              {
                freeaddrinfo(res);
                if ( use_syslog || opt_log_output || opt_log_level > 2 )
                {
                  snprintf(
                    (char *)tmp42,
                    0x800u,
                    "API mcast could not open socket to client %s",
                    (const char *)connectaddr);
                  applog(3, tmp42, 0);
                }
              }
              else
              {
                snprintf((char *)replybuf, 0x400u, "cgm-FTW-%d-%s", opt_api_port, (const char *)opt_api_mcast_des);
                v12 = strlen((const char *)replybuf);
                rep = sendto(reply_sock, replybuf, v12 + 1, 0, client->ai_addr, client->ai_addrlen);
                freeaddrinfo(res);
                if ( rep >= 0 )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(
                      (char *)tmp42,
                      0x800u,
                      "API mcast send reply (%s) succeeded (%d) (%d)",
                      (const char *)replybuf,
                      rep,
                      reply_sock);
                    applog(7, tmp42, 0);
                  }
                }
                else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  v13 = _errno_location();
                  v14 = strerror(*v13);
                  snprintf((char *)tmp42, 0x800u, "API mcast send reply failed (%s) (%d)", v14, reply_sock);
                  applog(7, tmp42, 0);
                }
                close(reply_sock);
              }
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(
              (char *)tmp42,
              0x800u,
              "API mcast request ignored - invalid port (%s)",
              (const char *)&buf[expect_code_len]);
            applog(7, tmp42, 0);
          }
        }
        else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy((char *)tmp42, "API mcast request was no good");
          applog(7, tmp42, 0);
        }
      }
    }
  }
  memset(&grp, 0, sizeof(grp));
  grp.imr_multiaddr.s_addr = *(_DWORD *)&host->ai_addr->sa_data[2];
  grp.imr_interface.s_addr = 0;
  if ( setsockopt(mcast_sock, 0, 35, &grp, 8u) >= 0 )
    goto LABEL_38;
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v4 = _errno_location();
    v5 = strerror(*v4);
    snprintf((char *)tmp42, 0x800u, "API mcast join failed (%s)%s", v5, (const char *)MUNAVAILABLE);
    applog(3, tmp42, 0);
  }
die:
  close(mcast_sock);
}

//----- (00086D30) --------------------------------------------------------
void *__cdecl mcast_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  RenameThread("APIMcast");
  mcast();
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (00086D90) --------------------------------------------------------
void mcast_init()
{
  unsigned __int8 tmp42[2048]; // [sp+Ch] [bp-808h] BYREF
  thr_info *thr; // [sp+80Ch] [bp-8h]

  thr = (thr_info *)cgcalloc(1, 0x40u, "api-btm.c", _func___12440, 5235);
  if ( thr_info_create(thr, 0, (void *(*)(void *))mcast_thread, thr) )
  {
    strcpy((char *)tmp42, "API mcast thread create failed");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00086E54) --------------------------------------------------------
void re_calculate_AVG()
{
  new_total_mhashes_done = total_mhashes_done;
  if ( total_secs <= 0.0 )
    new_total_secs = total_secs;
  else
    new_total_secs = total_secs - 1.0;
}

//----- (00086ED8) --------------------------------------------------------
void __cdecl api(int api_thr_id)
{
  double v1; // d0
  int v2; // r0
  int *v3; // r0
  char *v4; // r0
  int *v5; // r0
  char *v6; // r0
  int *v7; // r0
  int *v8; // r0
  char *v9; // r0
  int *v10; // r0
  char *v11; // r0
  const char *v12; // r3
  int *v13; // r0
  char *v14; // r0
  unsigned __int8 *v15; // r3
  int v16; // r0
  size_t v17; // r0
  unsigned __int8 *v18; // r3
  int v19; // r4
  int v20; // r4
  int v21; // r0
  const char *v22; // r3
  __pthread_unwind_buf_t __cancel_buf; // [sp+18h] [bp-DBDCh] BYREF
  unsigned __int8 tmp42[2048]; // [sp+130h] [bp-DAC4h] BYREF
  unsigned __int8 tmp42_0[2048]; // [sp+930h] [bp-D2C4h] BYREF
  unsigned __int8 tmp42_1[2048]; // [sp+1130h] [bp-CAC4h] BYREF
  unsigned __int8 tmp42_2[2048]; // [sp+1930h] [bp-C2C4h] BYREF
  unsigned __int8 tmp42_3[2048]; // [sp+2130h] [bp-BAC4h] BYREF
  unsigned __int8 tmp42_4[2048]; // [sp+2930h] [bp-B2C4h] BYREF
  unsigned __int8 tmp42_5[2048]; // [sp+3130h] [bp-AAC4h] BYREF
  unsigned __int8 tmp42_6[2048]; // [sp+3930h] [bp-A2C4h] BYREF
  unsigned __int8 tmp42_7[2048]; // [sp+4130h] [bp-9AC4h] BYREF
  unsigned __int8 tmp42_8[2048]; // [sp+4930h] [bp-92C4h] BYREF
  unsigned __int8 tmp42_9[2048]; // [sp+5130h] [bp-8AC4h] BYREF
  unsigned __int8 tmp42_10[2048]; // [sp+5930h] [bp-82C4h] BYREF
  unsigned __int8 tmp42_11[2048]; // [sp+6130h] [bp-7AC4h] BYREF
  unsigned __int8 tmp42_12[2048]; // [sp+6930h] [bp-72C4h] BYREF
  unsigned __int8 tmp42_13[2048]; // [sp+7130h] [bp-6AC4h] BYREF
  unsigned __int8 tmp42_14[2048]; // [sp+7930h] [bp-62C4h] BYREF
  unsigned __int8 tmp42_15[2048]; // [sp+8130h] [bp-5AC4h] BYREF
  unsigned __int8 tmp42_16[2048]; // [sp+8930h] [bp-52C4h] BYREF
  unsigned __int8 tmp42_17[2048]; // [sp+9130h] [bp-4AC4h] BYREF
  int optval; // [sp+9930h] [bp-42C4h] BYREF
  addrinfo *res; // [sp+9934h] [bp-42C0h] BYREF
  addrinfo hints; // [sp+9938h] [bp-42BCh] BYREF
  bool firstjoin; // [sp+995Bh] [bp-4299h] BYREF
  json_error_t json_err; // [sp+995Ch] [bp-4298h] BYREF
  unsigned __int8 group; // [sp+9A5Bh] [bp-4199h] BYREF
  unsigned __int8 cmdbuf[100]; // [sp+9A5Ch] [bp-4198h] BYREF
  socklen_t clisiz; // [sp+9AC0h] [bp-4134h] BYREF
  sockaddr_storage cli; // [sp+9AC4h] [bp-4130h] BYREF
  unsigned __int8 port_s[10]; // [sp+9B44h] [bp-40B0h] BYREF
  unsigned __int8 *connectaddr; // [sp+9B50h] [bp-40A4h] BYREF
  unsigned __int8 param_buf[8192]; // [sp+9B54h] [bp-40A0h] BYREF
  unsigned __int8 buf[8192]; // [sp+BB54h] [bp-20A0h] BYREF
  thr_info bye_thr; // [sp+DB54h] [bp-A0h] BYREF
  json_t_0 *json_val; // [sp+DB94h] [bp-60h]
  int n; // [sp+DB98h] [bp-5Ch]
  bool addrok; // [sp+DB9Fh] [bp-55h]
  int c; // [sp+DBA0h] [bp-54h]
  time_t bindstart; // [sp+DBA4h] [bp-50h]
  __int16 port; // [sp+DBAEh] [bp-46h]
  unsigned __int8 *cmdsbuf; // [sp+DBB0h] [bp-44h]
  unsigned __int8 *cmdptr; // [sp+DBB4h] [bp-40h]
  void *__cancel_arg; // [sp+DBB8h] [bp-3Ch]
  void (*__cancel_routine)(void *); // [sp+DBBCh] [bp-38h]
  int *apisock; // [sp+DBC0h] [bp-34h]
  addrinfo *host; // [sp+DBC4h] [bp-30h]
  int i; // [sp+DBC8h] [bp-2Ch]
  bool isjoin; // [sp+DBCDh] [bp-27h]
  bool did; // [sp+DBCEh] [bp-26h]
  bool isjson; // [sp+DBCFh] [bp-25h]
  json_t_0 *json_config; // [sp+DBD0h] [bp-24h]
  unsigned __int8 *param; // [sp+DBD4h] [bp-20h]
  unsigned __int8 *cmd; // [sp+DBD8h] [bp-1Ch]
  unsigned __int8 *binderror; // [sp+DBDCh] [bp-18h]
  int bound; // [sp+DBE0h] [bp-14h]
  io_data *io_data; // [sp+DBE4h] [bp-10h]

  port = opt_api_port;
  cmd = 0;
  apisock = (int *)cgmalloc(4u, "api-btm.c", _func___12478, 5279);
  *apisock = -1;
  json_config = 0;
  isjoin = 0;
  if ( !opt_api_listen )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)tmp42, 0x800u, "API not running%s", (const char *)UNAVAILABLE);
      applog(7, tmp42, 0);
    }
    free(apisock);
    return;
  }
  io_data = io_new(0x10000u, 1);
  mutex_init_2(&quit_restart_lock, "api-btm.c", _func___12478, 5293);
  __cancel_routine = (void (*)(void *))tidyup;
  __cancel_arg = apisock;
  if ( _sigsetjmp((struct __jmp_buf_tag *)&__cancel_buf, 0) )
  {
    __cancel_routine(__cancel_arg);
    _pthread_unwind_next(&__cancel_buf);
  }
  _pthread_register_cancel(&__cancel_buf);
  my_thr_id = api_thr_id;
  setup_groups();
  if ( opt_api_allow )
  {
    setup_ipaccess();
    if ( !ips )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42_0, 0x800u, "API not running (no valid IPs specified)%s", (const char *)UNAVAILABLE);
        applog(4, tmp42_0, 0);
      }
LABEL_54:
      free(apisock);
      return;
    }
  }
  cgsleep_ms(1000 * opt_log_interval);
  sprintf((char *)port_s, "%d", port);
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = 1;
  hints.ai_family = 0;
  if ( getaddrinfo((const char *)opt_api_host, (const char *)port_s, &hints, &res) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)tmp42_1, 0x800u, "API failed to resolve %s", (const char *)opt_api_host);
      applog(3, tmp42_1, 0);
    }
    goto LABEL_54;
  }
  for ( host = res; host; host = host->ai_next )
  {
    v2 = socket(res->ai_family, 1, 0);
    *apisock = v2;
    if ( *apisock > 0 )
      break;
  }
  if ( *apisock == -1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v3 = _errno_location();
      v4 = strerror(*v3);
      snprintf((char *)tmp42_2, 0x800u, "API initialisation failed (%s)%s", v4, (const char *)UNAVAILABLE);
      applog(3, tmp42_2, 0);
    }
    freeaddrinfo(res);
    free(apisock);
    return;
  }
  optval = 1;
  if ( setsockopt(*apisock, 1, 2, &optval, 4u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v5 = _errno_location();
    v6 = strerror(*v5);
    snprintf((char *)tmp42_3, 0x800u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v6);
    applog(7, tmp42_3, 0);
  }
  bound = 0;
  bindstart = time(0);
  while ( !bound )
  {
    if ( bind(*apisock, host->ai_addr, host->ai_addrlen) >= 0 )
    {
      bound = 1;
    }
    else
    {
      v7 = _errno_location();
      binderror = (unsigned __int8 *)strerror(*v7);
      if ( time(0) - bindstart > 61 )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42_4, 0x800u, "API bind to port %d failed - trying again in 30sec", port);
        applog(4, tmp42_4, 0);
      }
      cgsleep_ms(30000);
    }
  }
  freeaddrinfo(res);
  if ( !bound )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        (char *)tmp42_5,
        0x800u,
        "API bind to port %d failed (%s)%s",
        port,
        (const char *)binderror,
        (const char *)UNAVAILABLE);
      applog(3, tmp42_5, 0);
    }
    goto LABEL_54;
  }
  if ( listen(*apisock, 100) >= 0 )
  {
    if ( opt_api_allow )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf((char *)tmp42_7, 0x800u, "API running in IP access mode on port %d (%d)", port, *apisock);
        applog(4, tmp42_7, 0);
      }
    }
    else if ( opt_api_network )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(
          (char *)tmp42_8,
          0x800u,
          "API running in UNRESTRICTED read access mode on port %d (%d)",
          port,
          *apisock);
        applog(4, tmp42_8, 0);
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf((char *)tmp42_9, 0x800u, "API running in local read access mode on port %d (%d)", port, *apisock);
      applog(4, tmp42_9, 0);
    }
    if ( opt_api_mcast )
      mcast_init();
    strbufs = k_new_list("StrBufs", 0xCu, 2, 0, 0, "api-btm.c", _func___12478, 5405);
    while ( !bye )
    {
      clisiz = 128;
      c = accept(*apisock, (struct sockaddr *)&cli, &clisiz);
      if ( c < 0 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          v10 = _errno_location();
          v11 = strerror(*v10);
          snprintf((char *)tmp42_10, 0x800u, "API failed (%s)%s (%d)", v11, (const char *)UNAVAILABLE, *apisock);
          applog(3, tmp42_10, 0);
        }
        break;
      }
      addrok = check_connect(&cli, &connectaddr, &group);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        if ( addrok )
          v12 = "Accepted";
        else
          v12 = "Ignored";
        snprintf((char *)tmp42_11, 0x800u, "API: connection from %s - %s", (const char *)connectaddr, v12);
        applog(7, tmp42_11, 0);
      }
      if ( addrok )
      {
        n = recv(c, buf, 0x1FFFu, 0);
        if ( n >= 0 )
          buf[n] = 0;
        else
          buf[0] = 0;
        if ( opt_debug )
        {
          if ( n >= 0 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)tmp42_13, 0x800u, "API: recv command: (%d) '%s'", n, (const char *)buf);
              applog(7, tmp42_13, 0);
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            v13 = _errno_location();
            v14 = strerror(*v13);
            snprintf((char *)tmp42_12, 0x800u, "API: recv failed: %s", v14);
            applog(7, tmp42_12, 0);
          }
        }
        if ( n >= 0 )
        {
          when = time(0);
          io_reinit(io_data);
          did = 0;
          if ( buf[0] == 123 )
          {
            isjson = 1;
            param = 0;
            json_config = json_loadb(buf, n, 0, &json_err);
            if ( json_config && json_config->type == JSON_OBJECT )
            {
              json_val = json_object_get(json_config, JSON_COMMAND);
              if ( json_val )
              {
                if ( json_val->type == JSON_STRING )
                {
                  cmd = (unsigned __int8 *)json_string_value(json_val);
                  json_val = json_object_get(json_config, JSON_PARAMETER);
                  if ( json_val && json_val->type == JSON_STRING )
                  {
                    param = (unsigned __int8 *)json_string_value(json_val);
                  }
                  else if ( json_val && json_val->type == JSON_INTEGER )
                  {
                    v16 = json_integer_value(json_val);
                    sprintf((char *)param_buf, "%d", v16);
                    param = param_buf;
                  }
                  else if ( json_val && json_val->type == JSON_REAL )
                  {
                    json_real_value(json_val);
                    sprintf((char *)param_buf, "%f", v1);
                    param = param_buf;
                  }
                }
                else
                {
                  message(io_data, 14, 0, 0, isjson);
                  send_result(io_data, c, isjson);
                  did = 1;
                }
              }
              else
              {
                message(io_data, 24, 0, 0, isjson);
                send_result(io_data, c, isjson);
                did = 1;
              }
            }
            else
            {
              message(io_data, 23, 0, 0, isjson);
              send_result(io_data, c, isjson);
              did = 1;
            }
          }
          else
          {
            isjson = 0;
            param = (unsigned __int8 *)strchr((const char *)buf, 124);
            if ( param )
            {
              v15 = param++;
              *v15 = 0;
            }
            cmd = buf;
          }
          if ( !did )
          {
            cmdsbuf = 0;
            if ( strchr((const char *)cmd, 43) )
            {
              isjoin = 1;
              firstjoin = 1;
              v17 = strlen((const char *)cmd);
              cmdsbuf = (unsigned __int8 *)cgmalloc(v17 + 3, "api-btm.c", _func___12478, 5514);
              strcpy((char *)cmdsbuf, "|");
              param = 0;
            }
            else
            {
              isjoin = 0;
              firstjoin = 0;
            }
            cmdptr = cmd;
            do
            {
              did = 0;
              if ( !isjoin )
                goto LABEL_137;
              cmd = (unsigned __int8 *)strchr((const char *)cmdptr, 43);
              if ( cmd )
              {
                v18 = cmd++;
                *v18 = 0;
              }
              if ( *cmdptr )
              {
LABEL_137:
                for ( i = 0; cmds[i].name; ++i )
                {
                  if ( !strcmp((const char *)cmdptr, (const char *)cmds[i].name) )
                  {
                    sprintf((char *)cmdbuf, "|%s|", (const char *)cmdptr);
                    if ( !isjoin )
                      goto LABEL_144;
                    if ( strstr((const char *)cmdsbuf, (const char *)cmdbuf) )
                    {
                      did = 1;
                      break;
                    }
                    strcat((char *)cmdsbuf, (const char *)cmdptr);
                    strcat((char *)cmdsbuf, "|");
                    head_join(io_data, cmdptr, isjson, &firstjoin);
                    if ( !cmds[i].joinable )
                    {
                      message(io_data, 45, 0, cmds[i].name, isjson);
                      did = 1;
                      tail_join(io_data, isjson);
                    }
                    else
                    {
LABEL_144:
                      v19 = toupper(group);
                      if ( v19 == toupper(87)
                        || (v20 = toupper(group),
                            v21 = toupper(65),
                            strstr((const char *)apigroups[v20 - v21].commands, (const char *)cmdbuf)) )
                      {
                        cmds[i].func(io_data, c, param, isjson, group);
                      }
                      else
                      {
                        message(io_data, 45, 0, cmds[i].name, isjson);
                        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                        {
                          snprintf(
                            (char *)tmp42_14,
                            0x800u,
                            "API: access denied to '%s' for '%s' command",
                            (const char *)connectaddr,
                            (const char *)cmds[i].name);
                          applog(7, tmp42_14, 0);
                        }
                      }
                      did = 1;
                      if ( !isjoin )
                        send_result(io_data, c, isjson);
                      else
                        tail_join(io_data, isjson);
                    }
                    break;
                  }
                }
                if ( !did )
                {
                  if ( isjoin )
                    head_join(io_data, cmdptr, isjson, &firstjoin);
                  message(io_data, 14, 0, 0, isjson);
                  if ( isjoin )
                    tail_join(io_data, isjson);
                  else
                    send_result(io_data, c, isjson);
                }
              }
              if ( isjoin )
                cmdptr = cmd;
            }
            while ( isjoin && cmdptr );
          }
          if ( isjoin )
            send_result(io_data, c, isjson);
          if ( isjson && json_config && json_config->type == JSON_OBJECT )
            json_decref_1(json_config);
        }
      }
      close(c);
    }
    _pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
    free(apisock);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      if ( do_a_quit )
      {
        v22 = "QUIT";
      }
      else if ( do_a_restart )
      {
        v22 = "RESTART";
      }
      else if ( bye )
      {
        v22 = "BYE";
      }
      else
      {
        v22 = "UNKNOWN!";
      }
      snprintf((char *)tmp42_15, 0x800u, "API: terminating due to: %s", v22);
      applog(7, tmp42_15, 0);
    }
    mutex_lock_3(&quit_restart_lock, "api-btm.c", _func___12478, 5613);
    if ( do_a_restart )
    {
      if ( thr_info_create(&bye_thr, 0, (void *(*)(void *))restart_thread_0, &bye_thr) )
      {
        mutex_unlock_3(&quit_restart_lock, "api-btm.c", _func___12478, 5619);
        strcpy((char *)tmp42_16, "API failed to initiate a restart - aborting");
        applog(3, tmp42_16, 1);
        quit(1);
      }
    }
    else
    {
      if ( !do_a_quit )
      {
LABEL_195:
        mutex_unlock_3(&quit_restart_lock, "api-btm.c", _func___12478, 5634);
        return;
      }
      if ( thr_info_create(&bye_thr, 0, (void *(*)(void *))quit_thread, &bye_thr) )
      {
        mutex_unlock_3(&quit_restart_lock, "api-btm.c", _func___12478, 5628);
        strcpy((char *)tmp42_17, "API failed to initiate a clean quit - aborting");
        applog(3, tmp42_17, 1);
        quit(1);
      }
    }
    pthread_detach(bye_thr.pth);
    goto LABEL_195;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v8 = _errno_location();
    v9 = strerror(*v8);
    snprintf((char *)tmp42_6, 0x800u, "API3 initialisation failed (%s)%s", v9, (const char *)UNAVAILABLE);
    applog(3, tmp42_6, 0);
  }
  close(*apisock);
  free(apisock);
}
// 880A0: variable 'v1' is possibly undefined

//----- (000889F0) --------------------------------------------------------
void __cdecl sha2_starts(sha2_context *ctx)
{
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[0] = 1779033703;
  ctx->state[1] = -1150833019;
  ctx->state[2] = 1013904242;
  ctx->state[3] = -1521486534;
  ctx->state[4] = 1359893119;
  ctx->state[5] = -1694144372;
  ctx->state[6] = 528734635;
  ctx->state[7] = 1541459225;
}

//----- (00088AA8) --------------------------------------------------------
void __cdecl sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  unsigned int W; // [sp+8h] [bp-12Ch]
  unsigned int W_4; // [sp+Ch] [bp-128h]
  unsigned int W_8; // [sp+10h] [bp-124h]
  unsigned int W_12; // [sp+14h] [bp-120h]
  unsigned int W_16; // [sp+18h] [bp-11Ch]
  unsigned int W_20; // [sp+1Ch] [bp-118h]
  unsigned int W_24; // [sp+20h] [bp-114h]
  unsigned int W_28; // [sp+24h] [bp-110h]
  unsigned int W_32; // [sp+28h] [bp-10Ch]
  unsigned int W_36; // [sp+2Ch] [bp-108h]
  unsigned int W_40; // [sp+30h] [bp-104h]
  unsigned int W_44; // [sp+34h] [bp-100h]
  unsigned int W_48; // [sp+38h] [bp-FCh]
  unsigned int W_52; // [sp+3Ch] [bp-F8h]
  unsigned int W_56; // [sp+40h] [bp-F4h]
  unsigned int W_60; // [sp+44h] [bp-F0h]
  unsigned int W_64; // [sp+48h] [bp-ECh]
  unsigned int W_68; // [sp+4Ch] [bp-E8h]
  unsigned int W_72; // [sp+50h] [bp-E4h]
  unsigned int W_76; // [sp+54h] [bp-E0h]
  unsigned int W_80; // [sp+58h] [bp-DCh]
  unsigned int W_84; // [sp+5Ch] [bp-D8h]
  unsigned int W_88; // [sp+60h] [bp-D4h]
  unsigned int W_92; // [sp+64h] [bp-D0h]
  unsigned int W_96; // [sp+68h] [bp-CCh]
  unsigned int W_100; // [sp+6Ch] [bp-C8h]
  unsigned int W_104; // [sp+70h] [bp-C4h]
  unsigned int W_108; // [sp+74h] [bp-C0h]
  unsigned int W_112; // [sp+78h] [bp-BCh]
  unsigned int W_116; // [sp+7Ch] [bp-B8h]
  unsigned int W_120; // [sp+80h] [bp-B4h]
  unsigned int W_124; // [sp+84h] [bp-B0h]
  unsigned int W_128; // [sp+88h] [bp-ACh]
  unsigned int W_132; // [sp+8Ch] [bp-A8h]
  unsigned int W_136; // [sp+90h] [bp-A4h]
  unsigned int W_140; // [sp+94h] [bp-A0h]
  unsigned int W_144; // [sp+98h] [bp-9Ch]
  unsigned int W_148; // [sp+9Ch] [bp-98h]
  unsigned int W_152; // [sp+A0h] [bp-94h]
  unsigned int W_156; // [sp+A4h] [bp-90h]
  unsigned int W_160; // [sp+A8h] [bp-8Ch]
  unsigned int W_164; // [sp+ACh] [bp-88h]
  unsigned int W_168; // [sp+B0h] [bp-84h]
  unsigned int W_172; // [sp+B4h] [bp-80h]
  unsigned int W_176; // [sp+B8h] [bp-7Ch]
  unsigned int W_180; // [sp+BCh] [bp-78h]
  unsigned int W_184; // [sp+C0h] [bp-74h]
  unsigned int W_188; // [sp+C4h] [bp-70h]
  unsigned int W_192; // [sp+C8h] [bp-6Ch]
  unsigned int W_196; // [sp+CCh] [bp-68h]
  unsigned int W_200; // [sp+D0h] [bp-64h]
  unsigned int W_204; // [sp+D4h] [bp-60h]
  unsigned int W_208; // [sp+D8h] [bp-5Ch]
  unsigned int W_212; // [sp+DCh] [bp-58h]
  unsigned int W_216; // [sp+E0h] [bp-54h]
  unsigned int W_220; // [sp+E4h] [bp-50h]
  unsigned int W_224; // [sp+E8h] [bp-4Ch]
  unsigned int W_228; // [sp+ECh] [bp-48h]
  unsigned int W_232; // [sp+F0h] [bp-44h]
  unsigned int W_236; // [sp+F4h] [bp-40h]
  unsigned int W_240; // [sp+F8h] [bp-3Ch]
  unsigned int W_244; // [sp+FCh] [bp-38h]
  uint32_t temp1; // [sp+10Ch] [bp-28h]
  uint32_t temp1a; // [sp+10Ch] [bp-28h]
  uint32_t temp1b; // [sp+10Ch] [bp-28h]
  uint32_t temp1c; // [sp+10Ch] [bp-28h]
  uint32_t temp1d; // [sp+10Ch] [bp-28h]
  uint32_t temp1e; // [sp+10Ch] [bp-28h]
  uint32_t temp1f; // [sp+10Ch] [bp-28h]
  uint32_t temp1g; // [sp+10Ch] [bp-28h]
  uint32_t temp1h; // [sp+10Ch] [bp-28h]
  uint32_t temp1i; // [sp+10Ch] [bp-28h]
  uint32_t temp1j; // [sp+10Ch] [bp-28h]
  uint32_t temp1k; // [sp+10Ch] [bp-28h]
  uint32_t temp1l; // [sp+10Ch] [bp-28h]
  uint32_t temp1m; // [sp+10Ch] [bp-28h]
  uint32_t temp1n; // [sp+10Ch] [bp-28h]
  uint32_t temp1o; // [sp+10Ch] [bp-28h]
  uint32_t temp1p; // [sp+10Ch] [bp-28h]
  uint32_t temp1q; // [sp+10Ch] [bp-28h]
  uint32_t temp1r; // [sp+10Ch] [bp-28h]
  uint32_t temp1s; // [sp+10Ch] [bp-28h]
  uint32_t temp1t; // [sp+10Ch] [bp-28h]
  uint32_t temp1u; // [sp+10Ch] [bp-28h]
  uint32_t temp1v; // [sp+10Ch] [bp-28h]
  uint32_t temp1w; // [sp+10Ch] [bp-28h]
  uint32_t temp1x; // [sp+10Ch] [bp-28h]
  uint32_t temp1y; // [sp+10Ch] [bp-28h]
  uint32_t temp1z; // [sp+10Ch] [bp-28h]
  uint32_t temp1ba; // [sp+10Ch] [bp-28h]
  uint32_t temp1bb; // [sp+10Ch] [bp-28h]
  uint32_t temp1bc; // [sp+10Ch] [bp-28h]
  uint32_t temp1bd; // [sp+10Ch] [bp-28h]
  uint32_t temp1be; // [sp+10Ch] [bp-28h]
  uint32_t temp1bf; // [sp+10Ch] [bp-28h]
  uint32_t temp1bg; // [sp+10Ch] [bp-28h]
  uint32_t temp1bh; // [sp+10Ch] [bp-28h]
  uint32_t temp1bi; // [sp+10Ch] [bp-28h]
  uint32_t temp1bj; // [sp+10Ch] [bp-28h]
  uint32_t temp1bk; // [sp+10Ch] [bp-28h]
  uint32_t temp1bl; // [sp+10Ch] [bp-28h]
  uint32_t temp1bm; // [sp+10Ch] [bp-28h]
  uint32_t temp1bn; // [sp+10Ch] [bp-28h]
  uint32_t temp1bo; // [sp+10Ch] [bp-28h]
  uint32_t temp1bp; // [sp+10Ch] [bp-28h]
  uint32_t temp1bq; // [sp+10Ch] [bp-28h]
  uint32_t temp1br; // [sp+10Ch] [bp-28h]
  uint32_t temp1bs; // [sp+10Ch] [bp-28h]
  uint32_t temp1bt; // [sp+10Ch] [bp-28h]
  uint32_t temp1bu; // [sp+10Ch] [bp-28h]
  uint32_t temp1bv; // [sp+10Ch] [bp-28h]
  uint32_t temp1bw; // [sp+10Ch] [bp-28h]
  uint32_t temp1bx; // [sp+10Ch] [bp-28h]
  uint32_t temp1by; // [sp+10Ch] [bp-28h]
  uint32_t temp1bz; // [sp+10Ch] [bp-28h]
  uint32_t temp1ca; // [sp+10Ch] [bp-28h]
  uint32_t temp1cb; // [sp+10Ch] [bp-28h]
  uint32_t temp1cc; // [sp+10Ch] [bp-28h]
  uint32_t temp1cd; // [sp+10Ch] [bp-28h]
  uint32_t temp1ce; // [sp+10Ch] [bp-28h]
  uint32_t temp1cf; // [sp+10Ch] [bp-28h]
  uint32_t temp1cg; // [sp+10Ch] [bp-28h]
  uint32_t temp1ch; // [sp+10Ch] [bp-28h]
  uint32_t temp1ci; // [sp+10Ch] [bp-28h]
  uint32_t temp1cj; // [sp+10Ch] [bp-28h]
  uint32_t temp1ck; // [sp+10Ch] [bp-28h]
  uint32_t H; // [sp+110h] [bp-24h]
  uint32_t Ha; // [sp+110h] [bp-24h]
  uint32_t Hb; // [sp+110h] [bp-24h]
  uint32_t Hc; // [sp+110h] [bp-24h]
  uint32_t Hd; // [sp+110h] [bp-24h]
  uint32_t He; // [sp+110h] [bp-24h]
  uint32_t Hf; // [sp+110h] [bp-24h]
  uint32_t Hg; // [sp+110h] [bp-24h]
  uint32_t Hh; // [sp+110h] [bp-24h]
  uint32_t Hi; // [sp+110h] [bp-24h]
  uint32_t Hj; // [sp+110h] [bp-24h]
  uint32_t Hk; // [sp+110h] [bp-24h]
  uint32_t Hl; // [sp+110h] [bp-24h]
  uint32_t Hm; // [sp+110h] [bp-24h]
  uint32_t Hn; // [sp+110h] [bp-24h]
  uint32_t Ho; // [sp+110h] [bp-24h]
  uint32_t G; // [sp+114h] [bp-20h]
  uint32_t Ga; // [sp+114h] [bp-20h]
  uint32_t Gb; // [sp+114h] [bp-20h]
  uint32_t Gc; // [sp+114h] [bp-20h]
  uint32_t Gd; // [sp+114h] [bp-20h]
  uint32_t Ge; // [sp+114h] [bp-20h]
  uint32_t Gf; // [sp+114h] [bp-20h]
  uint32_t Gg; // [sp+114h] [bp-20h]
  uint32_t Gh; // [sp+114h] [bp-20h]
  uint32_t Gi; // [sp+114h] [bp-20h]
  uint32_t Gj; // [sp+114h] [bp-20h]
  uint32_t Gk; // [sp+114h] [bp-20h]
  uint32_t Gl; // [sp+114h] [bp-20h]
  uint32_t Gm; // [sp+114h] [bp-20h]
  uint32_t Gn; // [sp+114h] [bp-20h]
  uint32_t Go; // [sp+114h] [bp-20h]
  uint32_t Gp; // [sp+114h] [bp-20h]
  uint32_t F; // [sp+118h] [bp-1Ch]
  uint32_t Fa; // [sp+118h] [bp-1Ch]
  uint32_t Fb; // [sp+118h] [bp-1Ch]
  uint32_t Fc; // [sp+118h] [bp-1Ch]
  uint32_t Fd; // [sp+118h] [bp-1Ch]
  uint32_t Fe; // [sp+118h] [bp-1Ch]
  uint32_t Ff; // [sp+118h] [bp-1Ch]
  uint32_t Fg; // [sp+118h] [bp-1Ch]
  uint32_t Fh; // [sp+118h] [bp-1Ch]
  uint32_t Fi; // [sp+118h] [bp-1Ch]
  uint32_t Fj; // [sp+118h] [bp-1Ch]
  uint32_t Fk; // [sp+118h] [bp-1Ch]
  uint32_t Fl; // [sp+118h] [bp-1Ch]
  uint32_t Fm; // [sp+118h] [bp-1Ch]
  uint32_t Fn; // [sp+118h] [bp-1Ch]
  uint32_t Fo; // [sp+118h] [bp-1Ch]
  uint32_t Fp; // [sp+118h] [bp-1Ch]
  uint32_t E; // [sp+11Ch] [bp-18h]
  uint32_t Ea; // [sp+11Ch] [bp-18h]
  uint32_t Eb; // [sp+11Ch] [bp-18h]
  uint32_t Ec; // [sp+11Ch] [bp-18h]
  uint32_t Ed; // [sp+11Ch] [bp-18h]
  uint32_t Ee; // [sp+11Ch] [bp-18h]
  uint32_t Ef; // [sp+11Ch] [bp-18h]
  uint32_t Eg; // [sp+11Ch] [bp-18h]
  uint32_t Eh; // [sp+11Ch] [bp-18h]
  uint32_t Ei; // [sp+11Ch] [bp-18h]
  uint32_t Ej; // [sp+11Ch] [bp-18h]
  uint32_t Ek; // [sp+11Ch] [bp-18h]
  uint32_t El; // [sp+11Ch] [bp-18h]
  uint32_t Em; // [sp+11Ch] [bp-18h]
  uint32_t En; // [sp+11Ch] [bp-18h]
  uint32_t Eo; // [sp+11Ch] [bp-18h]
  uint32_t D; // [sp+120h] [bp-14h]
  uint32_t Da; // [sp+120h] [bp-14h]
  uint32_t Db; // [sp+120h] [bp-14h]
  uint32_t Dc; // [sp+120h] [bp-14h]
  uint32_t Dd; // [sp+120h] [bp-14h]
  uint32_t De; // [sp+120h] [bp-14h]
  uint32_t Df; // [sp+120h] [bp-14h]
  uint32_t Dg; // [sp+120h] [bp-14h]
  uint32_t Dh; // [sp+120h] [bp-14h]
  uint32_t Di; // [sp+120h] [bp-14h]
  uint32_t Dj; // [sp+120h] [bp-14h]
  uint32_t Dk; // [sp+120h] [bp-14h]
  uint32_t Dl; // [sp+120h] [bp-14h]
  uint32_t Dm; // [sp+120h] [bp-14h]
  uint32_t Dn; // [sp+120h] [bp-14h]
  uint32_t Do; // [sp+120h] [bp-14h]
  uint32_t C; // [sp+124h] [bp-10h]
  uint32_t Ca; // [sp+124h] [bp-10h]
  uint32_t Cb; // [sp+124h] [bp-10h]
  uint32_t Cc; // [sp+124h] [bp-10h]
  uint32_t Cd; // [sp+124h] [bp-10h]
  uint32_t Ce; // [sp+124h] [bp-10h]
  uint32_t Cf; // [sp+124h] [bp-10h]
  uint32_t Cg; // [sp+124h] [bp-10h]
  uint32_t Ch; // [sp+124h] [bp-10h]
  uint32_t Ci; // [sp+124h] [bp-10h]
  uint32_t Cj; // [sp+124h] [bp-10h]
  uint32_t Ck; // [sp+124h] [bp-10h]
  uint32_t Cl; // [sp+124h] [bp-10h]
  uint32_t Cm; // [sp+124h] [bp-10h]
  uint32_t Cn; // [sp+124h] [bp-10h]
  uint32_t Co; // [sp+124h] [bp-10h]
  uint32_t Cp; // [sp+124h] [bp-10h]
  uint32_t B; // [sp+128h] [bp-Ch]
  uint32_t Ba; // [sp+128h] [bp-Ch]
  uint32_t Bb; // [sp+128h] [bp-Ch]
  uint32_t Bc; // [sp+128h] [bp-Ch]
  uint32_t Bd; // [sp+128h] [bp-Ch]
  uint32_t Be; // [sp+128h] [bp-Ch]
  uint32_t Bf; // [sp+128h] [bp-Ch]
  uint32_t Bg; // [sp+128h] [bp-Ch]
  uint32_t Bh; // [sp+128h] [bp-Ch]
  uint32_t Bi; // [sp+128h] [bp-Ch]
  uint32_t Bj; // [sp+128h] [bp-Ch]
  uint32_t Bk; // [sp+128h] [bp-Ch]
  uint32_t Bl; // [sp+128h] [bp-Ch]
  uint32_t Bm; // [sp+128h] [bp-Ch]
  uint32_t Bn; // [sp+128h] [bp-Ch]
  uint32_t Bo; // [sp+128h] [bp-Ch]
  uint32_t Bp; // [sp+128h] [bp-Ch]
  uint32_t A; // [sp+12Ch] [bp-8h]
  uint32_t Aa; // [sp+12Ch] [bp-8h]
  uint32_t Ab; // [sp+12Ch] [bp-8h]
  uint32_t Ac; // [sp+12Ch] [bp-8h]
  uint32_t Ad; // [sp+12Ch] [bp-8h]
  uint32_t Ae; // [sp+12Ch] [bp-8h]
  uint32_t Af; // [sp+12Ch] [bp-8h]
  uint32_t Ag; // [sp+12Ch] [bp-8h]
  uint32_t Ah; // [sp+12Ch] [bp-8h]
  uint32_t Ai; // [sp+12Ch] [bp-8h]
  uint32_t Aj; // [sp+12Ch] [bp-8h]
  uint32_t Ak; // [sp+12Ch] [bp-8h]
  uint32_t Al; // [sp+12Ch] [bp-8h]
  uint32_t Am; // [sp+12Ch] [bp-8h]
  uint32_t An; // [sp+12Ch] [bp-8h]
  uint32_t Ao; // [sp+12Ch] [bp-8h]

  W = _byteswap_ulong(*(_DWORD *)data);
  W_4 = _byteswap_ulong(*((_DWORD *)data + 1));
  W_8 = _byteswap_ulong(*((_DWORD *)data + 2));
  W_12 = _byteswap_ulong(*((_DWORD *)data + 3));
  W_16 = _byteswap_ulong(*((_DWORD *)data + 4));
  W_20 = _byteswap_ulong(*((_DWORD *)data + 5));
  W_24 = _byteswap_ulong(*((_DWORD *)data + 6));
  W_28 = _byteswap_ulong(*((_DWORD *)data + 7));
  W_32 = _byteswap_ulong(*((_DWORD *)data + 8));
  W_36 = _byteswap_ulong(*((_DWORD *)data + 9));
  W_40 = _byteswap_ulong(*((_DWORD *)data + 10));
  W_44 = _byteswap_ulong(*((_DWORD *)data + 11));
  W_48 = _byteswap_ulong(*((_DWORD *)data + 12));
  W_52 = _byteswap_ulong(*((_DWORD *)data + 13));
  W_56 = _byteswap_ulong(*((_DWORD *)data + 14));
  W_60 = _byteswap_ulong(*((_DWORD *)data + 15));
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  E = ctx->state[4];
  F = ctx->state[5];
  G = ctx->state[6];
  temp1 = (__ROR4__(E, 6) ^ __ROR4__(E, 11) ^ __ROR4__(E, 25)) + ctx->state[7] + (G ^ (F ^ G) & E) + W + 1116352408;
  D = ctx->state[3] + temp1;
  H = temp1 + (__ROR4__(A, 2) ^ __ROR4__(A, 13) ^ __ROR4__(A, 22)) + (A & B | C & (A | B));
  temp1a = (__ROR4__(D, 6) ^ __ROR4__(D, 11) ^ __ROR4__(D, 25)) + G + (F ^ (E ^ F) & D) + W_4 + 1899447441;
  Ca = C + temp1a;
  Ga = temp1a + (__ROR4__(H, 2) ^ __ROR4__(H, 13) ^ __ROR4__(H, 22)) + (H & A | B & (H | A));
  temp1b = (__ROR4__(Ca, 6) ^ __ROR4__(Ca, 11) ^ __ROR4__(Ca, 25)) + F + (E ^ (D ^ E) & Ca) + W_8 - 1245643825;
  Ba = B + temp1b;
  Fa = temp1b + (__ROR4__(Ga, 2) ^ __ROR4__(Ga, 13) ^ __ROR4__(Ga, 22)) + (Ga & H | A & (Ga | H));
  temp1c = (__ROR4__(Ba, 6) ^ __ROR4__(Ba, 11) ^ __ROR4__(Ba, 25)) + E + (D ^ (Ca ^ D) & Ba) + W_12 - 373957723;
  Aa = A + temp1c;
  Ea = temp1c + (__ROR4__(Fa, 2) ^ __ROR4__(Fa, 13) ^ __ROR4__(Fa, 22)) + (Fa & Ga | H & (Fa | Ga));
  temp1d = (__ROR4__(Aa, 6) ^ __ROR4__(Aa, 11) ^ __ROR4__(Aa, 25)) + D + (Ca ^ (Ba ^ Ca) & Aa) + W_16 + 961987163;
  Ha = H + temp1d;
  Da = temp1d + (__ROR4__(Ea, 2) ^ __ROR4__(Ea, 13) ^ __ROR4__(Ea, 22)) + (Ea & Fa | Ga & (Ea | Fa));
  temp1e = (__ROR4__(Ha, 6) ^ __ROR4__(Ha, 11) ^ __ROR4__(Ha, 25)) + Ca + (Ba ^ (Aa ^ Ba) & Ha) + W_20 + 1508970993;
  Gb = Ga + temp1e;
  Cb = temp1e + (__ROR4__(Da, 2) ^ __ROR4__(Da, 13) ^ __ROR4__(Da, 22)) + (Da & Ea | Fa & (Da | Ea));
  temp1f = (__ROR4__(Gb, 6) ^ __ROR4__(Gb, 11) ^ __ROR4__(Gb, 25)) + Ba + (Aa ^ (Ha ^ Aa) & Gb) + W_24 - 1841331548;
  Fb = Fa + temp1f;
  Bb = temp1f + (__ROR4__(Cb, 2) ^ __ROR4__(Cb, 13) ^ __ROR4__(Cb, 22)) + (Cb & Da | Ea & (Cb | Da));
  temp1g = (__ROR4__(Fb, 6) ^ __ROR4__(Fb, 11) ^ __ROR4__(Fb, 25)) + Aa + (Ha ^ (Gb ^ Ha) & Fb) + W_28 - 1424204075;
  Eb = Ea + temp1g;
  Ab = temp1g + (__ROR4__(Bb, 2) ^ __ROR4__(Bb, 13) ^ __ROR4__(Bb, 22)) + (Bb & Cb | Da & (Bb | Cb));
  temp1h = (__ROR4__(Eb, 6) ^ __ROR4__(Eb, 11) ^ __ROR4__(Eb, 25)) + Ha + (Gb ^ (Fb ^ Gb) & Eb) + W_32 - 670586216;
  Db = Da + temp1h;
  Hb = temp1h + (__ROR4__(Ab, 2) ^ __ROR4__(Ab, 13) ^ __ROR4__(Ab, 22)) + (Ab & Bb | Cb & (Ab | Bb));
  temp1i = (__ROR4__(Db, 6) ^ __ROR4__(Db, 11) ^ __ROR4__(Db, 25)) + Gb + (Fb ^ (Eb ^ Fb) & Db) + W_36 + 310598401;
  Cc = Cb + temp1i;
  Gc = temp1i + (__ROR4__(Hb, 2) ^ __ROR4__(Hb, 13) ^ __ROR4__(Hb, 22)) + (Hb & Ab | Bb & (Hb | Ab));
  temp1j = (__ROR4__(Cc, 6) ^ __ROR4__(Cc, 11) ^ __ROR4__(Cc, 25)) + Fb + (Eb ^ (Db ^ Eb) & Cc) + W_40 + 607225278;
  Bc = Bb + temp1j;
  Fc = temp1j + (__ROR4__(Gc, 2) ^ __ROR4__(Gc, 13) ^ __ROR4__(Gc, 22)) + (Gc & Hb | Ab & (Gc | Hb));
  temp1k = (__ROR4__(Bc, 6) ^ __ROR4__(Bc, 11) ^ __ROR4__(Bc, 25)) + Eb + (Db ^ (Cc ^ Db) & Bc) + W_44 + 1426881987;
  Ac = Ab + temp1k;
  Ec = temp1k + (__ROR4__(Fc, 2) ^ __ROR4__(Fc, 13) ^ __ROR4__(Fc, 22)) + (Fc & Gc | Hb & (Fc | Gc));
  temp1l = (__ROR4__(Ac, 6) ^ __ROR4__(Ac, 11) ^ __ROR4__(Ac, 25)) + Db + (Cc ^ (Bc ^ Cc) & Ac) + W_48 + 1925078388;
  Hc = Hb + temp1l;
  Dc = temp1l + (__ROR4__(Ec, 2) ^ __ROR4__(Ec, 13) ^ __ROR4__(Ec, 22)) + (Ec & Fc | Gc & (Ec | Fc));
  temp1m = (__ROR4__(Hc, 6) ^ __ROR4__(Hc, 11) ^ __ROR4__(Hc, 25)) + Cc + (Bc ^ (Ac ^ Bc) & Hc) + W_52 - 2132889090;
  Gd = Gc + temp1m;
  Cd = temp1m + (__ROR4__(Dc, 2) ^ __ROR4__(Dc, 13) ^ __ROR4__(Dc, 22)) + (Dc & Ec | Fc & (Dc | Ec));
  temp1n = (__ROR4__(Gd, 6) ^ __ROR4__(Gd, 11) ^ __ROR4__(Gd, 25)) + Bc + (Ac ^ (Hc ^ Ac) & Gd) + W_56 - 1680079193;
  Fd = Fc + temp1n;
  Bd = temp1n + (__ROR4__(Cd, 2) ^ __ROR4__(Cd, 13) ^ __ROR4__(Cd, 22)) + (Cd & Dc | Ec & (Cd | Dc));
  temp1o = (__ROR4__(Fd, 6) ^ __ROR4__(Fd, 11) ^ __ROR4__(Fd, 25)) + Ac + (Hc ^ (Gd ^ Hc) & Fd) + W_60 - 1046744716;
  Ed = Ec + temp1o;
  Ad = temp1o + (__ROR4__(Bd, 2) ^ __ROR4__(Bd, 13) ^ __ROR4__(Bd, 22)) + (Bd & Cd | Dc & (Bd | Cd));
  W_64 = (__ROR4__(W_56, 17) ^ __ROR4__(W_56, 19) ^ (W_56 >> 10))
       + W_36
       + ((W_4 >> 3) ^ __ROR4__(W_4, 7) ^ __ROR4__(W_4, 18))
       + W;
  temp1p = (__ROR4__(Ed, 6) ^ __ROR4__(Ed, 11) ^ __ROR4__(Ed, 25)) + Hc + (Gd ^ (Fd ^ Gd) & Ed) + W_64 - 459576895;
  Dd = Dc + temp1p;
  Hd = temp1p + (__ROR4__(Ad, 2) ^ __ROR4__(Ad, 13) ^ __ROR4__(Ad, 22)) + (Ad & Bd | Cd & (Ad | Bd));
  W_68 = (__ROR4__(W_60, 17) ^ __ROR4__(W_60, 19) ^ (W_60 >> 10))
       + W_40
       + ((W_8 >> 3) ^ __ROR4__(W_8, 7) ^ __ROR4__(W_8, 18))
       + W_4;
  temp1q = (__ROR4__(Dd, 6) ^ __ROR4__(Dd, 11) ^ __ROR4__(Dd, 25)) + Gd + (Fd ^ (Ed ^ Fd) & Dd) + W_68 - 272742522;
  Ce = Cd + temp1q;
  Ge = temp1q + (__ROR4__(Hd, 2) ^ __ROR4__(Hd, 13) ^ __ROR4__(Hd, 22)) + (Hd & Ad | Bd & (Hd | Ad));
  W_72 = (__ROR4__(W_64, 17) ^ __ROR4__(W_64, 19) ^ (W_64 >> 10))
       + W_44
       + ((W_12 >> 3) ^ __ROR4__(W_12, 7) ^ __ROR4__(W_12, 18))
       + W_8;
  temp1r = (__ROR4__(Ce, 6) ^ __ROR4__(Ce, 11) ^ __ROR4__(Ce, 25)) + Fd + (Ed ^ (Dd ^ Ed) & Ce) + W_72 + 264347078;
  Be = Bd + temp1r;
  Fe = temp1r + (__ROR4__(Ge, 2) ^ __ROR4__(Ge, 13) ^ __ROR4__(Ge, 22)) + (Ge & Hd | Ad & (Ge | Hd));
  W_76 = (__ROR4__(W_68, 17) ^ __ROR4__(W_68, 19) ^ (W_68 >> 10))
       + W_48
       + ((W_16 >> 3) ^ __ROR4__(W_16, 7) ^ __ROR4__(W_16, 18))
       + W_12;
  temp1s = (__ROR4__(Be, 6) ^ __ROR4__(Be, 11) ^ __ROR4__(Be, 25)) + Ed + (Dd ^ (Ce ^ Dd) & Be) + W_76 + 604807628;
  Ae = Ad + temp1s;
  Ee = temp1s + (__ROR4__(Fe, 2) ^ __ROR4__(Fe, 13) ^ __ROR4__(Fe, 22)) + (Fe & Ge | Hd & (Fe | Ge));
  W_80 = (__ROR4__(W_72, 17) ^ __ROR4__(W_72, 19) ^ (W_72 >> 10))
       + W_52
       + ((W_20 >> 3) ^ __ROR4__(W_20, 7) ^ __ROR4__(W_20, 18))
       + W_16;
  temp1t = (__ROR4__(Ae, 6) ^ __ROR4__(Ae, 11) ^ __ROR4__(Ae, 25)) + Dd + (Ce ^ (Be ^ Ce) & Ae) + W_80 + 770255983;
  He = Hd + temp1t;
  De = temp1t + (__ROR4__(Ee, 2) ^ __ROR4__(Ee, 13) ^ __ROR4__(Ee, 22)) + (Ee & Fe | Ge & (Ee | Fe));
  W_84 = (__ROR4__(W_76, 17) ^ __ROR4__(W_76, 19) ^ (W_76 >> 10))
       + W_56
       + ((W_24 >> 3) ^ __ROR4__(W_24, 7) ^ __ROR4__(W_24, 18))
       + W_20;
  temp1u = (__ROR4__(He, 6) ^ __ROR4__(He, 11) ^ __ROR4__(He, 25)) + Ce + (Be ^ (Ae ^ Be) & He) + W_84 + 1249150122;
  Gf = Ge + temp1u;
  Cf = temp1u + (__ROR4__(De, 2) ^ __ROR4__(De, 13) ^ __ROR4__(De, 22)) + (De & Ee | Fe & (De | Ee));
  W_88 = (__ROR4__(W_80, 17) ^ __ROR4__(W_80, 19) ^ (W_80 >> 10))
       + W_60
       + ((W_28 >> 3) ^ __ROR4__(W_28, 7) ^ __ROR4__(W_28, 18))
       + W_24;
  temp1v = (__ROR4__(Gf, 6) ^ __ROR4__(Gf, 11) ^ __ROR4__(Gf, 25)) + Be + (Ae ^ (He ^ Ae) & Gf) + W_88 + 1555081692;
  Ff = Fe + temp1v;
  Bf = temp1v + (__ROR4__(Cf, 2) ^ __ROR4__(Cf, 13) ^ __ROR4__(Cf, 22)) + (Cf & De | Ee & (Cf | De));
  W_92 = (__ROR4__(W_84, 17) ^ __ROR4__(W_84, 19) ^ (W_84 >> 10))
       + W_64
       + ((W_32 >> 3) ^ __ROR4__(W_32, 7) ^ __ROR4__(W_32, 18))
       + W_28;
  temp1w = (__ROR4__(Ff, 6) ^ __ROR4__(Ff, 11) ^ __ROR4__(Ff, 25)) + Ae + (He ^ (Gf ^ He) & Ff) + W_92 + 1996064986;
  Ef = Ee + temp1w;
  Af = temp1w + (__ROR4__(Bf, 2) ^ __ROR4__(Bf, 13) ^ __ROR4__(Bf, 22)) + (Bf & Cf | De & (Bf | Cf));
  W_96 = (__ROR4__(W_88, 17) ^ __ROR4__(W_88, 19) ^ (W_88 >> 10))
       + W_68
       + ((W_36 >> 3) ^ __ROR4__(W_36, 7) ^ __ROR4__(W_36, 18))
       + W_32;
  temp1x = (__ROR4__(Ef, 6) ^ __ROR4__(Ef, 11) ^ __ROR4__(Ef, 25)) + He + (Gf ^ (Ff ^ Gf) & Ef) + W_96 - 1740746414;
  Df = De + temp1x;
  Hf = temp1x + (__ROR4__(Af, 2) ^ __ROR4__(Af, 13) ^ __ROR4__(Af, 22)) + (Af & Bf | Cf & (Af | Bf));
  W_100 = (__ROR4__(W_92, 17) ^ __ROR4__(W_92, 19) ^ (W_92 >> 10))
        + W_72
        + ((W_40 >> 3) ^ __ROR4__(W_40, 7) ^ __ROR4__(W_40, 18))
        + W_36;
  temp1y = (__ROR4__(Df, 6) ^ __ROR4__(Df, 11) ^ __ROR4__(Df, 25)) + Gf + (Ff ^ (Ef ^ Ff) & Df) + W_100 - 1473132947;
  Cg = Cf + temp1y;
  Gg = temp1y + (__ROR4__(Hf, 2) ^ __ROR4__(Hf, 13) ^ __ROR4__(Hf, 22)) + (Hf & Af | Bf & (Hf | Af));
  W_104 = (__ROR4__(W_96, 17) ^ __ROR4__(W_96, 19) ^ (W_96 >> 10))
        + W_76
        + ((W_44 >> 3) ^ __ROR4__(W_44, 7) ^ __ROR4__(W_44, 18))
        + W_40;
  temp1z = (__ROR4__(Cg, 6) ^ __ROR4__(Cg, 11) ^ __ROR4__(Cg, 25)) + Ff + (Ef ^ (Df ^ Ef) & Cg) + W_104 - 1341970488;
  Bg = Bf + temp1z;
  Fg = temp1z + (__ROR4__(Gg, 2) ^ __ROR4__(Gg, 13) ^ __ROR4__(Gg, 22)) + (Gg & Hf | Af & (Gg | Hf));
  W_108 = (__ROR4__(W_100, 17) ^ __ROR4__(W_100, 19) ^ (W_100 >> 10))
        + W_80
        + ((W_48 >> 3) ^ __ROR4__(W_48, 7) ^ __ROR4__(W_48, 18))
        + W_44;
  temp1ba = (__ROR4__(Bg, 6) ^ __ROR4__(Bg, 11) ^ __ROR4__(Bg, 25)) + Ef + (Df ^ (Cg ^ Df) & Bg) + W_108 - 1084653625;
  Ag = Af + temp1ba;
  Eg = temp1ba + (__ROR4__(Fg, 2) ^ __ROR4__(Fg, 13) ^ __ROR4__(Fg, 22)) + (Fg & Gg | Hf & (Fg | Gg));
  W_112 = (__ROR4__(W_104, 17) ^ __ROR4__(W_104, 19) ^ (W_104 >> 10))
        + W_84
        + ((W_52 >> 3) ^ __ROR4__(W_52, 7) ^ __ROR4__(W_52, 18))
        + W_48;
  temp1bb = (__ROR4__(Ag, 6) ^ __ROR4__(Ag, 11) ^ __ROR4__(Ag, 25)) + Df + (Cg ^ (Bg ^ Cg) & Ag) + W_112 - 958395405;
  Hg = Hf + temp1bb;
  Dg = temp1bb + (__ROR4__(Eg, 2) ^ __ROR4__(Eg, 13) ^ __ROR4__(Eg, 22)) + (Eg & Fg | Gg & (Eg | Fg));
  W_116 = (__ROR4__(W_108, 17) ^ __ROR4__(W_108, 19) ^ (W_108 >> 10))
        + W_88
        + ((W_56 >> 3) ^ __ROR4__(W_56, 7) ^ __ROR4__(W_56, 18))
        + W_52;
  temp1bc = (__ROR4__(Hg, 6) ^ __ROR4__(Hg, 11) ^ __ROR4__(Hg, 25)) + Cg + (Bg ^ (Ag ^ Bg) & Hg) + W_116 - 710438585;
  Gh = Gg + temp1bc;
  Ch = temp1bc + (__ROR4__(Dg, 2) ^ __ROR4__(Dg, 13) ^ __ROR4__(Dg, 22)) + (Dg & Eg | Fg & (Dg | Eg));
  W_120 = (__ROR4__(W_112, 17) ^ __ROR4__(W_112, 19) ^ (W_112 >> 10))
        + W_92
        + ((W_60 >> 3) ^ __ROR4__(W_60, 7) ^ __ROR4__(W_60, 18))
        + W_56;
  temp1bd = (__ROR4__(Gh, 6) ^ __ROR4__(Gh, 11) ^ __ROR4__(Gh, 25)) + Bg + (Ag ^ (Hg ^ Ag) & Gh) + W_120 + 113926993;
  Fh = Fg + temp1bd;
  Bh = temp1bd + (__ROR4__(Ch, 2) ^ __ROR4__(Ch, 13) ^ __ROR4__(Ch, 22)) + (Ch & Dg | Eg & (Ch | Dg));
  W_124 = (__ROR4__(W_116, 17) ^ __ROR4__(W_116, 19) ^ (W_116 >> 10))
        + W_96
        + ((W_64 >> 3) ^ __ROR4__(W_64, 7) ^ __ROR4__(W_64, 18))
        + W_60;
  temp1be = (__ROR4__(Fh, 6) ^ __ROR4__(Fh, 11) ^ __ROR4__(Fh, 25)) + Ag + (Hg ^ (Gh ^ Hg) & Fh) + W_124 + 338241895;
  Eh = Eg + temp1be;
  Ah = temp1be + (__ROR4__(Bh, 2) ^ __ROR4__(Bh, 13) ^ __ROR4__(Bh, 22)) + (Bh & Ch | Dg & (Bh | Ch));
  W_128 = (__ROR4__(W_120, 17) ^ __ROR4__(W_120, 19) ^ (W_120 >> 10))
        + W_100
        + ((W_68 >> 3) ^ __ROR4__(W_68, 7) ^ __ROR4__(W_68, 18))
        + W_64;
  temp1bf = (__ROR4__(Eh, 6) ^ __ROR4__(Eh, 11) ^ __ROR4__(Eh, 25)) + Hg + (Gh ^ (Fh ^ Gh) & Eh) + W_128 + 666307205;
  Dh = Dg + temp1bf;
  Hh = temp1bf + (__ROR4__(Ah, 2) ^ __ROR4__(Ah, 13) ^ __ROR4__(Ah, 22)) + (Ah & Bh | Ch & (Ah | Bh));
  W_132 = (__ROR4__(W_124, 17) ^ __ROR4__(W_124, 19) ^ (W_124 >> 10))
        + W_104
        + ((W_72 >> 3) ^ __ROR4__(W_72, 7) ^ __ROR4__(W_72, 18))
        + W_68;
  temp1bg = (__ROR4__(Dh, 6) ^ __ROR4__(Dh, 11) ^ __ROR4__(Dh, 25)) + Gh + (Fh ^ (Eh ^ Fh) & Dh) + W_132 + 773529912;
  Ci = Ch + temp1bg;
  Gi = temp1bg + (__ROR4__(Hh, 2) ^ __ROR4__(Hh, 13) ^ __ROR4__(Hh, 22)) + (Hh & Ah | Bh & (Hh | Ah));
  W_136 = (__ROR4__(W_128, 17) ^ __ROR4__(W_128, 19) ^ (W_128 >> 10))
        + W_108
        + ((W_76 >> 3) ^ __ROR4__(W_76, 7) ^ __ROR4__(W_76, 18))
        + W_72;
  temp1bh = (__ROR4__(Ci, 6) ^ __ROR4__(Ci, 11) ^ __ROR4__(Ci, 25)) + Fh + (Eh ^ (Dh ^ Eh) & Ci) + W_136 + 1294757372;
  Bi = Bh + temp1bh;
  Fi = temp1bh + (__ROR4__(Gi, 2) ^ __ROR4__(Gi, 13) ^ __ROR4__(Gi, 22)) + (Gi & Hh | Ah & (Gi | Hh));
  W_140 = (__ROR4__(W_132, 17) ^ __ROR4__(W_132, 19) ^ (W_132 >> 10))
        + W_112
        + ((W_80 >> 3) ^ __ROR4__(W_80, 7) ^ __ROR4__(W_80, 18))
        + W_76;
  temp1bi = (__ROR4__(Bi, 6) ^ __ROR4__(Bi, 11) ^ __ROR4__(Bi, 25)) + Eh + (Dh ^ (Ci ^ Dh) & Bi) + W_140 + 1396182291;
  Ai = Ah + temp1bi;
  Ei = temp1bi + (__ROR4__(Fi, 2) ^ __ROR4__(Fi, 13) ^ __ROR4__(Fi, 22)) + (Fi & Gi | Hh & (Fi | Gi));
  W_144 = (__ROR4__(W_136, 17) ^ __ROR4__(W_136, 19) ^ (W_136 >> 10))
        + W_116
        + ((W_84 >> 3) ^ __ROR4__(W_84, 7) ^ __ROR4__(W_84, 18))
        + W_80;
  temp1bj = (__ROR4__(Ai, 6) ^ __ROR4__(Ai, 11) ^ __ROR4__(Ai, 25)) + Dh + (Ci ^ (Bi ^ Ci) & Ai) + W_144 + 1695183700;
  Hi = Hh + temp1bj;
  Di = temp1bj + (__ROR4__(Ei, 2) ^ __ROR4__(Ei, 13) ^ __ROR4__(Ei, 22)) + (Ei & Fi | Gi & (Ei | Fi));
  W_148 = (__ROR4__(W_140, 17) ^ __ROR4__(W_140, 19) ^ (W_140 >> 10))
        + W_120
        + ((W_88 >> 3) ^ __ROR4__(W_88, 7) ^ __ROR4__(W_88, 18))
        + W_84;
  temp1bk = (__ROR4__(Hi, 6) ^ __ROR4__(Hi, 11) ^ __ROR4__(Hi, 25)) + Ci + (Bi ^ (Ai ^ Bi) & Hi) + W_148 + 1986661051;
  Gj = Gi + temp1bk;
  Cj = temp1bk + (__ROR4__(Di, 2) ^ __ROR4__(Di, 13) ^ __ROR4__(Di, 22)) + (Di & Ei | Fi & (Di | Ei));
  W_152 = (__ROR4__(W_144, 17) ^ __ROR4__(W_144, 19) ^ (W_144 >> 10))
        + W_124
        + ((W_92 >> 3) ^ __ROR4__(W_92, 7) ^ __ROR4__(W_92, 18))
        + W_88;
  temp1bl = (__ROR4__(Gj, 6) ^ __ROR4__(Gj, 11) ^ __ROR4__(Gj, 25)) + Bi + (Ai ^ (Hi ^ Ai) & Gj) + W_152 - 2117940946;
  Fj = Fi + temp1bl;
  Bj = temp1bl + (__ROR4__(Cj, 2) ^ __ROR4__(Cj, 13) ^ __ROR4__(Cj, 22)) + (Cj & Di | Ei & (Cj | Di));
  W_156 = (__ROR4__(W_148, 17) ^ __ROR4__(W_148, 19) ^ (W_148 >> 10))
        + W_128
        + ((W_96 >> 3) ^ __ROR4__(W_96, 7) ^ __ROR4__(W_96, 18))
        + W_92;
  temp1bm = (__ROR4__(Fj, 6) ^ __ROR4__(Fj, 11) ^ __ROR4__(Fj, 25)) + Ai + (Hi ^ (Gj ^ Hi) & Fj) + W_156 - 1838011259;
  Ej = Ei + temp1bm;
  Aj = temp1bm + (__ROR4__(Bj, 2) ^ __ROR4__(Bj, 13) ^ __ROR4__(Bj, 22)) + (Bj & Cj | Di & (Bj | Cj));
  W_160 = (__ROR4__(W_152, 17) ^ __ROR4__(W_152, 19) ^ (W_152 >> 10))
        + W_132
        + ((W_100 >> 3) ^ __ROR4__(W_100, 7) ^ __ROR4__(W_100, 18))
        + W_96;
  temp1bn = (__ROR4__(Ej, 6) ^ __ROR4__(Ej, 11) ^ __ROR4__(Ej, 25)) + Hi + (Gj ^ (Fj ^ Gj) & Ej) + W_160 - 1564481375;
  Dj = Di + temp1bn;
  Hj = temp1bn + (__ROR4__(Aj, 2) ^ __ROR4__(Aj, 13) ^ __ROR4__(Aj, 22)) + (Aj & Bj | Cj & (Aj | Bj));
  W_164 = (__ROR4__(W_156, 17) ^ __ROR4__(W_156, 19) ^ (W_156 >> 10))
        + W_136
        + ((W_104 >> 3) ^ __ROR4__(W_104, 7) ^ __ROR4__(W_104, 18))
        + W_100;
  temp1bo = (__ROR4__(Dj, 6) ^ __ROR4__(Dj, 11) ^ __ROR4__(Dj, 25)) + Gj + (Fj ^ (Ej ^ Fj) & Dj) + W_164 - 1474664885;
  Ck = Cj + temp1bo;
  Gk = temp1bo + (__ROR4__(Hj, 2) ^ __ROR4__(Hj, 13) ^ __ROR4__(Hj, 22)) + (Hj & Aj | Bj & (Hj | Aj));
  W_168 = (__ROR4__(W_160, 17) ^ __ROR4__(W_160, 19) ^ (W_160 >> 10))
        + W_140
        + ((W_108 >> 3) ^ __ROR4__(W_108, 7) ^ __ROR4__(W_108, 18))
        + W_104;
  temp1bp = (__ROR4__(Ck, 6) ^ __ROR4__(Ck, 11) ^ __ROR4__(Ck, 25)) + Fj + (Ej ^ (Dj ^ Ej) & Ck) + W_168 - 1035236496;
  Bk = Bj + temp1bp;
  Fk = temp1bp + (__ROR4__(Gk, 2) ^ __ROR4__(Gk, 13) ^ __ROR4__(Gk, 22)) + (Gk & Hj | Aj & (Gk | Hj));
  W_172 = (__ROR4__(W_164, 17) ^ __ROR4__(W_164, 19) ^ (W_164 >> 10))
        + W_144
        + ((W_112 >> 3) ^ __ROR4__(W_112, 7) ^ __ROR4__(W_112, 18))
        + W_108;
  temp1bq = (__ROR4__(Bk, 6) ^ __ROR4__(Bk, 11) ^ __ROR4__(Bk, 25)) + Ej + (Dj ^ (Ck ^ Dj) & Bk) + W_172 - 949202525;
  Ak = Aj + temp1bq;
  Ek = temp1bq + (__ROR4__(Fk, 2) ^ __ROR4__(Fk, 13) ^ __ROR4__(Fk, 22)) + (Fk & Gk | Hj & (Fk | Gk));
  W_176 = (__ROR4__(W_168, 17) ^ __ROR4__(W_168, 19) ^ (W_168 >> 10))
        + W_148
        + ((W_116 >> 3) ^ __ROR4__(W_116, 7) ^ __ROR4__(W_116, 18))
        + W_112;
  temp1br = (__ROR4__(Ak, 6) ^ __ROR4__(Ak, 11) ^ __ROR4__(Ak, 25)) + Dj + (Ck ^ (Bk ^ Ck) & Ak) + W_176 - 778901479;
  Hk = Hj + temp1br;
  Dk = temp1br + (__ROR4__(Ek, 2) ^ __ROR4__(Ek, 13) ^ __ROR4__(Ek, 22)) + (Ek & Fk | Gk & (Ek | Fk));
  W_180 = (__ROR4__(W_172, 17) ^ __ROR4__(W_172, 19) ^ (W_172 >> 10))
        + W_152
        + ((W_120 >> 3) ^ __ROR4__(W_120, 7) ^ __ROR4__(W_120, 18))
        + W_116;
  temp1bs = (__ROR4__(Hk, 6) ^ __ROR4__(Hk, 11) ^ __ROR4__(Hk, 25)) + Ck + (Bk ^ (Ak ^ Bk) & Hk) + W_180 - 694614492;
  Gl = Gk + temp1bs;
  Cl = temp1bs + (__ROR4__(Dk, 2) ^ __ROR4__(Dk, 13) ^ __ROR4__(Dk, 22)) + (Dk & Ek | Fk & (Dk | Ek));
  W_184 = (__ROR4__(W_176, 17) ^ __ROR4__(W_176, 19) ^ (W_176 >> 10))
        + W_156
        + ((W_124 >> 3) ^ __ROR4__(W_124, 7) ^ __ROR4__(W_124, 18))
        + W_120;
  temp1bt = (__ROR4__(Gl, 6) ^ __ROR4__(Gl, 11) ^ __ROR4__(Gl, 25)) + Bk + (Ak ^ (Hk ^ Ak) & Gl) + W_184 - 200395387;
  Fl = Fk + temp1bt;
  Bl = temp1bt + (__ROR4__(Cl, 2) ^ __ROR4__(Cl, 13) ^ __ROR4__(Cl, 22)) + (Cl & Dk | Ek & (Cl | Dk));
  W_188 = (__ROR4__(W_180, 17) ^ __ROR4__(W_180, 19) ^ (W_180 >> 10))
        + W_160
        + ((W_128 >> 3) ^ __ROR4__(W_128, 7) ^ __ROR4__(W_128, 18))
        + W_124;
  temp1bu = (__ROR4__(Fl, 6) ^ __ROR4__(Fl, 11) ^ __ROR4__(Fl, 25)) + Ak + (Hk ^ (Gl ^ Hk) & Fl) + W_188 + 275423344;
  El = Ek + temp1bu;
  Al = temp1bu + (__ROR4__(Bl, 2) ^ __ROR4__(Bl, 13) ^ __ROR4__(Bl, 22)) + (Bl & Cl | Dk & (Bl | Cl));
  W_192 = (__ROR4__(W_184, 17) ^ __ROR4__(W_184, 19) ^ (W_184 >> 10))
        + W_164
        + ((W_132 >> 3) ^ __ROR4__(W_132, 7) ^ __ROR4__(W_132, 18))
        + W_128;
  temp1bv = (__ROR4__(El, 6) ^ __ROR4__(El, 11) ^ __ROR4__(El, 25)) + Hk + (Gl ^ (Fl ^ Gl) & El) + W_192 + 430227734;
  Dl = Dk + temp1bv;
  Hl = temp1bv + (__ROR4__(Al, 2) ^ __ROR4__(Al, 13) ^ __ROR4__(Al, 22)) + (Al & Bl | Cl & (Al | Bl));
  W_196 = (__ROR4__(W_188, 17) ^ __ROR4__(W_188, 19) ^ (W_188 >> 10))
        + W_168
        + ((W_136 >> 3) ^ __ROR4__(W_136, 7) ^ __ROR4__(W_136, 18))
        + W_132;
  temp1bw = (__ROR4__(Dl, 6) ^ __ROR4__(Dl, 11) ^ __ROR4__(Dl, 25)) + Gl + (Fl ^ (El ^ Fl) & Dl) + W_196 + 506948616;
  Cm = Cl + temp1bw;
  Gm = temp1bw + (__ROR4__(Hl, 2) ^ __ROR4__(Hl, 13) ^ __ROR4__(Hl, 22)) + (Hl & Al | Bl & (Hl | Al));
  W_200 = (__ROR4__(W_192, 17) ^ __ROR4__(W_192, 19) ^ (W_192 >> 10))
        + W_172
        + ((W_140 >> 3) ^ __ROR4__(W_140, 7) ^ __ROR4__(W_140, 18))
        + W_136;
  temp1bx = (__ROR4__(Cm, 6) ^ __ROR4__(Cm, 11) ^ __ROR4__(Cm, 25)) + Fl + (El ^ (Dl ^ El) & Cm) + W_200 + 659060556;
  Bm = Bl + temp1bx;
  Fm = temp1bx + (__ROR4__(Gm, 2) ^ __ROR4__(Gm, 13) ^ __ROR4__(Gm, 22)) + (Gm & Hl | Al & (Gm | Hl));
  W_204 = (__ROR4__(W_196, 17) ^ __ROR4__(W_196, 19) ^ (W_196 >> 10))
        + W_176
        + ((W_144 >> 3) ^ __ROR4__(W_144, 7) ^ __ROR4__(W_144, 18))
        + W_140;
  temp1by = (__ROR4__(Bm, 6) ^ __ROR4__(Bm, 11) ^ __ROR4__(Bm, 25)) + El + (Dl ^ (Cm ^ Dl) & Bm) + W_204 + 883997877;
  Am = Al + temp1by;
  Em = temp1by + (__ROR4__(Fm, 2) ^ __ROR4__(Fm, 13) ^ __ROR4__(Fm, 22)) + (Fm & Gm | Hl & (Fm | Gm));
  W_208 = (__ROR4__(W_200, 17) ^ __ROR4__(W_200, 19) ^ (W_200 >> 10))
        + W_180
        + ((W_148 >> 3) ^ __ROR4__(W_148, 7) ^ __ROR4__(W_148, 18))
        + W_144;
  temp1bz = (__ROR4__(Am, 6) ^ __ROR4__(Am, 11) ^ __ROR4__(Am, 25)) + Dl + (Cm ^ (Bm ^ Cm) & Am) + W_208 + 958139571;
  Hm = Hl + temp1bz;
  Dm = temp1bz + (__ROR4__(Em, 2) ^ __ROR4__(Em, 13) ^ __ROR4__(Em, 22)) + (Em & Fm | Gm & (Em | Fm));
  W_212 = (__ROR4__(W_204, 17) ^ __ROR4__(W_204, 19) ^ (W_204 >> 10))
        + W_184
        + ((W_152 >> 3) ^ __ROR4__(W_152, 7) ^ __ROR4__(W_152, 18))
        + W_148;
  temp1ca = (__ROR4__(Hm, 6) ^ __ROR4__(Hm, 11) ^ __ROR4__(Hm, 25)) + Cm + (Bm ^ (Am ^ Bm) & Hm) + W_212 + 1322822218;
  Gn = Gm + temp1ca;
  Cn = temp1ca + (__ROR4__(Dm, 2) ^ __ROR4__(Dm, 13) ^ __ROR4__(Dm, 22)) + (Dm & Em | Fm & (Dm | Em));
  W_216 = (__ROR4__(W_208, 17) ^ __ROR4__(W_208, 19) ^ (W_208 >> 10))
        + W_188
        + ((W_156 >> 3) ^ __ROR4__(W_156, 7) ^ __ROR4__(W_156, 18))
        + W_152;
  temp1cb = (__ROR4__(Gn, 6) ^ __ROR4__(Gn, 11) ^ __ROR4__(Gn, 25)) + Bm + (Am ^ (Hm ^ Am) & Gn) + W_216 + 1537002063;
  Fn = Fm + temp1cb;
  Bn = temp1cb + (__ROR4__(Cn, 2) ^ __ROR4__(Cn, 13) ^ __ROR4__(Cn, 22)) + (Cn & Dm | Em & (Cn | Dm));
  W_220 = (__ROR4__(W_212, 17) ^ __ROR4__(W_212, 19) ^ (W_212 >> 10))
        + W_192
        + ((W_160 >> 3) ^ __ROR4__(W_160, 7) ^ __ROR4__(W_160, 18))
        + W_156;
  temp1cc = (__ROR4__(Fn, 6) ^ __ROR4__(Fn, 11) ^ __ROR4__(Fn, 25)) + Am + (Hm ^ (Gn ^ Hm) & Fn) + W_220 + 1747873779;
  En = Em + temp1cc;
  An = temp1cc + (__ROR4__(Bn, 2) ^ __ROR4__(Bn, 13) ^ __ROR4__(Bn, 22)) + (Bn & Cn | Dm & (Bn | Cn));
  W_224 = (__ROR4__(W_216, 17) ^ __ROR4__(W_216, 19) ^ (W_216 >> 10))
        + W_196
        + ((W_164 >> 3) ^ __ROR4__(W_164, 7) ^ __ROR4__(W_164, 18))
        + W_160;
  temp1cd = (__ROR4__(En, 6) ^ __ROR4__(En, 11) ^ __ROR4__(En, 25)) + Hm + (Gn ^ (Fn ^ Gn) & En) + W_224 + 1955562222;
  Dn = Dm + temp1cd;
  Hn = temp1cd + (__ROR4__(An, 2) ^ __ROR4__(An, 13) ^ __ROR4__(An, 22)) + (An & Bn | Cn & (An | Bn));
  W_228 = (__ROR4__(W_220, 17) ^ __ROR4__(W_220, 19) ^ (W_220 >> 10))
        + W_200
        + ((W_168 >> 3) ^ __ROR4__(W_168, 7) ^ __ROR4__(W_168, 18))
        + W_164;
  temp1ce = (__ROR4__(Dn, 6) ^ __ROR4__(Dn, 11) ^ __ROR4__(Dn, 25)) + Gn + (Fn ^ (En ^ Fn) & Dn) + W_228 + 2024104815;
  Co = Cn + temp1ce;
  Go = temp1ce + (__ROR4__(Hn, 2) ^ __ROR4__(Hn, 13) ^ __ROR4__(Hn, 22)) + (Hn & An | Bn & (Hn | An));
  W_232 = (__ROR4__(W_224, 17) ^ __ROR4__(W_224, 19) ^ (W_224 >> 10))
        + W_204
        + ((W_172 >> 3) ^ __ROR4__(W_172, 7) ^ __ROR4__(W_172, 18))
        + W_168;
  temp1cf = (__ROR4__(Co, 6) ^ __ROR4__(Co, 11) ^ __ROR4__(Co, 25)) + Fn + (En ^ (Dn ^ En) & Co) + W_232 - 2067236844;
  Bo = Bn + temp1cf;
  Fo = temp1cf + (__ROR4__(Go, 2) ^ __ROR4__(Go, 13) ^ __ROR4__(Go, 22)) + (Go & Hn | An & (Go | Hn));
  W_236 = (__ROR4__(W_228, 17) ^ __ROR4__(W_228, 19) ^ (W_228 >> 10))
        + W_208
        + ((W_176 >> 3) ^ __ROR4__(W_176, 7) ^ __ROR4__(W_176, 18))
        + W_172;
  temp1cg = (__ROR4__(Bo, 6) ^ __ROR4__(Bo, 11) ^ __ROR4__(Bo, 25)) + En + (Dn ^ (Co ^ Dn) & Bo) + W_236 - 1933114872;
  Ao = An + temp1cg;
  Eo = temp1cg + (__ROR4__(Fo, 2) ^ __ROR4__(Fo, 13) ^ __ROR4__(Fo, 22)) + (Fo & Go | Hn & (Fo | Go));
  W_240 = (__ROR4__(W_232, 17) ^ __ROR4__(W_232, 19) ^ (W_232 >> 10))
        + W_212
        + ((W_180 >> 3) ^ __ROR4__(W_180, 7) ^ __ROR4__(W_180, 18))
        + W_176;
  temp1ch = (__ROR4__(Ao, 6) ^ __ROR4__(Ao, 11) ^ __ROR4__(Ao, 25)) + Dn + (Co ^ (Bo ^ Co) & Ao) + W_240 - 1866530822;
  Ho = Hn + temp1ch;
  Do = temp1ch + (__ROR4__(Eo, 2) ^ __ROR4__(Eo, 13) ^ __ROR4__(Eo, 22)) + (Eo & Fo | Go & (Eo | Fo));
  W_244 = (__ROR4__(W_236, 17) ^ __ROR4__(W_236, 19) ^ (W_236 >> 10))
        + W_216
        + ((W_184 >> 3) ^ __ROR4__(W_184, 7) ^ __ROR4__(W_184, 18))
        + W_180;
  temp1ci = (__ROR4__(Ho, 6) ^ __ROR4__(Ho, 11) ^ __ROR4__(Ho, 25)) + Co + (Bo ^ (Ao ^ Bo) & Ho) + W_244 - 1538233109;
  Gp = Go + temp1ci;
  Cp = temp1ci + (__ROR4__(Do, 2) ^ __ROR4__(Do, 13) ^ __ROR4__(Do, 22)) + (Do & Eo | Fo & (Do | Eo));
  temp1cj = (__ROR4__(Gp, 6) ^ __ROR4__(Gp, 11) ^ __ROR4__(Gp, 25))
          + Bo
          + (Ao ^ (Ho ^ Ao) & Gp)
          + (__ROR4__(W_240, 17) ^ __ROR4__(W_240, 19) ^ (W_240 >> 10))
          + W_220
          + ((W_188 >> 3) ^ __ROR4__(W_188, 7) ^ __ROR4__(W_188, 18))
          + W_184
          - 1090935817;
  Fp = Fo + temp1cj;
  Bp = temp1cj + (__ROR4__(Cp, 2) ^ __ROR4__(Cp, 13) ^ __ROR4__(Cp, 22)) + (Cp & Do | Eo & (Cp | Do));
  temp1ck = (__ROR4__(Fp, 6) ^ __ROR4__(Fp, 11) ^ __ROR4__(Fp, 25))
          + Ao
          + (Ho ^ (Gp ^ Ho) & Fp)
          + (__ROR4__(W_244, 17) ^ __ROR4__(W_244, 19) ^ (W_244 >> 10))
          + W_224
          + ((W_192 >> 3) ^ __ROR4__(W_192, 7) ^ __ROR4__(W_192, 18))
          + W_188
          - 965641998;
  ctx->state[0] += temp1ck + (__ROR4__(Bp, 2) ^ __ROR4__(Bp, 13) ^ __ROR4__(Bp, 22)) + (Bp & Cp | Do & (Bp | Cp));
  ctx->state[1] += Bp;
  ctx->state[2] += Cp;
  ctx->state[3] += Do;
  ctx->state[4] += Eo + temp1ck;
  ctx->state[5] += Fp;
  ctx->state[6] += Gp;
  ctx->state[7] += Ho;
}

//----- (0008D428) --------------------------------------------------------
void __cdecl sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  signed int ilena; // [sp+4h] [bp-18h]
  const unsigned __int8 *inputa; // [sp+8h] [bp-14h]
  signed int fill; // [sp+10h] [bp-Ch]
  uint32_t left; // [sp+14h] [bp-8h]

  inputa = input;
  ilena = ilen;
  if ( ilen > 0 )
  {
    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    ctx->total[0] += ilen;
    ctx->total[0] = ctx->total[0];
    if ( ctx->total[0] < ilen )
      ++ctx->total[1];
    if ( left && ilen >= fill )
    {
      memcpy(&ctx->buffer[left], input, fill);
      sha2_process(ctx, ctx->buffer);
      inputa += fill;
      ilena -= fill;
      left = 0;
    }
    while ( ilena > 63 )
    {
      sha2_process(ctx, inputa);
      inputa += 64;
      ilena -= 64;
    }
    if ( ilena > 0 )
      memcpy(&ctx->buffer[left], inputa, ilena);
  }
}

//----- (0008D5A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __cdecl sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  uint32_t v2; // r3
  unsigned __int8 msglen[8]; // [sp+8h] [bp-1Ch] BYREF
  uint32_t padn; // [sp+10h] [bp-14h]
  uint32_t last; // [sp+14h] [bp-10h]
  __int64 low; // [sp+18h] [bp-Ch] OVERLAPPED

  low = 8LL * *(_QWORD *)ctx->total;
  msglen[0] = HIBYTE(low);
  msglen[1] = BYTE6(low);
  msglen[2] = BYTE5(low);
  msglen[3] = BYTE4(low);
  msglen[4] = BYTE3(low);
  msglen[5] = BYTE2(low);
  msglen[6] = BYTE1(low);
  msglen[7] = low;
  last = ctx->total[0] & 0x3F;
  if ( last > 0x37 )
    v2 = 120 - last;
  else
    v2 = 56 - last;
  padn = v2;
  sha2_update(ctx, sha2_padding, v2);
  sha2_update(ctx, msglen, 8);
  *output = HIBYTE(ctx->state[0]);
  output[1] = BYTE2(ctx->state[0]);
  output[2] = BYTE1(ctx->state[0]);
  output[3] = ctx->state[0];
  output[4] = HIBYTE(ctx->state[1]);
  output[5] = BYTE2(ctx->state[1]);
  output[6] = BYTE1(ctx->state[1]);
  output[7] = ctx->state[1];
  output[8] = HIBYTE(ctx->state[2]);
  output[9] = BYTE2(ctx->state[2]);
  output[10] = BYTE1(ctx->state[2]);
  output[11] = ctx->state[2];
  output[12] = HIBYTE(ctx->state[3]);
  output[13] = BYTE2(ctx->state[3]);
  output[14] = BYTE1(ctx->state[3]);
  output[15] = ctx->state[3];
  output[16] = HIBYTE(ctx->state[4]);
  output[17] = BYTE2(ctx->state[4]);
  output[18] = BYTE1(ctx->state[4]);
  output[19] = ctx->state[4];
  output[20] = HIBYTE(ctx->state[5]);
  output[21] = BYTE2(ctx->state[5]);
  output[22] = BYTE1(ctx->state[5]);
  output[23] = ctx->state[5];
  output[24] = HIBYTE(ctx->state[6]);
  output[25] = BYTE2(ctx->state[6]);
  output[26] = BYTE1(ctx->state[6]);
  output[27] = ctx->state[6];
  output[28] = HIBYTE(ctx->state[7]);
  output[29] = BYTE2(ctx->state[7]);
  output[30] = BYTE1(ctx->state[7]);
  output[31] = ctx->state[7];
}
// 8D5A0: variables would overlap: ^18.8 and stkvar "low" ^18.4(has user info),stkvar "high" ^1C.4(has user info)

//----- (0008DA24) --------------------------------------------------------
void __cdecl sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  sha2_context ctx; // [sp+10h] [bp-ECh] BYREF

  sha2_starts(&ctx);
  sha2_update(&ctx, input, ilen);
  sha2_finish(&ctx, output);
  memset(&ctx, 0, sizeof(ctx));
}

//----- (0008DA8C) --------------------------------------------------------
unsigned __int8 *__cdecl arg_bad(const unsigned __int8 *fmt, const unsigned __int8 *arg)
{
  size_t v2; // r4
  size_t v3; // r0
  unsigned __int8 *str; // [sp+Ch] [bp-10h]

  v2 = strlen((const char *)fmt);
  v3 = strlen((const char *)arg);
  str = (unsigned __int8 *)malloc(v2 + v3);
  sprintf((char *)str, (const char *)fmt, arg);
  return str;
}

//----- (0008DAEC) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_bool(bool *b)
{
  *b = 1;
  return 0;
}

//----- (0008DB1C) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_false(bool *b)
{
  *b = 0;
  return 0;
}

//----- (0008DB4C) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_invbool(bool *b)
{
  *b = 0;
  return 0;
}

//----- (0008DB7C) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_charp(const unsigned __int8 *arg, unsigned __int8 **p)
{
  *p = (unsigned __int8 *)arg;
  return 0;
}

//----- (0008DBB0) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_intval(const unsigned __int8 *arg, int *i)
{
  int l; // [sp+8h] [bp-Ch] BYREF
  unsigned __int8 *err; // [sp+Ch] [bp-8h]

  err = opt_set_longval(arg, &l);
  if ( err )
    return err;
  *i = l;
  if ( *i == l )
    return err;
  else
    return arg_bad("value '%s' does not fit into an integer", arg);
}

//----- (0008DC34) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_floatval(const unsigned __int8 *arg, float *f)
{
  int v2; // s0
  unsigned __int8 *endp; // [sp+Ch] [bp-8h] BYREF

  *_errno_location() = 0;
  strtof(arg, &endp);
  *(_DWORD *)f = v2;
  if ( *endp || !*arg )
    return arg_bad("'%s' is not a number", arg);
  if ( *_errno_location() )
    return arg_bad("'%s' is out of range", arg);
  return 0;
}
// 8DC70: variable 'v2' is possibly undefined
// 12270: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (0008DCE8) --------------------------------------------------------
unsigned __int8 *__cdecl opt_set_longval(const unsigned __int8 *arg, int *l)
{
  unsigned __int8 *endp; // [sp+Ch] [bp-8h] BYREF

  *_errno_location() = 0;
  *l = strtol((const char *)arg, (char **)&endp, 0);
  if ( *endp || !*arg )
    return arg_bad("'%s' is not a number", arg);
  if ( *_errno_location() )
    return arg_bad("'%s' is out of range", arg);
  return 0;
}

//----- (0008DDA0) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_version_and_exit(const unsigned __int8 *version)
{
  puts((const char *)version);
  fflush((FILE *)stdout);
  exit(0);
}
// C4484: using guessed type int stdout;

//----- (0008DDD4) --------------------------------------------------------
unsigned __int8 *__cdecl __noreturn opt_usage_and_exit(const unsigned __int8 *extra)
{
  unsigned __int8 *v1; // r0

  v1 = opt_usage(opt_argv0, extra);
  printf("%s", (const char *)v1);
  fflush((FILE *)stdout);
  exit(0);
}
// C4484: using guessed type int stdout;

//----- (0008DE2C) --------------------------------------------------------
void __cdecl opt_show_intval(unsigned __int8 *buf, const int *i)
{
  snprintf((char *)buf, 0x50u, "%i", *i);
}

//----- (0008DE68) --------------------------------------------------------
void __cdecl opt_show_floatval(unsigned __int8 *buf, const float *f)
{
  snprintf((char *)buf, 0x50u, "%.1f", *f);
}

//----- (0008DEAC) --------------------------------------------------------
const unsigned __int8 *__cdecl first_name(const unsigned __int8 *names, unsigned int *len)
{
  *len = strcspn((const char *)names + 1, (const char *)&off_AEFB8);
  return names + 1;
}
// AEFB8: using guessed type void *off_AEFB8;

//----- (0008DEF8) --------------------------------------------------------
const unsigned __int8 *__cdecl next_name(const unsigned __int8 *names, unsigned int *len)
{
  const unsigned __int8 *namesa; // [sp+4h] [bp-8h]

  namesa = &names[*len];
  if ( *namesa == 32 || *namesa == 61 || !*namesa )
    return 0;
  else
    return first_name(namesa + 1, len);
}

//----- (0008DF7C) --------------------------------------------------------
const unsigned __int8 *__cdecl first_opt(unsigned int *i, unsigned int *len)
{
  for ( *i = 0; *i < opt_count; ++*i )
  {
    if ( opt_table_0[*i].type != OPT_SUBTABLE )
      return first_name(opt_table_0[*i].names, len);
  }
  return 0;
}

//----- (0008E058) --------------------------------------------------------
const unsigned __int8 *__cdecl next_opt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  while ( *i < opt_count )
  {
    if ( opt_table_0[*i].type != OPT_SUBTABLE )
    {
      if ( !p )
        return first_name(opt_table_0[*i].names, len);
      p = next_name(p, len);
      if ( p )
        return p;
    }
    ++*i;
  }
  return 0;
}

//----- (0008E15C) --------------------------------------------------------
const unsigned __int8 *__cdecl first_lopt(unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *p; // [sp+Ch] [bp-8h]

  for ( p = first_opt(i, len); p; p = next_opt(p, i, len) )
  {
    if ( *p == 45 )
    {
      --*len;
      ++p;
      return p;
    }
  }
  return p;
}

//----- (0008E1E8) --------------------------------------------------------
const unsigned __int8 *__cdecl next_lopt(const unsigned __int8 *p, unsigned int *i, unsigned int *len)
{
  const unsigned __int8 *pa; // [sp+Ch] [bp-8h]

  for ( pa = next_opt(p, i, len); pa; pa = next_opt(pa, i, len) )
  {
    if ( *pa == 45 )
    {
      --*len;
      ++pa;
      return pa;
    }
  }
  return pa;
}

//----- (0008E27C) --------------------------------------------------------
const unsigned __int8 *__cdecl first_sopt(unsigned int *i)
{
  unsigned int len; // [sp+8h] [bp-Ch] BYREF
  const unsigned __int8 *p; // [sp+Ch] [bp-8h]

  len = 0;
  for ( p = first_opt(i, &len); p && *p == 45; p = next_opt(p, i, &len) )
    ;
  return p;
}

//----- (0008E2F8) --------------------------------------------------------
const unsigned __int8 *__cdecl next_sopt(const unsigned __int8 *p, unsigned int *i)
{
  const unsigned __int8 *pa; // [sp+4h] [bp-10h]
  unsigned int len[2]; // [sp+Ch] [bp-8h] BYREF

  len[0] = 1;
  for ( pa = next_opt(p, i, len); pa && *pa == 45; pa = next_opt(pa, i, len) )
    ;
  return pa;
}

//----- (0008E37C) --------------------------------------------------------
void __cdecl check_opt(const opt_table *entry)
{
  unsigned int len; // [sp+10h] [bp-Ch] BYREF
  const unsigned __int8 *p; // [sp+14h] [bp-8h]

  if ( entry->type != OPT_HASARG && entry->type != OPT_NOARG && entry->type != OPT_PROCESSARG )
    errx(1, "Option %s: unknown entry type %u", (const char *)entry->names, entry->type);
  if ( !entry->desc )
    errx(1, "Option %s: description cannot be NULL", (const char *)entry->names);
  if ( *entry->names != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)entry->names);
  for ( p = first_name(entry->names, &len); p; p = next_name(p, &len) )
  {
    if ( *p == 45 )
    {
      if ( len == 1 )
        errx(1, "Option %s: invalid long option '--'", (const char *)entry->names);
      ++opt_num_long;
    }
    else
    {
      if ( len != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", (const char *)entry->names, len + 1, (const char *)p - 1);
      ++opt_num_short;
      if ( entry->type == OPT_HASARG || entry->type == OPT_PROCESSARG )
        ++opt_num_short_arg;
    }
    if ( entry->type == OPT_NOARG && (p[len] == 32 || p[len] == 61) )
      errx(1, "Option %s: does not take arguments '%s'", (const char *)entry->names, (const char *)&p[len + 1]);
  }
}

//----- (0008E5DC) --------------------------------------------------------
void __cdecl add_opt(const opt_table *entry)
{
  unsigned int v1; // r2
  opt_table *v2; // r12
  opt_type type; // r1
  unsigned __int8 *(*cb)(void *); // r2
  unsigned __int8 *(*cb_arg)(const unsigned __int8 *, void *); // r3
  const void *carg; // r1
  const unsigned __int8 *desc; // r2

  opt_table_0 = (opt_table *)realloc(opt_table_0, 28 * (opt_count + 1));
  v1 = opt_count++;
  v2 = &opt_table_0[v1];
  type = entry->type;
  cb = entry->cb;
  cb_arg = entry->cb_arg;
  v2->names = entry->names;
  v2->type = type;
  v2->cb = cb;
  v2->cb_arg = cb_arg;
  v2 = (opt_table *)((char *)v2 + 16);
  carg = entry->u.carg;
  desc = entry->desc;
  v2->names = (const unsigned __int8 *)entry->show;
  v2->type = (opt_type)carg;
  v2->cb = (unsigned __int8 *(*)(void *))desc;
}

//----- (0008E694) --------------------------------------------------------
void __cdecl opt_register_table(const opt_table *entry, const unsigned __int8 *desc)
{
  opt_table heading; // [sp+Ch] [bp-28h] BYREF
  unsigned int start; // [sp+28h] [bp-Ch]
  unsigned int i; // [sp+2Ch] [bp-8h]

  start = opt_count;
  if ( desc )
  {
    heading.names = 0;
    heading.type = OPT_SUBTABLE;
    memset(&heading.cb, 0, 16);
    heading.desc = desc;
    add_opt(&heading);
  }
  for ( i = 0; entry[i].type != OPT_END; ++i )
  {
    if ( entry[i].type == OPT_SUBTABLE )
    {
      opt_register_table((const opt_table *)entry[i].names, entry[i].desc);
    }
    else
    {
      check_opt(&entry[i]);
      add_opt(&entry[i]);
    }
  }
  if ( desc )
    opt_table_0[start].u.tlen = opt_count - start;
}

//----- (0008E870) --------------------------------------------------------
bool __cdecl opt_parse(int *argc, unsigned __int8 **argv, void (*errlog)(const unsigned __int8 *, ...))
{
  unsigned int offset; // [sp+10h] [bp-Ch] BYREF
  int ret; // [sp+14h] [bp-8h]

  offset = 0;
  opt_argv0 = *argv;
  do
    ret = parse_one(argc, argv, &offset, errlog);
  while ( ret == 1 );
  return ret == 0;
}

//----- (0008E8E8) --------------------------------------------------------
unsigned int __cdecl write_short_options(unsigned __int8 *str)
{
  unsigned int v1; // r3
  unsigned int i; // [sp+Ch] [bp-10h] BYREF
  const unsigned __int8 *p; // [sp+10h] [bp-Ch]
  unsigned int num; // [sp+14h] [bp-8h]

  num = 0;
  for ( p = first_sopt(&i); p; p = next_sopt(p, &i) )
  {
    if ( opt_table_0[i].desc != opt_hidden )
    {
      v1 = num++;
      str[v1] = *p;
    }
  }
  return num;
}

//----- (0008E99C) --------------------------------------------------------
unsigned __int8 *__cdecl opt_usage(const unsigned __int8 *argv0, const unsigned __int8 *extra)
{
  size_t v2; // r4
  int v4; // r0
  unsigned int v5; // r2
  int v6; // r0
  int v7; // r0
  int v8; // r0
  const unsigned __int8 *extraa; // [sp+0h] [bp-7Ch]
  unsigned __int8 buf[84]; // [sp+8h] [bp-74h] BYREF
  unsigned int num; // [sp+5Ch] [bp-20h]
  unsigned __int8 *ret; // [sp+60h] [bp-1Ch]
  unsigned __int8 *p; // [sp+64h] [bp-18h]
  unsigned int len; // [sp+68h] [bp-14h]
  unsigned int i; // [sp+6Ch] [bp-10h]

  extraa = extra;
  if ( !extra )
  {
    extraa = (const unsigned __int8 *)&unk_AF0B8;
    for ( i = 0; i < opt_count; ++i )
    {
      if ( (unsigned __int8 *(__cdecl *)(const unsigned __int8 *))opt_table_0[i].cb == opt_usage_and_exit
        && opt_table_0[i].u.tlen )
      {
        extraa = (const unsigned __int8 *)opt_table_0[i].u.carg;
        break;
      }
    }
  }
  v2 = strlen((const char *)argv0) + opt_num_short;
  len = v2 + strlen((const char *)extraa) + 20;
  for ( i = 0; i < opt_count; ++i )
  {
    if ( opt_table_0[i].type == OPT_SUBTABLE )
    {
      len += strlen((const char *)opt_table_0[i].desc) + 3;
    }
    else if ( opt_table_0[i].desc != opt_hidden )
    {
      len += strlen((const char *)opt_table_0[i].names) + 6;
      len += strlen((const char *)opt_table_0[i].desc) + 21;
      if ( opt_table_0[i].show )
        len += 97;
      ++len;
    }
  }
  ret = (unsigned __int8 *)malloc(len);
  p = ret;
  if ( !ret )
    return 0;
  p += sprintf((char *)p, "Usage: %s", (const char *)argv0);
  *(_DWORD *)p = &nonce_num[1][67][31];
  p += 3;
  num = write_short_options(p);
  if ( num )
  {
    p += num;
    strcpy((char *)p++, "]");
  }
  else
  {
    p -= 3;
  }
  if ( extraa )
    p += sprintf((char *)p, " %s", (const char *)extraa);
  strcpy((char *)p++, "\n");
  for ( i = 0; i < opt_count; ++i )
  {
    if ( opt_table_0[i].desc != opt_hidden )
    {
      if ( opt_table_0[i].type == OPT_SUBTABLE )
      {
        v4 = sprintf((char *)p, "%s:\n", (const char *)opt_table_0[i].desc);
        p += v4;
      }
      else
      {
        len = sprintf((char *)p, "%s", (const char *)opt_table_0[i].names);
        if ( opt_table_0[i].type == OPT_HASARG
          && !strchr((const char *)opt_table_0[i].names, 32)
          && !strchr((const char *)opt_table_0[i].names, 61) )
        {
          strcpy((char *)&p[len], " <arg>");
          len += 6;
        }
        if ( len > 0x13 )
          v5 = 1;
        else
          v5 = 20 - len;
        v6 = sprintf((char *)&p[len], "%.*s", v5, "                    ");
        len += v6;
        v7 = sprintf((char *)&p[len], "%s", (const char *)opt_table_0[i].desc);
        len += v7;
        if ( opt_table_0[i].show )
        {
          strcpy((char *)&buf[80], "...");
          opt_table_0[i].show(buf, (const void *)opt_table_0[i].u.tlen);
          v8 = sprintf((char *)&p[len], " (default: %s)", (const char *)buf);
          len += v8;
        }
        p += len;
        strcpy((char *)p++, "\n");
      }
    }
  }
  *p = 0;
  return ret;
}

//----- (0008F1AC) --------------------------------------------------------
int __cdecl parse_err(
        void (*errlog)(const unsigned __int8 *, ...),
        const unsigned __int8 *argv0,
        const unsigned __int8 *arg,
        unsigned int len,
        const unsigned __int8 *problem)
{
  errlog("%s: %.*s: %s", (const char *)argv0, len, (const char *)arg, (const char *)problem);
  return -1;
}

//----- (0008F1FC) --------------------------------------------------------
void __cdecl consume_option(int *argc, unsigned __int8 **argv, unsigned int optnum)
{
  memmove(&argv[optnum], &argv[optnum + 1], 4 * (*argc - optnum));
  --*argc;
}

//----- (0008F278) --------------------------------------------------------
int __cdecl parse_one(
        int *argc,
        unsigned __int8 **argv,
        unsigned int *offset,
        void (*errlog)(const unsigned __int8 *, ...))
{
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int len; // [sp+18h] [bp-24h] BYREF
  unsigned int i; // [sp+1Ch] [bp-20h] BYREF
  unsigned __int8 *problem; // [sp+20h] [bp-1Ch]
  const unsigned __int8 *optarg; // [sp+24h] [bp-18h]
  const unsigned __int8 *o; // [sp+28h] [bp-14h]
  unsigned int arg; // [sp+2Ch] [bp-10h]

  optarg = 0;
  if ( getenv("POSIXLY_CORRECT") )
  {
    arg = 1;
  }
  else
  {
    for ( arg = 1; argv[arg] && *argv[arg] != 45; ++arg )
      ;
  }
  if ( !argv[arg] || *argv[arg] != 45 )
    return 0;
  if ( !strcmp((const char *)argv[arg], "--") )
  {
    consume_option(argc, argv, arg);
    return 0;
  }
  else
  {
    if ( argv[arg][1] == 45 )
    {
      if ( *offset )
        _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, (const char *)_PRETTY_FUNCTION___6518);
      for ( o = first_lopt(&i, &len); o; o = next_lopt(o, &i, &len) )
      {
        if ( !strncmp((const char *)argv[arg] + 2, (const char *)o, len) )
        {
          if ( argv[arg][len + 2] == 61 )
          {
            optarg = &argv[arg][len + 3];
            break;
          }
          if ( !argv[arg][len + 2] )
            break;
        }
      }
      if ( !o )
      {
        v5 = strlen((const char *)argv[arg]);
        return parse_err(errlog, *argv, argv[arg], v5, "unrecognized option");
      }
      o -= 2;
      len += 2;
    }
    else
    {
      for ( o = first_sopt(&i); o; o = next_sopt(o, &i) )
      {
        if ( argv[arg][*offset + 1] == *o )
        {
          ++*offset;
          break;
        }
      }
      if ( !o )
      {
        v6 = strlen((const char *)argv[arg]);
        return parse_err(errlog, *argv, argv[arg], v6, "unrecognized option");
      }
      --o;
      len = 2;
    }
    if ( opt_table_0[i].type == OPT_NOARG )
    {
      if ( optarg )
        return parse_err(errlog, *argv, o, len, "doesn't allow an argument");
      problem = opt_table_0[i].cb(opt_table_0[i].u.tlen);
    }
    else
    {
      if ( !optarg )
      {
        if ( *offset && argv[arg][*offset + 1] )
        {
          optarg = &argv[arg][*offset + 1];
          *offset = 0;
        }
        else
        {
          optarg = argv[arg + 1];
        }
      }
      if ( !optarg )
        return parse_err(errlog, *argv, o, len, "requires an argument");
      if ( opt_table_0[i].type == OPT_PROCESSARG )
        opt_set_charp(optarg, (unsigned __int8 **)opt_table_0[i].u.carg);
      problem = opt_table_0[i].cb_arg(optarg, opt_table_0[i].u.tlen);
    }
    if ( problem )
    {
      parse_err(errlog, *argv, o, len, problem);
      free(problem);
      return -1;
    }
    else
    {
      if ( *offset && !argv[arg][*offset + 1] )
        *offset = 0;
      if ( !*offset )
      {
        consume_option(argc, argv, arg);
        if ( optarg )
        {
          if ( optarg == argv[arg] )
            consume_option(argc, argv, arg);
        }
      }
      return 1;
    }
  }
}

//----- (0008F9FC) --------------------------------------------------------
int __cdecl strbuffer_init(strbuffer_t *strbuff)
{
  strbuff->size = 16;
  strbuff->length = 0;
  strbuff->value = (unsigned __int8 *)jsonp_malloc(strbuff->size);
  if ( !strbuff->value )
    return -1;
  *strbuff->value = 0;
  return 0;
}

//----- (0008FA78) --------------------------------------------------------
void __cdecl strbuffer_close(strbuffer_t *strbuff)
{
  if ( strbuff->value )
    jsonp_free(strbuff->value);
  strbuff->size = 0;
  strbuff->length = 0;
  strbuff->value = 0;
}

//----- (0008FAD8) --------------------------------------------------------
void __cdecl strbuffer_clear(strbuffer_t *strbuff)
{
  strbuff->length = 0;
  *strbuff->value = 0;
}

//----- (0008FB14) --------------------------------------------------------
const unsigned __int8 *__cdecl strbuffer_value(const strbuffer_t *strbuff)
{
  return strbuff->value;
}

//----- (0008FB3C) --------------------------------------------------------
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, unsigned __int8 byte)
{
  unsigned __int8 bytea; // [sp+3h] [bp-9h] BYREF
  strbuffer_t *strbuffa; // [sp+4h] [bp-8h]

  strbuffa = strbuff;
  bytea = byte;
  return strbuffer_append_bytes(strbuff, &bytea, 1u);
}

//----- (0008FB78) --------------------------------------------------------
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const unsigned __int8 *data, size_t size)
{
  size_t v4; // r3
  unsigned __int8 *new_value; // [sp+10h] [bp-Ch]
  size_t new_size; // [sp+14h] [bp-8h]

  if ( size < strbuff->size - strbuff->length )
    goto LABEL_11;
  if ( (strbuff->size & 0x80000000) == 0 && size != -1 && strbuff->length <= -2 - size )
  {
    v4 = 2 * strbuff->size;
    if ( strbuff->length + size + 1 >= v4 )
      v4 = strbuff->length + size + 1;
    new_size = v4;
    new_value = (unsigned __int8 *)jsonp_malloc(v4);
    if ( !new_value )
      return -1;
    memcpy(new_value, strbuff->value, strbuff->length);
    jsonp_free(strbuff->value);
    strbuff->value = new_value;
    strbuff->size = new_size;
LABEL_11:
    memcpy(&strbuff->value[strbuff->length], data, size);
    strbuff->length += size;
    strbuff->value[strbuff->length] = 0;
    return 0;
  }
  return -1;
}

//----- (0008FCF0) --------------------------------------------------------
unsigned __int8 __cdecl strbuffer_pop(strbuffer_t *strbuff)
{
  unsigned __int8 *value; // r2
  unsigned __int8 c; // [sp+Fh] [bp-5h]

  if ( !strbuff->length )
    return 0;
  value = strbuff->value;
  c = value[--strbuff->length];
  strbuff->value[strbuff->length] = 0;
  return c;
}

//----- (0008FD78) --------------------------------------------------------
void __cdecl jsonp_error_init(json_error_t *error, const unsigned __int8 *source)
{
  if ( error )
  {
    error->text[0] = 0;
    error->line = -1;
    error->column = -1;
    error->position = 0;
    if ( source )
      jsonp_error_set_source(error, source);
    else
      error->source[0] = 0;
  }
}

//----- (0008FDFC) --------------------------------------------------------
void __cdecl jsonp_error_set_source(json_error_t *error, const unsigned __int8 *source)
{
  size_t length; // [sp+Ch] [bp-8h]

  if ( error && source )
  {
    length = strlen((const char *)source);
    if ( length > 0x4F )
    {
      *(_WORD *)error->source = 11822;
      error->source[2] = 46;
      strncpy((char *)&error->source[3], (const char *)&source[length - 76], 0x4Du);
    }
    else
    {
      strncpy((char *)error->source, (const char *)source, length + 1);
    }
  }
}

//----- (0008FECC) --------------------------------------------------------
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const unsigned __int8 *msg, ...)
{
  va_list va; // [sp+2Ch] [bp+8h] BYREF

  va_start(va, msg);
  jsonp_error_vset(error, line, column, position, msg, va);
}

//----- (0008FF20) --------------------------------------------------------
void __cdecl jsonp_error_vset(
        json_error_t *error,
        int line,
        int column,
        size_t position,
        const unsigned __int8 *msg,
        va_list ap)
{
  if ( error )
  {
    if ( !error->text[0] )
    {
      error->line = line;
      error->column = column;
      error->position = position;
      vsnprintf((char *)error->text, 0xA0u, (const char *)msg, ap);
      error->text[159] = 0;
    }
  }
}

//----- (0008FFB8) --------------------------------------------------------
void __cdecl to_locale(strbuffer_t *strbuffer)
{
  struct lconv *v1; // r0
  unsigned __int8 *pos; // [sp+8h] [bp-Ch]
  const unsigned __int8 *point; // [sp+Ch] [bp-8h]

  v1 = localeconv();
  point = (const unsigned __int8 *)v1->decimal_point;
  if ( *v1->decimal_point != 46 )
  {
    pos = (unsigned __int8 *)strchr((const char *)strbuffer->value, 46);
    if ( pos )
      *pos = *point;
  }
}

//----- (0009002C) --------------------------------------------------------
void __cdecl from_locale(unsigned __int8 *buffer)
{
  struct lconv *v1; // r0
  unsigned __int8 *pos; // [sp+8h] [bp-Ch]

  v1 = localeconv();
  if ( *v1->decimal_point != 46 )
  {
    pos = (unsigned __int8 *)strchr((const char *)buffer, *(unsigned __int8 *)v1->decimal_point);
    if ( pos )
      *pos = 46;
  }
}

//----- (000900A0) --------------------------------------------------------
int __cdecl jsonp_strtod(strbuffer_t *strbuffer, double *out)
{
  double v2; // d0
  unsigned __int8 *end; // [sp+Ch] [bp-10h] BYREF
  double value; // [sp+10h] [bp-Ch]

  to_locale(strbuffer);
  *_errno_location() = 0;
  strtod((const char *)strbuffer->value, (char **)&end);
  value = v2;
  if ( &strbuffer->value[strbuffer->length] != end )
    _assert_fail(
      "end == strbuffer->value + strbuffer->length",
      "compat/jansson-2.9/src/strconv.c",
      0x50u,
      (const char *)_PRETTY_FUNCTION___8123);
  if ( (value > 1.79769313e308 || value < -1.79769313e308) && *_errno_location() == 34 )
    return -1;
  *out = value;
  return 0;
}
// 900E4: variable 'v2' is possibly undefined

//----- (00090198) --------------------------------------------------------
int __cdecl jsonp_dtostr(unsigned __int8 *buffer, size_t size, double value, int precision)
{
  double v4; // d0
  int precisiona; // [sp+Ch] [bp-28h]
  signed int ret; // [sp+20h] [bp-14h]
  int length; // [sp+24h] [bp-10h]
  unsigned __int8 *end; // [sp+28h] [bp-Ch]
  unsigned __int8 *start; // [sp+2Ch] [bp-8h]
  unsigned __int8 *starta; // [sp+2Ch] [bp-8h]

  precisiona = LODWORD(value);
  if ( !LODWORD(value) )
    precisiona = 17;
  ret = snprintf((char *)buffer, size, "%.*g", precisiona, v4);
  if ( ret < 0 )
    return -1;
  length = ret;
  if ( ret >= size )
    return -1;
  from_locale(buffer);
  if ( !strchr((const char *)buffer, 46) && !strchr((const char *)buffer, 101) )
  {
    if ( size <= ret + 3 )
      return -1;
    buffer[ret] = 46;
    buffer[ret + 1] = 48;
    buffer[ret + 2] = 0;
    length = ret + 2;
  }
  start = (unsigned __int8 *)strchr((const char *)buffer, 101);
  if ( start )
  {
    starta = start + 1;
    end = starta + 1;
    if ( *starta == 45 )
      ++starta;
    while ( *end == 48 )
      ++end;
    if ( end != starta )
    {
      memmove(starta, end, length - (end - buffer));
      length -= end - starta;
    }
  }
  return length;
}
// 901E4: variable 'v4' is possibly undefined

//----- (00090398) --------------------------------------------------------
void __cdecl json_decref_2(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (000903FC) --------------------------------------------------------
void __cdecl json_init(json_t_0 *json, json_type type)
{
  json->type = type;
  json->refcount = 1;
}

//----- (00090438) --------------------------------------------------------
json_object_t *json_object()
{
  json_object_t *object; // [sp+4h] [bp-8h]

  object = (json_object_t *)jsonp_malloc(0x28u);
  if ( !object )
    return 0;
  if ( !hashtable_seed )
    json_object_seed(0);
  json_init(&object->json, JSON_OBJECT);
  if ( hashtable_init(&object->hashtable) )
  {
    jsonp_free(object);
    return 0;
  }
  else
  {
    object->visited = 0;
    return object;
  }
}

//----- (000904D8) --------------------------------------------------------
void __cdecl json_delete_object(json_object_t *object)
{
  hashtable_close(&object->hashtable);
  jsonp_free(object);
}

//----- (0009050C) --------------------------------------------------------
size_t __cdecl json_object_size(const json_t_0 *json)
{
  if ( json && json->type == JSON_OBJECT )
    return json[1].type;
  else
    return 0;
}

//----- (00090560) --------------------------------------------------------
json_t_0 *__cdecl json_object_get(const json_t_0 *json, const unsigned __int8 *key)
{
  if ( key && json && json->type == JSON_OBJECT )
    return (json_t_0 *)hashtable_get((hashtable_t *)&json[1], key);
  else
    return 0;
}

//----- (000905D0) --------------------------------------------------------
int __cdecl json_object_set_new_nocheck(json_t_0 *json, const unsigned __int8 *key, json_t_0 *value)
{
  if ( !value )
    return -1;
  if ( key && json && json->type == JSON_OBJECT && json != value && !hashtable_set((hashtable_t *)&json[1], key, value) )
    return 0;
  json_decref_2(value);
  return -1;
}

//----- (00090690) --------------------------------------------------------
void *__cdecl json_object_iter(json_t_0 *json)
{
  if ( json && json->type == JSON_OBJECT )
    return hashtable_iter((hashtable_t *)&json[1]);
  else
    return 0;
}

//----- (000906EC) --------------------------------------------------------
void *__cdecl json_object_iter_next(json_t_0 *json, void *iter)
{
  if ( json && json->type == JSON_OBJECT && iter )
    return hashtable_iter_next((hashtable_t *)&json[1], iter);
  else
    return 0;
}

//----- (0009075C) --------------------------------------------------------
const unsigned __int8 *__cdecl json_object_iter_key(void *iter)
{
  if ( iter )
    return (const unsigned __int8 *)hashtable_iter_key(iter);
  else
    return 0;
}

//----- (00090798) --------------------------------------------------------
json_t_0 *__cdecl json_object_iter_value(void *iter)
{
  if ( iter )
    return (json_t_0 *)hashtable_iter_value(iter);
  else
    return 0;
}

//----- (000907D4) --------------------------------------------------------
void *__cdecl json_object_key_to_iter(const unsigned __int8 *key)
{
  if ( key )
    return (void *)(key - 16);
  else
    return 0;
}

//----- (00090814) --------------------------------------------------------
json_array_t *json_array()
{
  json_array_t *array; // [sp+4h] [bp-8h]

  array = (json_array_t *)jsonp_malloc(0x18u);
  if ( !array )
    return 0;
  json_init(&array->json, JSON_ARRAY);
  array->entries = 0;
  array->size = 8;
  array->table = (json_t_0 **)jsonp_malloc(4 * array->size);
  if ( array->table )
  {
    array->visited = 0;
    return array;
  }
  else
  {
    jsonp_free(array);
    return 0;
  }
}

//----- (000908C4) --------------------------------------------------------
void __cdecl json_delete_array(json_array_t *array)
{
  size_t i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < array->entries; ++i )
    json_decref_2(array->table[i]);
  jsonp_free(array->table);
  jsonp_free(array);
}

//----- (00090944) --------------------------------------------------------
size_t __cdecl json_array_size(const json_t_0 *json)
{
  if ( json && json->type == JSON_ARRAY )
    return json[1].refcount;
  else
    return 0;
}

//----- (00090990) --------------------------------------------------------
json_t_0 *__cdecl json_array_get(const json_t_0 *json, size_t index)
{
  if ( !json || json->type != JSON_ARRAY )
    return 0;
  if ( index < json[1].refcount )
    return *(json_t_0 **)(json[2].type + 4 * index);
  return 0;
}

//----- (00090A14) --------------------------------------------------------
void __cdecl array_copy(json_t_0 **dest, size_t dpos, json_t_0 **src, size_t spos, size_t count)
{
  memcpy(&dest[dpos], &src[spos], 4 * count);
}

//----- (00090A6C) --------------------------------------------------------
json_t_0 **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy)
{
  size_t v4; // r3
  json_t_0 **new_table; // [sp+1Ch] [bp-10h]
  size_t new_size; // [sp+20h] [bp-Ch]
  json_t_0 **old_table; // [sp+24h] [bp-8h]

  if ( array->entries + amount <= array->size )
    return array->table;
  old_table = array->table;
  v4 = array->size + amount;
  if ( 2 * array->size >= v4 )
    v4 = 2 * array->size;
  new_size = v4;
  new_table = (json_t_0 **)jsonp_malloc(4 * v4);
  if ( !new_table )
    return 0;
  array->size = new_size;
  array->table = new_table;
  if ( !copy )
    return old_table;
  array_copy(array->table, 0, old_table, 0, array->entries);
  jsonp_free(old_table);
  return array->table;
}

//----- (00090B7C) --------------------------------------------------------
int __cdecl json_array_append_new(json_t_0 *json, json_t_0 *value)
{
  if ( !value )
    return -1;
  if ( json && json->type == JSON_ARRAY && json != value && json_array_grow((json_array_t *)json, 1u, 1) )
  {
    *(_DWORD *)(json[2].type + 4 * json[1].refcount++) = value;
    return 0;
  }
  else
  {
    json_decref_2(value);
    return -1;
  }
}

//----- (00090C58) --------------------------------------------------------
json_t_0 *__cdecl string_create(const unsigned __int8 *value, size_t len, int own)
{
  json_string_t *string; // [sp+10h] [bp-Ch]
  unsigned __int8 *v; // [sp+14h] [bp-8h]

  if ( !value )
    return 0;
  if ( own )
  {
    v = (unsigned __int8 *)value;
  }
  else
  {
    v = jsonp_strndup(value, len);
    if ( !v )
      return 0;
  }
  string = (json_string_t *)jsonp_malloc(0x10u);
  if ( string )
  {
    json_init(&string->json, JSON_STRING);
    string->value = v;
    string->length = len;
    return &string->json;
  }
  else
  {
    if ( !own )
      jsonp_free(v);
    return 0;
  }
}

//----- (00090D2C) --------------------------------------------------------
json_t_0 *__cdecl jsonp_stringn_nocheck_own(const unsigned __int8 *value, size_t len)
{
  return string_create(value, len, 1);
}

//----- (00090D60) --------------------------------------------------------
const unsigned __int8 *__cdecl json_string_value(const json_t_0 *json)
{
  if ( json && json->type == JSON_STRING )
    return (const unsigned __int8 *)json[1].type;
  else
    return 0;
}

//----- (00090DAC) --------------------------------------------------------
size_t __cdecl json_string_length(const json_t_0 *json)
{
  if ( json && json->type == JSON_STRING )
    return json[1].refcount;
  else
    return 0;
}

//----- (00090DF8) --------------------------------------------------------
void __cdecl json_delete_string(json_string_t *string)
{
  jsonp_free(string->value);
  jsonp_free(string);
}

//----- (00090E2C) --------------------------------------------------------
json_t_0 *__cdecl json_integer(json_int_t value)
{
  json_integer_t *integer; // [sp+Ch] [bp-8h]

  integer = (json_integer_t *)jsonp_malloc(0x10u);
  if ( !integer )
    return 0;
  json_init(&integer->json, JSON_INTEGER);
  integer->value = value;
  return &integer->json;
}

//----- (00090E88) --------------------------------------------------------
json_int_t __cdecl json_integer_value(const json_t_0 *json)
{
  if ( json && json->type == JSON_INTEGER )
    return (json_int_t)json[1];
  else
    return 0LL;
}

//----- (00090EDC) --------------------------------------------------------
void __cdecl json_delete_integer(json_integer_t *integer)
{
  jsonp_free(integer);
}

//----- (00090F00) --------------------------------------------------------
json_t_0 *__cdecl json_real(double value)
{
  double v1; // d0
  json_real_t *real; // [sp+Ch] [bp-8h]

  if ( fabs(v1) > 1.79769313e308 )
    return 0;
  real = (json_real_t *)jsonp_malloc(0x10u);
  if ( !real )
    return 0;
  json_init(&real->json, JSON_REAL);
  real->value = v1;
  return &real->json;
}
// 90F28: variable 'v1' is possibly undefined

//----- (00090FB0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_real_value(const json_t_0 *json)
{
  double result; // r0

  LODWORD(result) = json;
  return result;
}
// 90FB0: variables would overlap: r0.4 and r0.8
// 90FB0: bad return variable

//----- (00091004) --------------------------------------------------------
void __cdecl json_delete_real(json_real_t *real)
{
  jsonp_free(real);
}

//----- (00091028) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_number_value(const json_t_0 *json)
{
  double result; // r0

  if ( json && json->type == JSON_INTEGER )
  {
    *(double *)&json = (double)json_integer_value(json);
  }
  else if ( json && json->type == JSON_REAL )
  {
    *(double *)&json = json_real_value(json);
  }
  LODWORD(result) = json;
  return result;
}
// 91028: variables would overlap: r0.4 and r0.8
// 91028: bad return variable

//----- (000910C0) --------------------------------------------------------
json_t_0 *json_true()
{
  return &the_true_8956;
}

//----- (000910E0) --------------------------------------------------------
json_t_0 *json_false()
{
  return &the_false_8960;
}

//----- (00091100) --------------------------------------------------------
json_t_0 *json_null()
{
  return &the_null_8964;
}

//----- (00091120) --------------------------------------------------------
void __cdecl json_delete(json_t_0 *json)
{
  if ( json )
  {
    switch ( json->type )
    {
      case JSON_OBJECT:
        json_delete_object((json_object_t *)json);
        break;
      case JSON_ARRAY:
        json_delete_array((json_array_t *)json);
        break;
      case JSON_STRING:
        json_delete_string((json_string_t *)json);
        break;
      case JSON_INTEGER:
        json_delete_integer((json_integer_t *)json);
        break;
      case JSON_REAL:
        json_delete_real((json_real_t *)json);
        break;
      default:
        return;
    }
  }
}
// 9114C: control flows out of bounds to 91150

//----- (000911B4) --------------------------------------------------------
int __cdecl seed_from_timestamp_and_pid(uint32_t *seed)
{
  *seed = time(0);
  return 0;
}

//----- (000911EC) --------------------------------------------------------
uint32_t generate_seed()
{
  uint32_t seed; // [sp+0h] [bp-Ch] BYREF
  int done; // [sp+4h] [bp-8h]

  done = 0;
  seed_from_timestamp_and_pid(&seed);
  if ( !seed )
    return 1;
  return seed;
}

//----- (0009123C) --------------------------------------------------------
void __cdecl json_object_seed(size_t seed)
{
  size_t new_seed; // [sp+Ch] [bp-8h]

  new_seed = seed;
  if ( !hashtable_seed )
  {
    if ( !seed )
      new_seed = generate_seed();
    hashtable_seed = new_seed;
  }
}

//----- (00091298) --------------------------------------------------------
json_t_0 *__cdecl json_incref(json_t_0 *json)
{
  if ( json )
  {
    if ( json->refcount != -1 )
      ++json->refcount;
  }
  return json;
}

//----- (000912EC) --------------------------------------------------------
void __cdecl json_decref_3(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (00091350) --------------------------------------------------------
int __cdecl json_object_set_nocheck(json_t_0 *object, const unsigned __int8 *key, json_t_0 *value)
{
  json_t_0 *v3; // r0

  v3 = json_incref(value);
  return json_object_set_new_nocheck(object, key, v3);
}

//----- (00091394) --------------------------------------------------------
int __cdecl json_array_append(json_t_0 *array, json_t_0 *value)
{
  json_t_0 *v2; // r0

  v2 = json_incref(value);
  return json_array_append_new(array, v2);
}

//----- (000913D0) --------------------------------------------------------
void error_set(json_error_t *error, const lex_t *lex, const unsigned __int8 *msg, ...)
{
  unsigned __int8 msg_with_context[160]; // [sp+10h] [bp-15Ch] BYREF
  unsigned __int8 msg_text[160]; // [sp+B0h] [bp-BCh] BYREF
  va_list ap; // [sp+150h] [bp-1Ch]
  const unsigned __int8 *saved_text; // [sp+154h] [bp-18h]
  const unsigned __int8 *result; // [sp+158h] [bp-14h]
  size_t pos; // [sp+15Ch] [bp-10h]
  int col; // [sp+160h] [bp-Ch]
  int line; // [sp+164h] [bp-8h]
  const unsigned __int8 *msga; // [sp+170h] [bp+4h]
  va_list varg_r3; // [sp+174h] [bp+8h] BYREF

  va_start(varg_r3, msg);
  msga = msg;
  line = -1;
  col = -1;
  pos = 0;
  result = msg_text;
  if ( error )
  {
    va_copy(ap, varg_r3);
    vsnprintf((char *)msg_text, 0xA0u, (const char *)msga, varg_r3);
    msg_text[159] = 0;
    if ( lex )
    {
      saved_text = strbuffer_value(&lex->saved_text);
      line = lex->stream.line;
      col = lex->stream.column;
      pos = lex->stream.position;
      if ( saved_text && *saved_text )
      {
        if ( lex->saved_text.length <= 0x14 )
        {
          snprintf((char *)msg_with_context, 0xA0u, "%s near '%s'", (const char *)msg_text, (const char *)saved_text);
          msg_with_context[159] = 0;
          result = msg_with_context;
        }
      }
      else if ( lex->stream.state == -2 )
      {
        result = msg_text;
      }
      else
      {
        snprintf((char *)msg_with_context, 0xA0u, "%s near end of file", (const char *)msg_text);
        msg_with_context[159] = 0;
        result = msg_with_context;
      }
    }
    jsonp_error_set(error, line, col, pos, "%s", (const char *)result);
  }
}

//----- (00091564) --------------------------------------------------------
void __cdecl stream_init(stream_t *stream, get_func get, void *data)
{
  stream->get = get;
  stream->data = data;
  stream->buffer[0] = 0;
  stream->buffer_pos = 0;
  stream->state = 0;
  stream->line = 1;
  stream->column = 0;
  stream->position = 0;
}

//----- (000915EC) --------------------------------------------------------
int __cdecl stream_get(stream_t *stream, json_error_t *error)
{
  size_t buffer_pos; // r3
  size_t count; // [sp+Ch] [bp-10h]
  int c; // [sp+10h] [bp-Ch]
  int ca; // [sp+10h] [bp-Ch]
  size_t i; // [sp+14h] [bp-8h]

  if ( stream->state )
    return stream->state;
  if ( !stream->buffer[stream->buffer_pos] )
  {
    c = stream->get(stream->data);
    if ( c == -1 )
    {
      stream->state = -1;
      return -1;
    }
    stream->buffer[0] = c;
    stream->buffer_pos = 0;
    if ( c <= 127 || c > 255 )
    {
      stream->buffer[1] = 0;
    }
    else
    {
      count = utf8_check_first(c);
      if ( !count )
        goto out;
      if ( count <= 1 )
        _assert_fail("count >= 2", "compat/jansson-2.9/src/load.c", 0xBCu, (const char *)_PRETTY_FUNCTION___7339);
      for ( i = 1; i < count; stream->buffer[i++] = stream->get(stream->data) )
        ;
      if ( !utf8_check_full(stream->buffer, count, 0) )
      {
out:
        stream->state = -2;
        error_set(error, (const lex_t *)stream, "unable to decode byte 0x%x", c);
        return -2;
      }
      stream->buffer[count] = 0;
    }
  }
  buffer_pos = stream->buffer_pos;
  stream->buffer_pos = buffer_pos + 1;
  ca = stream->buffer[buffer_pos];
  ++stream->position;
  if ( ca == 10 )
  {
    ++stream->line;
    stream->last_column = stream->column;
    stream->column = 0;
  }
  else if ( utf8_check_first(ca) )
  {
    ++stream->column;
  }
  return ca;
}

//----- (00091890) --------------------------------------------------------
void __cdecl stream_unget(stream_t *stream, int c)
{
  if ( c != -1 && c != -2 )
  {
    --stream->position;
    if ( c == 10 )
    {
      --stream->line;
      stream->column = stream->last_column;
    }
    else if ( utf8_check_first(c) )
    {
      --stream->column;
    }
    if ( !stream->buffer_pos )
      _assert_fail(
        "stream->buffer_pos > 0",
        "compat/jansson-2.9/src/load.c",
        0xF0u,
        (const char *)_PRETTY_FUNCTION___7347);
    if ( c != stream->buffer[--stream->buffer_pos] )
      _assert_fail(
        "stream->buffer[stream->buffer_pos] == c",
        "compat/jansson-2.9/src/load.c",
        0xF2u,
        (const char *)_PRETTY_FUNCTION___7347);
  }
}

//----- (000919C8) --------------------------------------------------------
int __cdecl lex_get(lex_t *lex, json_error_t *error)
{
  return stream_get(&lex->stream, error);
}

//----- (000919FC) --------------------------------------------------------
void __cdecl lex_save(lex_t *lex, int c)
{
  strbuffer_append_byte(&lex->saved_text, c);
}

//----- (00091A38) --------------------------------------------------------
int __cdecl lex_get_save(lex_t *lex, json_error_t *error)
{
  int c; // [sp+Ch] [bp-8h]

  c = stream_get(&lex->stream, error);
  if ( c != -1 && c != -2 )
    lex_save(lex, c);
  return c;
}

//----- (00091A94) --------------------------------------------------------
void __cdecl lex_unget(lex_t *lex, int c)
{
  stream_unget(&lex->stream, c);
}

//----- (00091AC4) --------------------------------------------------------
void __cdecl lex_unget_unsave(lex_t *lex, int c)
{
  if ( c != -1 && c != -2 )
  {
    stream_unget(&lex->stream, c);
    if ( c != strbuffer_pop(&lex->saved_text) )
      _assert_fail("c == d", "compat/jansson-2.9/src/load.c", 0x11Du, (const char *)_PRETTY_FUNCTION___7370);
  }
}

//----- (00091B54) --------------------------------------------------------
void __cdecl lex_save_cached(lex_t *lex)
{
  while ( lex->stream.buffer[lex->stream.buffer_pos] )
  {
    lex_save(lex, lex->stream.buffer[lex->stream.buffer_pos]);
    ++lex->stream.buffer_pos;
    ++lex->stream.position;
  }
}

//----- (00091BD8) --------------------------------------------------------
void __cdecl lex_free_string(lex_t *lex)
{
  jsonp_free(lex->value.string.val);
  lex->value.string.val = 0;
  lex->value.string.len = 0;
}

//----- (00091C1C) --------------------------------------------------------
int32_t __cdecl decode_unicode_escape(const unsigned __int8 *str)
{
  unsigned __int8 c; // [sp+Fh] [bp-Dh]
  int32_t value; // [sp+10h] [bp-Ch]
  int32_t valuea; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  value = 0;
  if ( *str != 117 )
    _assert_fail("str[0] == 'u'", "compat/jansson-2.9/src/load.c", 0x138u, (const char *)_PRETTY_FUNCTION___7385);
  for ( i = 1; i <= 4; ++i )
  {
    c = str[i];
    valuea = 16 * value;
    if ( c <= 0x2Fu || c > 0x39u )
    {
      if ( c <= 0x60u || c > 0x7Au )
      {
        if ( c <= 0x40u || c > 0x5Au )
          return -1;
        value = valuea + c - 55;
      }
      else
      {
        value = valuea + c - 87;
      }
    }
    else
    {
      value = valuea + c - 48;
    }
  }
  return value;
}

//----- (00091D50) --------------------------------------------------------
void __cdecl lex_scan_string(lex_t *lex, json_error_t *error)
{
  int v2; // r3
  const unsigned __int8 *v3; // r2
  unsigned __int8 *v4; // r3
  size_t length; // [sp+14h] [bp-20h] BYREF
  int32_t value2; // [sp+18h] [bp-1Ch]
  int32_t value; // [sp+1Ch] [bp-18h]
  int i; // [sp+20h] [bp-14h]
  unsigned __int8 *t; // [sp+24h] [bp-10h]
  const unsigned __int8 *p; // [sp+28h] [bp-Ch]
  int c; // [sp+2Ch] [bp-8h]

  lex->value.string.val = 0;
  lex->token = -1;
  c = lex_get_save(lex, error);
  while ( c != 34 )
  {
    if ( c == -2 )
      goto out;
    if ( c == -1 )
    {
      error_set(error, lex, "premature end of input");
out:
      lex_free_string(lex);
      return;
    }
    if ( c >= 0 && c <= 31 )
    {
      lex_unget_unsave(lex, c);
      if ( c == 10 )
        error_set(error, lex, "unexpected newline", 10);
      else
        error_set(error, lex, "control character 0x%x", c);
      goto out;
    }
    if ( c == 92 )
    {
      c = lex_get_save(lex, error);
      if ( c != 117 )
      {
        if ( c != 34 && c != 92 && c != 47 && c != 98 && c != 102 && c != 110 && c != 114 && c != 116 )
        {
LABEL_19:
          error_set(error, lex, "invalid escape");
          goto out;
        }
        goto LABEL_33;
      }
      c = lex_get_save(lex, error);
      for ( i = 0; i <= 3; ++i )
      {
        if ( (c <= 47 || c > 57) && (c <= 64 || c > 70) && (c <= 96 || c > 102) )
          goto LABEL_19;
        c = lex_get_save(lex, error);
      }
    }
    else
    {
LABEL_33:
      c = lex_get_save(lex, error);
    }
  }
  t = (unsigned __int8 *)jsonp_malloc(lex->saved_text.length + 1);
  if ( !t )
    goto out;
  lex->value.string.val = t;
  p = strbuffer_value(&lex->saved_text) + 1;
  while ( *p != 34 )
  {
    if ( *p == 92 )
    {
      if ( *++p == 117 )
      {
        value = decode_unicode_escape(p);
        if ( value < 0 )
          goto LABEL_40;
        p += 5;
        if ( value < 55296 || value >= 56320 )
        {
          if ( value >= 56320 && value < 57344 )
          {
LABEL_53:
            error_set(error, lex, "invalid Unicode '\\u%04X'", value);
            goto out;
          }
        }
        else
        {
          if ( *p != 92 || p[1] != 117 )
            goto LABEL_53;
          value2 = decode_unicode_escape(++p);
          if ( value2 < 0 )
          {
LABEL_40:
            error_set(error, lex, "invalid Unicode escape '%.6s'", (const char *)p - 1);
            goto out;
          }
          p += 5;
          if ( value2 < 56320 || value2 >= 57344 )
          {
            error_set(error, lex, "invalid Unicode '\\u%04X\\u%04X'", value, value2);
            goto out;
          }
          value = ((value - 55296) << 10) + value2 - 56320 + 0x10000;
        }
        if ( utf8_encode(value, t, &length) )
          _assert_fail("0", "compat/jansson-2.9/src/load.c", 0x1DBu, (const char *)_PRETTY_FUNCTION___7408);
        t += length;
      }
      else
      {
        v2 = *p;
        if ( v2 == 98 )
        {
          *t = 8;
        }
        else if ( *p > 0x62u )
        {
          if ( v2 == 110 )
          {
            *t = 10;
          }
          else if ( *p > 0x6Eu )
          {
            if ( v2 == 114 )
            {
              *t = 13;
            }
            else
            {
              if ( v2 != 116 )
                goto LABEL_76;
              *t = 9;
            }
          }
          else
          {
            if ( v2 != 102 )
              goto LABEL_76;
            *t = 12;
          }
        }
        else
        {
          if ( v2 != 47 && v2 != 92 && v2 != 34 )
LABEL_76:
            _assert_fail("0", "compat/jansson-2.9/src/load.c", 0x1F7u, (const char *)_PRETTY_FUNCTION___7408);
          *t = *p;
        }
        ++t;
        ++p;
      }
    }
    else
    {
      v3 = p++;
      v4 = t++;
      *v4 = *v3;
    }
  }
  *t = 0;
  lex->value.string.len = t - lex->value.string.val;
  lex->token = 256;
}

//----- (00092380) --------------------------------------------------------
int __cdecl lex_scan_number(lex_t *lex, int c, json_error_t *error)
{
  int ca; // [sp+8h] [bp-2Ch]
  int cb; // [sp+8h] [bp-2Ch]
  double doubleval; // [sp+10h] [bp-24h] BYREF
  unsigned __int8 *end; // [sp+1Ch] [bp-18h] BYREF
  json_int_t intval; // [sp+20h] [bp-14h]
  const unsigned __int8 *saved_text; // [sp+2Ch] [bp-8h]

  ca = c;
  lex->token = -1;
  if ( c == 45 )
    ca = lex_get_save(lex, error);
  if ( ca == 48 )
  {
    ca = lex_get_save(lex, error);
    if ( ca > 47 && ca <= 57 )
    {
LABEL_6:
      lex_unget_unsave(lex, ca);
      return -1;
    }
  }
  else
  {
    if ( ca <= 47 || ca > 57 )
      goto LABEL_6;
    do
      ca = lex_get_save(lex, error);
    while ( ca > 47 && ca <= 57 );
  }
  if ( (lex->flags & 8) != 0 || ca == 46 || ca == 69 || ca == 101 )
  {
    if ( ca == 46 )
    {
      cb = lex_get(lex, error);
      if ( cb <= 47 || cb > 57 )
      {
        lex_unget(lex, cb);
        return -1;
      }
      lex_save(lex, cb);
      do
        ca = lex_get_save(lex, error);
      while ( ca > 47 && ca <= 57 );
    }
    if ( ca == 69 || ca == 101 )
    {
      ca = lex_get_save(lex, error);
      if ( ca == 43 || ca == 45 )
        ca = lex_get_save(lex, error);
      if ( ca <= 47 || ca > 57 )
        goto LABEL_6;
      do
        ca = lex_get_save(lex, error);
      while ( ca > 47 && ca <= 57 );
    }
    lex_unget_unsave(lex, ca);
    if ( jsonp_strtod(&lex->saved_text, &doubleval) )
    {
      error_set(error, lex, "real number overflow");
      return -1;
    }
    lex->token = 258;
    lex->value.real = doubleval;
    return 0;
  }
  else
  {
    lex_unget_unsave(lex, ca);
    saved_text = strbuffer_value(&lex->saved_text);
    *_errno_location() = 0;
    intval = strtoll((const char *)saved_text, (char **)&end, 10);
    if ( *_errno_location() == 34 )
    {
      if ( intval >= 0 )
        error_set(error, lex, "too big integer", HIDWORD(intval));
      else
        error_set(error, lex, "too big negative integer", HIDWORD(intval));
      return -1;
    }
    if ( &saved_text[lex->saved_text.length] != end )
      _assert_fail(
        "end == saved_text + lex->saved_text.length",
        "compat/jansson-2.9/src/load.c",
        0x249u,
        (const char *)_PRETTY_FUNCTION___7434);
    lex->token = 257;
    lex->value.integer = intval;
    return 0;
  }
}

//----- (0009271C) --------------------------------------------------------
int __cdecl lex_scan(lex_t *lex, json_error_t *error)
{
  const unsigned __int8 *saved_text; // [sp+8h] [bp-Ch]
  int c; // [sp+Ch] [bp-8h]
  int ca; // [sp+Ch] [bp-8h]

  strbuffer_clear(&lex->saved_text);
  if ( lex->token == 256 )
    lex_free_string(lex);
  do
  {
    do
      c = lex_get(lex, error);
    while ( c == 32 );
  }
  while ( c == 9 || c == 10 || c == 13 );
  if ( c == -1 )
  {
    lex->token = 0;
  }
  else if ( c == -2 )
  {
    lex->token = -1;
  }
  else
  {
    lex_save(lex, c);
    if ( c == 123 || c == 125 || c == 91 || c == 93 || c == 58 || c == 44 )
    {
      lex->token = c;
    }
    else if ( c == 34 )
    {
      lex_scan_string(lex, error);
    }
    else if ( c > 47 && c <= 57 || c == 45 )
    {
      lex_scan_number(lex, c, error);
    }
    else if ( (c <= 64 || c > 90) && (c <= 96 || c > 122) )
    {
      lex_save_cached(lex);
      lex->token = -1;
    }
    else
    {
      do
      {
        do
          ca = lex_get_save(lex, error);
        while ( ca > 64 && ca <= 90 );
      }
      while ( ca > 96 && ca <= 122 );
      lex_unget_unsave(lex, ca);
      saved_text = strbuffer_value(&lex->saved_text);
      if ( !strcmp((const char *)saved_text, "true") )
      {
        lex->token = 259;
      }
      else if ( !strcmp((const char *)saved_text, "false") )
      {
        lex->token = 260;
      }
      else if ( !strcmp((const char *)saved_text, "null") )
      {
        lex->token = 261;
      }
      else
      {
        lex->token = -1;
      }
    }
  }
  return lex->token;
}

//----- (000929DC) --------------------------------------------------------
unsigned __int8 *__cdecl lex_steal_string(lex_t *lex, size_t *out_len)
{
  unsigned __int8 *result; // [sp+Ch] [bp-8h]

  result = 0;
  if ( lex->token == 256 )
  {
    result = lex->value.string.val;
    *out_len = lex->value.string.len;
    lex->value.integer = 0LL;
  }
  return result;
}

//----- (00092A50) --------------------------------------------------------
int __cdecl lex_init(lex_t *lex, get_func get, size_t flags, void *data)
{
  stream_init(&lex->stream, get, data);
  if ( strbuffer_init(&lex->saved_text) )
    return -1;
  lex->flags = flags;
  lex->token = -1;
  return 0;
}

//----- (00092ACC) --------------------------------------------------------
void __cdecl lex_close(lex_t *lex)
{
  if ( lex->token == 256 )
    lex_free_string(lex);
  strbuffer_close(&lex->saved_text);
}

//----- (00092B10) --------------------------------------------------------
json_t_0 *__cdecl parse_object(lex_t *lex, size_t flags, json_error_t *error)
{
  size_t len; // [sp+10h] [bp-14h] BYREF
  json_t_0 *value; // [sp+14h] [bp-10h]
  unsigned __int8 *key; // [sp+18h] [bp-Ch]
  json_t_0 *object; // [sp+1Ch] [bp-8h]

  object = (json_t_0 *)json_object();
  if ( !object )
    return 0;
  lex_scan(lex, error);
  if ( lex->token == 125 )
    return object;
  while ( 1 )
  {
    if ( lex->token != 256 )
    {
      error_set(error, lex, "string or '}' expected");
      goto LABEL_25;
    }
    key = lex_steal_string(lex, &len);
    if ( !key )
      return 0;
    if ( rpl_memchr(key, 0, len) )
    {
      jsonp_free(key);
      error_set(error, lex, "NUL byte in object key not supported");
      goto LABEL_25;
    }
    if ( (flags & 1) != 0 && json_object_get(object, key) )
    {
      jsonp_free(key);
      error_set(error, lex, "duplicate object key");
      goto LABEL_25;
    }
    lex_scan(lex, error);
    if ( lex->token != 58 )
    {
      jsonp_free(key);
      error_set(error, lex, "':' expected");
      goto LABEL_25;
    }
    lex_scan(lex, error);
    value = parse_value(lex, flags, error);
    if ( !value )
    {
      jsonp_free(key);
      goto LABEL_25;
    }
    if ( json_object_set_nocheck(object, key, value) )
    {
      jsonp_free(key);
      json_decref_3(value);
      goto LABEL_25;
    }
    json_decref_3(value);
    jsonp_free(key);
    lex_scan(lex, error);
    if ( lex->token != 44 )
      break;
    lex_scan(lex, error);
  }
  if ( lex->token == 125 )
    return object;
  error_set(error, lex, "'}' expected");
LABEL_25:
  json_decref_3(object);
  return 0;
}

//----- (00092D70) --------------------------------------------------------
json_t_0 *__cdecl parse_array(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t_0 *elem; // [sp+10h] [bp-Ch]
  json_array_t *array; // [sp+14h] [bp-8h]

  array = json_array();
  if ( !array )
    return 0;
  lex_scan(lex, error);
  if ( lex->token == 93 )
    return &array->json;
  while ( lex->token )
  {
    elem = parse_value(lex, flags, error);
    if ( !elem )
      goto LABEL_14;
    if ( json_array_append(&array->json, elem) )
    {
      json_decref_3(elem);
      goto LABEL_14;
    }
    json_decref_3(elem);
    lex_scan(lex, error);
    if ( lex->token != 44 )
      break;
    lex_scan(lex, error);
  }
  if ( lex->token == 93 )
    return &array->json;
  error_set(error, lex, "']' expected");
LABEL_14:
  json_decref_3(&array->json);
  return 0;
}

//----- (00092EA0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t_0 *__cdecl parse_value(lex_t *lex, size_t flags, json_error_t *error)
{
  int token; // r3
  char v5; // r1
  size_t v6; // r1
  size_t v7; // r1
  size_t len; // [sp+14h] [bp-10h]
  unsigned __int8 *value; // [sp+18h] [bp-Ch]
  json_t_0 *json; // [sp+1Ch] [bp-8h]

  if ( ++lex->depth > 0x800 )
  {
    error_set(error, lex, "maximum parsing depth reached");
    return 0;
  }
  token = lex->token;
  if ( token == 257 )
  {
    json = json_integer(lex->value.integer);
  }
  else if ( token > 257 )
  {
    if ( token == 259 )
    {
      json = json_true();
    }
    else if ( token < 259 )
    {
      json = json_real(*(double *)&lex);
    }
    else if ( token == 260 )
    {
      json = json_false();
    }
    else
    {
      if ( token != 261 )
        goto LABEL_30;
      json = json_null();
    }
  }
  else if ( token == 91 )
  {
    json = parse_array(lex, v7, error);
  }
  else
  {
    if ( token <= 91 )
    {
      if ( token == -1 )
      {
        error_set(error, lex, "invalid token");
        return 0;
      }
LABEL_30:
      error_set(error, lex, "unexpected token");
      return 0;
    }
    if ( token == 123 )
    {
      json = parse_object(lex, v6, error);
    }
    else
    {
      if ( token != 256 )
        goto LABEL_30;
      value = lex->value.string.val;
      len = lex->value.string.len;
      if ( (v5 & 0x10) == 0 && rpl_memchr(value, 0, len) )
      {
        error_set(error, lex, "\\u0000 is not allowed without JSON_ALLOW_NUL");
        return 0;
      }
      json = jsonp_stringn_nocheck_own(value, len);
      if ( json )
      {
        lex->value.string.val = 0;
        lex->value.string.len = 0;
      }
    }
  }
  if ( !json )
    return 0;
  --lex->depth;
  return json;
}
// 92EA0: variables would overlap: r0.4 and r0.8

//----- (0009310C) --------------------------------------------------------
json_t_0 *__cdecl parse_json(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t_0 *result; // [sp+14h] [bp-8h]

  lex->depth = 0;
  lex_scan(lex, error);
  if ( (flags & 4) != 0 || lex->token == 91 || lex->token == 123 )
  {
    result = parse_value(lex, flags, error);
    if ( result )
    {
      if ( (flags & 2) != 0 || (lex_scan(lex, error), !lex->token) )
      {
        if ( error )
          error->position = lex->stream.position;
        return result;
      }
      else
      {
        error_set(error, lex, "end of file expected");
        json_decref_3(result);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    error_set(error, lex, "'[' or '{' expected");
    return 0;
  }
}

//----- (00093230) --------------------------------------------------------
int __cdecl string_get(void *data)
{
  unsigned __int8 c; // [sp+Bh] [bp-9h]

  c = *(_BYTE *)(*(_DWORD *)data + *((_DWORD *)data + 1));
  if ( !c )
    return -1;
  ++*((_DWORD *)data + 1);
  return c;
}

//----- (000932A0) --------------------------------------------------------
json_t_0 *__cdecl json_loads(const unsigned __int8 *string, size_t flags, json_error_t *error)
{
  string_data_t stream_data; // [sp+10h] [bp-5Ch] BYREF
  lex_t lex; // [sp+18h] [bp-54h] BYREF
  json_t_0 *result; // [sp+64h] [bp-8h]

  jsonp_error_init(error, "<string>");
  if ( string )
  {
    stream_data.data = string;
    stream_data.pos = 0;
    if ( lex_init(&lex, (get_func)string_get, flags, &stream_data) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (00093360) --------------------------------------------------------
int __cdecl buffer_get(void *data)
{
  if ( *((_DWORD *)data + 2) >= *((_DWORD *)data + 1) )
    return -1;
  return *(unsigned __int8 *)(*(_DWORD *)data + (*((_DWORD *)data + 2))++);
}

//----- (000933DC) --------------------------------------------------------
json_t_0 *__cdecl json_loadb(const unsigned __int8 *buffer, size_t buflen, size_t flags, json_error_t *error)
{
  buffer_data_t stream_data; // [sp+14h] [bp-60h] BYREF
  lex_t lex; // [sp+20h] [bp-54h] BYREF
  json_t_0 *result; // [sp+6Ch] [bp-8h]

  jsonp_error_init(error, "<buffer>");
  if ( buffer )
  {
    stream_data.data = buffer;
    stream_data.pos = 0;
    stream_data.len = buflen;
    if ( lex_init(&lex, (get_func)buffer_get, flags, &stream_data) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (000934A8) --------------------------------------------------------
json_t_0 *__cdecl json_loadf(FILE *input, size_t flags, json_error_t *error)
{
  lex_t lex; // [sp+10h] [bp-54h] BYREF
  json_t_0 *result; // [sp+58h] [bp-Ch]
  const unsigned __int8 *source; // [sp+5Ch] [bp-8h]

  if ( input == (FILE *)stdin )
    source = "<stdin>";
  else
    source = "<stream>";
  jsonp_error_init(error, source);
  if ( input )
  {
    if ( lex_init(&lex, (get_func)fgetc, flags, input) )
    {
      return 0;
    }
    else
    {
      result = parse_json(&lex, flags, error);
      lex_close(&lex);
      return result;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}
// C4480: using guessed type int stdin;

//----- (00093588) --------------------------------------------------------
json_t_0 *__cdecl json_load_file(const unsigned __int8 *path, size_t flags, json_error_t *error)
{
  int *v4; // r0
  char *v5; // r0
  json_t_0 *result; // [sp+18h] [bp-Ch]
  FILE *fp; // [sp+1Ch] [bp-8h]

  jsonp_error_init(error, path);
  if ( path )
  {
    fp = fopen((const char *)path, "rb");
    if ( fp )
    {
      result = json_loadf(fp, flags, error);
      fclose(fp);
      return result;
    }
    else
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      error_set(error, 0, "unable to open %s: %s", (const char *)path, v5);
      return 0;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (0009365C) --------------------------------------------------------
int __cdecl dump_to_strbuffer(const unsigned __int8 *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
}

//----- (00093694) --------------------------------------------------------
int __cdecl dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data)
{
  size_t v6; // r3
  int cur_n; // [sp+14h] [bp-10h]
  unsigned int n_spaces; // [sp+1Ch] [bp-8h]

  if ( (flags & 0x1F) == 0 )
  {
    if ( space && (flags & 0x20) == 0 )
      return dump(byte_AF648, 1, data);
    return 0;
  }
  n_spaces = depth * (flags & 0x1F);
  if ( !dump(byte_AF644, 1, data) )
  {
    while ( n_spaces )
    {
      v6 = n_spaces;
      if ( n_spaces >= 0x20 )
        v6 = 32;
      cur_n = v6;
      if ( dump(whitespace, v6, data) )
        return -1;
      n_spaces -= cur_n;
    }
    return 0;
  }
  return -1;
}
// AF644: using guessed type unsigned __int8 byte_AF644[4];
// AF648: using guessed type unsigned __int8 byte_AF648[4];

//----- (000937B4) --------------------------------------------------------
int __cdecl dump_string(const unsigned __int8 *str, size_t len, json_dump_callback_t dump, void *data, size_t flags)
{
  unsigned __int8 seq[13]; // [sp+18h] [bp-34h] BYREF
  int32_t codepoint; // [sp+28h] [bp-24h] BYREF
  int32_t last; // [sp+2Ch] [bp-20h]
  int32_t first; // [sp+30h] [bp-1Ch]
  const unsigned __int8 *lim; // [sp+34h] [bp-18h]
  int length; // [sp+38h] [bp-14h]
  const unsigned __int8 *text; // [sp+3Ch] [bp-10h]
  const unsigned __int8 *end; // [sp+40h] [bp-Ch]
  const unsigned __int8 *pos; // [sp+44h] [bp-8h]

  if ( !dump(byte_AF64C, 1, data) )
  {
    pos = str;
    end = str;
    lim = &str[len];
    while ( 1 )
    {
      while ( end < lim )
      {
        end = utf8_iterate(pos, lim - pos, &codepoint);
        if ( !end )
          return -1;
        if ( codepoint == 92
          || codepoint == 34
          || codepoint <= 31
          || (flags & 0x400) != 0 && codepoint == 47
          || (flags & 0x40) != 0 && codepoint > 127 )
        {
          break;
        }
        pos = end;
      }
      if ( pos != str && dump(str, pos - str, data) )
        return -1;
      if ( end == pos )
        return dump(byte_AF64C, 1, data);
      length = 2;
      if ( codepoint == 12 )
      {
        text = (const unsigned __int8 *)&unk_AF65C;
        goto LABEL_44;
      }
      if ( codepoint > 12 )
      {
        if ( codepoint == 34 )
        {
          text = (const unsigned __int8 *)&unk_AF654;
          goto LABEL_44;
        }
        if ( codepoint > 34 )
        {
          if ( codepoint == 47 )
          {
            text = (const unsigned __int8 *)&unk_AF66C;
            goto LABEL_44;
          }
          if ( codepoint == 92 )
          {
            text = (const unsigned __int8 *)&unk_AF650;
            goto LABEL_44;
          }
        }
        else if ( codepoint == 13 )
        {
          text = (const unsigned __int8 *)&unk_AF664;
          goto LABEL_44;
        }
      }
      else
      {
        switch ( codepoint )
        {
          case 9:
            text = (const unsigned __int8 *)&unk_AF668;
            goto LABEL_44;
          case 10:
            text = (const unsigned __int8 *)&unk_AF660;
            goto LABEL_44;
          case 8:
            text = (const unsigned __int8 *)&unk_AF658;
            goto LABEL_44;
        }
      }
      if ( codepoint >= 0x10000 )
      {
        codepoint -= 0x10000;
        first = (codepoint >> 10) & 0x3FF | 0xD800;
        last = codepoint & 0x3FF | 0xDC00;
        snprintf((char *)seq, 0xDu, "\\u%04X\\u%04X", first, last);
        length = 12;
      }
      else
      {
        snprintf((char *)seq, 0xDu, "\\u%04X", codepoint);
        length = 6;
      }
      text = seq;
LABEL_44:
      if ( dump(text, length, data) )
        return -1;
      pos = end;
      str = end;
    }
  }
  return -1;
}
// AF64C: using guessed type unsigned __int8 byte_AF64C[4];

//----- (00093B14) --------------------------------------------------------
int __cdecl compare_keys(const void *key1, const void *key2)
{
  return strcmp(*(const char **)key1, *(const char **)key2);
}

//----- (00093B54) --------------------------------------------------------
int __cdecl do_dump(const json_t_0 *json, size_t flags, int depth, json_dump_callback_t dump, void *data)
{
  double v5; // d0
  json_int_t v7; // r0
  double v8; // r2
  const unsigned __int8 *v9; // r4
  size_t v10; // r0
  json_t_0 *v11; // r0
  size_t v12; // r0
  size_t v13; // r0
  json_t_0 *v14; // r0
  int precision; // [sp+0h] [bp-D4h]
  unsigned __int8 buffer[100]; // [sp+18h] [bp-BCh] BYREF
  json_t_0 *value_0; // [sp+7Ch] [bp-58h]
  const unsigned __int8 *key; // [sp+80h] [bp-54h]
  const unsigned __int8 **keys; // [sp+84h] [bp-50h]
  size_t size_1; // [sp+88h] [bp-4Ch]
  const unsigned __int8 *key_0; // [sp+8Ch] [bp-48h]
  void *next; // [sp+90h] [bp-44h]
  json_object_t *object; // [sp+94h] [bp-40h]
  size_t n; // [sp+98h] [bp-3Ch]
  json_array_t *array; // [sp+9Ch] [bp-38h]
  int size; // [sp+A0h] [bp-34h]
  int size_0; // [sp+A4h] [bp-30h]
  double value; // [sp+A8h] [bp-2Ch]
  size_t i_0; // [sp+B4h] [bp-20h]
  int separator_length; // [sp+B8h] [bp-1Ch]
  const unsigned __int8 *separator; // [sp+BCh] [bp-18h]
  void *iter; // [sp+C0h] [bp-14h]
  size_t i; // [sp+C4h] [bp-10h]

  if ( json )
  {
    switch ( json->type )
    {
      case JSON_OBJECT:
        if ( (flags & 0x20) != 0 )
        {
          separator = ":";
          separator_length = 1;
        }
        else
        {
          separator = ": ";
          separator_length = 2;
        }
        object = (json_object_t *)json;
        if ( json[4].refcount )
          goto object_error;
        object->visited = 1;
        iter = json_object_iter((json_t_0 *)json);
        if ( dump("{", 1, data) )
          goto object_error;
        if ( !iter )
          goto LABEL_37;
        if ( dump_indent(flags, depth + 1, 0, dump, data) )
          goto object_error;
        if ( (flags & 0x80) != 0 )
        {
          size_1 = json_object_size(json);
          keys = (const unsigned __int8 **)jsonp_malloc(4 * size_1);
          if ( !keys )
          {
object_error:
            object->visited = 0;
            return -1;
          }
          i_0 = 0;
          while ( iter )
          {
            keys[i_0] = json_object_iter_key(iter);
            iter = json_object_iter_next((json_t_0 *)json, iter);
            ++i_0;
          }
          if ( i_0 != size_1 )
            _assert_fail("i == size", "compat/jansson-2.9/src/dump.c", 0x152u, (const char *)_PRETTY_FUNCTION___7378);
          qsort(keys, size_1, 4u, (__compar_fn_t)compare_keys);
          for ( i_0 = 0; i_0 < size_1; ++i_0 )
          {
            key = keys[i_0];
            value_0 = json_object_get(json, key);
            if ( !value_0 )
              _assert_fail("value", "compat/jansson-2.9/src/dump.c", 0x15Du, (const char *)_PRETTY_FUNCTION___7378);
            v12 = strlen((const char *)key);
            dump_string(key, v12, dump, data, flags);
            if ( dump(separator, separator_length, data) || do_dump(value_0, flags, depth + 1, dump, data) )
            {
LABEL_57:
              jsonp_free(keys);
              goto object_error;
            }
            if ( i_0 >= size_1 - 1 )
            {
              if ( dump_indent(flags, depth, 0, dump, data) )
                goto LABEL_57;
            }
            else if ( dump(",", 1, data) || dump_indent(flags, depth + 1, 1, dump, data) )
            {
              goto LABEL_57;
            }
          }
          jsonp_free(keys);
        }
        else
        {
          while ( iter )
          {
            next = json_object_iter_next((json_t_0 *)json, iter);
            key_0 = json_object_iter_key(iter);
            v13 = strlen((const char *)key_0);
            dump_string(key_0, v13, dump, data, flags);
            if ( dump(separator, separator_length, data) )
              goto object_error;
            v14 = json_object_iter_value(iter);
            if ( do_dump(v14, flags, depth + 1, dump, data) )
              goto object_error;
            if ( next )
            {
              if ( dump(",", 1, data) || dump_indent(flags, depth + 1, 1, dump, data) )
                goto object_error;
            }
            else if ( dump_indent(flags, depth, 0, dump, data) )
            {
              goto object_error;
            }
            iter = next;
          }
        }
LABEL_37:
        object->visited = 0;
        return dump("}", 1, data);
      case JSON_ARRAY:
        array = (json_array_t *)json;
        if ( json[2].refcount )
          goto array_error;
        array->visited = 1;
        n = json_array_size(json);
        if ( dump("[", 1, data) )
          goto array_error;
        if ( !n )
          goto LABEL_18;
        if ( dump_indent(flags, depth + 1, 0, dump, data) )
          goto array_error;
        i = 0;
        while ( 2 )
        {
          if ( i >= n )
          {
LABEL_18:
            array->visited = 0;
            return dump("]", 1, data);
          }
          v11 = json_array_get(json, i);
          if ( do_dump(v11, flags, depth + 1, dump, data) )
            break;
          if ( i >= n - 1 )
          {
            if ( !dump_indent(flags, depth, 0, dump, data) )
            {
LABEL_27:
              ++i;
              continue;
            }
          }
          else if ( !dump(",", 1, data) && !dump_indent(flags, depth + 1, 1, dump, data) )
          {
            goto LABEL_27;
          }
          break;
        }
array_error:
        array->visited = 0;
        return -1;
      case JSON_STRING:
        v9 = json_string_value(json);
        v10 = json_string_length(json);
        return dump_string(v9, v10, dump, data, flags);
      case JSON_INTEGER:
        v7 = json_integer_value(json);
        size = snprintf((char *)buffer, 0x64u, "%lld", v7);
        if ( size >= 0 && size <= 99 )
          return dump(buffer, size, data);
        else
          return -1;
      case JSON_REAL:
        json_real_value(json);
        value = v5;
        LODWORD(v8) = (unsigned __int16)flags >> 11;
        HIDWORD(v8) = buffer;
        size_0 = jsonp_dtostr(buffer, 0x64u, v8, precision);
        if ( size_0 >= 0 )
          return dump(buffer, size_0, data);
        else
          return -1;
      case JSON_TRUE:
        return dump("true", 4, data);
      case JSON_FALSE:
        return dump("false", 5, data);
      case JSON_NULL:
        return dump("null", 4, data);
      default:
        return -1;
    }
  }
  return -1;
}
// 93B94: control flows out of bounds to 93B98
// 93C88: variable 'v5' is possibly undefined
// 93CA8: variable 'precision' is possibly undefined

//----- (00094444) --------------------------------------------------------
unsigned __int8 *__cdecl json_dumps(const json_t_0 *json, size_t flags)
{
  const unsigned __int8 *v3; // r0
  strbuffer_t strbuff; // [sp+8h] [bp-14h] BYREF
  unsigned __int8 *result; // [sp+14h] [bp-8h]

  if ( strbuffer_init(&strbuff) )
    return 0;
  if ( json_dump_callback(json, (json_dump_callback_t)dump_to_strbuffer, &strbuff, flags) )
  {
    result = 0;
  }
  else
  {
    v3 = strbuffer_value(&strbuff);
    result = jsonp_strdup(v3);
  }
  strbuffer_close(&strbuff);
  return result;
}

//----- (000944E0) --------------------------------------------------------
int __cdecl json_dump_callback(const json_t_0 *json, json_dump_callback_t callback, void *data, size_t flags)
{
  if ( (flags & 0x200) != 0 || json && json->type == JSON_ARRAY || json && json->type == JSON_OBJECT )
    return do_dump(json, (unsigned __int16)flags, 0, callback, data);
  else
    return -1;
}

//----- (00094578) --------------------------------------------------------
void *__cdecl jsonp_malloc(size_t size)
{
  if ( size )
    return do_malloc(size);
  else
    return 0;
}

//----- (000945C0) --------------------------------------------------------
void __cdecl jsonp_free(void *ptr)
{
  if ( ptr )
    do_free(ptr);
}

//----- (00094600) --------------------------------------------------------
unsigned __int8 *__cdecl jsonp_strdup(const unsigned __int8 *str)
{
  size_t v1; // r0

  v1 = strlen((const char *)str);
  return jsonp_strndup(str, v1);
}

//----- (00094638) --------------------------------------------------------
unsigned __int8 *__cdecl jsonp_strndup(const unsigned __int8 *str, size_t len)
{
  unsigned __int8 *new_str; // [sp+Ch] [bp-8h]

  new_str = (unsigned __int8 *)jsonp_malloc(len + 1);
  if ( !new_str )
    return 0;
  memcpy(new_str, str, len);
  new_str[len] = 0;
  return new_str;
}

//----- (000946A8) --------------------------------------------------------
int __cdecl utf8_encode(int32_t codepoint, unsigned __int8 *buffer, size_t *size)
{
  if ( codepoint >= 0 )
  {
    if ( codepoint > 127 )
    {
      if ( codepoint >= 2048 )
      {
        if ( codepoint >= 0x10000 )
        {
          if ( codepoint >= 1114112 )
            return -1;
          *buffer = ((codepoint >> 18) & 7) - 16;
          buffer[1] = ((codepoint >> 12) & 0x3F) + 0x80;
          buffer[2] = ((codepoint >> 6) & 0x3F) + 0x80;
          buffer[3] = (codepoint & 0x3F) + 0x80;
          *size = 4;
        }
        else
        {
          *buffer = ((codepoint >> 12) & 0xF) - 32;
          buffer[1] = ((codepoint >> 6) & 0x3F) + 0x80;
          buffer[2] = (codepoint & 0x3F) + 0x80;
          *size = 3;
        }
      }
      else
      {
        *buffer = ((codepoint >> 6) & 0x1F) - 64;
        buffer[1] = (codepoint & 0x3F) + 0x80;
        *size = 2;
      }
    }
    else
    {
      *buffer = codepoint;
      *size = 1;
    }
    return 0;
  }
  return -1;
}

//----- (000948C0) --------------------------------------------------------
size_t __cdecl utf8_check_first(unsigned __int8 byte)
{
  if ( (byte & 0x80u) == 0 )
    return 1;
  if ( byte <= 0xBFu )
    return 0;
  if ( byte == 192 || byte == 193 )
    return 0;
  if ( byte > 0xC1u && byte <= 0xDFu )
    return 2;
  if ( byte > 0xDFu && byte <= 0xEFu )
    return 3;
  if ( byte <= 0xEFu || byte > 0xF4u )
    return 0;
  return 4;
}

//----- (000949A4) --------------------------------------------------------
size_t __cdecl utf8_check_full(const unsigned __int8 *buffer, size_t size, int32_t *codepoint)
{
  _BYTE u[5]; // [sp+17h] [bp-Dh]
  size_t i; // [sp+1Ch] [bp-8h]

  *(_DWORD *)u = *buffer;
  switch ( size )
  {
    case 2u:
      *(_DWORD *)&u[1] = u[0] & 0x1F;
      break;
    case 3u:
      *(_DWORD *)&u[1] = u[0] & 0xF;
      break;
    case 4u:
      *(_DWORD *)&u[1] = u[0] & 7;
      break;
    default:
      return 0;
  }
  for ( i = 1; i < size; ++i )
  {
    u[0] = buffer[i];
    if ( u[0] >= 0 || u[0] > 0xBFu )
      return 0;
    *(_DWORD *)&u[1] = (*(_DWORD *)&u[1] << 6) + (u[0] & 0x3F);
  }
  if ( *(int *)&u[1] >= 1114112 )
    return 0;
  if ( *(int *)&u[1] >= 55296 && *(int *)&u[1] < 57344 )
    return 0;
  if ( size == 2 && *(int *)&u[1] <= 127 || size == 3 && *(int *)&u[1] < 2048 || size == 4 && *(int *)&u[1] < 0x10000 )
    return 0;
  if ( codepoint )
    *codepoint = *(_DWORD *)&u[1];
  return 1;
}

//----- (00094B50) --------------------------------------------------------
const unsigned __int8 *__cdecl utf8_iterate(const unsigned __int8 *buffer, size_t bufsize, int32_t *codepoint)
{
  int32_t value; // [sp+10h] [bp-Ch] BYREF
  size_t count; // [sp+14h] [bp-8h]

  if ( !bufsize )
    return buffer;
  count = utf8_check_first(*buffer);
  if ( !count )
    return 0;
  if ( count == 1 )
  {
    value = *buffer;
  }
  else if ( count > bufsize || !utf8_check_full(buffer, count, &value) )
  {
    return 0;
  }
  if ( codepoint )
    *codepoint = value;
  return &buffer[count];
}

//----- (00094C28) --------------------------------------------------------
void __cdecl json_decref_4(json_t_0 *json)
{
  if ( json && json->refcount != -1 && !--json->refcount )
    json_delete(json);
}

//----- (00094C8C) --------------------------------------------------------
uint32_t __cdecl hashlittle(const void *key, size_t length, uint32_t initval)
{
  size_t lengtha; // [sp+8h] [bp-34h]
  const uint8_t *k_1; // [sp+20h] [bp-1Ch]
  const uint16_t *k_0; // [sp+24h] [bp-18h]
  const uint32_t *k; // [sp+28h] [bp-14h]
  int c; // [sp+2Ch] [bp-10h]
  uint32_t ca; // [sp+2Ch] [bp-10h]
  uint32_t cb; // [sp+2Ch] [bp-10h]
  int cc; // [sp+2Ch] [bp-10h]
  uint32_t cd; // [sp+2Ch] [bp-10h]
  uint32_t ce; // [sp+2Ch] [bp-10h]
  uint32_t cf; // [sp+2Ch] [bp-10h]
  int cg; // [sp+2Ch] [bp-10h]
  uint32_t ch; // [sp+2Ch] [bp-10h]
  uint32_t ci; // [sp+2Ch] [bp-10h]
  uint32_t cj; // [sp+2Ch] [bp-10h]
  int ck; // [sp+2Ch] [bp-10h]
  uint32_t cl; // [sp+2Ch] [bp-10h]
  uint32_t cm; // [sp+2Ch] [bp-10h]
  uint32_t cn; // [sp+2Ch] [bp-10h]
  uint32_t b; // [sp+30h] [bp-Ch]
  uint32_t ba; // [sp+30h] [bp-Ch]
  int bb; // [sp+30h] [bp-Ch]
  uint32_t bc; // [sp+30h] [bp-Ch]
  int bd; // [sp+30h] [bp-Ch]
  uint32_t be; // [sp+30h] [bp-Ch]
  int bf; // [sp+30h] [bp-Ch]
  uint32_t bg; // [sp+30h] [bp-Ch]
  int bh; // [sp+30h] [bp-Ch]
  uint32_t bi; // [sp+30h] [bp-Ch]
  int bj; // [sp+30h] [bp-Ch]
  uint32_t bk; // [sp+30h] [bp-Ch]
  int bl; // [sp+30h] [bp-Ch]
  uint32_t bm; // [sp+30h] [bp-Ch]
  uint32_t bn; // [sp+30h] [bp-Ch]
  uint32_t a; // [sp+34h] [bp-8h]
  int aa; // [sp+34h] [bp-8h]
  uint32_t ab; // [sp+34h] [bp-8h]
  int ac; // [sp+34h] [bp-8h]
  int ad; // [sp+34h] [bp-8h]
  uint32_t ae; // [sp+34h] [bp-8h]
  int af; // [sp+34h] [bp-8h]
  int ag; // [sp+34h] [bp-8h]
  uint32_t ah; // [sp+34h] [bp-8h]
  int ai; // [sp+34h] [bp-8h]
  uint32_t aj; // [sp+34h] [bp-8h]
  uint32_t ak; // [sp+34h] [bp-8h]

  lengtha = length;
  c = length + initval - 559038737;
  b = c;
  a = c;
  if ( ((unsigned __int8)key & 3) != 0 )
  {
    if ( ((unsigned __int8)key & 1) != 0 )
    {
      k_1 = (const uint8_t *)key;
      while ( lengtha > 0xC )
      {
        bi = b + k_1[4] + (k_1[5] << 8) + (k_1[6] << 16) + (k_1[7] << 24);
        ci = c + k_1[8] + (k_1[9] << 8) + (k_1[10] << 16) + (k_1[11] << 24);
        ag = __ROR4__(ci, 28) ^ (a + *k_1 + (k_1[1] << 8) + (k_1[2] << 16) + (k_1[3] << 24) - ci);
        cj = ci + bi;
        bj = __ROR4__(ag, 26) ^ (bi - ag);
        ah = ag + cj;
        ck = __ROR4__(bj, 24) ^ (cj - bj);
        bk = bj + ah;
        ai = __ROR4__(ck, 16) ^ (ah - ck);
        cl = ck + bk;
        bl = __ROR4__(ai, 13) ^ (bk - ai);
        a = ai + cl;
        c = __ROR4__(bl, 28) ^ (cl - bl);
        b = bl + a;
        lengtha -= 12;
        k_1 += 12;
      }
      switch ( lengtha )
      {
        case 0u:
          return c;
        case 1u:
          goto LABEL_52;
        case 2u:
          goto LABEL_51;
        case 3u:
          goto LABEL_50;
        case 4u:
          goto LABEL_49;
        case 5u:
          goto LABEL_48;
        case 6u:
          goto LABEL_47;
        case 7u:
          goto LABEL_46;
        case 8u:
          goto LABEL_45;
        case 9u:
          goto LABEL_44;
        case 0xAu:
          goto LABEL_43;
        case 0xBu:
          goto LABEL_42;
        case 0xCu:
          c += k_1[11] << 24;
LABEL_42:
          c += k_1[10] << 16;
LABEL_43:
          c += k_1[9] << 8;
LABEL_44:
          c += k_1[8];
LABEL_45:
          b += k_1[7] << 24;
LABEL_46:
          b += k_1[6] << 16;
LABEL_47:
          b += k_1[5] << 8;
LABEL_48:
          b += k_1[4];
LABEL_49:
          a += k_1[3] << 24;
LABEL_50:
          a += k_1[2] << 16;
LABEL_51:
          a += k_1[1] << 8;
LABEL_52:
          a += *k_1;
          break;
        default:
          break;
      }
    }
    else
    {
      k_0 = (const uint16_t *)key;
      while ( lengtha > 0xC )
      {
        be = b + k_0[2] + (k_0[3] << 16);
        ce = c + k_0[4] + (k_0[5] << 16);
        ad = __ROR4__(ce, 28) ^ (a + *k_0 + (k_0[1] << 16) - ce);
        cf = ce + be;
        bf = __ROR4__(ad, 26) ^ (be - ad);
        ae = ad + cf;
        cg = __ROR4__(bf, 24) ^ (cf - bf);
        bg = bf + ae;
        af = __ROR4__(cg, 16) ^ (ae - cg);
        ch = cg + bg;
        bh = __ROR4__(af, 13) ^ (bg - af);
        a = af + ch;
        c = __ROR4__(bh, 28) ^ (ch - bh);
        b = bh + a;
        lengtha -= 12;
        k_0 += 6;
      }
      switch ( lengtha )
      {
        case 0u:
          return c;
        case 1u:
          a += *(unsigned __int8 *)k_0;
          break;
        case 2u:
          goto LABEL_34;
        case 3u:
          a += *((unsigned __int8 *)k_0 + 2) << 16;
LABEL_34:
          a += *k_0;
          break;
        case 4u:
          goto LABEL_32;
        case 5u:
          b += *((unsigned __int8 *)k_0 + 4);
LABEL_32:
          a += *k_0 + (k_0[1] << 16);
          break;
        case 6u:
          goto LABEL_30;
        case 7u:
          b += *((unsigned __int8 *)k_0 + 6) << 16;
LABEL_30:
          b += k_0[2];
          a += *k_0 + (k_0[1] << 16);
          break;
        case 8u:
          goto LABEL_28;
        case 9u:
          c += *((unsigned __int8 *)k_0 + 8);
LABEL_28:
          b += k_0[2] + (k_0[3] << 16);
          a += *k_0 + (k_0[1] << 16);
          break;
        case 0xAu:
          goto LABEL_26;
        case 0xBu:
          c += *((unsigned __int8 *)k_0 + 10) << 16;
LABEL_26:
          c += k_0[4];
          b += k_0[2] + (k_0[3] << 16);
          a += *k_0 + (k_0[1] << 16);
          break;
        case 0xCu:
          c += k_0[4] + (k_0[5] << 16);
          b += k_0[2] + (k_0[3] << 16);
          a += *k_0 + (k_0[1] << 16);
          break;
        default:
          break;
      }
    }
  }
  else
  {
    k = (const uint32_t *)key;
    while ( lengtha > 0xC )
    {
      ba = b + k[1];
      ca = c + k[2];
      aa = __ROR4__(ca, 28) ^ (a + *k - ca);
      cb = ca + ba;
      bb = __ROR4__(aa, 26) ^ (ba - aa);
      ab = aa + cb;
      cc = __ROR4__(bb, 24) ^ (cb - bb);
      bc = bb + ab;
      ac = __ROR4__(cc, 16) ^ (ab - cc);
      cd = cc + bc;
      bd = __ROR4__(ac, 13) ^ (bc - ac);
      a = ac + cd;
      c = __ROR4__(bd, 28) ^ (cd - bd);
      b = bd + a;
      lengtha -= 12;
      k += 3;
    }
    switch ( lengtha )
    {
      case 0u:
        return c;
      case 1u:
        goto LABEL_17;
      case 2u:
        goto LABEL_16;
      case 3u:
        a += *((unsigned __int8 *)k + 2) << 16;
LABEL_16:
        a += *((unsigned __int8 *)k + 1) << 8;
LABEL_17:
        a += *(unsigned __int8 *)k;
        break;
      case 4u:
        goto LABEL_14;
      case 5u:
        goto LABEL_13;
      case 6u:
        goto LABEL_12;
      case 7u:
        b += *((unsigned __int8 *)k + 6) << 16;
LABEL_12:
        b += *((unsigned __int8 *)k + 5) << 8;
LABEL_13:
        b += *((unsigned __int8 *)k + 4);
LABEL_14:
        a += *k;
        break;
      case 8u:
        goto LABEL_10;
      case 9u:
        goto LABEL_9;
      case 0xAu:
        goto LABEL_8;
      case 0xBu:
        c += *((unsigned __int8 *)k + 10) << 16;
LABEL_8:
        c += *((unsigned __int8 *)k + 9) << 8;
LABEL_9:
        c += *((unsigned __int8 *)k + 8);
LABEL_10:
        b += k[1];
        a += *k;
        break;
      case 0xCu:
        c += k[2];
        b += k[1];
        a += *k;
        break;
      default:
        break;
    }
  }
  cm = (b ^ c) - __ROR4__(b, 18);
  aj = (cm ^ a) - __ROR4__(cm, 21);
  bm = (aj ^ b) - __ROR4__(aj, 7);
  cn = (bm ^ cm) - __ROR4__(bm, 16);
  ak = (cn ^ aj) - __ROR4__(cn, 28);
  bn = (ak ^ bm) - __ROR4__(ak, 18);
  return (bn ^ cn) - __ROR4__(bn, 8);
}
// 94EA8: control flows out of bounds to 94EAC
// 9528C: control flows out of bounds to 95290
// 95838: control flows out of bounds to 9583C

//----- (00095AD8) --------------------------------------------------------
void __cdecl list_init(list_t *list)
{
  list->next = list;
  list->prev = list;
}

//----- (00095B10) --------------------------------------------------------
void __cdecl list_insert(list_t *list, list_t *node)
{
  node->next = list;
  node->prev = list->prev;
  list->prev->next = node;
  list->prev = node;
}

//----- (00095B6C) --------------------------------------------------------
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket)
{
  return bucket->first == &hashtable->list && bucket->first == bucket->last;
}

//----- (00095BCC) --------------------------------------------------------
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list)
{
  if ( bucket_is_empty(hashtable, bucket) )
  {
    list_insert(&hashtable->list, list);
    bucket->last = list;
    bucket->first = bucket->last;
  }
  else
  {
    list_insert(bucket->first, list);
    bucket->first = list;
  }
}

//----- (00095C5C) --------------------------------------------------------
pair_t *__cdecl hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const unsigned __int8 *key, size_t hash)
{
  pair_t *list; // [sp+14h] [bp-8h]

  if ( bucket_is_empty(hashtable, bucket) )
    return 0;
  for ( list = (pair_t *)bucket->first; ; list = (pair_t *)list->list.next )
  {
    if ( hash == list->hash && !strcmp((const char *)list->key, (const char *)key) )
      return list;
    if ( list == (pair_t *)bucket->last )
      break;
  }
  return 0;
}

//----- (00095D20) --------------------------------------------------------
void __cdecl hashtable_do_clear(hashtable_t *hashtable)
{
  list_t *next; // [sp+10h] [bp-Ch]
  hashtable_list *list; // [sp+14h] [bp-8h]

  for ( list = hashtable->list.next; list != &hashtable->list; list = next )
  {
    next = list->next;
    json_decref_4((json_t_0 *)list[2].next);
    jsonp_free(list);
  }
}

//----- (00095D94) --------------------------------------------------------
int __cdecl hashtable_do_rehash(hashtable_t *hashtable)
{
  hashtable_bucket *v2; // r3
  list_t *next; // [sp+10h] [bp-1Ch]
  hashtable_bucket *new_buckets; // [sp+14h] [bp-18h]
  size_t new_order; // [sp+1Ch] [bp-10h]
  size_t i; // [sp+20h] [bp-Ch]
  hashtable_t *list; // [sp+24h] [bp-8h]

  new_order = hashtable->order + 1;
  new_buckets = (hashtable_bucket *)jsonp_malloc(8 * (1 << new_order));
  if ( !new_buckets )
    return -1;
  jsonp_free(hashtable->buckets);
  hashtable->buckets = new_buckets;
  hashtable->order = new_order;
  for ( i = 0; i < 1 << hashtable->order; ++i )
  {
    v2 = &hashtable->buckets[i];
    v2->last = &hashtable->list;
    hashtable->buckets[i].first = v2->last;
  }
  list = (hashtable_t *)hashtable->list.next;
  list_init(&hashtable->list);
  while ( list != (hashtable_t *)&hashtable->list )
  {
    next = (list_t *)list->buckets;
    insert_to_bucket(hashtable, &hashtable->buckets[(unsigned int)list->list.next % (1 << new_order)], (list_t *)list);
    list = (hashtable_t *)next;
  }
  return 0;
}

//----- (00095F24) --------------------------------------------------------
int __cdecl hashtable_init(hashtable_t *hashtable)
{
  hashtable_bucket *v2; // r3
  size_t i; // [sp+Ch] [bp-8h]

  hashtable->size = 0;
  hashtable->order = 3;
  hashtable->buckets = (hashtable_bucket *)jsonp_malloc(8 << hashtable->order);
  if ( !hashtable->buckets )
    return -1;
  list_init(&hashtable->list);
  list_init(&hashtable->ordered_list);
  for ( i = 0; i < 1 << hashtable->order; ++i )
  {
    v2 = &hashtable->buckets[i];
    v2->last = &hashtable->list;
    hashtable->buckets[i].first = v2->last;
  }
  return 0;
}

//----- (00096028) --------------------------------------------------------
void __cdecl hashtable_close(hashtable_t *hashtable)
{
  hashtable_do_clear(hashtable);
  jsonp_free(hashtable->buckets);
}

//----- (0009605C) --------------------------------------------------------
int __cdecl hashtable_set(hashtable_t *hashtable, const unsigned __int8 *key, json_t_0 *value)
{
  size_t v4; // r0
  size_t len; // [sp+14h] [bp-18h]
  pair_t *pair; // [sp+18h] [bp-14h]
  pair_t *paira; // [sp+18h] [bp-14h]
  hashtable_bucket *bucket; // [sp+1Ch] [bp-10h]
  uint32_t hash; // [sp+24h] [bp-8h]

  if ( !(hashtable->size >> hashtable->order) || !hashtable_do_rehash(hashtable) )
  {
    v4 = strlen((const char *)key);
    hash = hashlittle(key, v4, hashtable_seed);
    bucket = &hashtable->buckets[((1 << hashtable->order) - 1) & hash];
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if ( pair )
    {
      json_decref_4(pair->value);
      pair->value = value;
    }
    else
    {
      len = strlen((const char *)key);
      if ( len > 0xFFFFFFE6 )
        return -1;
      paira = (pair_t *)jsonp_malloc(len + 25);
      if ( !paira )
        return -1;
      paira->hash = hash;
      strncpy((char *)paira->key, (const char *)key, len + 1);
      paira->value = value;
      list_init(&paira->list);
      list_init(&paira->ordered_list);
      insert_to_bucket(hashtable, bucket, &paira->list);
      list_insert(&hashtable->ordered_list, &paira->ordered_list);
      ++hashtable->size;
    }
    return 0;
  }
  return -1;
}

//----- (0009623C) --------------------------------------------------------
void *__cdecl hashtable_get(hashtable_t *hashtable, const unsigned __int8 *key)
{
  size_t v2; // r0
  pair_t *pair; // [sp+Ch] [bp-10h]
  uint32_t hash; // [sp+14h] [bp-8h]

  v2 = strlen((const char *)key);
  hash = hashlittle(key, v2, hashtable_seed);
  pair = hashtable_find_pair(hashtable, &hashtable->buckets[hash & ((1 << hashtable->order) - 1)], key, hash);
  if ( pair )
    return pair->value;
  else
    return 0;
}

//----- (000962E8) --------------------------------------------------------
void *__cdecl hashtable_iter(hashtable_t *hashtable)
{
  return hashtable_iter_next(hashtable, &hashtable->ordered_list);
}

//----- (0009631C) --------------------------------------------------------
void *__cdecl hashtable_iter_next(hashtable_t *hashtable, void *iter)
{
  if ( *((hashtable_t **)iter + 1) == (hashtable_t *)&hashtable->ordered_list )
    return 0;
  else
    return (void *)*((_DWORD *)iter + 1);
}

//----- (00096370) --------------------------------------------------------
void *__cdecl hashtable_iter_key(void *iter)
{
  return (char *)iter + 16;
}

//----- (000963A4) --------------------------------------------------------
void *__cdecl hashtable_iter_value(void *iter)
{
  return (void *)*((_DWORD *)iter + 3);
}

//----- (000963D8) --------------------------------------------------------
void *__cdecl rpl_memchr(const void *s, int c_in, size_t n)
{
  int repeated_c; // [sp+14h] [bp-18h]
  const rpl_memchr::longword *longword_ptr; // [sp+20h] [bp-Ch]
  const unsigned __int8 *char_ptra; // [sp+24h] [bp-8h]

  while ( n && ((unsigned __int8)s & 3) != 0 )
  {
    if ( (unsigned __int8)c_in == *(unsigned __int8 *)s )
      return (void *)s;
    --n;
    s = (char *)s + 1;
  }
  for ( longword_ptr = (const rpl_memchr::longword *)s; n > 3; ++longword_ptr )
  {
    repeated_c = (unsigned __int8)c_in | ((unsigned __int8)c_in << 8) | (((unsigned __int8)c_in | ((unsigned __int8)c_in << 8)) << 16);
    if ( (((*longword_ptr ^ repeated_c) - 16843009) & ~(*longword_ptr ^ repeated_c) & 0x80808080) != 0 )
      break;
    n -= 4;
  }
  char_ptra = (const unsigned __int8 *)longword_ptr;
  while ( n )
  {
    if ( (unsigned __int8)c_in == *char_ptra )
      return (void *)char_ptra;
    --n;
    ++char_ptra;
  }
  return 0;
}

//----- (00096560) --------------------------------------------------------
size_t __cdecl critical_factorization(const unsigned __int8 *needle, size_t needle_len, size_t *period)
{
  size_t v4; // r3
  size_t v5; // r3
  unsigned __int8 b; // [sp+12h] [bp-1Ah]
  unsigned __int8 ba; // [sp+12h] [bp-1Ah]
  unsigned __int8 a; // [sp+13h] [bp-19h]
  unsigned __int8 aa; // [sp+13h] [bp-19h]
  size_t p; // [sp+14h] [bp-18h]
  size_t pa; // [sp+14h] [bp-18h]
  size_t k; // [sp+18h] [bp-14h]
  size_t ka; // [sp+18h] [bp-14h]
  size_t j; // [sp+1Ch] [bp-10h]
  size_t ja; // [sp+1Ch] [bp-10h]
  size_t max_suffix_rev; // [sp+20h] [bp-Ch]
  size_t max_suffix; // [sp+24h] [bp-8h]

  if ( needle_len > 2 )
  {
    max_suffix = -1;
    j = 0;
    p = 1;
    k = 1;
    while ( needle_len > j + k )
    {
      a = needle[j + k];
      b = needle[max_suffix + k];
      if ( a >= (unsigned int)b )
      {
        if ( a == b )
        {
          if ( k == p )
          {
            j += p;
            k = 1;
          }
          else
          {
            ++k;
          }
        }
        else
        {
          v4 = j++;
          max_suffix = v4;
          p = 1;
          k = 1;
        }
      }
      else
      {
        j += k;
        k = 1;
        p = j - max_suffix;
      }
    }
    *period = p;
    max_suffix_rev = -1;
    ja = 0;
    pa = 1;
    ka = 1;
    while ( needle_len > ja + ka )
    {
      aa = needle[ja + ka];
      ba = needle[max_suffix_rev + ka];
      if ( ba >= (unsigned int)aa )
      {
        if ( aa == ba )
        {
          if ( ka == pa )
          {
            ja += pa;
            ka = 1;
          }
          else
          {
            ++ka;
          }
        }
        else
        {
          v5 = ja++;
          max_suffix_rev = v5;
          pa = 1;
          ka = 1;
        }
      }
      else
      {
        ja += ka;
        ka = 1;
        pa = ja - max_suffix_rev;
      }
    }
    if ( max_suffix_rev + 1 >= max_suffix + 1 )
    {
      *period = pa;
      return max_suffix_rev + 1;
    }
    else
    {
      return max_suffix + 1;
    }
  }
  else
  {
    *period = 1;
    return needle_len - 1;
  }
}

//----- (00096828) --------------------------------------------------------
void *__cdecl two_way_short_needle(
        const unsigned __int8 *haystack,
        size_t haystack_len,
        const unsigned __int8 *needle,
        size_t needle_len)
{
  size_t v4; // r3
  size_t v6; // r3
  size_t period; // [sp+14h] [bp-18h] BYREF
  size_t suffix; // [sp+18h] [bp-14h]
  size_t memory; // [sp+1Ch] [bp-10h]
  size_t j; // [sp+20h] [bp-Ch]
  size_t i; // [sp+24h] [bp-8h]

  suffix = critical_factorization(needle, needle_len, &period);
  if ( !memcmp(needle, &needle[period], suffix) )
  {
    memory = 0;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      v4 = memory;
      if ( suffix >= memory )
        v4 = suffix;
      for ( i = v4; i < needle_len && needle[i] == haystack[i + j]; ++i )
        ;
      if ( needle_len > i )
      {
        j += i - suffix + 1;
        memory = 0;
      }
      else
      {
        for ( i = suffix - 1; memory < i + 1 && needle[i] == haystack[i + j]; --i )
          ;
        if ( i + 1 < memory + 1 )
          return (void *)&haystack[j];
        j += period;
        memory = needle_len - period;
      }
    }
  }
  else
  {
    v6 = suffix;
    if ( needle_len - suffix >= suffix )
      v6 = needle_len - suffix;
    period = v6 + 1;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      for ( i = suffix; i < needle_len && needle[i] == haystack[i + j]; ++i )
        ;
      if ( needle_len > i )
      {
        j += i - suffix + 1;
      }
      else
      {
        for ( i = suffix - 1; i != -1 && needle[i] == haystack[i + j]; --i )
          ;
        if ( i == -1 )
          return (void *)&haystack[j];
        j += period;
      }
    }
  }
  return 0;
}

//----- (00096B60) --------------------------------------------------------
void *__cdecl two_way_long_needle(
        const unsigned __int8 *haystack,
        size_t haystack_len,
        const unsigned __int8 *needle,
        size_t needle_len)
{
  size_t v4; // r3
  size_t v6; // r3
  size_t shift_table[256]; // [sp+14h] [bp-420h]
  size_t period; // [sp+414h] [bp-20h] BYREF
  size_t shift_0; // [sp+418h] [bp-1Ch]
  size_t suffix; // [sp+41Ch] [bp-18h]
  size_t shift; // [sp+420h] [bp-14h]
  size_t memory; // [sp+424h] [bp-10h]
  size_t j; // [sp+428h] [bp-Ch]
  size_t i; // [sp+42Ch] [bp-8h]

  suffix = critical_factorization(needle, needle_len, &period);
  for ( i = 0; i <= 0xFF; ++i )
    shift_table[i] = needle_len;
  for ( i = 0; i < needle_len; ++i )
    shift_table[needle[i]] = needle_len - i - 1;
  if ( !memcmp(needle, &needle[period], suffix) )
  {
    memory = 0;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      shift = shift_table[haystack[j - 1 + needle_len]];
      if ( shift )
      {
        if ( memory && shift < period )
          shift = needle_len - period;
        memory = 0;
        j += shift;
      }
      else
      {
        v4 = memory;
        if ( suffix >= memory )
          v4 = suffix;
        for ( i = v4; i < needle_len - 1 && needle[i] == haystack[i + j]; ++i )
          ;
        if ( i < needle_len - 1 )
        {
          j += i - suffix + 1;
          memory = 0;
        }
        else
        {
          for ( i = suffix - 1; memory < i + 1 && needle[i] == haystack[i + j]; --i )
            ;
          if ( i + 1 < memory + 1 )
            return (void *)&haystack[j];
          j += period;
          memory = needle_len - period;
        }
      }
    }
  }
  else
  {
    v6 = suffix;
    if ( needle_len - suffix >= suffix )
      v6 = needle_len - suffix;
    period = v6 + 1;
    j = 0;
    while ( j <= haystack_len - needle_len )
    {
      shift_0 = shift_table[haystack[j - 1 + needle_len]];
      if ( shift_0 )
      {
        j += shift_0;
      }
      else
      {
        for ( i = suffix; i < needle_len - 1 && needle[i] == haystack[i + j]; ++i )
          ;
        if ( i < needle_len - 1 )
        {
          j += i - suffix + 1;
        }
        else
        {
          for ( i = suffix - 1; i != -1 && needle[i] == haystack[i + j]; --i )
            ;
          if ( i == -1 )
            return (void *)&haystack[j];
          j += period;
        }
      }
    }
  }
  return 0;
}

//----- (00097014) --------------------------------------------------------
void *__cdecl memmem(const void *haystack_start, size_t haystack_len, const void *needle_start, size_t needle_len)
{
  size_t haystack_lenb; // [sp+8h] [bp-14h]
  const unsigned __int8 *haystack; // [sp+14h] [bp-8h]

  if ( !needle_len )
    return (void *)haystack_start;
  if ( haystack_len < needle_len )
    return 0;
  if ( needle_len > 0x1F )
    return two_way_long_needle(
             (const unsigned __int8 *)haystack_start,
             haystack_len,
             (const unsigned __int8 *)needle_start,
             needle_len);
  haystack = (const unsigned __int8 *)rpl_memchr(haystack_start, *(unsigned __int8 *)needle_start, haystack_len);
  if ( !haystack || needle_len == 1 )
    return (void *)haystack;
  haystack_lenb = haystack_len - (haystack - (_BYTE *)haystack_start);
  if ( haystack_lenb >= needle_len )
    return two_way_short_needle(haystack, haystack_lenb, (const unsigned __int8 *)needle_start, needle_len);
  else
    return 0;
}

//----- (0009733C) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3
  bool v5; // zf
  unsigned int v6; // r2
  _BOOL4 v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r0
  int v25; // r0
  int v26; // r0
  int v27; // r0
  int v28; // r0
  int v29; // r0
  int v30; // r0
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      v6 = 31 - (__clz(a2) - __clz(v4));
      v5 = v6 == 0;
      if ( v6 )
        v6 *= 3;
      if ( v5 )
      {
        v7 = v4 >= a2 << 31;
        if ( v4 >= a2 << 31 )
          v4 -= a2 << 31;
        v8 = v7 + (v4 >= a2 << 30) + v7;
        if ( v4 >= a2 << 30 )
          v4 -= a2 << 30;
        v9 = v8 + (v4 >= a2 << 29) + v8;
        if ( v4 >= a2 << 29 )
          v4 -= a2 << 29;
        v10 = v9 + (v4 >= a2 << 28) + v9;
        if ( v4 >= a2 << 28 )
          v4 -= a2 << 28;
        v11 = v10 + (v4 >= a2 << 27) + v10;
        if ( v4 >= a2 << 27 )
          v4 -= a2 << 27;
        v12 = v11 + (v4 >= a2 << 26) + v11;
        if ( v4 >= a2 << 26 )
          v4 -= a2 << 26;
        v13 = v12 + (v4 >= a2 << 25) + v12;
        if ( v4 >= a2 << 25 )
          v4 -= a2 << 25;
        v14 = v13 + (v4 >= a2 << 24) + v13;
        if ( v4 >= a2 << 24 )
          v4 -= a2 << 24;
        v15 = v14 + (v4 >= a2 << 23) + v14;
        if ( v4 >= a2 << 23 )
          v4 -= a2 << 23;
        v16 = v15 + (v4 >= a2 << 22) + v15;
        if ( v4 >= a2 << 22 )
          v4 -= a2 << 22;
        v17 = v16 + (v4 >= a2 << 21) + v16;
        if ( v4 >= a2 << 21 )
          v4 -= a2 << 21;
        v18 = v17 + (v4 >= a2 << 20) + v17;
        if ( v4 >= a2 << 20 )
          v4 -= a2 << 20;
        v19 = v18 + (v4 >= a2 << 19) + v18;
        if ( v4 >= a2 << 19 )
          v4 -= a2 << 19;
        v20 = v19 + (v4 >= a2 << 18) + v19;
        if ( v4 >= a2 << 18 )
          v4 -= a2 << 18;
        v21 = v20 + (v4 >= a2 << 17) + v20;
        if ( v4 >= a2 << 17 )
          v4 -= a2 << 17;
        v22 = v21 + (v4 >= a2 << 16) + v21;
        if ( v4 >= a2 << 16 )
          v4 -= a2 << 16;
        v23 = v22 + (v4 >= a2 << 15) + v22;
        if ( v4 >= a2 << 15 )
          v4 -= a2 << 15;
        v24 = v23 + (v4 >= a2 << 14) + v23;
        if ( v4 >= a2 << 14 )
          v4 -= a2 << 14;
        v25 = v24 + (v4 >= a2 << 13) + v24;
        if ( v4 >= a2 << 13 )
          v4 -= a2 << 13;
        v26 = v25 + (v4 >= a2 << 12) + v25;
        if ( v4 >= a2 << 12 )
          v4 -= a2 << 12;
        v27 = v26 + (v4 >= a2 << 11) + v26;
        if ( v4 >= a2 << 11 )
          v4 -= a2 << 11;
        v28 = v27 + (v4 >= a2 << 10) + v27;
        if ( v4 >= a2 << 10 )
          v4 -= a2 << 10;
        v29 = v28 + (v4 >= a2 << 9) + v28;
        if ( v4 >= a2 << 9 )
          v4 -= a2 << 9;
        v30 = v29 + (v4 >= a2 << 8) + v29;
        if ( v4 >= a2 << 8 )
          v4 -= a2 << 8;
        v31 = v30 + (v4 >= a2 << 7) + v30;
        if ( v4 >= a2 << 7 )
          v4 -= a2 << 7;
        v32 = v31 + (v4 >= a2 << 6) + v31;
        if ( v4 >= a2 << 6 )
          v4 -= a2 << 6;
        v33 = v32 + (v4 >= 32 * a2) + v32;
        if ( v4 >= 32 * a2 )
          v4 -= 32 * a2;
        v34 = v33 + (v4 >= 16 * a2) + v33;
        if ( v4 >= 16 * a2 )
          v4 -= 16 * a2;
        v35 = v34 + (v4 >= 8 * a2) + v34;
        if ( v4 >= 8 * a2 )
          v4 -= 8 * a2;
        v36 = v35 + (v4 >= 4 * a2) + v35;
        if ( v4 >= 4 * a2 )
          v4 -= 4 * a2;
        v37 = v36 + (v4 >= 2 * a2) + v36;
        if ( v4 >= 2 * a2 )
          v4 -= 2 * a2;
        result = v37 + (v4 >= a2) + v37;
        if ( v3 < 0 )
          return -result;
      }
      else
      {
        return ((int (__fastcall *)(_DWORD))((char *)&loc_97384 + 4 * v6))(0);
      }
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 97340: variable 'v2' is possibly undefined

//----- (00097970) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (000979F0) --------------------------------------------------------
int __fastcall _udivmoddi4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  int v6; // r12
  unsigned __int64 v7; // r6
  bool v8; // cf
  unsigned __int64 v9; // r6
  int v10; // r2
  int v11; // r0
  int v12; // r3

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( v3 )
  {
    if ( HIDWORD(a2) )
      v5 = __clz(HIDWORD(a2));
    else
      v5 = __clz(a2);
    if ( !HIDWORD(a2) )
      v5 += 32;
    if ( HIDWORD(a1) )
      LODWORD(a1) = __clz(HIDWORD(a1));
    else
      LODWORD(a1) = __clz(v4);
    if ( !HIDWORD(a1) )
      LODWORD(a1) = a1 + 32;
    v6 = v5 - a1;
    v7 = a2 << v6;
    v8 = HIDWORD(a1) >= a2 << v6 >> 32;
    if ( HIDWORD(a1) == a2 << v6 >> 32 )
      v8 = (unsigned int)v4 >= (unsigned int)v7;
    if ( v8 )
    {
      LODWORD(a1) = 1 << v6;
      v4 -= v7;
    }
    else
    {
      LODWORD(a1) = 0;
    }
    if ( v6 )
    {
      v9 = v7 >> 1;
      v10 = v6;
      do
      {
        while ( v4 >= v9 )
        {
          v4 = 2 * (v4 - v9) + 1;
          if ( !--v10 )
            goto LABEL_25;
        }
        v4 *= 2LL;
        --v10;
      }
      while ( v10 );
LABEL_25:
      v11 = a1 + v4;
      v12 = v4 >> v6;
      HIDWORD(v4) >>= v6;
      LODWORD(v4) = v12;
      LODWORD(a1) = v11 - (v12 << v6);
    }
  }
  if ( a3 )
    *a3 = v4;
  return a1;
}

//----- (00097B18) --------------------------------------------------------
void __fastcall _libc_csu_init(int a1, int a2, int a3)
{
  int (**v6)(); // r5
  int i; // r4
  void (__fastcall *v8)(int, int, int); // t1

  init_proc();
  v6 = _frame_dummy_init_array_entry;
  for ( i = 0; i != 1; ++i )
  {
    v8 = (void (__fastcall *)(int, int, int))*v6++;
    v8(a1, a2, a3);
  }
}
// BFEF8: using guessed type int (*_frame_dummy_init_array_entry[2])();

//----- (00097B7C) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1433 queued=1090 decompiled=1090 lumina nreq=0 worse=0 better=0
// ALL OK, 1090 function(s) have been successfully decompiled
